Index: lucene/analysis/common/src/test/org/apache/lucene/analysis/shingle/ShingleAnalyzerWrapperTest.java
===================================================================
--- lucene/analysis/common/src/test/org/apache/lucene/analysis/shingle/ShingleAnalyzerWrapperTest.java	(revision 1668924)
+++ lucene/analysis/common/src/test/org/apache/lucene/analysis/shingle/ShingleAnalyzerWrapperTest.java	(working copy)
@@ -17,6 +17,9 @@
  * limitations under the License.
  */
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.BaseTokenStreamTestCase;
 import org.apache.lucene.analysis.MockAnalyzer;
@@ -36,7 +39,13 @@
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.*;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.store.Directory;
 
 /**
@@ -98,7 +107,7 @@
    * This shows how to construct a phrase query containing shingles.
    */
   public void testShingleAnalyzerWrapperPhraseQuery() throws Exception {
-    PhraseQuery q = new PhraseQuery();
+    List<TermAndPosition> termPos = new ArrayList<>();
 
     try (TokenStream ts = analyzer.tokenStream("content", "this sentence")) {
       int j = -1;
@@ -110,12 +119,12 @@
       while (ts.incrementToken()) {
         j += posIncrAtt.getPositionIncrement();
         String termText = termAtt.toString();
-        q.add(new Term("content", termText), j);
+        termPos.add(new TermAndPosition(new Term("content", termText), j));
       }
       ts.end();
     }
 
-    ScoreDoc[] hits = searcher.search(q, 1000).scoreDocs;
+    ScoreDoc[] hits = searcher.search(new PhraseQuery(termPos), 1000).scoreDocs;
     int[] ranks = new int[] { 0 };
     compareRanks(hits, ranks);
   }
@@ -126,7 +135,7 @@
    * in the right order and adjacent to each other.
    */
   public void testShingleAnalyzerWrapperBooleanQuery() throws Exception {
-    BooleanQuery q = new BooleanQuery();
+    List<BooleanClause> clauses = new ArrayList<>();
 
     try (TokenStream ts = analyzer.tokenStream("content", "test sentence")) {
       CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);
@@ -134,13 +143,13 @@
       ts.reset();
       while (ts.incrementToken()) {
         String termText =  termAtt.toString();
-        q.add(new TermQuery(new Term("content", termText)),
-            BooleanClause.Occur.SHOULD);
+        clauses.add(new BooleanClause(new TermQuery(new Term("content", termText)),
+            BooleanClause.Occur.SHOULD));
       }
       ts.end();
     }
 
-    ScoreDoc[] hits = searcher.search(q, 1000).scoreDocs;
+    ScoreDoc[] hits = searcher.search(new BooleanQuery(clauses), 1000).scoreDocs;
     int[] ranks = new int[] { 1, 2, 0 };
     compareRanks(hits, ranks);
   }
Index: lucene/analysis/common/src/test/org/apache/lucene/collation/TestCollationDocValuesField.java
===================================================================
--- lucene/analysis/common/src/test/org/apache/lucene/collation/TestCollationDocValuesField.java	(revision 1668924)
+++ lucene/analysis/common/src/test/org/apache/lucene/collation/TestCollationDocValuesField.java	(working copy)
@@ -25,6 +25,7 @@
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.DocValuesRangeQuery;
@@ -131,9 +132,9 @@
     }
     
     // negative test
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);
-    bq.add(query, Occur.MUST_NOT);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(new MatchAllDocsQuery(), Occur.SHOULD),
+        new BooleanClause(query, Occur.MUST_NOT));
     docs = is.search(bq, is.getIndexReader().maxDoc());
     for (ScoreDoc doc : docs.scoreDocs) {
       String value = is.doc(doc.doc).get("field");
Index: lucene/analysis/icu/src/test/org/apache/lucene/collation/TestICUCollationDocValuesField.java
===================================================================
--- lucene/analysis/icu/src/test/org/apache/lucene/collation/TestICUCollationDocValuesField.java	(revision 1668924)
+++ lucene/analysis/icu/src/test/org/apache/lucene/collation/TestICUCollationDocValuesField.java	(working copy)
@@ -22,6 +22,7 @@
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.DocValuesRangeQuery;
@@ -128,9 +129,9 @@
     }
     
     // negative test
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);
-    bq.add(query, Occur.MUST_NOT);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(new MatchAllDocsQuery(), Occur.SHOULD),
+        new BooleanClause(query, Occur.MUST_NOT));
     docs = is.search(bq, is.getIndexReader().maxDoc());
     for (ScoreDoc doc : docs.scoreDocs) {
       String value = is.doc(doc.doc).get("field");
Index: lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java
===================================================================
--- lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java	(revision 1668924)
+++ lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java	(working copy)
@@ -20,6 +20,7 @@
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryparser.classic.QueryParser;
+import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
@@ -53,10 +54,9 @@
     qq.add(q1);
     Query q2 = new TermQuery(new Term(DocMaker.BODY_FIELD,"simple"));
     qq.add(q2);
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(q1,Occur.MUST);
-    bq.add(q2,Occur.MUST);
-    qq.add(bq);
+    qq.add(new BooleanQuery(
+        new BooleanClause(q1, Occur.MUST),
+        new BooleanClause(q2, Occur.MUST)));
     qq.add(qp.parse("synthetic body"));
     qq.add(qp.parse("\"synthetic body\""));
     qq.add(qp.parse("synthetic text"));
Index: lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java
===================================================================
--- lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java	(revision 1668924)
+++ lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java	(working copy)
@@ -18,10 +18,12 @@
  */
 
 import java.util.ArrayList;
+import java.util.List;
 import java.util.StringTokenizer;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.search.Query;
 
 /**
@@ -50,30 +52,28 @@
         for (int wd=0; wd<words.length-qlen-slop; wd++) {
           // ordered
           int remainedSlop = slop;
-          PhraseQuery q = new PhraseQuery();
-          q.setSlop(slop);
+          List<TermAndPosition> termPos = new ArrayList<>();
           int wind = wd;
           for (int i=0; i<qlen; i++) {
-            q.add(new Term(DocMaker.BODY_FIELD,words[wind++]));
+            termPos.add(new TermAndPosition(new Term(DocMaker.BODY_FIELD,words[wind++]), i));
             if (remainedSlop>0) {
               remainedSlop--;
               wind++;
             }
           }
-          queries.add(q);
+          queries.add(new PhraseQuery(slop, termPos));
           // reversed
           remainedSlop = slop;
-          q = new PhraseQuery();
-          q.setSlop(slop+2*qlen);
+          termPos = new ArrayList<>();
           wind = wd+qlen+remainedSlop-1;
           for (int i=0; i<qlen; i++) {
-            q.add(new Term(DocMaker.BODY_FIELD,words[wind--]));
+            termPos.add(new TermAndPosition(new Term(DocMaker.BODY_FIELD,words[wind--]), i));
             if (remainedSlop>0) {
               remainedSlop--;
               wind--;
             }
           }
-          queries.add(q);
+          queries.add(new PhraseQuery(slop+2*qlen, termPos));
         }
       }
     }
Index: lucene/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/SimpleQQParser.java
===================================================================
--- lucene/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/SimpleQQParser.java	(revision 1668924)
+++ lucene/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/SimpleQQParser.java	(working copy)
@@ -16,6 +16,9 @@
  */
 package org.apache.lucene.benchmark.quality.utils;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.benchmark.quality.QualityQuery;
 import org.apache.lucene.benchmark.quality.QualityQueryParser;
@@ -25,7 +28,6 @@
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.util.Version;
 
 /**
  * Simplistic quality query parser. A Lucene query is created by passing 
@@ -66,11 +68,11 @@
       qp = new QueryParser(indexField, new StandardAnalyzer());
       queryParser.set(qp);
     }
-    BooleanQuery bq = new BooleanQuery();
+    List<BooleanClause> clauses = new ArrayList<>();
     for (int i = 0; i < qqNames.length; i++)
-      bq.add(qp.parse(QueryParserBase.escape(qq.getValue(qqNames[i]))), BooleanClause.Occur.SHOULD);
+      clauses.add(new BooleanClause(qp.parse(QueryParserBase.escape(qq.getValue(qqNames[i]))), BooleanClause.Occur.SHOULD));
     
-    return bq;
+    return new BooleanQuery(clauses);
   }
 
 }
Index: lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier.java
===================================================================
--- lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier.java	(revision 1668924)
+++ lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier.java	(working copy)
@@ -17,6 +17,7 @@
 package org.apache.lucene.classification;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.SortedMap;
@@ -163,11 +164,12 @@
 
     int batchCount = 0;
 
-    BooleanQuery q = new BooleanQuery();
-    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, "*")), BooleanClause.Occur.MUST));
+    List<BooleanClause> clauses = new ArrayList<>();
+    clauses.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, "*")), BooleanClause.Occur.MUST));
     if (query != null) {
-      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));
+      clauses.add(new BooleanClause(query, BooleanClause.Occur.MUST));
     }
+    BooleanQuery q = new BooleanQuery(clauses);
     // run the search and use stored field values
     for (ScoreDoc scoreDoc : indexSearcher.search(q,
         Integer.MAX_VALUE).scoreDocs) {
Index: lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier.java
===================================================================
--- lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier.java	(revision 1668924)
+++ lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier.java	(working copy)
@@ -188,18 +188,18 @@
     // if we dont get the answer, but it's relevant we must search it and insert to the cache
     if (insertPoint != null || !justCachedTerms) {
       for (BytesRef cclass : cclasses) {
-        BooleanQuery booleanQuery = new BooleanQuery();
-        BooleanQuery subQuery = new BooleanQuery();
+        List<BooleanClause> subClauses = new ArrayList<>();
         for (String textFieldName : textFieldNames) {
-          subQuery.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));
+          subClauses.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));
         }
-        booleanQuery.add(new BooleanClause(subQuery, BooleanClause.Occur.MUST));
-        booleanQuery.add(new BooleanClause(new TermQuery(new Term(classFieldName, cclass)), BooleanClause.Occur.MUST));
+        List<BooleanClause> clauses = new ArrayList<>();
+        clauses.add(new BooleanClause(new BooleanQuery(subClauses), BooleanClause.Occur.MUST));
+        clauses.add(new BooleanClause(new TermQuery(new Term(classFieldName, cclass)), BooleanClause.Occur.MUST));
         if (query != null) {
-          booleanQuery.add(query, BooleanClause.Occur.MUST);
+          clauses.add(new BooleanClause(query, BooleanClause.Occur.MUST));
         }
         TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();
-        indexSearcher.search(booleanQuery, totalHitCountCollector);
+        indexSearcher.search(new BooleanQuery(clauses), totalHitCountCollector);
 
         int ret = totalHitCountCollector.getTotalHits();
         if (ret != 0) {
Index: lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java
===================================================================
--- lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java	(revision 1668924)
+++ lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java	(working copy)
@@ -121,16 +121,16 @@
     if (mlt == null) {
       throw new IOException("You must first call Classifier#train");
     }
-    BooleanQuery mltQuery = new BooleanQuery();
+    List<BooleanClause> mltClauses = new ArrayList<>();
     for (String textFieldName : textFieldNames) {
-      mltQuery.add(new BooleanClause(mlt.like(textFieldName, new StringReader(text)), BooleanClause.Occur.SHOULD));
+      mltClauses.add(new BooleanClause(mlt.like(textFieldName, new StringReader(text)), BooleanClause.Occur.SHOULD));
     }
     Query classFieldQuery = new WildcardQuery(new Term(classFieldName, "*"));
-    mltQuery.add(new BooleanClause(classFieldQuery, BooleanClause.Occur.MUST));
+    mltClauses.add(new BooleanClause(classFieldQuery, BooleanClause.Occur.MUST));
     if (query != null) {
-      mltQuery.add(query, BooleanClause.Occur.MUST);
+      mltClauses.add(new BooleanClause(query, BooleanClause.Occur.MUST));
     }
-    return indexSearcher.search(mltQuery, k);
+    return indexSearcher.search(new BooleanQuery(mltClauses), k);
   }
 
   private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {
Index: lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier.java
===================================================================
--- lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier.java	(revision 1668924)
+++ lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier.java	(working copy)
@@ -206,12 +206,12 @@
     int docCount = MultiFields.getTerms(this.leafReader, this.classFieldName).getDocCount();
     if (docCount == -1) { // in case codec doesn't support getDocCount
       TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();
-      BooleanQuery q = new BooleanQuery();
-      q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, String.valueOf(WildcardQuery.WILDCARD_STRING))), BooleanClause.Occur.MUST));
+      List<BooleanClause> clauses = new ArrayList<>();
+      clauses.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, String.valueOf(WildcardQuery.WILDCARD_STRING))), BooleanClause.Occur.MUST));
       if (query != null) {
-        q.add(query, BooleanClause.Occur.MUST);
+        clauses.add(new BooleanClause(query, BooleanClause.Occur.MUST));
       }
-      indexSearcher.search(q,
+      indexSearcher.search(new BooleanQuery(clauses),
           totalHitCountCollector);
       docCount = totalHitCountCollector.getTotalHits();
     }
@@ -274,19 +274,17 @@
   }
 
   private int getWordFreqForClass(String word, BytesRef c) throws IOException {
-    BooleanQuery booleanQuery = new BooleanQuery();
-    BooleanQuery subQuery = new BooleanQuery();
+    List<BooleanClause> subClauses = new ArrayList<>();
     for (String textFieldName : textFieldNames) {
-      subQuery.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));
+      subClauses.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));
     }
-    booleanQuery.add(new BooleanClause(subQuery, BooleanClause.Occur.MUST));
-    booleanQuery.add(new BooleanClause(new TermQuery(new Term(classFieldName, c)), BooleanClause.Occur.MUST));
+    List<BooleanClause> clauses = new ArrayList<>();
+    clauses.add(new BooleanClause(new BooleanQuery(subClauses), BooleanClause.Occur.MUST));
+    clauses.add(new BooleanClause(new TermQuery(new Term(classFieldName, c)), BooleanClause.Occur.MUST));
     if (query != null) {
-      booleanQuery.add(query, BooleanClause.Occur.MUST);
+      clauses.add(new BooleanClause(query, BooleanClause.Occur.MUST));
     }
-    TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();
-    indexSearcher.search(booleanQuery, totalHitCountCollector);
-    return totalHitCountCollector.getTotalHits();
+    return indexSearcher.count(new BooleanQuery(clauses));
   }
 
   private double calculateLogPrior(BytesRef currentClass, int docsWithClassSize) throws IOException {
Index: lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanClause.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanClause.java	(working copy)
@@ -33,7 +33,6 @@
      * matching documents. For a BooleanQuery with no <code>MUST</code> 
      * clauses one or more <code>SHOULD</code> clauses must match a document 
      * for the BooleanQuery to match.
-     * @see BooleanQuery#setMinimumNumberShouldMatch
      */
     SHOULD   { @Override public String toString() { return "";  } },
 
Index: lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java	(working copy)
@@ -19,6 +19,8 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
@@ -31,7 +33,7 @@
 
 /** A Query that matches documents matching boolean combinations of other
   * queries, e.g. {@link TermQuery}s, {@link PhraseQuery}s or other
-  * BooleanQuerys.
+  * {@link BooleanQuery}s.
   */
 public class BooleanQuery extends Query implements Iterable<BooleanClause> {
 
@@ -66,12 +68,13 @@
     BooleanQuery.maxClauseCount = maxClauseCount;
   }
 
-  private ArrayList<BooleanClause> clauses = new ArrayList<>();
+  private List<BooleanClause> clauses;
   private final boolean disableCoord;
+  private final int minNrShouldMatch;
 
-  /** Constructs an empty boolean query. */
-  public BooleanQuery() {
-    disableCoord = false;
+  /** Constructs a boolean query with the provided clauses. */
+  public BooleanQuery(List<BooleanClause> clauses) {
+    this(false, 0, clauses);
   }
 
   /** Constructs an empty boolean query.
@@ -82,39 +85,40 @@
    * FuzzyQuery}.
    *
    * @param disableCoord disables {@link Similarity#coord(int,int)} in scoring.
+   * @param minimumNumberShouldMatch the minimum of {@link Occur#SHOULD} clauses that
+   *            need to match for a document to match
    */
-  public BooleanQuery(boolean disableCoord) {
+  public BooleanQuery(boolean disableCoord, int minimumNumberShouldMatch, List<BooleanClause> clauses) {
+    if (clauses.size() > maxClauseCount) {
+      throw new TooManyClauses();
+    }
     this.disableCoord = disableCoord;
+    this.minNrShouldMatch = minimumNumberShouldMatch;
+    this.clauses = Collections.unmodifiableList(new ArrayList<>(clauses));
   }
 
-  /** Returns true iff {@link Similarity#coord(int,int)} is disabled in
-   * scoring for this query instance.
-   * @see #BooleanQuery(boolean)
+  /**
+   * Sugar for BooleanQuery(Arrays.asList(clauses))
+   * @see BooleanQuery#BooleanQuery(List)
    */
-  public boolean isCoordDisabled() { return disableCoord; }
+  public BooleanQuery(BooleanClause... clauses) {
+    this(Arrays.asList(clauses));
+  }
 
   /**
-   * Specifies a minimum number of the optional BooleanClauses
-   * which must be satisfied.
-   *
-   * <p>
-   * By default no optional clauses are necessary for a match
-   * (unless there are no required clauses).  If this method is used,
-   * then the specified number of clauses is required.
-   * </p>
-   * <p>
-   * Use of this method is totally independent of specifying that
-   * any specific clauses are required (or prohibited).  This number will
-   * only be compared against the number of matching optional clauses.
-   * </p>
-   *
-   * @param min the number of optional clauses that must match
+   * Sugar for BooleanQuery(disableCoord, Arrays.asList(clauses))
+   * @see BooleanQuery#BooleanQuery(boolean,int,List)
    */
-  public void setMinimumNumberShouldMatch(int min) {
-    this.minNrShouldMatch = min;
+  public BooleanQuery(boolean disableCoord, int minimumNumberShouldMatch, BooleanClause... clauses) {
+    this(disableCoord, minimumNumberShouldMatch, Arrays.asList(clauses));
   }
-  protected int minNrShouldMatch = 0;
 
+  /** Returns true iff {@link Similarity#coord(int,int)} is disabled in
+   * scoring for this query instance.
+   * @see #BooleanQuery(boolean,int,List)
+   */
+  public boolean isCoordDisabled() { return disableCoord; }
+
   /**
    * Gets the minimum number of the optional BooleanClauses
    * which must be satisfied.
@@ -123,27 +127,6 @@
     return minNrShouldMatch;
   }
 
-  /** Adds a clause to a boolean query.
-   *
-   * @throws TooManyClauses if the new number of clauses exceeds the maximum clause number
-   * @see #getMaxClauseCount()
-   */
-  public void add(Query query, BooleanClause.Occur occur) {
-    add(new BooleanClause(query, occur));
-  }
-
-  /** Adds a clause to a boolean query.
-   * @throws TooManyClauses if the new number of clauses exceeds the maximum clause number
-   * @see #getMaxClauseCount()
-   */
-  public void add(BooleanClause clause) {
-    if (clauses.size() >= maxClauseCount) {
-      throw new TooManyClauses();
-    }
-
-    clauses.add(clause);
-  }
-
   /** Returns the set of clauses in this query. */
   public BooleanClause[] getClauses() {
     return clauses.toArray(new BooleanClause[clauses.size()]);
@@ -160,16 +143,17 @@
   public final Iterator<BooleanClause> iterator() { return clauses().iterator(); }
 
   private static BooleanQuery downgradeMustClauseToFilter(BooleanQuery bq) {
-    BooleanQuery clone = bq.clone();
-    clone.clauses.clear();
+    List<BooleanClause> newClauses = new ArrayList<>();
     for (BooleanClause clause : bq.clauses()) {
       if (clause.getOccur() == Occur.MUST) {
-        clone.add(clause.getQuery(), Occur.FILTER);
+        newClauses.add(new BooleanClause(clause.getQuery(), Occur.FILTER));
       } else {
-        clone.add(clause);
+        newClauses.add(clause);
       }
     }
-    return clone;
+    BooleanQuery newQuery = new BooleanQuery(bq.isCoordDisabled(), bq.getMinimumNumberShouldMatch(), newClauses);
+    newQuery.setBoost(bq.getBoost());
+    return newQuery;
   }
 
   @Override
@@ -212,24 +196,22 @@
       }
     }
 
-    BooleanQuery clone = null;                    // recursively rewrite
-    for (int i = 0 ; i < clauses.size(); i++) {
-      BooleanClause c = clauses.get(i);
-      Query query = c.getQuery().rewrite(reader);
-      if (query != c.getQuery()) {                     // clause rewrote: must clone
-        if (clone == null) {
-          // The BooleanQuery clone is lazily initialized so only initialize
-          // it if a rewritten clause differs from the original clause (and hasn't been
-          // initialized already).  If nothing differs, the clone isn't needlessly created
-          clone = this.clone();
-        }
-        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));
+    List<BooleanClause> rewrittenClauses = new ArrayList<>();
+    boolean changed = false;
+    for (BooleanClause clause : clauses) {
+      final Query q = clause.getQuery();
+      final Query rewritten = q.rewrite(reader);
+      rewrittenClauses.add(new BooleanClause(rewritten, clause.getOccur()));
+      if (q != rewritten) {
+        changed = true;
       }
     }
-    if (clone != null) {
-      return clone;                               // some clauses rewrote
+    if (changed) {
+      return this;
     } else {
-      return this;                                // no clauses rewrote
+      BooleanQuery rewritten = (BooleanQuery) clone();
+      rewritten.clauses = Collections.unmodifiableList(rewrittenClauses);
+      return rewritten;
     }
   }
 
@@ -243,13 +225,6 @@
     }
   }
 
-  @Override @SuppressWarnings("unchecked")
-  public BooleanQuery clone() {
-    BooleanQuery clone = (BooleanQuery)super.clone();
-    clone.clauses = new ArrayList<>(clauses);
-    return clone;
-  }
-
   /** Prints a user-readable version of this query. */
   @Override
   public String toString(String field) {
Index: lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java	(working copy)
@@ -233,11 +233,11 @@
       return null;
     }
 
-    if (query.minNrShouldMatch > optional.size()) {
+    if (query.getMinimumNumberShouldMatch() > optional.size()) {
       return null;
     }
 
-    return new BooleanScorer(this, disableCoord, maxCoord, optional, Math.max(1, query.minNrShouldMatch));
+    return new BooleanScorer(this, disableCoord, maxCoord, optional, Math.max(1, query.getMinimumNumberShouldMatch()));
   }
 
   @Override
@@ -246,7 +246,7 @@
     if (bulkScorer != null) { // BooleanScorer is applicable
       // TODO: what is the right heuristic here?
       final long costThreshold;
-      if (query.minNrShouldMatch <= 1) {
+      if (query.getMinimumNumberShouldMatch() <= 1) {
         // when all clauses are optional, use BooleanScorer aggressively
         // TODO: is there actually a threshold under which we should rather
         // use the regular scorer?
@@ -273,7 +273,7 @@
     // initially the user provided value,
     // but if minNrShouldMatch == optional.size(),
     // we will optimize and move these to required, making this 0
-    int minShouldMatch = query.minNrShouldMatch;
+    int minShouldMatch = query.getMinimumNumberShouldMatch();
 
     List<Scorer> required = new ArrayList<>();
     // clauses that are required AND participate in scoring, subset of 'required'
Index: lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java	(working copy)
@@ -59,13 +59,6 @@
     this(query, QueryCachingPolicy.CacheOnLargeSegments.DEFAULT);
   }
 
-  @Override
-  public CachingWrapperQuery clone() {
-    final CachingWrapperQuery clone = (CachingWrapperQuery) super.clone();
-    clone.query = query.clone();
-    return clone;
-  }
-
   /**
    * Gets the contained query.
    * @return the contained query.
@@ -97,7 +90,7 @@
     if (query == rewritten) {
       return this;
     } else {
-      CachingWrapperQuery clone = clone();
+      CachingWrapperQuery clone = (CachingWrapperQuery) clone();
       clone.query = rewritten;
       return clone;
     }
Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(working copy)
@@ -18,7 +18,9 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
@@ -45,46 +47,29 @@
 public class DisjunctionMaxQuery extends Query implements Iterable<Query> {
 
   /* The subqueries */
-  private ArrayList<Query> disjuncts = new ArrayList<>();
+  private List<Query> disjuncts;
 
   /* Multiple of the non-max disjunct scores added into our final score.  Non-zero values support tie-breaking. */
   private float tieBreakerMultiplier = 0.0f;
 
-  /** Creates a new empty DisjunctionMaxQuery.  Use add() to add the subqueries.
-   * @param tieBreakerMultiplier the score of each non-maximum disjunct for a document is multiplied by this weight
+  /**
+   * Creates a new DisjunctionMaxQuery
+   * @param disjuncts a {@code Collection<Query>} of all the disjuncts to add
+   * @param tieBreakerMultiplier   the score of each non-maximum disjunct for a document is multiplied by this weight
    *        and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that
    *        10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
    *        word in the lower scored field (i.e., one that is not in any higher scored field.
    */
-  public DisjunctionMaxQuery(float tieBreakerMultiplier) {
+  public DisjunctionMaxQuery(float tieBreakerMultiplier, Collection<Query> disjuncts) {
     this.tieBreakerMultiplier = tieBreakerMultiplier;
+    this.disjuncts = Collections.unmodifiableList(new ArrayList<>(disjuncts));
   }
 
-  /**
-   * Creates a new DisjunctionMaxQuery
-   * @param disjuncts a {@code Collection<Query>} of all the disjuncts to add
-   * @param tieBreakerMultiplier   the weight to give to each matching non-maximum disjunct
-   */
-  public DisjunctionMaxQuery(Collection<Query> disjuncts, float tieBreakerMultiplier) {
-    this.tieBreakerMultiplier = tieBreakerMultiplier;
-    add(disjuncts);
+  /** Same as {@link #DisjunctionMaxQuery(float, Collection)}. */
+  public DisjunctionMaxQuery(float tieBreakerMultiplier, Query... disjuncts) {
+    this(tieBreakerMultiplier, Arrays.asList(disjuncts));
   }
 
-  /** Add a subquery to this disjunction
-   * @param query the disjunct added
-   */
-  public void add(Query query) {
-    disjuncts.add(query);
-  }
-
-  /** Add a collection of disjuncts to this disjunction
-   * via {@code Iterable<Query>}
-   * @param disjuncts a collection of queries to add as disjuncts.
-   */
-  public void add(Collection<Query> disjuncts) {
-    this.disjuncts.addAll(disjuncts);
-  }
-
   /** @return An {@code Iterator<Query>} over the disjuncts */
   @Override
   public Iterator<Query> iterator() {
@@ -94,7 +79,7 @@
   /**
    * @return the disjuncts.
    */
-  public ArrayList<Query> getDisjuncts() {
+  public List<Query> getDisjuncts() {
     return disjuncts;
   }
 
@@ -215,28 +200,24 @@
       }
       return result;
     }
-    DisjunctionMaxQuery clone = null;
-    for (int i = 0 ; i < numDisjunctions; i++) {
-      Query clause = disjuncts.get(i);
+    boolean changed = false;
+    List<Query> rewrittenDisjuncts = new ArrayList<>();
+    for (Query clause : disjuncts) {
       Query rewrite = clause.rewrite(reader);
+      rewrittenDisjuncts.add(rewrite);
       if (rewrite != clause) {
-        if (clone == null) clone = this.clone();
-        clone.disjuncts.set(i, rewrite);
+        changed = true;
       }
     }
-    if (clone != null) return clone;
-    else return this;
+    if (changed) {
+      DisjunctionMaxQuery rewritten = (DisjunctionMaxQuery) clone();
+      rewritten.disjuncts = Collections.unmodifiableList(rewrittenDisjuncts);
+      return rewritten;
+    } else {
+      return this;
+    }
   }
 
-  /** Create a shallow copy of us -- used in rewriting if necessary
-   * @return a copy of us (but reuse, don't copy, our subqueries) */
-  @Override @SuppressWarnings("unchecked")
-  public DisjunctionMaxQuery clone() {
-    DisjunctionMaxQuery clone = (DisjunctionMaxQuery)super.clone();
-    clone.disjuncts = (ArrayList<Query>) this.disjuncts.clone();
-    return clone;
-  }
-
   // inherit javadoc
   @Override
   public void extractTerms(Set<Term> terms) {
Index: lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(working copy)
@@ -345,9 +345,9 @@
     if (filter instanceof QueryWrapperFilter) {
       // In that case the filter does not implement random-access anyway so
       // we want to take advantage of approximations
-      BooleanQuery rewritten = new BooleanQuery();
-      rewritten.add(query, Occur.MUST);
-      rewritten.add(((QueryWrapperFilter) filter).getQuery(), Occur.FILTER);
+      BooleanQuery rewritten = new BooleanQuery(
+          new BooleanClause(query, Occur.MUST_NOT),
+          new BooleanClause(((QueryWrapperFilter) filter).getQuery(), Occur.FILTER));
       rewritten.setBoost(getBoost());
       return rewritten;
     }
Index: lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java	(working copy)
@@ -32,8 +32,7 @@
 
 /**
  * A {@link Scorer} for {@link BooleanQuery} when
- * {@link BooleanQuery#setMinimumNumberShouldMatch(int) minShouldMatch} is
- * between 2 and the total number of clauses.
+ * minShouldMatch is between 2 and the total number of clauses.
  *
  * This implementation keeps sub scorers in 3 different places:
  *  - lead: a linked list of scorer that are positioned on the desired doc ID
Index: lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -18,20 +18,30 @@
  */
 
 import java.io.IOException;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
-import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
@@ -39,8 +49,8 @@
 import org.apache.lucene.util.ToStringUtils;
 
 /**
- * MultiPhraseQuery is a generalized version of PhraseQuery, with an added
- * method {@link #add(Term[])}.
+ * MultiPhraseQuery is a generalized version of PhraseQuery which can handle
+ * several terms at the same position.
  * To use this class, to search for the phrase "Microsoft app*" first use
  * add(Term) on the term "Microsoft", then find all terms that have "app" as
  * prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[]
@@ -48,71 +58,119 @@
  *
  */
 public class MultiPhraseQuery extends Query {
-  private String field;
-  private ArrayList<Term[]> termArrays = new ArrayList<>();
-  private ArrayList<Integer> positions = new ArrayList<>();
 
-  private int slop = 0;
+  /** Wrapper around a set of {@link Term}s and a (relative) position. */
+  public static final class TermsAndPosition {
+    public final Set<Term> terms;
+    public final int position;
 
-  /** Sets the phrase slop for this query.
-   * @see PhraseQuery#setSlop(int)
-   */
-  public void setSlop(int s) {
-    if (s < 0) {
-      throw new IllegalArgumentException("slop value cannot be negative");
+    /** Sole constructor.
+     * @param terms the terms to match
+     * @param position the relative position of the term in the phrase
+     */
+    public TermsAndPosition(Collection<Term> terms, int position) {
+      if (terms.size() == 0) {
+        throw new IllegalArgumentException("The list of terms must contain at least one entry.");
+      }
+      this.terms = new HashSet<>();
+      for (Term t : terms) {
+        this.terms.add(new Term(t.field(), BytesRef.deepCopyOf(t.bytes())));
+      }
+      this.position = position;
     }
-    slop = s; 
-  }
 
-  /** Sets the phrase slop for this query.
-   * @see PhraseQuery#getSlop()
-   */
-  public int getSlop() { return slop; }
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof TermsAndPosition == false) {
+        return false;
+      }
+      TermsAndPosition that = (TermsAndPosition) obj;
+      return terms.equals(that.terms) && this.position == that.position;
+    }
 
-  /** Add a single term at the next position in the phrase.
-   * @see PhraseQuery#add(Term)
-   */
-  public void add(Term term) { add(new Term[]{term}); }
+    @Override
+    public int hashCode() {
+      return 31 * terms.hashCode() + position;
+    }
+  }
+  
+  private final TermsAndPosition[] termsPositions;
+  private final int slop;
 
-  /** Add multiple terms at the next position in the phrase.  Any of the terms
-   * may match.
-   *
-   * @see PhraseQuery#add(Term)
-   */
-  public void add(Term[] terms) {
-    int position = 0;
-    if (positions.size() > 0)
-      position = positions.get(positions.size()-1).intValue() + 1;
-
-    add(terms, position);
+  private static void validate(TermsAndPosition[] termPositions) {
+    String field = null;
+    int previousPosition = 0;
+    for (TermsAndPosition termPos : termPositions) {
+      if (termPos.position < 0) {
+        throw new IllegalArgumentException("Positions must be positive, got " + termPos.position);
+      }
+      if (termPos.position < previousPosition) {
+        throw new IllegalArgumentException("Positions must be added in order. Got position="
+            + termPos.position + " while previous position was " + previousPosition);
+      }
+      for (Term term : termPos.terms) {
+        if (field != null && term.field().equals(field) == false) {
+          throw new IllegalArgumentException("All phrase terms must be in the same field: " + field + " / " + term.field());
+        }
+        field = term.field();
+      }
+      previousPosition = termPos.position;
+    }
   }
 
   /**
-   * Allows to specify the relative position of terms within the phrase.
-   * 
-   * @see PhraseQuery#add(Term, int)
+   * Create a new {@link MultiPhraseQuery}.
+   *
+   * The {@code slop} is the number of other words permitted between words in query phrase.
+   * If zero, then this is an exact phrase search.  For larger values this works
+   * like a <code>WITHIN</code> or <code>NEAR</code> operator.
+   *
+   * <p>The slop is in fact an edit-distance, where the units correspond to
+   * moves of terms in the query phrase out of position.  For example, to switch
+   * the order of two words requires two moves (the first move places the words
+   * atop one another), so to permit re-orderings of phrases, the slop must be
+   * at least two.
+   *
+   * <p>More exact matches are scored higher than sloppier matches, thus search
+   * results are sorted by exactness.
    */
-  public void add(Term[] terms, int position) {
-    if (termArrays.size() == 0)
-      field = terms[0].field();
+  public MultiPhraseQuery(int slop, List<TermsAndPosition> termsPositions) {
+    this.slop = slop;
+    this.termsPositions = termsPositions.toArray(new TermsAndPosition[termsPositions.size()]);
+    validate(this.termsPositions);
+  }
 
-    for (int i = 0; i < terms.length; i++) {
-      if (!terms[i].field().equals(field)) {
-        throw new IllegalArgumentException(
-            "All phrase terms must be in the same field (" + field + "): "
-                + terms[i]);
-      }
-    }
+  /** Shortcut for MultiPhraseQuery(slop, Arrays.asList(termsPositions))
+   *  @see #MultiPhraseQuery(int, List) */
+  public MultiPhraseQuery(int slop, TermsAndPosition... termsPositions) {
+    this(slop, Arrays.asList(termsPositions));
+  }
 
-    termArrays.add(terms);
-    positions.add(Integer.valueOf(position));
+  /** Create a {@link MultiPhraseQuery} with a slop of {@code 0}. */
+  public MultiPhraseQuery(List<TermsAndPosition> termsPositions) {
+    this(0, termsPositions);
   }
 
+  /** Shortcut for MultiPhraseQuery(Arrays.asList(positions))
+   *  @see #MultiPhraseQuery(List) */
+  public MultiPhraseQuery(TermsAndPosition... termsPositions) {
+    this(Arrays.asList(termsPositions));
+  }
+
+  /** Gets the phrase slop for this query.
+   * @see PhraseQuery#getSlop()
+   */
+  public int getSlop() { return slop; }
+
   /**
    * Returns a List of the terms in the multiphrase.
    * Do not modify the List or its contents.
    */
   public List<Term[]> getTermArrays() {
+    List<Term[]> termArrays = new ArrayList<>();
+    for (TermsAndPosition tp : termsPositions) {
+      termArrays.add(tp.terms.toArray(new Term[0]));
+    }
     return Collections.unmodifiableList(termArrays);
   }
 
@@ -120,17 +178,23 @@
    * Returns the relative positions of terms in this phrase.
    */
   public int[] getPositions() {
-    int[] result = new int[positions.size()];
-    for (int i = 0; i < positions.size(); i++)
-      result[i] = positions.get(i).intValue();
+    int[] result = new int[termsPositions.length];
+    for (int i = 0; i < termsPositions.length; i++)
+      result[i] = termsPositions[i].position;
     return result;
   }
 
-  // inherit javadoc
+  /**
+   * Return the list of Term[]/position tuples.
+   */
+  public List<TermsAndPosition> getTermsAndPositions() {
+    return Collections.unmodifiableList(Arrays.asList(termsPositions));
+  }
+
   @Override
   public void extractTerms(Set<Term> terms) {
-    for (final Term[] arr : termArrays) {
-      for (final Term term: arr) {
+    for (TermsAndPosition tp : termsPositions) {
+      for (Term term : tp.terms) {
         terms.add(term);
       }
     }
@@ -152,8 +216,8 @@
       
       // compute idf
       ArrayList<TermStatistics> allTermStats = new ArrayList<>();
-      for(final Term[] terms: termArrays) {
-        for (Term term: terms) {
+      for (TermsAndPosition tp : termsPositions) {
+        for (Term term: tp.terms) {
           TermContext termContext = termContexts.get(term);
           if (termContext == null) {
             termContext = TermContext.build(context, term);
@@ -163,7 +227,7 @@
         }
       }
       stats = similarity.computeWeight(getBoost(),
-          searcher.collectionStatistics(field), 
+          searcher.collectionStatistics(termsPositions[0].terms.iterator().next().field()),
           allTermStats.toArray(new TermStatistics[allTermStats.size()]));
     }
 
@@ -179,13 +243,13 @@
 
     @Override
     public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
-      assert !termArrays.isEmpty();
+      assert termsPositions.length > 0;
       final LeafReader reader = context.reader();
       final Bits liveDocs = acceptDocs;
       
-      PhraseQuery.PostingsAndFreq[] postingsFreqs = new PhraseQuery.PostingsAndFreq[termArrays.size()];
+      PhraseQuery.PostingsAndFreq[] postingsFreqs = new PhraseQuery.PostingsAndFreq[termsPositions.length];
 
-      final Terms fieldTerms = reader.terms(field);
+      final Terms fieldTerms = reader.terms(termsPositions[0].terms.iterator().next().field());
       if (fieldTerms == null) {
         return null;
       }
@@ -194,7 +258,7 @@
       final TermsEnum termsEnum = fieldTerms.iterator(null);
 
       for (int pos=0; pos<postingsFreqs.length; pos++) {
-        Term[] terms = termArrays.get(pos);
+        Term[] terms = termsPositions[pos].terms.toArray(new Term[0]);
 
         final PostingsEnum postingsEnum;
         int docFreq;
@@ -239,7 +303,7 @@
           docFreq = termsEnum.docFreq();
         }
 
-        postingsFreqs[pos] = new PhraseQuery.PostingsAndFreq(postingsEnum, docFreq, positions.get(pos).intValue(), terms);
+        postingsFreqs[pos] = new PhraseQuery.PostingsAndFreq(postingsEnum, docFreq, termsPositions[pos].position, terms);
       }
 
       // sort by increasing docFreq order
@@ -278,16 +342,16 @@
 
   @Override
   public Query rewrite(IndexReader reader) {
-    if (termArrays.isEmpty()) {
+    if (termsPositions.length == 0) {
       BooleanQuery bq = new BooleanQuery();
       bq.setBoost(getBoost());
       return bq;
-    } else if (termArrays.size() == 1) {                 // optimize one-term case
-      Term[] terms = termArrays.get(0);
-      BooleanQuery boq = new BooleanQuery(true);
-      for (int i=0; i<terms.length; i++) {
-        boq.add(new TermQuery(terms[i]), BooleanClause.Occur.SHOULD);
+    } else if (termsPositions.length == 1) {                 // optimize one-term case
+      List<BooleanClause> clauses = new ArrayList<>();
+      for (Term term : termsPositions[0].terms) {
+        clauses.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));
       }
+      BooleanQuery boq = new BooleanQuery(true, 0, clauses);
       boq.setBoost(getBoost());
       return boq;
     } else {
@@ -304,7 +368,13 @@
   @Override
   public final String toString(String f) {
     StringBuilder buffer = new StringBuilder();
-    if (field == null || !field.equals(f)) {
+    final String field;
+    if (termsPositions.length > 0) {
+      field = termsPositions[0].terms.iterator().next().field();
+    } else {
+      field = null;
+    }
+    if (field != null && !field.equals(f)) {
       buffer.append(field);
       buffer.append(":");
     }
@@ -311,32 +381,30 @@
 
     buffer.append("\"");
     int k = 0;
-    Iterator<Term[]> i = termArrays.iterator();
     int lastPos = -1;
     boolean first = true;
-    while (i.hasNext()) {
-      Term[] terms = i.next();
-      int position = positions.get(k);
+    for (TermsAndPosition tp : termsPositions) {
       if (first) {
         first = false;
       } else {
         buffer.append(" ");
-        for (int j=1; j<(position-lastPos); j++) {
+        for (int j=1; j<(tp.position-lastPos); j++) {
           buffer.append("? ");
         }
       }
-      if (terms.length > 1) {
+      if (tp.terms.size() > 1) {
         buffer.append("(");
-        for (int j = 0; j < terms.length; j++) {
-          buffer.append(terms[j].text());
-          if (j < terms.length-1)
+        int j = 0;
+        for (Term term : tp.terms) {
+          buffer.append(term.text());
+          if (j++ < tp.terms.size()-1)
             buffer.append(" ");
         }
         buffer.append(")");
       } else {
-        buffer.append(terms[0].text());
+        buffer.append(tp.terms.iterator().next().text());
       }
-      lastPos = position;
+      lastPos = tp.position;
       ++k;
     }
     buffer.append("\"");
@@ -359,8 +427,7 @@
     MultiPhraseQuery other = (MultiPhraseQuery)o;
     return super.equals(o)
       && this.slop == other.slop
-      && termArraysEquals(this.termArrays, other.termArrays)
-      && this.positions.equals(other.positions);
+      && termsPositions.equals(other.termsPositions);
   }
 
   /** Returns a hash code value for this object.*/
@@ -368,37 +435,8 @@
   public int hashCode() {
     return super.hashCode()
       ^ slop
-      ^ termArraysHashCode()
-      ^ positions.hashCode();
+      ^ termsPositions.hashCode();
   }
-  
-  // Breakout calculation of the termArrays hashcode
-  private int termArraysHashCode() {
-    int hashCode = 1;
-    for (final Term[] termArray: termArrays) {
-      hashCode = 31 * hashCode
-          + (termArray == null ? 0 : Arrays.hashCode(termArray));
-    }
-    return hashCode;
-  }
-
-  // Breakout calculation of the termArrays equals
-  private boolean termArraysEquals(List<Term[]> termArrays1, List<Term[]> termArrays2) {
-    if (termArrays1.size() != termArrays2.size()) {
-      return false;
-    }
-    ListIterator<Term[]> iterator1 = termArrays1.listIterator();
-    ListIterator<Term[]> iterator2 = termArrays2.listIterator();
-    while (iterator1.hasNext()) {
-      Term[] termArray1 = iterator1.next();
-      Term[] termArray2 = iterator2.next();
-      if (!(termArray1 == null ? termArray2 == null : Arrays.equals(termArray1,
-          termArray2))) {
-        return false;
-      }
-    }
-    return true;
-  }
 }
 
 /**
Index: lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java	(working copy)
@@ -18,6 +18,8 @@
  */
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.lucene.index.FilteredTermsEnum; // javadocs
 import org.apache.lucene.index.IndexReader;
@@ -137,7 +139,7 @@
    * 
    * @see #setRewriteMethod
    */
-  public static final class TopTermsScoringBooleanQueryRewrite extends TopTermsRewrite<BooleanQuery> {
+  public static final class TopTermsScoringBooleanQueryRewrite extends TopTermsRewrite<List<BooleanClause>> {
 
     /** 
      * Create a TopTermsScoringBooleanQueryRewrite for 
@@ -156,15 +158,20 @@
     }
     
     @Override
-    protected BooleanQuery getTopLevelQuery() {
-      return new BooleanQuery(true);
+    protected List<BooleanClause> getTopLevelBuilder() {
+      return new ArrayList<>();
     }
     
     @Override
-    protected void addClause(BooleanQuery topLevel, Term term, int docCount, float boost, TermContext states) {
+    protected Query build(List<BooleanClause> clauses) {
+      return new BooleanQuery(true, 0, clauses);
+    }
+    
+    @Override
+    protected void addClause(List<BooleanClause> topLevel, Term term, int docCount, float boost, TermContext states) {
       final TermQuery tq = new TermQuery(term, states);
       tq.setBoost(boost);
-      topLevel.add(tq, BooleanClause.Occur.SHOULD);
+      topLevel.add(new BooleanClause(tq, BooleanClause.Occur.SHOULD));
     }
   }
   
@@ -178,7 +185,7 @@
    * 
    * @see #setRewriteMethod
    */
-  public static final class TopTermsBoostOnlyBooleanQueryRewrite extends TopTermsRewrite<BooleanQuery> {
+  public static final class TopTermsBoostOnlyBooleanQueryRewrite extends TopTermsRewrite<List<BooleanClause>> {
     
     /** 
      * Create a TopTermsBoostOnlyBooleanQueryRewrite for 
@@ -197,15 +204,20 @@
     }
     
     @Override
-    protected BooleanQuery getTopLevelQuery() {
-      return new BooleanQuery(true);
+    protected List<BooleanClause> getTopLevelBuilder() {
+      return new ArrayList<>();
     }
-    
+
     @Override
-    protected void addClause(BooleanQuery topLevel, Term term, int docFreq, float boost, TermContext states) {
+    protected Query build(List<BooleanClause> clauses) {
+      return new BooleanQuery(true, 0, clauses);
+    }
+
+    @Override
+    protected void addClause(List<BooleanClause> topLevel, Term term, int docFreq, float boost, TermContext states) {
       final Query q = new ConstantScoreQuery(new TermQuery(term, states));
       q.setBoost(boost);
-      topLevel.add(q, BooleanClause.Occur.SHOULD);
+      topLevel.add(new BooleanClause(q, BooleanClause.Occur.SHOULD));
     }
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/NGramPhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/NGramPhraseQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/NGramPhraseQuery.java	(working copy)
@@ -18,9 +18,11 @@
  */
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 
 /**
  * This is a {@link PhraseQuery} which is optimized for n-gram phrase query.
@@ -30,51 +32,64 @@
  * will query "AB/0 BC/1 CD/2" (where term/position).
  *
  */
-public class NGramPhraseQuery extends PhraseQuery {
+public final class NGramPhraseQuery extends Query {
   private final int n;
+  private final PhraseQuery pq;
   
   /**
    * Constructor that takes gram size.
    * @param n n-gram size
    */
-  public NGramPhraseQuery(int n){
+  public NGramPhraseQuery(int n, PhraseQuery pq){
     super();
     this.n = n;
+    this.pq = pq;
   }
 
   @Override
   public Query rewrite(IndexReader reader) throws IOException {
-    if(getSlop() != 0) return super.rewrite(reader);
-    
+    if (getBoost() != 1f) {
+      PhraseQuery pqClone = (PhraseQuery) pq.clone();
+      pqClone.setBoost(getBoost() * pqClone.getBoost());
+      return new NGramPhraseQuery(n, pqClone);
+    }
+
+    if (pq.getSlop() != 0) {
+      return pq.rewrite(reader);
+    }
+
+    Query pqRewritten = pq.rewrite(reader);
+    if (pqRewritten != pq) {
+      if (pqRewritten instanceof PhraseQuery) {
+        return new NGramPhraseQuery(n, (PhraseQuery) pqRewritten);
+      } else {
+        return pqRewritten;
+      }
+    }
+
     // check whether optimizable or not
     if(n < 2 || // non-overlap n-gram cannot be optimized
-        getTerms().length < 3)  // too short to optimize
+        pq.termAndPositions().size() < 3) {  // too short to optimize
       return super.rewrite(reader);
+    }
 
     // check all posIncrement is 1
     // if not, cannot optimize
-    int[] positions = getPositions();
-    Term[] terms = getTerms();
-    int prevPosition = positions[0];
-    for(int i = 1; i < positions.length; i++){
-      int pos = positions[i];
-      if(prevPosition + 1 != pos) return super.rewrite(reader);
-      prevPosition = pos;
+    List<TermAndPosition> termPos = pq.termAndPositions();
+    for (int i = 0; i < termPos.size(); ++i) {
+      if (termPos.get(i).position != i) {
+        return pq.rewrite(reader);
+      }
     }
 
     // now create the new optimized phrase query for n-gram
-    PhraseQuery optimized = new PhraseQuery();
-    optimized.setBoost(getBoost());
-    int pos = 0;
-    final int lastPos = terms.length - 1;
-    for(int i = 0; i < terms.length; i++){
-      if(pos % n == 0 || pos >= lastPos){
-        optimized.add(terms[i], positions[i]);
+    List<TermAndPosition> optimized = new ArrayList<>();
+    for (int i = 0; i < termPos.size(); ++i) {
+      if (i % n == 0 || i == termPos.size() - 1) {
+        optimized.add(termPos.get(i));
       }
-      pos++;
     }
-    
-    return optimized;
+    return new PhraseQuery(pq.getSlop(), optimized);
   }
 
   /** Returns true iff <code>o</code> is equal to this. */
@@ -84,16 +99,17 @@
       return false;
     NGramPhraseQuery other = (NGramPhraseQuery)o;
     if(this.n != other.n) return false;
-    return super.equals(other);
+    return pq.equals(other.pq);
   }
 
   /** Returns a hash code value for this object.*/
   @Override
   public int hashCode() {
-    return Float.floatToIntBits(getBoost())
-      ^ getSlop()
-      ^ getTerms().hashCode()
-      ^ getPositions().hashCode()
-      ^ n;
+    return 31 * pq.hashCode() + n;
   }
+
+  @Override
+  public String toString(String field) {
+    return pq.toString(field);
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java	(working copy)
@@ -20,13 +20,15 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import java.util.Set;
 
-import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
@@ -36,6 +38,7 @@
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 /** A Query that matches documents containing a particular sequence of terms.
@@ -57,115 +60,155 @@
  * pq.add(new Term("body", "two"), 1);
  * </pre>
  */
-public class PhraseQuery extends Query {
-  private String field;
-  private ArrayList<Term> terms = new ArrayList<>(4);
-  private ArrayList<Integer> positions = new ArrayList<>(4);
-  private int slop = 0;
+public final class PhraseQuery extends Query {
 
-  /** Constructs an empty phrase query. */
-  public PhraseQuery() {}
+  /** Wrapper around a {@link Term} and a (relative) position. */
+  public static final class TermAndPosition {
+    public final Term term;
+    public final int position;
 
-  /** Sets the number of other words permitted between words in query phrase.
-    If zero, then this is an exact phrase search.  For larger values this works
-    like a <code>WITHIN</code> or <code>NEAR</code> operator.
+    /** Sole constructor.
+     * @param term the term to match
+     * @param position the relative position of the term in the phrase
+     */
+    public TermAndPosition(Term term, int position) {
+      this.term = new Term(term.field(), BytesRef.deepCopyOf(term.bytes()));
+      this.position = position;
+    }
 
-    <p>The slop is in fact an edit-distance, where the units correspond to
-    moves of terms in the query phrase out of position.  For example, to switch
-    the order of two words requires two moves (the first move places the words
-    atop one another), so to permit re-orderings of phrases, the slop must be
-    at least two.
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof TermAndPosition == false) {
+        return false;
+      }
+      TermAndPosition that = (TermAndPosition) obj;
+      return this.term.equals(that.term) && this.position == that.position;
+    }
 
-    <p>More exact matches are scored higher than sloppier matches, thus search
-    results are sorted by exactness.
+    @Override
+    public int hashCode() {
+      return 31 * term.hashCode() + position;
+    }
+  }
 
-    <p>The slop is zero by default, requiring exact matches.*/
-  public void setSlop(int s) {
-    if (s < 0) {
-      throw new IllegalArgumentException("slop value cannot be negative");
+  private static void validate(TermAndPosition[] termPositions) {
+    String field = null;
+    int previousPosition = 0;
+    for (TermAndPosition termPos : termPositions) {
+      if (termPos.position < 0) {
+        throw new IllegalArgumentException("Positions must be positive, got " + termPos.position);
+      }
+      if (termPos.position < previousPosition) {
+        throw new IllegalArgumentException("Positions must be added in order. Got position="
+            + termPos.position + " while previous position was " + previousPosition);
+      }
+      if (field != null && termPos.term.field().equals(field) == false) {
+        throw new IllegalArgumentException("All phrase terms must be in the same field: " + field + " / " + termPos.term.field());
+      }
+      field = termPos.term.field();
+      previousPosition = termPos.position;
     }
-    slop = s; 
   }
-  /** Returns the slop.  See setSlop(). */
-  public int getSlop() { return slop; }
 
+  private final TermAndPosition[] termPositions;
+  private final int slop;
+
   /**
-   * Adds a term to the end of the query phrase.
-   * The relative position of the term is the one immediately after the last term added.
+   * Create a new {@link PhraseQuery}.
+   *
+   * The {@code slop} is the number of other words permitted between words in query phrase.
+   * If zero, then this is an exact phrase search.  For larger values this works
+   * like a <code>WITHIN</code> or <code>NEAR</code> operator.
+   *
+   * <p>The slop is in fact an edit-distance, where the units correspond to
+   * moves of terms in the query phrase out of position.  For example, to switch
+   * the order of two words requires two moves (the first move places the words
+   * atop one another), so to permit re-orderings of phrases, the slop must be
+   * at least two.
+   *
+   * <p>More exact matches are scored higher than sloppier matches, thus search
+   * results are sorted by exactness.
    */
-  public void add(Term term) {
-    int position = 0;
-    if (positions.size() > 0) {
-      position = positions.get(positions.size()-1) + 1;
-    }
+  public PhraseQuery(int slop, List<TermAndPosition> termPositions) {
+    this.slop = slop;
+    this.termPositions = termPositions.toArray(new TermAndPosition[termPositions.size()]);
+    validate(this.termPositions);
+  }
 
-    add(term, position);
+  /** Shortcut for PhraseQuery(slop, Arrays.asList(positions))
+   *  @see #PhraseQuery(int, List) */
+  public PhraseQuery(int slop, TermAndPosition... termPositions) {
+    this(slop, Arrays.asList(termPositions));
   }
 
-  /**
-   * Adds a term to the end of the query phrase.
-   * The relative position of the term within the phrase is specified explicitly.
-   * This allows e.g. phrases with more than one term at the same position
-   * or phrases with gaps (e.g. in connection with stopwords).
-   * 
-   */
-  public void add(Term term, int position) {
-    if (positions.size() > 0) {
-      final int previousPosition = positions.get(positions.size()-1);
-      if (position < previousPosition) {
-        throw new IllegalArgumentException("Positions must be added in order. Got position="
-            + position + " while previous position was " + previousPosition);
-      }
-    } else if (position < 0) {
-      throw new IllegalArgumentException("Positions must be positive, got " + position);
-    }
+  /** Create a {@link PhraseQuery} with a slop of {@code 0}. */
+  public PhraseQuery(List<TermAndPosition> termPositions) {
+    this(0, termPositions);
+  }
 
-    if (terms.size() == 0) {
-      field = term.field();
-    } else if (!term.field().equals(field)) {
-      throw new IllegalArgumentException("All phrase terms must be in the same field: " + term);
+  /** Shortcut for PhraseQuery(Arrays.asList(positions))
+   *  @see #PhraseQuery(List) */
+  public PhraseQuery(TermAndPosition... termPositions) {
+    this(Arrays.asList(termPositions));
+  }
+
+  private static TermAndPosition[] toTermAndPositions(Term... terms) {
+    TermAndPosition[] termPos = new TermAndPosition[terms.length];
+    for (int i = 0; i < terms.length; ++i) {
+      termPos[i] = new TermAndPosition(terms[i], i);
     }
+    return termPos;
+  }
 
-    terms.add(term);
-    positions.add(Integer.valueOf(position));
+  /** Create a {@link PhraseQuery} that will match the given terms at
+   *  consecutive positions. */
+  public PhraseQuery(int slop, Term... terms) {
+    this(slop, toTermAndPositions(terms));
   }
 
-  /** Returns the set of terms in this phrase. */
-  public Term[] getTerms() {
-    return terms.toArray(new Term[0]);
+  /** Create a {@link PhraseQuery} that will match the given terms at
+   *  consecutive positions. */
+  public PhraseQuery(Term... terms) {
+    this(toTermAndPositions(terms));
   }
 
-  /**
-   * Returns the relative positions of terms in this phrase.
-   */
-  public int[] getPositions() {
-      int[] result = new int[positions.size()];
-      for(int i = 0; i < positions.size(); i++)
-          result[i] = positions.get(i).intValue();
-      return result;
+  private static List<TermAndPosition> toTermAndPositions(List<Term> terms) {
+    List<TermAndPosition> termPos = new ArrayList<>();
+    int i = 0;
+    for (Term term : terms) {
+      termPos.add(new TermAndPosition(term, i++));
+    }
+    return termPos;
   }
 
+  /** Returns the slop. */
+  public int getSlop() { return slop; }
+
+  /** Return the list of {@link TermAndPosition}s. */
+  public List<TermAndPosition> termAndPositions() {
+    return Collections.unmodifiableList(Arrays.asList(termPositions));
+  }
+
   @Override
   public Query rewrite(IndexReader reader) throws IOException {
-    if (terms.isEmpty()) {
-      BooleanQuery bq = new BooleanQuery();
-      bq.setBoost(getBoost());
-      return bq;
-    } else if (terms.size() == 1) {
-      TermQuery tq = new TermQuery(terms.get(0));
+    if (termPositions.length == 0) {
+      MatchNoDocsQuery q = new MatchNoDocsQuery();
+      q.setBoost(getBoost());
+      return q;
+    } else if (termPositions.length == 1) {
+      TermQuery tq = new TermQuery(termPositions[0].term);
       tq.setBoost(getBoost());
       return tq;
-    } else if (positions.get(0).intValue() != 0) {
+    } else if (termPositions[0].position != 0) {
       // PhraseWeight requires that positions start at 0 so we need to rebase
       // positions
-      final Term[] terms = getTerms();
-      final int[] positions = getPositions();
-      PhraseQuery rewritten = new PhraseQuery();
-      for (int i = 0; i < terms.length; ++i) {
-        rewritten.add(terms[i], positions[i] - positions[0]);
+      final int base = termPositions[0].position;
+      List<TermAndPosition> newTermPositions = new ArrayList<>();
+      for (TermAndPosition tp : termPositions) {
+        newTermPositions.add(new TermAndPosition(tp.term, tp.position - base));
       }
+      PhraseQuery rewritten = new PhraseQuery(slop, newTermPositions);
       rewritten.setBoost(getBoost());
-      rewritten.setSlop(getSlop());
       return rewritten;
     } else {
       return super.rewrite(reader);
@@ -253,23 +296,22 @@
     public PhraseWeight(IndexSearcher searcher, boolean needsScores)
       throws IOException {
       super(PhraseQuery.this);
-      final int[] positions = PhraseQuery.this.getPositions();
-      if (positions.length < 2) {
+      if (termPositions.length < 2) {
         throw new IllegalStateException("PhraseWeight does not support less than 2 terms, call rewrite first");
-      } else if (positions[0] != 0) {
+      } else if (termPositions[0].position != 0) {
         throw new IllegalStateException("PhraseWeight requires that the first position is 0, call rewrite first");
       }
       this.needsScores = needsScores;
       this.similarity = searcher.getSimilarity();
       final IndexReaderContext context = searcher.getTopReaderContext();
-      states = new TermContext[terms.size()];
-      TermStatistics termStats[] = new TermStatistics[terms.size()];
-      for (int i = 0; i < terms.size(); i++) {
-        final Term term = terms.get(i);
-        states[i] = TermContext.build(context, term);
-        termStats[i] = searcher.termStatistics(term, states[i]);
+      states = new TermContext[termPositions.length];
+      TermStatistics termStats[] = new TermStatistics[termPositions.length];
+      for (int i = 0; i < termPositions.length; i++) {
+        final TermAndPosition term = termPositions[i];
+        states[i] = TermContext.build(context, term.term);
+        termStats[i] = searcher.termStatistics(term.term, states[i]);
       }
-      stats = similarity.computeWeight(getBoost(), searcher.collectionStatistics(field), termStats);
+      stats = similarity.computeWeight(getBoost(), searcher.collectionStatistics(termPositions[0].term.field()), termStats);
     }
 
     @Override
@@ -287,12 +329,11 @@
 
     @Override
     public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
-      assert !terms.isEmpty();
       final LeafReader reader = context.reader();
       final Bits liveDocs = acceptDocs;
-      PostingsAndFreq[] postingsFreqs = new PostingsAndFreq[terms.size()];
+      PostingsAndFreq[] postingsFreqs = new PostingsAndFreq[termPositions.length];
 
-      final Terms fieldTerms = reader.terms(field);
+      final Terms fieldTerms = reader.terms(termPositions[0].term.field());
       if (fieldTerms == null) {
         return null;
       }
@@ -300,24 +341,24 @@
       // Reuse single TermsEnum below:
       final TermsEnum te = fieldTerms.iterator(null);
       
-      for (int i = 0; i < terms.size(); i++) {
-        final Term t = terms.get(i);
+      for (int i = 0; i < termPositions.length; i++) {
+        final TermAndPosition t = termPositions[i];
         final TermState state = states[i].get(context.ord);
         if (state == null) { /* term doesnt exist in this segment */
-          assert termNotInReader(reader, t): "no termstate found but term exists in reader";
+          assert termNotInReader(reader, t.term): "no termstate found but term exists in reader";
           return null;
         }
-        te.seekExact(t.bytes(), state);
+        te.seekExact(t.term.bytes(), state);
         PostingsEnum postingsEnum = te.postings(liveDocs, null, PostingsEnum.POSITIONS);
 
         // PhraseQuery on a field that did not index
         // positions.
         if (postingsEnum == null) {
-          assert te.seekExact(t.bytes()) : "termstate found but no term exists in reader";
+          assert te.seekExact(t.term.bytes()) : "termstate found but no term exists in reader";
           // term does exist, but has no positions
-          throw new IllegalStateException("field \"" + t.field() + "\" was indexed without position data; cannot run PhraseQuery (term=" + t.text() + ")");
+          throw new IllegalStateException("field \"" + t.term.field() + "\" was indexed without position data; cannot run PhraseQuery (term=" + t.term.text() + ")");
         }
-        postingsFreqs[i] = new PostingsAndFreq(postingsEnum, te.docFreq(), positions.get(i), t);
+        postingsFreqs[i] = new PostingsAndFreq(postingsEnum, te.docFreq(), t.position, t.term);
       }
 
       // sort by increasing docFreq order
@@ -369,7 +410,9 @@
    */
   @Override
   public void extractTerms(Set<Term> queryTerms) {
-    queryTerms.addAll(terms);
+    for (TermAndPosition tp : termPositions) {
+      queryTerms.add(tp.term);
+    }
   }
 
   /** Prints a user-readable version of this query. */
@@ -376,28 +419,27 @@
   @Override
   public String toString(String f) {
     StringBuilder buffer = new StringBuilder();
-    if (field != null && !field.equals(f)) {
-      buffer.append(field);
+    if (termPositions.length > 0 && termPositions[0].term.field().equals(f)) {
+      buffer.append(termPositions[0].term.field());
       buffer.append(":");
     }
 
     buffer.append("\"");
     final int maxPosition;
-    if (positions.isEmpty()) {
+    if (termPositions.length == 0) {
       maxPosition = -1;
     } else {
-      maxPosition = positions.get(positions.size() - 1);
+      maxPosition = termPositions[termPositions.length - 1].position;
     }
     String[] pieces = new String[maxPosition + 1];
-    for (int i = 0; i < terms.size(); i++) {
-      int pos = positions.get(i).intValue();
-      String s = pieces[pos];
+    for (TermAndPosition tp : termPositions) {
+      String s = pieces[tp.position];
       if (s == null) {
-        s = (terms.get(i)).text();
+        s = tp.term.text();
       } else {
-        s = s + "|" + (terms.get(i)).text();
+        s = s + "|" + tp.term.text();
       }
-      pieces[pos] = s;
+      pieces[tp.position] = s;
     }
     for (int i = 0; i < pieces.length; i++) {
       if (i > 0) {
@@ -430,8 +472,7 @@
     PhraseQuery other = (PhraseQuery)o;
     return super.equals(o)
       && (this.slop == other.slop)
-      &&  this.terms.equals(other.terms)
-      && this.positions.equals(other.positions);
+      &&  this.termPositions.equals(other.termPositions);
   }
 
   /** Returns a hash code value for this object.*/
@@ -439,8 +480,7 @@
   public int hashCode() {
     return super.hashCode()
       ^ slop
-      ^ terms.hashCode()
-      ^ positions.hashCode();
+      ^ termPositions.hashCode();
   }
 
 }
Index: lucene/core/src/java/org/apache/lucene/search/Query.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/Query.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/Query.java	(working copy)
@@ -100,7 +100,8 @@
     throw new UnsupportedOperationException(getClass().getName());
   }
 
-  /** Returns a clone of this query. */
+  /** Returns a shallow clone of this query so that the {@link #getBoost() boost}
+   *  can be changed. This is typically useful for rewriting. */
   @Override
   public Query clone() {
     try {
Index: lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.java	(working copy)
@@ -18,6 +18,9 @@
  */
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
@@ -24,7 +27,6 @@
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
-
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.ByteBlockPool;
 import org.apache.lucene.util.BytesRef;
@@ -37,7 +39,7 @@
  * the scores as computed by the query.
  * <p>
  * @lucene.internal Only public to be accessible by spans package. */
-public abstract class ScoringRewrite<Q extends Query> extends TermCollectingRewrite<Q> {
+public abstract class ScoringRewrite<Q> extends TermCollectingRewrite<Q> {
 
   /** A rewrite method that first translates each term into
    *  {@link BooleanClause.Occur#SHOULD} clause in a
@@ -52,18 +54,22 @@
    *  exceeds {@link BooleanQuery#getMaxClauseCount}.
    *
    *  @see MultiTermQuery#setRewriteMethod */
-  public final static ScoringRewrite<BooleanQuery> SCORING_BOOLEAN_REWRITE = new ScoringRewrite<BooleanQuery>() {
+  public final static ScoringRewrite<?> SCORING_BOOLEAN_REWRITE = new ScoringRewrite<List<BooleanClause>>() {
     @Override
-    protected BooleanQuery getTopLevelQuery() {
-      return new BooleanQuery(true);
+    protected List<BooleanClause> getTopLevelBuilder() {
+      return new ArrayList<>();
     }
-    
+
+    protected Query build(List<BooleanClause> clauses) {
+      return new BooleanQuery(true, 0, clauses);
+    }
+
     @Override
-    protected void addClause(BooleanQuery topLevel, Term term, int docCount,
+    protected void addClause(List<BooleanClause> topLevel, Term term, int docCount,
         float boost, TermContext states) {
       final TermQuery tq = new TermQuery(term, states);
       tq.setBoost(boost);
-      topLevel.add(tq, BooleanClause.Occur.SHOULD);
+      topLevel.add(new BooleanClause(tq, BooleanClause.Occur.SHOULD));
     }
     
     @Override
@@ -86,9 +92,9 @@
   public final static RewriteMethod CONSTANT_SCORE_BOOLEAN_REWRITE = new RewriteMethod() {
     @Override
     public Query rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
-      final BooleanQuery bq = SCORING_BOOLEAN_REWRITE.rewrite(reader, query);
+      final Query q = SCORING_BOOLEAN_REWRITE.rewrite(reader, query);
       // strip the scores off
-      final Query result = new ConstantScoreQuery(bq);
+      final Query result = new ConstantScoreQuery(q);
       result.setBoost(query.getBoost());
       return result;
     }
@@ -99,8 +105,8 @@
   protected abstract void checkMaxClauseCount(int count) throws IOException;
   
   @Override
-  public final Q rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {
-    final Q result = getTopLevelQuery();
+  public final Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {
+    final Q result = getTopLevelBuilder();
     final ParallelArraysTermCollector col = new ParallelArraysTermCollector();
     collectTerms(reader, query, col);
     
@@ -116,7 +122,7 @@
         addClause(result, term, termStates[pos].docFreq(), query.getBoost() * boost[pos], termStates[pos]);
       }
     }
-    return result;
+    return build(result);
   }
 
   final class ParallelArraysTermCollector extends TermCollector {
Index: lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite.java	(working copy)
@@ -20,7 +20,6 @@
 import java.io.IOException;
 
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Fields;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.Term;
@@ -30,12 +29,15 @@
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
 
-abstract class TermCollectingRewrite<Q extends Query> extends MultiTermQuery.RewriteMethod {
+abstract class TermCollectingRewrite<Q> extends MultiTermQuery.RewriteMethod {
   
   
-  /** Return a suitable top-level Query for holding all expanded terms. */
-  protected abstract Q getTopLevelQuery() throws IOException;
-  
+  /** Return a Query builder for holding all expanded terms. */
+  protected abstract Q getTopLevelBuilder() throws IOException;
+
+  /** Build the query. */
+  protected abstract Query build(Q builder);
+
   /** Add a MultiTermQuery term to the top-level query */
   protected final void addClause(Q topLevel, Term term, int docCount, float boost) throws IOException {
     addClause(topLevel, term, docCount, boost, null);
Index: lucene/core/src/java/org/apache/lucene/search/TermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TermQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/TermQuery.java	(working copy)
@@ -32,6 +32,7 @@
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 /**
@@ -146,7 +147,7 @@
    * of looking up the docFreq against the searcher.
    */
   public TermQuery(Term t, int docFreq) {
-    term = t;
+    term = new Term(t.field(), BytesRef.deepCopyOf(t.bytes()));
     this.docFreq = docFreq;
     perReaderTermState = null;
   }
@@ -157,7 +158,7 @@
    */
   public TermQuery(Term t, TermContext states) {
     assert states != null;
-    term = t;
+    term = new Term(t.field(), BytesRef.deepCopyOf(t.bytes()));
     docFreq = states.docFreq();
     perReaderTermState = states;
   }
Index: lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java	(working copy)
@@ -37,7 +37,7 @@
  * via a priority queue.
  * @lucene.internal Only public to be accessible by spans package.
  */
-public abstract class TopTermsRewrite<Q extends Query> extends TermCollectingRewrite<Q> {
+public abstract class TopTermsRewrite<Q> extends TermCollectingRewrite<Q> {
 
   private final int size;
   
@@ -61,7 +61,7 @@
   protected abstract int getMaxSize();
   
   @Override
-  public final Q rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {
+  public final Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {
     final int maxSize = Math.min(size, getMaxSize());
     final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();
     collectTerms(reader, query, new TermCollector() {
@@ -154,7 +154,7 @@
       }
     });
     
-    final Q q = getTopLevelQuery();
+    final Q q = getTopLevelBuilder();
     final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);
     ArrayUtil.timSort(scoreTerms, scoreTermSortByTermComp);
     
@@ -163,7 +163,7 @@
       assert reader.docFreq(term) == st.termState.docFreq() : "reader DF is " + reader.docFreq(term) + " vs " + st.termState.docFreq() + " term=" + term;
       addClause(q, term, st.termState.docFreq(), query.getBoost() * st.boost, st.termState); // add to query
     }
-    return q;
+    return build(q);
   }
 
   @Override
Index: lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(working copy)
@@ -39,6 +39,7 @@
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
@@ -91,10 +92,10 @@
       }
 
     } else if (query instanceof PhraseQuery) {
-      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();
-      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];
-      for (int i = 0; i < phraseQueryTerms.length; i++) {
-        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);
+      List<TermAndPosition> phraseQueryTerms = ((PhraseQuery) query).termAndPositions();
+      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.size()];
+      for (int i = 0; i < phraseQueryTerms.size(); i++) {
+        clauses[i] = new SpanTermQuery(phraseQueryTerms.get(i).term);
       }
 
       int slop = ((PhraseQuery) query).getSlop();
Index: lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java	(working copy)
@@ -664,7 +664,7 @@
    * return larger values when the edit distance is small and smaller values
    * when it is large.
    *
-   * @see PhraseQuery#setSlop(int)
+   * @see PhraseQuery#PhraseQuery(int, java.util.List)
    * @param distance the edit distance of this sloppy phrase match
    * @return the frequency increment for this match
    */
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java	(working copy)
@@ -165,10 +165,14 @@
   public final static SpanRewriteMethod SCORING_SPAN_QUERY_REWRITE = new SpanRewriteMethod() {
     private final ScoringRewrite<SpanOrQuery> delegate = new ScoringRewrite<SpanOrQuery>() {
       @Override
-      protected SpanOrQuery getTopLevelQuery() {
+      protected SpanOrQuery getTopLevelBuilder() {
         return new SpanOrQuery();
       }
 
+      protected Query build(SpanOrQuery builder) {
+        return builder; //nocommit
+      }
+
       @Override
       protected void checkMaxClauseCount(int count) {
         // we accept all terms as SpanOrQuery has no limits
@@ -187,7 +191,7 @@
     
     @Override
     public SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
-      return delegate.rewrite(reader, query);
+      return (SpanQuery) delegate.rewrite(reader, query);
     }
   };
   
@@ -217,11 +221,16 @@
         }
     
         @Override
-        protected SpanOrQuery getTopLevelQuery() {
+        protected SpanOrQuery getTopLevelBuilder() {
           return new SpanOrQuery();
         }
 
         @Override
+        protected Query build(SpanOrQuery builder) {
+          return builder;
+        }
+
+        @Override
         protected void addClause(SpanOrQuery topLevel, Term term, int docFreq, float boost, TermContext states) {
           final SpanTermQuery q = new SpanTermQuery(term);
           q.setBoost(boost);
@@ -237,7 +246,7 @@
 
     @Override
     public SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
-      return delegate.rewrite(reader, query);
+      return (SpanQuery) delegate.rewrite(reader, query);
     }
   
     @Override
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 /** Matches spans containing a term. */
@@ -36,7 +37,7 @@
   protected Term term;
 
   /** Construct a SpanTermQuery matching the named term's spans. */
-  public SpanTermQuery(Term term) { this.term = term; }
+  public SpanTermQuery(Term term) { this.term = new Term(term.field(), BytesRef.deepCopyOf(term.bytes())); }
 
   /** Return the term whose spans are matched. */
   public Term getTerm() { return term; }
Index: lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java	(revision 1668924)
+++ lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java	(working copy)
@@ -28,9 +28,12 @@
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.search.MultiPhraseQuery.TermsAndPosition;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 
@@ -135,7 +138,7 @@
     Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);
     if (query instanceof BooleanQuery) {
       BooleanQuery bq = (BooleanQuery) query;
-      bq.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));
+      query = new BooleanQuery(bq.isCoordDisabled(), (int) (fraction * bq.clauses().size()), bq.clauses());
     }
     return query;
   }
@@ -259,7 +262,7 @@
           
           if (positionCount == 1) {
             // simple case: only one position, with synonyms
-            BooleanQuery q = newBooleanQuery(true);
+            List<BooleanClause> clauses = new ArrayList<>();
             for (int i = 0; i < numTokens; i++) {
               try {
                 boolean hasNext = buffer.incrementToken();
@@ -270,12 +273,12 @@
               }
               Query currentQuery = newTermQuery(
                   new Term(field, BytesRef.deepCopyOf(bytes)));
-              q.add(currentQuery, BooleanClause.Occur.SHOULD);
+              clauses.add(new BooleanClause(currentQuery, BooleanClause.Occur.SHOULD));
             }
-            return q;
+            return newBooleanQuery(true, clauses);
           } else {
             // multiple positions
-            BooleanQuery q = newBooleanQuery(false);
+            List<BooleanClause> clauses = new ArrayList<>();
             Query currentQuery = null;
             for (int i = 0; i < numTokens; i++) {
               try {
@@ -286,26 +289,26 @@
                 // safe to ignore, because we know the number of tokens
               }
               if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {
-                if (!(currentQuery instanceof BooleanQuery)) {
-                  Query t = currentQuery;
-                  currentQuery = newBooleanQuery(true);
-                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);
+                List<BooleanClause> currentClauses = new ArrayList<>();
+                if (currentQuery instanceof BooleanQuery) {
+                  currentClauses.addAll(((BooleanQuery) currentQuery).clauses());
+                } else {
+                  currentClauses.add(new BooleanClause(currentQuery, Occur.SHOULD));
                 }
-                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);
+                currentClauses.add(new BooleanClause(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD));
               } else {
                 if (currentQuery != null) {
-                  q.add(currentQuery, operator);
+                  clauses.add(new BooleanClause(currentQuery, operator));
                 }
                 currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));
               }
             }
-            q.add(currentQuery, operator);
-            return q;
+            clauses.add(new BooleanClause(currentQuery, operator));
+            return newBooleanQuery(false, clauses);
           }
         } else {
           // phrase query:
-          MultiPhraseQuery mpq = newMultiPhraseQuery();
-          mpq.setSlop(phraseSlop);
+          List<TermsAndPosition> termsPositions = new ArrayList<>();
           List<Term> multiTerms = new ArrayList<>();
           int position = -1;
           for (int i = 0; i < numTokens; i++) {
@@ -323,9 +326,9 @@
 
             if (positionIncrement > 0 && multiTerms.size() > 0) {
               if (enablePositionIncrements) {
-                mpq.add(multiTerms.toArray(new Term[0]),position);
+                termsPositions.add(new TermsAndPosition(multiTerms, position));
               } else {
-                mpq.add(multiTerms.toArray(new Term[0]));
+                termsPositions.add(new TermsAndPosition(multiTerms, termsPositions.isEmpty() ? 0 : termsPositions.get(termsPositions.size() - 1).position + 1));
               }
               multiTerms.clear();
             }
@@ -333,15 +336,14 @@
             multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));
           }
           if (enablePositionIncrements) {
-            mpq.add(multiTerms.toArray(new Term[0]),position);
+            termsPositions.add(new TermsAndPosition(multiTerms, position));
           } else {
-            mpq.add(multiTerms.toArray(new Term[0]));
+            termsPositions.add(new TermsAndPosition(multiTerms, termsPositions.isEmpty() ? 0 : termsPositions.get(termsPositions.size() - 1).position + 1));
           }
-          return mpq;
+          return newMultiPhraseQuery(phraseSlop, termsPositions);
         }
       } else {
-        PhraseQuery pq = newPhraseQuery();
-        pq.setSlop(phraseSlop);
+        List<TermAndPosition> termPositions = new ArrayList<>();
         int position = -1;
 
         for (int i = 0; i < numTokens; i++) {
@@ -360,12 +362,12 @@
 
           if (enablePositionIncrements) {
             position += positionIncrement;
-            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);
+            termPositions.add(new TermAndPosition(new Term(field, BytesRef.deepCopyOf(bytes)), position));
           } else {
-            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));
+            termPositions.add(new TermAndPosition(new Term(field, BytesRef.deepCopyOf(bytes)), termPositions.isEmpty() ? 0 : termPositions.get(termPositions.size() - 1).position + 1));
           }
         }
-        return pq;
+        return newPhraseQuery(phraseSlop, termPositions);
       }
     }
   }
@@ -375,10 +377,11 @@
    * <p>
    * This is intended for subclasses that wish to customize the generated queries.
    * @param disableCoord disable coord
+   * @param clauses the list of clauses
    * @return new BooleanQuery instance
    */
-  protected BooleanQuery newBooleanQuery(boolean disableCoord) {
-    return new BooleanQuery(disableCoord);
+  protected BooleanQuery newBooleanQuery(boolean disableCoord, List<BooleanClause> clauses) {
+    return new BooleanQuery(disableCoord, 0, clauses);
   }
   
   /**
@@ -398,8 +401,8 @@
    * This is intended for subclasses that wish to customize the generated queries.
    * @return new PhraseQuery instance
    */
-  protected PhraseQuery newPhraseQuery() {
-    return new PhraseQuery();
+  protected PhraseQuery newPhraseQuery(int slop, List<TermAndPosition> termPositions) {
+    return new PhraseQuery(slop, termPositions);
   }
   
   /**
@@ -408,7 +411,7 @@
    * This is intended for subclasses that wish to customize the generated queries.
    * @return new MultiPhraseQuery instance
    */
-  protected MultiPhraseQuery newMultiPhraseQuery() {
-    return new MultiPhraseQuery();
+  protected MultiPhraseQuery newMultiPhraseQuery(int slop, List<TermsAndPosition> termsPositions) {
+    return new MultiPhraseQuery(slop, termsPositions);
   }
 }
Index: lucene/core/src/test/org/apache/lucene/document/TestDocument.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/document/TestDocument.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/document/TestDocument.java	(working copy)
@@ -33,6 +33,7 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TermQuery;
@@ -246,9 +247,9 @@
     IndexReader reader = writer.getReader();
     
     IndexSearcher searcher = newSearcher(reader);
-    PhraseQuery query = new PhraseQuery();
-    query.add(new Term("indexed_not_tokenized", "test1"));
-    query.add(new Term("indexed_not_tokenized", "test2"));
+    PhraseQuery query = new PhraseQuery(
+        new TermAndPosition(new Term("indexed_not_tokenized", "test1"), 0),
+        new TermAndPosition(new Term("indexed_not_tokenized", "test2"), 1));
     
     ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;
     assertEquals(1, hits.length);
Index: lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java	(working copy)
@@ -37,6 +37,7 @@
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.BaseDirectoryWrapper;
 import org.apache.lucene.store.Directory;
@@ -172,9 +173,9 @@
       writer.updateDocument(new Term("id", "" + (i%10)), doc);
     }
     // Deletes one of the 10 added docs, leaving 9:
-    PhraseQuery q = new PhraseQuery();
-    q.add(new Term("content", "bbb"));
-    q.add(new Term("content", "14"));
+    PhraseQuery q = new PhraseQuery(
+        new TermAndPosition(new Term("content", "bbb"), 0),
+        new TermAndPosition(new Term("content", "14"), 1));
     writer.deleteDocuments(q);
 
     writer.forceMerge(1);
@@ -210,9 +211,9 @@
     writer.addIndexes(aux);
     
     // Deletes one of the 10 added docs, leaving 9:
-    PhraseQuery q = new PhraseQuery();
-    q.add(new Term("content", "bbb"));
-    q.add(new Term("content", "14"));
+    PhraseQuery q = new PhraseQuery(
+        new TermAndPosition(new Term("content", "bbb"), 0),
+        new TermAndPosition(new Term("content", "14"), 1));
     writer.deleteDocuments(q);
 
     writer.forceMerge(1);
@@ -246,9 +247,9 @@
     }
 
     // Deletes one of the 10 added docs, leaving 9:
-    PhraseQuery q = new PhraseQuery();
-    q.add(new Term("content", "bbb"));
-    q.add(new Term("content", "14"));
+    PhraseQuery q = new PhraseQuery(
+        new TermAndPosition(new Term("content", "bbb"), 0),
+        new TermAndPosition(new Term("content", "14"), 1));
     writer.deleteDocuments(q);
 
     writer.addIndexes(aux);
Index: lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java	(working copy)
@@ -59,6 +59,7 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.store.AlreadyClosedException;
@@ -73,7 +74,6 @@
 import org.apache.lucene.store.SimpleFSLockFactory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.LuceneTestCase;
@@ -1902,9 +1902,9 @@
     IndexReader ir = iw.getReader();
     iw.close();
     IndexSearcher is = newSearcher(ir);
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("body", "just"), 0);
-    pq.add(new Term("body", "test"), 2);
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("body", "just"), 0),
+        new TermAndPosition(new Term("body", "test"), 2));
     // body:"just ? test"
     assertEquals(1, is.search(pq, 5).totalHits);
     ir.close();
@@ -1933,9 +1933,9 @@
     IndexReader ir = iw.getReader();
     iw.close();
     IndexSearcher is = newSearcher(ir);
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("body", "just"), 0);
-    pq.add(new Term("body", "test"), 3);
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("body", "just"), 0),
+        new TermAndPosition(new Term("body", "test"), 3));
     // body:"just ? ? test"
     assertEquals(1, is.search(pq, 5).totalHits);
     ir.close();
Index: lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java	(working copy)
@@ -52,6 +52,7 @@
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.BaseDirectoryWrapper;
 import org.apache.lucene.store.Directory;
@@ -1412,14 +1413,14 @@
     w.close();
 
     final IndexSearcher s = newSearcher(r);
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("content", "silly"));
-    pq.add(new Term("content", "content"));
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("content", "silly"), 0),
+        new TermAndPosition(new Term("content", "content"), 1));
     assertEquals(0, s.search(pq, 1).totalHits);
 
-    pq = new PhraseQuery();
-    pq.add(new Term("content", "good"));
-    pq.add(new Term("content", "content"));
+    pq = new PhraseQuery(
+        new TermAndPosition(new Term("content", "good"), 0),
+        new TermAndPosition(new Term("content", "content"), 1));
     assertEquals(numDocs1+numDocs2, s.search(pq, 1).totalHits);
     r.close();
     dir.close();
@@ -1493,14 +1494,13 @@
     w.close();
 
     final IndexSearcher s = newSearcher(r);
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("content", "silly"));
-    pq.add(new Term("content", "content"));
-    assertEquals(numDocs2, s.search(pq, 1).totalHits);
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("content", "silly"), 0),
+        new TermAndPosition(new Term("content", "content"), 1));
 
-    pq = new PhraseQuery();
-    pq.add(new Term("content", "good"));
-    pq.add(new Term("content", "content"));
+    pq = new PhraseQuery(
+        new TermAndPosition(new Term("content", "good"), 0),
+        new TermAndPosition(new Term("content", "content"), 1));
     assertEquals(numDocs1+numDocs3+numDocs4, s.search(pq, 1).totalHits);
     r.close();
     dir.close();
Index: lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java	(working copy)
@@ -353,16 +353,16 @@
             assertTrue(vectors == null || vectors.terms(name) == null);
           }
 
-          BooleanQuery bq = new BooleanQuery();
-          bq.add(new TermQuery(new Term("id", ""+id)), BooleanClause.Occur.MUST);
-          bq.add(new TermQuery(new Term(name, "text")), BooleanClause.Occur.MUST);
+          BooleanQuery bq = new BooleanQuery(
+              new BooleanClause(new TermQuery(new Term("id", ""+id)), BooleanClause.Occur.MUST),
+              new BooleanClause(new TermQuery(new Term(name, "text")), BooleanClause.Occur.MUST));
           final TopDocs hits2 = s.search(bq, 1);
           assertEquals(1, hits2.totalHits);
           assertEquals(docID, hits2.scoreDocs[0].doc);
 
-          bq = new BooleanQuery();
-          bq.add(new TermQuery(new Term("id", ""+id)), BooleanClause.Occur.MUST);
-          bq.add(new TermQuery(new Term(name, ""+counter)), BooleanClause.Occur.MUST);
+          bq = new BooleanQuery(
+              new BooleanClause(new TermQuery(new Term("id", ""+id)), BooleanClause.Occur.MUST),
+              new BooleanClause(new TermQuery(new Term(name, ""+counter)), BooleanClause.Occur.MUST));
           final TopDocs hits3 = s.search(bq, 1);
           assertEquals(1, hits3.totalHits);
           assertEquals(docID, hits3.scoreDocs[0].doc);
Index: lucene/core/src/test/org/apache/lucene/index/TestLazyProxSkipping.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestLazyProxSkipping.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/index/TestLazyProxSkipping.java	(working copy)
@@ -25,6 +25,7 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
@@ -111,9 +112,9 @@
     
     private ScoreDoc[] search() throws IOException {
         // create PhraseQuery "term1 term2" and search
-        PhraseQuery pq = new PhraseQuery();
-        pq.add(new Term(this.field, this.term1));
-        pq.add(new Term(this.field, this.term2));
+        PhraseQuery pq = new PhraseQuery(
+            new TermAndPosition(new Term(this.field, this.term1), 0),
+            new TermAndPosition(new Term(this.field, this.term2), 1));
         return this.searcher.search(pq, 1000).scoreDocs;        
     }
     
Index: lucene/core/src/test/org/apache/lucene/index/TestOmitTf.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestOmitTf.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/index/TestOmitTf.java	(working copy)
@@ -25,6 +25,7 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.TextField;
+import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.CollectionStatistics;
@@ -308,9 +309,7 @@
     TermQuery q3 = new TermQuery(c);
     TermQuery q4 = new TermQuery(d);
 
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(a);
-    pq.add(c);
+    PhraseQuery pq = new PhraseQuery(a, c);
     try {
       searcher.search(pq, 10);
       fail("did not hit expected exception");
@@ -417,9 +416,9 @@
         
         
         
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(q1,Occur.MUST);
-    bq.add(q4,Occur.MUST);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(q1, Occur.MUST),
+        new BooleanClause(q4, Occur.MUST));
         
     searcher.search(bq,
                     new CountingHitCollector() {
Index: lucene/core/src/test/org/apache/lucene/index/TestParallelCompositeReader.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestParallelCompositeReader.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/index/TestParallelCompositeReader.java	(working copy)
@@ -71,9 +71,9 @@
     queryTest(new TermQuery(new Term("f4", "v1")));
     queryTest(new TermQuery(new Term("f4", "v2")));
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(new TermQuery(new Term("f1", "v1")), Occur.MUST);
-    bq1.add(new TermQuery(new Term("f4", "v1")), Occur.MUST);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("f1", "v1")), Occur.MUST),
+        new BooleanClause(new TermQuery(new Term("f4", "v1")), Occur.MUST));
     queryTest(bq1);
   }
 
Index: lucene/core/src/test/org/apache/lucene/index/TestParallelLeafReader.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestParallelLeafReader.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/index/TestParallelLeafReader.java	(working copy)
@@ -48,9 +48,9 @@
     queryTest(new TermQuery(new Term("f4", "v1")));
     queryTest(new TermQuery(new Term("f4", "v2")));
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(new TermQuery(new Term("f1", "v1")), Occur.MUST);
-    bq1.add(new TermQuery(new Term("f4", "v1")), Occur.MUST);
+    BooleanQuery bq1 = new BooleanQuery(
+      new BooleanClause(new TermQuery(new Term("f1", "v1")), Occur.MUST),
+      new BooleanClause(new TermQuery(new Term("f4", "v1")), Occur.MUST));
     queryTest(bq1);
     
     single.getIndexReader().close(); single = null;
Index: lucene/core/src/test/org/apache/lucene/search/TestApproximationSearchEquivalence.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestApproximationSearchEquivalence.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestApproximationSearchEquivalence.java	(working copy)
@@ -31,13 +31,13 @@
     TermQuery q1 = new TermQuery(t1);
     TermQuery q2 = new TermQuery(t2);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(q1, Occur.MUST);
-    bq1.add(q2, Occur.MUST);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(q1, Occur.MUST),
+        new BooleanClause(q2, Occur.MUST));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(new RandomApproximationQuery(q1, random()), Occur.MUST);
-    bq2.add(new RandomApproximationQuery(q2, random()), Occur.MUST);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.MUST),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.MUST));
 
     assertSameScores(bq1, bq2);
   }
@@ -50,21 +50,21 @@
     TermQuery q2 = new TermQuery(t2);
     TermQuery q3 = new TermQuery(t3);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(q1, Occur.MUST);
-    bq1.add(q2, Occur.MUST);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(q1, Occur.MUST),
+        new BooleanClause(q2, Occur.MUST));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(bq1, Occur.MUST);
-    bq2.add(q3, Occur.MUST);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(bq1, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
     
-    BooleanQuery bq3 = new BooleanQuery();
-    bq3.add(new RandomApproximationQuery(q1, random()), Occur.MUST);
-    bq3.add(new RandomApproximationQuery(q2, random()), Occur.MUST);
+    BooleanQuery bq3 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.MUST),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.MUST));
 
-    BooleanQuery bq4 = new BooleanQuery();
-    bq4.add(bq3, Occur.MUST);
-    bq4.add(q3, Occur.MUST);
+    BooleanQuery bq4 = new BooleanQuery(
+        new BooleanClause(bq3, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
 
     assertSameScores(bq2, bq4);
   }
@@ -75,13 +75,13 @@
     TermQuery q1 = new TermQuery(t1);
     TermQuery q2 = new TermQuery(t2);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(q1, Occur.SHOULD);
-    bq1.add(q2, Occur.SHOULD);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(q1, Occur.SHOULD),
+        new BooleanClause(q2, Occur.SHOULD));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(new RandomApproximationQuery(q1, random()), Occur.SHOULD);
-    bq2.add(new RandomApproximationQuery(q2, random()), Occur.SHOULD);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.SHOULD),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.SHOULD));
 
     assertSameScores(bq1, bq2);
   }
@@ -94,21 +94,21 @@
     TermQuery q2 = new TermQuery(t2);
     TermQuery q3 = new TermQuery(t3);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(q1, Occur.SHOULD);
-    bq1.add(q2, Occur.SHOULD);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(q1, Occur.SHOULD),
+        new BooleanClause(q2, Occur.SHOULD));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(bq1, Occur.SHOULD);
-    bq2.add(q3, Occur.SHOULD);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(bq1, Occur.SHOULD),
+        new BooleanClause(q3, Occur.SHOULD));
 
-    BooleanQuery bq3 = new BooleanQuery();
-    bq3.add(new RandomApproximationQuery(q1, random()), Occur.SHOULD);
-    bq3.add(new RandomApproximationQuery(q2, random()), Occur.SHOULD);
+    BooleanQuery bq3 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.SHOULD),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.SHOULD));
 
-    BooleanQuery bq4 = new BooleanQuery();
-    bq4.add(bq3, Occur.SHOULD);
-    bq4.add(q3, Occur.SHOULD);
+    BooleanQuery bq4 = new BooleanQuery(
+        new BooleanClause(bq3, Occur.SHOULD),
+        new BooleanClause(q3, Occur.SHOULD));
 
     assertSameScores(bq2, bq4);
   }
@@ -121,21 +121,21 @@
     TermQuery q2 = new TermQuery(t2);
     TermQuery q3 = new TermQuery(t3);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(q1, Occur.SHOULD);
-    bq1.add(q2, Occur.SHOULD);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(q1, Occur.SHOULD),
+        new BooleanClause(q2, Occur.SHOULD));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(bq1, Occur.MUST);
-    bq2.add(q3, Occur.MUST);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(bq1, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
 
-    BooleanQuery bq3 = new BooleanQuery();
-    bq3.add(new RandomApproximationQuery(q1, random()), Occur.SHOULD);
-    bq3.add(new RandomApproximationQuery(q2, random()), Occur.SHOULD);
+    BooleanQuery bq3 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.SHOULD),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.SHOULD));
 
-    BooleanQuery bq4 = new BooleanQuery();
-    bq4.add(bq3, Occur.MUST);
-    bq4.add(q3, Occur.MUST);
+    BooleanQuery bq4 = new BooleanQuery(
+        new BooleanClause(bq3, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
 
     assertSameScores(bq2, bq4);
   }
@@ -148,21 +148,21 @@
     TermQuery q2 = new TermQuery(t2);
     TermQuery q3 = new TermQuery(t3);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(q1, Occur.MUST);
-    bq1.add(q2, Occur.MUST);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(q1, Occur.MUST),
+        new BooleanClause(q2, Occur.MUST));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(bq1, Occur.SHOULD);
-    bq2.add(q3, Occur.SHOULD);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(bq1, Occur.SHOULD),
+        new BooleanClause(q3, Occur.SHOULD));
 
-    BooleanQuery bq3 = new BooleanQuery();
-    bq3.add(new RandomApproximationQuery(q1, random()), Occur.MUST);
-    bq3.add(new RandomApproximationQuery(q2, random()), Occur.MUST);
+    BooleanQuery bq3 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.MUST),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.MUST));
 
-    BooleanQuery bq4 = new BooleanQuery();
-    bq4.add(bq3, Occur.SHOULD);
-    bq4.add(q3, Occur.SHOULD);
+    BooleanQuery bq4 = new BooleanQuery(
+        new BooleanClause(bq3, Occur.SHOULD),
+        new BooleanClause(q3, Occur.SHOULD));
 
     assertSameScores(bq2, bq4);
   }
@@ -173,13 +173,13 @@
     TermQuery q1 = new TermQuery(t1);
     TermQuery q2 = new TermQuery(t2);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(new ConstantScoreQuery(q1), Occur.MUST);
-    bq1.add(new ConstantScoreQuery(q2), Occur.MUST);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(new ConstantScoreQuery(q1), Occur.MUST),
+        new BooleanClause(new ConstantScoreQuery(q2), Occur.MUST));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(new ConstantScoreQuery(new RandomApproximationQuery(q1, random())), Occur.MUST);
-    bq2.add(new ConstantScoreQuery(new RandomApproximationQuery(q2, random())), Occur.MUST);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(new ConstantScoreQuery(new RandomApproximationQuery(q1, random())), Occur.MUST),
+        new BooleanClause(new ConstantScoreQuery(new RandomApproximationQuery(q2, random())), Occur.MUST));
 
     assertSameScores(bq1, bq2);
   }
@@ -190,13 +190,13 @@
     TermQuery q1 = new TermQuery(t1);
     TermQuery q2 = new TermQuery(t2);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(q1, Occur.MUST);
-    bq1.add(q2, Occur.MUST_NOT);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(q1, Occur.MUST),
+        new BooleanClause(q2, Occur.MUST_NOT));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(new RandomApproximationQuery(q1, random()), Occur.MUST);
-    bq2.add(new RandomApproximationQuery(q2, random()), Occur.MUST_NOT);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.MUST),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.MUST_NOT));
 
     assertSameScores(bq1, bq2);
   }
@@ -209,44 +209,44 @@
     TermQuery q2 = new TermQuery(t2);
     TermQuery q3 = new TermQuery(t3);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(q1, Occur.MUST);
-    bq1.add(q2, Occur.MUST_NOT);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(q1, Occur.MUST),
+        new BooleanClause(q2, Occur.MUST_NOT));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(bq1, Occur.MUST);
-    bq2.add(q3, Occur.MUST);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(bq1, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
 
     // Both req and excl have approximations
-    BooleanQuery bq3 = new BooleanQuery();
-    bq3.add(new RandomApproximationQuery(q1, random()), Occur.MUST);
-    bq3.add(new RandomApproximationQuery(q2, random()), Occur.MUST_NOT);
+    BooleanQuery bq3 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.MUST),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.MUST_NOT));
 
-    BooleanQuery bq4 = new BooleanQuery();
-    bq4.add(bq3, Occur.MUST);
-    bq4.add(q3, Occur.MUST);
+    BooleanQuery bq4 = new BooleanQuery(
+        new BooleanClause(bq3, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
 
     assertSameScores(bq2, bq4);
 
     // Only req has an approximation
-    bq3 = new BooleanQuery();
-    bq3.add(new RandomApproximationQuery(q1, random()), Occur.MUST);
-    bq3.add(q2, Occur.MUST_NOT);
+    bq3 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.MUST),
+        new BooleanClause(q2, Occur.MUST_NOT));
 
-    bq4 = new BooleanQuery();
-    bq4.add(bq3, Occur.MUST);
-    bq4.add(q3, Occur.MUST);
+    bq4 = new BooleanQuery(
+        new BooleanClause(bq3, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
 
     assertSameScores(bq2, bq4);
 
     // Only excl has an approximation
-    bq3 = new BooleanQuery();
-    bq3.add(q1, Occur.MUST);
-    bq3.add(new RandomApproximationQuery(q2, random()), Occur.MUST_NOT);
+    bq3 = new BooleanQuery(
+        new BooleanClause(q1, Occur.MUST),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.MUST_NOT));
 
-    bq4 = new BooleanQuery();
-    bq4.add(bq3, Occur.MUST);
-    bq4.add(q3, Occur.MUST);
+    bq4 = new BooleanQuery(
+        new BooleanClause(bq3, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
 
     assertSameScores(bq2, bq4);
   }
@@ -259,21 +259,21 @@
     TermQuery q2 = new TermQuery(t2);
     TermQuery q3 = new TermQuery(t3);
 
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(q1, Occur.MUST);
-    bq1.add(q2, Occur.SHOULD);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(q1, Occur.MUST),
+        new BooleanClause(q2, Occur.SHOULD));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(bq1, Occur.MUST);
-    bq2.add(q3, Occur.MUST);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(bq1, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
     
-    BooleanQuery bq3 = new BooleanQuery();
-    bq3.add(new RandomApproximationQuery(q1, random()), Occur.MUST);
-    bq3.add(new RandomApproximationQuery(q2, random()), Occur.SHOULD);
+    BooleanQuery bq3 = new BooleanQuery(
+        new BooleanClause(new RandomApproximationQuery(q1, random()), Occur.MUST),
+        new BooleanClause(new RandomApproximationQuery(q2, random()), Occur.SHOULD));
 
-    BooleanQuery bq4 = new BooleanQuery();
-    bq4.add(bq3, Occur.MUST);
-    bq4.add(q3, Occur.MUST);
+    BooleanQuery bq4 = new BooleanQuery(
+        new BooleanClause(bq3, Occur.MUST),
+        new BooleanClause(q3, Occur.MUST));
 
     assertSameScores(bq2, bq4);
   }
Index: lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java	(working copy)
@@ -18,6 +18,8 @@
  */
 
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Random;
 
 import org.apache.lucene.analysis.MockAnalyzer;
@@ -147,9 +149,9 @@
 
   @Test
   public void testQueries01() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST));
     int[] expDocNrs = {2,3};
     queriesTest(query, expDocNrs);
   }
@@ -156,9 +158,9 @@
 
   @Test
   public void testQueries02() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.SHOULD));
     int[] expDocNrs = {2,3,1,0};
     queriesTest(query, expDocNrs);
   }
@@ -165,9 +167,9 @@
 
   @Test
   public void testQueries03() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.SHOULD);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.SHOULD));
     int[] expDocNrs = {2,3,1,0};
     queriesTest(query, expDocNrs);
   }
@@ -174,9 +176,9 @@
 
   @Test
   public void testQueries04() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.SHOULD);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST_NOT));
     int[] expDocNrs = {1,0};
     queriesTest(query, expDocNrs);
   }
@@ -183,9 +185,9 @@
 
   @Test
   public void testQueries05() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST_NOT));
     int[] expDocNrs = {1,0};
     queriesTest(query, expDocNrs);
   }
@@ -192,10 +194,10 @@
 
   @Test
   public void testQueries06() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST_NOT);
-    query.add(new TermQuery(new Term(field, "w5")), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST_NOT),
+        new BooleanClause(new TermQuery(new Term(field, "w5")), BooleanClause.Occur.MUST_NOT));
     int[] expDocNrs = {1};
     queriesTest(query, expDocNrs);
   }
@@ -202,10 +204,10 @@
 
   @Test
   public void testQueries07() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST_NOT);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST_NOT);
-    query.add(new TermQuery(new Term(field, "w5")), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST_NOT),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST_NOT),
+        new BooleanClause(new TermQuery(new Term(field, "w5")), BooleanClause.Occur.MUST_NOT));
     int[] expDocNrs = {};
     queriesTest(query, expDocNrs);
   }
@@ -212,10 +214,10 @@
 
   @Test
   public void testQueries08() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.SHOULD);
-    query.add(new TermQuery(new Term(field, "w5")), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(field, "w5")), BooleanClause.Occur.MUST_NOT));
     int[] expDocNrs = {2,3,1};
     queriesTest(query, expDocNrs);
   }
@@ -222,11 +224,11 @@
 
   @Test
   public void testQueries09() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "w2")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "zz")), BooleanClause.Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "w2")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "zz")), BooleanClause.Occur.SHOULD));
     int[] expDocNrs = {2, 3};
     queriesTest(query, expDocNrs);
   }
@@ -233,11 +235,11 @@
 
   @Test
   public void testQueries10() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "w2")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(field, "zz")), BooleanClause.Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(field, "w3")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "xx")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "w2")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(field, "zz")), BooleanClause.Occur.SHOULD));
 
     int[] expDocNrs = {2, 3};
     Similarity oldSimilarity = searcher.getSimilarity();
@@ -296,9 +298,9 @@
         tot+=hits2.length;
         CheckHits.checkEqual(q1, hits1, hits2);
 
-        BooleanQuery q3 = new BooleanQuery();
-        q3.add(q1, BooleanClause.Occur.SHOULD);
-        q3.add(new PrefixQuery(new Term("field2", "b")), BooleanClause.Occur.SHOULD);
+        BooleanQuery q3 = new BooleanQuery(
+            new BooleanClause(q1, BooleanClause.Occur.SHOULD),
+            new BooleanClause(new PrefixQuery(new Term("field2", "b")), BooleanClause.Occur.SHOULD));
         TopDocs hits4 = bigSearcher.search(q3, 1);
         assertEquals(mulFactor*collector.totalHits + NUM_EXTRA_DOCS/2, hits4.totalHits);
       }
@@ -315,14 +317,16 @@
 
   // used to set properties or change every BooleanQuery
   // generated from randBoolQuery.
-  public static interface Callback {
-    public void postCreate(BooleanQuery q);
+  public static abstract class Callback {
+    public BooleanQuery create(List<BooleanClause> clauses) {
+      return new BooleanQuery(clauses);
+    }
   }
 
   // Random rnd is passed in so that the exact same random query may be created
   // more than once.
   public static BooleanQuery randBoolQuery(Random rnd, boolean allowMust, int level, String field, String[] vals, Callback cb) {
-    BooleanQuery current = new BooleanQuery(rnd.nextInt()<0);
+    List<BooleanClause> clauses = new ArrayList<>();
     for (int i=0; i<rnd.nextInt(vals.length)+1; i++) {
       int qType=0; // term query
       if (level>0) {
@@ -334,11 +338,7 @@
       } else if (qType < 4) {
         Term t1 = new Term(field, vals[rnd.nextInt(vals.length)]);
         Term t2 = new Term(field, vals[rnd.nextInt(vals.length)]);
-        PhraseQuery pq = new PhraseQuery();
-        pq.add(t1);
-        pq.add(t2);
-        pq.setSlop(10); // increase possibility of matching
-        q = pq;
+        q = new PhraseQuery(10, t1, t2);
       } else if (qType < 7) {
         q = new WildcardQuery(new Term(field, "w*"));
       } else {
@@ -360,10 +360,10 @@
         occur=BooleanClause.Occur.SHOULD;
       }
 
-      current.add(q, occur);
+      clauses.add(new BooleanClause(q, occur));
     }
-    if (cb!=null) cb.postCreate(current);
-    return current;
+    if (cb!=null) return cb.create(clauses);
+    return new BooleanQuery(clauses);
   }
 
 
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord.java	(working copy)
@@ -128,69 +128,69 @@
   // disjunctions
   
   public void testDisjunction1TermMatches() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/1f, bq);
   }
   
   public void testDisjunction2TermMatches() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 1/1f, bq);
   }
   
   public void testDisjunction1OutOf2() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/2f, bq);
   }
   
   public void testDisjunction1OutOf2Missing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/2f, bq);
   }
   
   public void testDisjunction1OutOf3() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("2"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("2"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/3f, bq);
   }
   
   public void testDisjunction1OutOf3MissingOne() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/3f, bq);
   }
   
   public void testDisjunction1OutOf3MissingTwo() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Y"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Y"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/3f, bq);
   }
   
   public void testDisjunction2OutOf3() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/3f, bq);
   }
   
   public void testDisjunction2OutOf3Missing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/3f, bq);
   }
   
@@ -197,166 +197,155 @@
   // disjunctions with coord disabled
   
   public void testDisjunction1TermMatchesCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testDisjunction2TermMatchesCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testDisjunction1OutOf2CoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testDisjunction1OutOf2MissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testDisjunction1OutOf3CoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("2"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("2"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testDisjunction1OutOf3MissingOneCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testDisjunction1OutOf3MissingTwoCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Y"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Y"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testDisjunction2OutOf3CoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testDisjunction2OutOf3MissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   // minShouldMatch
   public void testMinShouldMatch1TermMatches() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/1f, bq);
   }
   
   public void testMinShouldMatchn2TermMatches() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 1/1f, bq);
   }
   
   public void testMinShouldMatch1OutOf2() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/2f, bq);
   }
   
   public void testMinShouldMatch1OutOf2Missing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/2f, bq);
   }
   
   public void testMinShouldMatch1OutOf3() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("2"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
+        new BooleanClause(term("2"), BooleanClause.Occur.SHOULD);
     assertScore(1 * 1/3f, bq);
   }
   
   public void testMinShouldMatch1OutOf3MissingOne() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/3f, bq);
   }
   
   public void testMinShouldMatch1OutOf3MissingTwo() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Y"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Y"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/3f, bq);
   }
   
   public void testMinShouldMatch2OutOf3() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/3f, bq);
   }
   
   public void testMinShouldMatch2OutOf3Missing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/3f, bq);
   }
   
   public void testMinShouldMatch2OutOf4() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("2"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("2"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/4f, bq);
   }
   
   public void testMinShouldMatch2OutOf4Missing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/4f, bq);
   }
   
@@ -363,98 +352,87 @@
   // minShouldMatch with coord disabled
   
   public void testMinShouldMatch1TermMatchesCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testMinShouldMatch2TermMatchesCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testMinShouldMatch1OutOf2CoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testMinShouldMatch1OutOf2MissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testMinShouldMatch1OutOf3CoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("2"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("2"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testMinShouldMatch1OutOf3MissingOneCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testMinShouldMatch1OutOf3MissingTwoCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Y"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Y"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testMinShouldMatch2OutOf3CoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testMinShouldMatch2OutOf3MissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testMinShouldMatch2OutOf4CoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("2"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("2"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testMinShouldMatch2OutOf4MissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.SHOULD);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
@@ -461,30 +439,30 @@
   // conjunctions
   
   public void testConjunction1TermMatches() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST));
     assertScore(1 * 1/1f, bq);
   }
   
   public void testConjunction1TermMatches1Prohib() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.MUST_NOT));
     assertScore(1 * 1/1f, bq);
   }
   
   public void testConjunction1TermMatches2Prohib() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.MUST_NOT);
-    bq.add(term("2"), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.MUST_NOT),
+        new BooleanClause(term("2"), BooleanClause.Occur.MUST_NOT));
     assertScore(1 * 1/1f, bq);
   }
   
   public void testConjunction2TermMatches() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.MUST);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.MUST));
     assertScore(2 * 1/1f, bq);
   }
   
@@ -491,137 +469,137 @@
   // conjunctions coord disabled
   
   public void testConjunction1TermMatchesCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST));
     assertScore(1, bq);
   }
   
   public void testConjunction1TermMatches1ProhibCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.MUST_NOT));
     assertScore(1, bq);
   }
   
   public void testConjunction1TermMatches2ProhibCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.MUST_NOT);
-    bq.add(term("2"), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.MUST_NOT),
+        new BooleanClause(term("2"), BooleanClause.Occur.MUST_NOT));
     assertScore(1, bq);
   }
   
   public void testConjunction2TermMatchesCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.MUST);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.MUST));
     assertScore(2, bq);
   }
   
   // optional + mandatory mix
   public void testMix2TermMatches() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/2f, bq);
   }
   
   public void testMixMatch1OutOfTwo() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/2f, bq);
   }
   
   public void testMixMatch1OutOfTwoMissing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/2f, bq);
   }
   
   public void testMixMatch1OutOfThree() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("2"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("2"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/3f, bq);
   }
   
   public void testMixMatch1OutOfThreeOneMissing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/3f, bq);
   }
   
   public void testMixMatch2OutOfThree() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/3f, bq);
   }
   
   public void testMixMatch2OutOfThreeMissing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/3f, bq);
   }
   
   public void testMix2TermMatchesCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testMixMatch1OutOfTwoCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testMixMatch1OutOfTwoMissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testMixMatch1OutOfThreeCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("2"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("2"), BooleanClause.Occur.SHOULD));
     assertScore(1, bq);
   }
   
   public void testMixMatch1OutOfThreeOneMissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(1 * 1/3f, bq);
   }
   
   public void testMixMatch2OutOfThreeCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testMixMatch2OutOfThreeMissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 0,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
@@ -628,78 +606,70 @@
   // min should match + mandatory mix
   
   public void testMixMinShouldMatch2OutOfThree() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/3f, bq);
   }
   
   public void testMixMinShouldMatch2OutOfThreeMissing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2 * 2/3f, bq);
   }
   
   public void testMixMinShouldMatch3OutOfFour() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("C"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("C"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(3 * 3/4f, bq);
   }
   
   public void testMixMinShouldMatch3OutOfFourMissing() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("C"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("C"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(3 * 3/4f, bq);
   }
   
   public void testMixMinShouldMatch2OutOfThreeCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testMixMinShouldMatch2OutOfThreeMissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(1);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 1,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(2, bq);
   }
   
   public void testMixMinShouldMatch3OutOfFourCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("C"), BooleanClause.Occur.SHOULD);
-    bq.add(term("1"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("C"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("1"), BooleanClause.Occur.SHOULD));
     assertScore(3, bq);
   }
   
   public void testMixMinShouldMatch3OutOfFourMissingCoordDisabled() throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.setMinimumNumberShouldMatch(2);
-    bq.add(term("A"), BooleanClause.Occur.MUST);
-    bq.add(term("B"), BooleanClause.Occur.SHOULD);
-    bq.add(term("C"), BooleanClause.Occur.SHOULD);
-    bq.add(term("Z"), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(true, 2,
+        new BooleanClause(term("A"), BooleanClause.Occur.MUST),
+        new BooleanClause(term("B"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("C"), BooleanClause.Occur.SHOULD),
+        new BooleanClause(term("Z"), BooleanClause.Occur.SHOULD));
     assertScore(3, bq);
   }
   
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java	(working copy)
@@ -32,6 +32,8 @@
 
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Locale;
 import java.util.Random;
 
@@ -107,25 +109,22 @@
 
     public void testAllOptional() throws Exception {
 
-        BooleanQuery q = new BooleanQuery();
+        List<BooleanClause> clauses = new ArrayList<>();
         for (int i = 1; i <=4; i++) {
-            q.add(new TermQuery(new Term("data",""+i)), BooleanClause.Occur.SHOULD);//false, false);
+            clauses.add(new BooleanClause(new TermQuery(new Term("data",""+i)), BooleanClause.Occur.SHOULD));
         }
-        q.setMinimumNumberShouldMatch(2); // match at least two of 4
-        verifyNrHits(q, 2);
+        verifyNrHits(new BooleanQuery(false, 2, clauses), 2);// match at least two of 4
     }
 
     public void testOneReqAndSomeOptional() throws Exception {
 
         /* one required, some optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.SHOULD);//false, false);
+        BooleanQuery q = new BooleanQuery(false, 2, // 2 of 3 optional 
+            new BooleanClause(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.SHOULD));//false, false);
 
-        q.setMinimumNumberShouldMatch(2); // 2 of 3 optional 
-
         verifyNrHits(q, 5);
     }
 
@@ -132,15 +131,13 @@
     public void testSomeReqAndSomeOptional() throws Exception {
 
         /* two required, some optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.SHOULD);//false, false);
+        BooleanQuery q = new BooleanQuery(false, 2, // 2 of 3 optional
+            new BooleanClause(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.SHOULD));//false, false);
 
-        q.setMinimumNumberShouldMatch(2); // 2 of 3 optional 
-
         verifyNrHits(q, 5);
     }
 
@@ -147,14 +144,12 @@
     public void testOneProhibAndSomeOptional() throws Exception {
 
         /* one prohibited, some optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
-        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
+        BooleanQuery q = new BooleanQuery(false, 2, // 2 of 3 optional 
+            new BooleanClause(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT),//false, true );
+            new BooleanClause(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD));//false, false);
 
-        q.setMinimumNumberShouldMatch(2); // 2 of 3 optional 
-
         verifyNrHits(q, 1);
     }
 
@@ -161,15 +156,13 @@
     public void testSomeProhibAndSomeOptional() throws Exception {
 
         /* two prohibited, some optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
-        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT);//false, true );
+        BooleanQuery q = new BooleanQuery(false, 2, // 2 of 3 optional 
+            new BooleanClause(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT),//false, true );
+            new BooleanClause(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT));//false, true );
 
-        q.setMinimumNumberShouldMatch(2); // 2 of 3 optional 
-
         verifyNrHits(q, 1);
     }
 
@@ -176,16 +169,14 @@
     public void testOneReqOneProhibAndSomeOptional() throws Exception {
 
         /* one required, one prohibited, some optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);// true,  false);
-        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
+        BooleanQuery q = new BooleanQuery(false, 3, // 3 of 4 optional 
+            new BooleanClause(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST),// true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT),//false, true );
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD));//false, false);
 
-        q.setMinimumNumberShouldMatch(3); // 3 of 4 optional 
-
         verifyNrHits(q, 1);
     }
 
@@ -192,17 +183,15 @@
     public void testSomeReqOneProhibAndSomeOptional() throws Exception {
 
         /* two required, one prohibited, some optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("all",  "all")), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
+        BooleanQuery q = new BooleanQuery(false, 3, // 3 of 4 optional
+            new BooleanClause(new TermQuery(new Term("all",  "all")), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT),//false, true );
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD));//false, false);
 
-        q.setMinimumNumberShouldMatch(3); // 3 of 4 optional 
-
         verifyNrHits(q, 1);
     }
 
@@ -209,17 +198,15 @@
     public void testOneReqSomeProhibAndSomeOptional() throws Exception {
 
         /* one required, two prohibited, some optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT);//false, true );
+        BooleanQuery q = new BooleanQuery(false, 3, // 3 of 4 optional 
+            new BooleanClause(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT),//false, true );
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT));//false, true );
 
-        q.setMinimumNumberShouldMatch(3); // 3 of 4 optional 
-
         verifyNrHits(q, 1);
     }
 
@@ -226,18 +213,16 @@
     public void testSomeReqSomeProhibAndSomeOptional() throws Exception {
 
         /* two required, two prohibited, some optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("all",  "all")), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT);//false, true );
+        BooleanQuery q = new BooleanQuery(false, 3, // 3 of 4 optional 
+            new BooleanClause(new TermQuery(new Term("all",  "all")), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT),//false, true );
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT));//false, true );
 
-        q.setMinimumNumberShouldMatch(3); // 3 of 4 optional 
-
         verifyNrHits(q, 1);
     }
 
@@ -244,18 +229,16 @@
     public void testMinHigherThenNumOptional() throws Exception {
 
         /* two required, two prohibited, some optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("all",  "all")), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT);//false, true );
+        BooleanQuery q = new BooleanQuery(false, 90, // 90 of 4 optional ?!?!?!
+            new BooleanClause(new TermQuery(new Term("all",  "all")), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT),//false, true );
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT));//false, true );
 
-        q.setMinimumNumberShouldMatch(90); // 90 of 4 optional ?!?!?!
-
         verifyNrHits(q, 0);
     }
 
@@ -262,14 +245,12 @@
     public void testMinEqualToNumOptional() throws Exception {
 
         /* two required, two optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
+        BooleanQuery q = new BooleanQuery(false, 2, // 2 of 2 optional
+            new BooleanClause(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD));//false, false);
 
-        q.setMinimumNumberShouldMatch(2); // 2 of 2 optional 
-
         verifyNrHits(q, 1);
     }
 
@@ -276,13 +257,11 @@
     public void testOneOptionalEqualToMin() throws Exception {
 
         /* two required, one optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.SHOULD);//false, false);
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.MUST);//true,  false);
+        BooleanQuery q = new BooleanQuery(false, 1, // 1 of 1 optional 
+            new BooleanClause(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.SHOULD),//false, false);
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.MUST));//true,  false);
 
-        q.setMinimumNumberShouldMatch(1); // 1 of 1 optional 
-
         verifyNrHits(q, 1);
     }
 
@@ -289,12 +268,10 @@
     public void testNoOptionalButMin() throws Exception {
 
         /* two required, no optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST);//true,  false);
-        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.MUST);//true,  false);
+        BooleanQuery q = new BooleanQuery(false, 1, // 1 of 0 optional
+            new BooleanClause(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST),//true,  false);
+            new BooleanClause(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.MUST));//true,  false);
 
-        q.setMinimumNumberShouldMatch(1); // 1 of 0 optional 
-
         verifyNrHits(q, 0);
     }
 
@@ -301,11 +278,9 @@
     public void testNoOptionalButMin2() throws Exception {
 
         /* one required, no optional */
-        BooleanQuery q = new BooleanQuery();
-        q.add(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST);//true,  false);
+        BooleanQuery q = new BooleanQuery(false, 1, // 1 of 0 optional 
+            new BooleanClause(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST));//true,  false);
 
-        q.setMinimumNumberShouldMatch(1); // 1 of 0 optional 
-
         verifyNrHits(q, 0);
     }
 
@@ -317,18 +292,18 @@
       // callback object to set a random setMinimumNumberShouldMatch
       TestBoolean2.Callback minNrCB = new TestBoolean2.Callback() {
         @Override
-        public void postCreate(BooleanQuery q) {
-          BooleanClause[] c =q.getClauses();
+        public BooleanQuery create(List<BooleanClause> clauses) {
           int opt=0;
-          for (int i=0; i<c.length;i++) {
-            if (c[i].getOccur() == BooleanClause.Occur.SHOULD) opt++;
+          for (BooleanClause clause : clauses) {
+            if (clause.getOccur() == BooleanClause.Occur.SHOULD) opt++;
           }
-          q.setMinimumNumberShouldMatch(random().nextInt(opt+2));
+          final int minShouldMatch = random().nextInt(opt+2);
           if (random().nextBoolean()) {
             // also add a random negation
             Term randomTerm = new Term(field, vals[random().nextInt(vals.length)]);
-            q.add(new TermQuery(randomTerm), BooleanClause.Occur.MUST_NOT);
+            clauses.add(new BooleanClause(new TermQuery(randomTerm), BooleanClause.Occur.MUST_NOT));
           }
+          return new BooleanQuery(false, minShouldMatch, clauses);
         }
       };
 
@@ -344,7 +319,7 @@
         BooleanQuery q2 = TestBoolean2.randBoolQuery(new Random(seed), true, lev, field, vals, null);
         // only set minimumNumberShouldMatch on the top level query since setting
         // at a lower level can change the score.
-        minNrCB.postCreate(q2);
+        q2 = minNrCB.create(new ArrayList<>(q2.clauses()));
 
         // Can't use Hits because normalized scores will mess things
         // up.  The non-sorting version of search() that returns TopDocs
@@ -405,11 +380,10 @@
             return overlap / ((float)maxOverlap + 1);
           }
         });
-        BooleanQuery q1 = new BooleanQuery();
-        q1.add(new TermQuery(new Term("data", "1")), BooleanClause.Occur.SHOULD);
-        BooleanQuery q2 = new BooleanQuery();
-        q2.add(new TermQuery(new Term("data", "1")), BooleanClause.Occur.SHOULD);
-        q2.setMinimumNumberShouldMatch(1);
+        BooleanQuery q1 = new BooleanQuery(
+            new BooleanClause(new TermQuery(new Term("data", "1")), BooleanClause.Occur.SHOULD));
+        BooleanQuery q2 = new BooleanQuery(false, 1,
+            new BooleanClause(new TermQuery(new Term("data", "1")), BooleanClause.Occur.SHOULD));
         TopDocs top1 = s.search(q1,100);
         TopDocs top2 = s.search(q2,100);
         assertSubsetOfSameScores(q2, top1, top2);
@@ -427,11 +401,11 @@
             return overlap / ((float)maxOverlap + 1);
           }
         });
-        BooleanQuery q1 = new BooleanQuery();
-        q1.add(new TermQuery(new Term("data", "1")), BooleanClause.Occur.SHOULD);
-        BooleanQuery q2 = new BooleanQuery();
-        q2.add(new TermQuery(new Term("data", "1")), BooleanClause.Occur.SHOULD);
-        q2.add(new TermQuery(new Term("data", "Z")), BooleanClause.Occur.MUST_NOT);
+        BooleanQuery q1 = new BooleanQuery(
+            new BooleanClause(new TermQuery(new Term("data", "1")), BooleanClause.Occur.SHOULD));
+        BooleanQuery q2 = new BooleanQuery(
+            new BooleanClause(new TermQuery(new Term("data", "1")), BooleanClause.Occur.SHOULD),
+            new BooleanClause(new TermQuery(new Term("data", "Z")), BooleanClause.Occur.MUST_NOT));
         TopDocs top1 = s.search(q1,100);
         TopDocs top2 = s.search(q2,100);
         assertSubsetOfSameScores(q2, top1, top2);
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java	(working copy)
@@ -67,11 +67,11 @@
    * it works.
    */
   public void testFlat() throws IOException {
-    BooleanQuery q = new BooleanQuery();
-    q.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
-    q.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
-    q.add(new BooleanClause(c1, BooleanClause.Occur.SHOULD));
-    q.add(new BooleanClause(c2, BooleanClause.Occur.SHOULD));
+    BooleanQuery q = new BooleanQuery(
+        new BooleanClause(t1, BooleanClause.Occur.SHOULD),
+        new BooleanClause(t2, BooleanClause.Occur.SHOULD),
+        new BooleanClause(c1, BooleanClause.Occur.SHOULD),
+        new BooleanClause(c2, BooleanClause.Occur.SHOULD));
     assertEquals(1, search(q));
   }
 
@@ -80,15 +80,15 @@
    * it works.
    */
   public void testParenthesisMust() throws IOException {
-    BooleanQuery q3 = new BooleanQuery();
-    q3.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
-    q3.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
-    BooleanQuery q4 = new BooleanQuery();
-    q4.add(new BooleanClause(c1, BooleanClause.Occur.MUST));
-    q4.add(new BooleanClause(c2, BooleanClause.Occur.MUST));
-    BooleanQuery q2 = new BooleanQuery();
-    q2.add(q3, BooleanClause.Occur.SHOULD);
-    q2.add(q4, BooleanClause.Occur.SHOULD);
+    BooleanQuery q3 = new BooleanQuery(
+        new BooleanClause(t1, BooleanClause.Occur.SHOULD),
+        new BooleanClause(t2, BooleanClause.Occur.SHOULD));
+    BooleanQuery q4 = new BooleanQuery(
+        new BooleanClause(c1, BooleanClause.Occur.MUST),
+        new BooleanClause(c2, BooleanClause.Occur.MUST));
+    BooleanQuery q2 = new BooleanQuery(
+        new BooleanClause(q3, BooleanClause.Occur.SHOULD),
+        new BooleanClause(q4, BooleanClause.Occur.SHOULD));
     assertEquals(1, search(q2));
   }
 
@@ -97,15 +97,15 @@
    * not working. results NO HIT.
    */
   public void testParenthesisMust2() throws IOException {
-    BooleanQuery q3 = new BooleanQuery();
-    q3.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
-    q3.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
-    BooleanQuery q4 = new BooleanQuery();
-    q4.add(new BooleanClause(c1, BooleanClause.Occur.SHOULD));
-    q4.add(new BooleanClause(c2, BooleanClause.Occur.SHOULD));
-    BooleanQuery q2 = new BooleanQuery();
-    q2.add(q3, BooleanClause.Occur.SHOULD);
-    q2.add(q4, BooleanClause.Occur.MUST);
+    BooleanQuery q3 = new BooleanQuery(
+        new BooleanClause(t1, BooleanClause.Occur.SHOULD),
+        new BooleanClause(t2, BooleanClause.Occur.SHOULD));
+    BooleanQuery q4 = new BooleanQuery(
+        new BooleanClause(c1, BooleanClause.Occur.SHOULD),
+        new BooleanClause(c2, BooleanClause.Occur.SHOULD));
+    BooleanQuery q2 = new BooleanQuery(
+        new BooleanClause(q3, BooleanClause.Occur.SHOULD),
+        new BooleanClause(q4, BooleanClause.Occur.MUST));
     assertEquals(1, search(q2));
   }
 
@@ -114,15 +114,15 @@
    * not working. results NO HIT.
    */
   public void testParenthesisShould() throws IOException {
-    BooleanQuery q3 = new BooleanQuery();
-    q3.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
-    q3.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
-    BooleanQuery q4 = new BooleanQuery();
-    q4.add(new BooleanClause(c1, BooleanClause.Occur.SHOULD));
-    q4.add(new BooleanClause(c2, BooleanClause.Occur.SHOULD));
-    BooleanQuery q2 = new BooleanQuery();
-    q2.add(q3, BooleanClause.Occur.SHOULD);
-    q2.add(q4, BooleanClause.Occur.SHOULD);
+    BooleanQuery q3 = new BooleanQuery(
+        new BooleanClause(t1, BooleanClause.Occur.SHOULD),
+        new BooleanClause(t2, BooleanClause.Occur.SHOULD));
+    BooleanQuery q4 = new BooleanQuery(
+        new BooleanClause(c1, BooleanClause.Occur.SHOULD),
+        new BooleanClause(c2, BooleanClause.Occur.SHOULD));
+    BooleanQuery q2 = new BooleanQuery(
+        new BooleanClause(q3, BooleanClause.Occur.SHOULD),
+        new BooleanClause(q4, BooleanClause.Occur.SHOULD));
     assertEquals(1, search(q2));
   }
 
@@ -181,9 +181,9 @@
     riw.close();
 
     IndexSearcher s = newSearcher(r);
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
-    bq.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD));
 
     Weight w = s.createNormalizedWeight(bq, true);
 
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.BitSet;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -42,6 +43,7 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanTopLevelScorers.BoostedScorer;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
@@ -53,21 +55,23 @@
 public class TestBooleanQuery extends LuceneTestCase {
 
   public void testEquality() throws Exception {
-    BooleanQuery bq1 = new BooleanQuery();
-    bq1.add(new TermQuery(new Term("field", "value1")), BooleanClause.Occur.SHOULD);
-    bq1.add(new TermQuery(new Term("field", "value2")), BooleanClause.Occur.SHOULD);
-    BooleanQuery nested1 = new BooleanQuery();
-    nested1.add(new TermQuery(new Term("field", "nestedvalue1")), BooleanClause.Occur.SHOULD);
-    nested1.add(new TermQuery(new Term("field", "nestedvalue2")), BooleanClause.Occur.SHOULD);
-    bq1.add(nested1, BooleanClause.Occur.SHOULD);
+    BooleanQuery bq1 = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "value1")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("field", "value2")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(
+            new BooleanQuery(
+                new BooleanClause(new TermQuery(new Term("field", "nestedvalue1")), BooleanClause.Occur.SHOULD),
+                new BooleanClause(new TermQuery(new Term("field", "nestedvalue2")), BooleanClause.Occur.SHOULD)),
+                Occur.SHOULD));
 
-    BooleanQuery bq2 = new BooleanQuery();
-    bq2.add(new TermQuery(new Term("field", "value1")), BooleanClause.Occur.SHOULD);
-    bq2.add(new TermQuery(new Term("field", "value2")), BooleanClause.Occur.SHOULD);
-    BooleanQuery nested2 = new BooleanQuery();
-    nested2.add(new TermQuery(new Term("field", "nestedvalue1")), BooleanClause.Occur.SHOULD);
-    nested2.add(new TermQuery(new Term("field", "nestedvalue2")), BooleanClause.Occur.SHOULD);
-    bq2.add(nested2, BooleanClause.Occur.SHOULD);
+    BooleanQuery bq2 = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "value1")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("field", "value2")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(
+            new BooleanQuery(
+                new BooleanClause(new TermQuery(new Term("field", "nestedvalue1")), BooleanClause.Occur.SHOULD),
+                new BooleanClause(new TermQuery(new Term("field", "nestedvalue2")), BooleanClause.Occur.SHOULD)),
+                Occur.SHOULD));
 
     assertEquals(bq1, bq2);
   }
@@ -95,50 +99,52 @@
     // otherwise scores are different!
     s.setSimilarity(new DefaultSimilarity());
 
-    BooleanQuery q = new BooleanQuery();
-    q.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
-
     // LUCENE-2617: make sure that a term not in the index still contributes to the score via coord factor
-    float score = s.search(q, 10).getMaxScore();
+    float score = s.search(new BooleanQuery(new BooleanClause(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD)), 10).getMaxScore();
     Query subQuery = new TermQuery(new Term("field", "not_in_index"));
     subQuery.setBoost(0);
-    q.add(subQuery, BooleanClause.Occur.SHOULD);
+    BooleanQuery q = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(subQuery, BooleanClause.Occur.SHOULD));
     float score2 = s.search(q, 10).getMaxScore();
     assertEquals(score*.5F, score2, 1e-6);
 
     // LUCENE-2617: make sure that a clause not in the index still contributes to the score via coord factor
-    BooleanQuery qq = q.clone();
-    PhraseQuery phrase = new PhraseQuery();
-    phrase.add(new Term("field", "not_in_index"));
-    phrase.add(new Term("field", "another_not_in_index"));
+    PhraseQuery phrase = new PhraseQuery(
+        new TermAndPosition(new Term("field", "not_in_index"), 0),
+        new TermAndPosition(new Term("field", "another_not_in_index"), 1));
     phrase.setBoost(0);
-    qq.add(phrase, BooleanClause.Occur.SHOULD);
+    BooleanQuery qq = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(subQuery, BooleanClause.Occur.SHOULD),
+        new BooleanClause(phrase, BooleanClause.Occur.SHOULD));
     score2 = s.search(qq, 10).getMaxScore();
     assertEquals(score*(1/3F), score2, 1e-6);
 
     // now test BooleanScorer2
-    subQuery = new TermQuery(new Term("field", "b"));
-    subQuery.setBoost(0);
-    q.add(subQuery, BooleanClause.Occur.MUST);
+    Query subQuery2 = new TermQuery(new Term("field", "b"));
+    subQuery2.setBoost(0);
+    q = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(subQuery, BooleanClause.Occur.SHOULD),
+        new BooleanClause(subQuery2, BooleanClause.Occur.MUST));
     score2 = s.search(q, 10).getMaxScore();
     assertEquals(score*(2/3F), score2, 1e-6);
 
     // PhraseQuery w/ no terms added returns a null scorer
-    PhraseQuery pq = new PhraseQuery();
-    q.add(pq, BooleanClause.Occur.SHOULD);
+    PhraseQuery pq = new PhraseQuery(Collections.emptyList());
+    qq = new BooleanQuery(new BooleanClause(pq, BooleanClause.Occur.SHOULD));
     assertEquals(1, s.search(q, 10).totalHits);
 
     // A required clause which returns null scorer should return null scorer to
     // IndexSearcher.
-    q = new BooleanQuery();
-    pq = new PhraseQuery();
-    q.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
-    q.add(pq, BooleanClause.Occur.MUST);
+    q = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new PhraseQuery(Collections.emptyList()), BooleanClause.Occur.MUST));
     assertEquals(0, s.search(q, 10).totalHits);
 
-    DisjunctionMaxQuery dmq = new DisjunctionMaxQuery(1.0f);
-    dmq.add(new TermQuery(new Term("field", "a")));
-    dmq.add(pq);
+    DisjunctionMaxQuery dmq = new DisjunctionMaxQuery(1.0f,
+        new TermQuery(new Term("field", "a")), pq);
     assertEquals(1, s.search(dmq, 10).totalHits);
 
     r.close();
@@ -163,11 +169,11 @@
     IndexReader reader2 = iw2.getReader();
     iw2.close();
 
-    BooleanQuery query = new BooleanQuery(); // Query: +foo -ba*
-    query.add(new TermQuery(new Term("field", "foo")), BooleanClause.Occur.MUST);
     WildcardQuery wildcardQuery = new WildcardQuery(new Term("field", "ba*"));
     wildcardQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);
-    query.add(wildcardQuery, BooleanClause.Occur.MUST_NOT);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "foo")), BooleanClause.Occur.MUST),
+        new BooleanClause(wildcardQuery, BooleanClause.Occur.MUST_NOT));
 
     MultiReader multireader = new MultiReader(reader1, reader2);
     IndexSearcher searcher = newSearcher(multireader);
@@ -232,12 +238,12 @@
         System.out.println("  terms=" + terms);
       }
 
-      final BooleanQuery q = new BooleanQuery();
-      for(String term : terms) {
-        q.add(new BooleanClause(new TermQuery(new Term("field", term)), BooleanClause.Occur.SHOULD));
+      List<BooleanClause> clauses = new ArrayList<>();
+      for (String term : terms) {
+        clauses.add(new BooleanClause(new TermQuery(new Term("field", term)), BooleanClause.Occur.SHOULD));
       }
 
-      Weight weight = s.createNormalizedWeight(q, true);
+      Weight weight = s.createNormalizedWeight(new BooleanQuery(clauses), true);
 
       Scorer scorer = weight.scorer(s.leafContexts.get(0), null);
 
@@ -255,7 +261,7 @@
       // verify exact match:
       for(int iter2=0;iter2<10;iter2++) {
 
-        weight = s.createNormalizedWeight(q, true);
+        weight = s.createNormalizedWeight(new BooleanQuery(clauses), true);
         scorer = weight.scorer(s.leafContexts.get(0), null);
 
         if (VERBOSE) {
@@ -313,11 +319,11 @@
     IndexReader indexReader = DirectoryReader.open(directory);
     IndexSearcher searcher = newSearcher(indexReader);
 
-    BooleanQuery query = new BooleanQuery();
     SpanQuery sq1 = new SpanTermQuery(new Term(FIELD, "clockwork"));
     SpanQuery sq2 = new SpanTermQuery(new Term(FIELD, "clckwork"));
-    query.add(sq1, BooleanClause.Occur.SHOULD);
-    query.add(sq2, BooleanClause.Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(sq1, BooleanClause.Occur.SHOULD),
+        new BooleanClause(sq2, BooleanClause.Occur.SHOULD));
     TopScoreDocCollector collector = TopScoreDocCollector.create(1000);
     searcher.search(query, collector);
     hits = collector.topDocs().scoreDocs.length;
@@ -352,10 +358,9 @@
         actual.setBoost(BOOST);
       }
 
-      BooleanQuery bq = new BooleanQuery();
-      bq.add(actual, random().nextBoolean()
-             ? BooleanClause.Occur.SHOULD : BooleanClause.Occur.MUST);
-      actual = bq;
+      actual = new BooleanQuery(
+          new BooleanClause(actual, random().nextBoolean()
+             ? BooleanClause.Occur.SHOULD : BooleanClause.Occur.MUST));
     }
     if (needBoost) {
       actual.setBoost(BOOST);
@@ -376,12 +381,11 @@
     w.addDocument(doc);
     IndexReader r = DirectoryReader.open(w, true);
     IndexSearcher s = newSearcher(r);
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
-    bq.add(new TermQuery(new Term("field", "b")), BooleanClause.Occur.SHOULD);
+    BooleanQuery bq = new BooleanQuery(false, 4,
+        new BooleanClause(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("field", "b")), BooleanClause.Occur.SHOULD));
 
     // No doc can match: BQ has only 2 clauses and we are asking for minShouldMatch=4
-    bq.setMinimumNumberShouldMatch(4);
     assertEquals(0, s.search(bq, 1).totalHits);
     r.close();
     w.close();
@@ -432,16 +436,17 @@
         Arrays.asList("d"),
         Arrays.asList("e"),
         Arrays.asList())) {
-      final BooleanQuery bq1 = new BooleanQuery();
+      List<BooleanClause> clauses1 = new ArrayList<>();
+      List<BooleanClause> clauses2 = new ArrayList<>();
       final BooleanQuery bq2 = new BooleanQuery();
       for (String term : requiredTerms) {
         final Query q = new TermQuery(new Term("field", term));
-        bq1.add(q, Occur.MUST);
-        bq2.add(q, Occur.FILTER);
+        clauses1.add(new BooleanClause(q, Occur.MUST));
+        clauses2.add(new BooleanClause(q, Occur.FILTER));
       }
 
-      final BitSet matches1 = getMatches(searcher, bq1);
-      final BitSet matches2 = getMatches(searcher, bq2);
+      final BitSet matches1 = getMatches(searcher, new BooleanQuery(clauses1));
+      final BitSet matches2 = getMatches(searcher, new BooleanQuery(clauses2));
       assertEquals(matches1, matches2);
     }
 
@@ -451,14 +456,13 @@
   }
 
   private void assertSameScoresWithoutFilters(IndexSearcher searcher, BooleanQuery bq) throws IOException {
-    final BooleanQuery bq2 = new BooleanQuery();
+    List<BooleanClause> clausesWithoutFilter = new ArrayList<>();
     for (BooleanClause c : bq.getClauses()) {
       if (c.getOccur() != Occur.FILTER) {
-        bq2.add(c);
+        clausesWithoutFilter.add(c);
       }
     }
-    bq2.setMinimumNumberShouldMatch(bq.getMinimumNumberShouldMatch());
-    bq2.setBoost(bq.getBoost());
+    BooleanQuery bq2 = new BooleanQuery(bq.isCoordDisabled(), bq.getMinimumNumberShouldMatch(), clausesWithoutFilter);
 
     final AtomicBoolean matched = new AtomicBoolean();
     searcher.search(bq, new SimpleCollector() {
@@ -509,9 +513,9 @@
     DirectoryReader reader = w.getReader();
     final IndexSearcher searcher = new IndexSearcher(reader);
 
-    BooleanQuery q = new BooleanQuery();
+    BooleanQuery q = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), Occur.FILTER));
     q.setBoost(random().nextFloat());
-    q.add(new TermQuery(new Term("field", "a")), Occur.FILTER);
 
     // With a single clause, we will rewrite to the underlying
     // query. Make sure that it returns null scores
@@ -519,36 +523,41 @@
 
     // Now with two clauses, we will get a conjunction scorer
     // Make sure it returns null scores
-    q.add(new TermQuery(new Term("field", "b")), Occur.FILTER);
+    q = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), Occur.FILTER),
+        new BooleanClause(new TermQuery(new Term("field", "b")), Occur.FILTER));
     assertSameScoresWithoutFilters(searcher, q);
 
     // Now with a scoring clause, we need to make sure that
     // the boolean scores are the same as those from the term
     // query
-    q.add(new TermQuery(new Term("field", "c")), Occur.SHOULD);
+    q = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), Occur.FILTER),
+        new BooleanClause(new TermQuery(new Term("field", "b")), Occur.FILTER),
+        new BooleanClause(new TermQuery(new Term("field", "c")), Occur.FILTER));
     assertSameScoresWithoutFilters(searcher, q);
 
     // FILTER and empty SHOULD
     q = new BooleanQuery();
     q.setBoost(random().nextFloat());
-    q.add(new TermQuery(new Term("field", "a")), Occur.FILTER);
-    q.add(new TermQuery(new Term("field", "e")), Occur.SHOULD);
+    q = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), Occur.FILTER),
+        new BooleanClause(new TermQuery(new Term("field", "e")), Occur.SHOULD));
     assertSameScoresWithoutFilters(searcher, q);
 
     // mix of FILTER and MUST
-    q = new BooleanQuery();
+    q = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), Occur.FILTER),
+        new BooleanClause(new TermQuery(new Term("field", "d")), Occur.MUST));
     q.setBoost(random().nextFloat());
-    q.add(new TermQuery(new Term("field", "a")), Occur.FILTER);
-    q.add(new TermQuery(new Term("field", "d")), Occur.MUST);
     assertSameScoresWithoutFilters(searcher, q);
 
     // FILTER + minShouldMatch
-    q = new BooleanQuery();
+    q = new BooleanQuery(false, 1,
+        new BooleanClause(new TermQuery(new Term("field", "b")), Occur.FILTER),
+        new BooleanClause(new TermQuery(new Term("field", "a")), Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("field", "d")), Occur.SHOULD));
     q.setBoost(random().nextFloat());
-    q.add(new TermQuery(new Term("field", "b")), Occur.FILTER);
-    q.add(new TermQuery(new Term("field", "a")), Occur.SHOULD);
-    q.add(new TermQuery(new Term("field", "d")), Occur.SHOULD);
-    q.setMinimumNumberShouldMatch(1);
     assertSameScoresWithoutFilters(searcher, q);
 
     reader.close();
@@ -568,8 +577,8 @@
     DirectoryReader reader = w.getReader();
     final IndexSearcher searcher = new IndexSearcher(reader);
 
-    BooleanQuery query1 = new BooleanQuery();
-    query1.add(new TermQuery(new Term("field", "a")), Occur.FILTER);
+    BooleanQuery query1 = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), Occur.FILTER));
 
     // Single clauses rewrite to a term query
     final Query rewritten1 = query1.rewrite(reader);
@@ -579,9 +588,9 @@
     // When there are two clauses, we cannot rewrite, but if one of them creates
     // a null scorer we will end up with a single filter scorer and will need to
     // make sure to set score=0
-    BooleanQuery query2 = new BooleanQuery();
-    query2.add(new TermQuery(new Term("field", "a")), Occur.FILTER);
-    query2.add(new TermQuery(new Term("field", "b")), Occur.SHOULD);
+    BooleanQuery query2 = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), Occur.FILTER),
+        new BooleanClause(new TermQuery(new Term("field", "b")), Occur.SHOULD));
     final Weight weight = searcher.createNormalizedWeight(query2, true);
     final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
     assertTrue(scorer.getClass().getName(), scorer instanceof BooleanTopLevelScorers.BoostedScorer);
@@ -605,13 +614,13 @@
     final IndexSearcher searcher = newSearcher(reader);
     searcher.setQueryCache(null); // to still have approximations
 
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("field", "a"));
-    pq.add(new Term("field", "b"));
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("field", "a"), 0),
+        new TermAndPosition(new Term("field", "b"), 1));
 
-    BooleanQuery q = new BooleanQuery();
-    q.add(pq, Occur.MUST);
-    q.add(new TermQuery(new Term("field", "c")), Occur.FILTER);
+    BooleanQuery q = new BooleanQuery(
+        new BooleanClause(pq, Occur.MUST),
+        new BooleanClause(new TermQuery(new Term("field", "c")), Occur.FILTER));
 
     final Weight weight = searcher.createNormalizedWeight(q, random().nextBoolean());
     final Scorer scorer = weight.scorer(searcher.getIndexReader().leaves().get(0), null);
@@ -636,13 +645,13 @@
     final IndexSearcher searcher = new IndexSearcher(reader);
     searcher.setQueryCache(null); // to still have approximations
 
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("field", "a"));
-    pq.add(new Term("field", "b"));
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("field", "a"), 0),
+        new TermAndPosition(new Term("field", "b"), 1));
 
-    BooleanQuery q = new BooleanQuery();
-    q.add(pq, Occur.SHOULD);
-    q.add(new TermQuery(new Term("field", "c")), Occur.SHOULD);
+    BooleanQuery q = new BooleanQuery(
+        new BooleanClause(pq, Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("field", "c")), Occur.SHOULD));
 
     final Weight weight = searcher.createNormalizedWeight(q, random().nextBoolean());
     final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
@@ -667,13 +676,13 @@
     final IndexSearcher searcher = newSearcher(reader);
     searcher.setQueryCache(null); // to still have approximations
 
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("field", "a"));
-    pq.add(new Term("field", "b"));
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("field", "a"), 0),
+        new TermAndPosition(new Term("field", "b"), 1));
 
-    BooleanQuery q = new BooleanQuery();
-    q.add(pq, Occur.SHOULD);
-    q.add(new TermQuery(new Term("field", "d")), Occur.SHOULD);
+    BooleanQuery q = new BooleanQuery(
+        new BooleanClause(pq, Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("field", "d")), Occur.SHOULD));
 
     final Weight weight = searcher.createNormalizedWeight(q, random().nextBoolean());
     final Scorer scorer = weight.scorer(searcher.getIndexReader().leaves().get(0), null);
@@ -698,13 +707,13 @@
     final IndexSearcher searcher = new IndexSearcher(reader);
     searcher.setQueryCache(null); // to still have approximations
 
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("field", "a"));
-    pq.add(new Term("field", "b"));
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("field", "a"), 0),
+        new TermAndPosition(new Term("field", "b"), 1));
 
-    BooleanQuery q = new BooleanQuery();
-    q.add(pq, Occur.SHOULD);
-    q.add(new TermQuery(new Term("field", "c")), Occur.MUST_NOT);
+    BooleanQuery q = new BooleanQuery(
+        new BooleanClause(pq, Occur.MUST),
+        new BooleanClause(new TermQuery(new Term("field", "c")), Occur.MUST_NOT));
 
     final Weight weight = searcher.createNormalizedWeight(q, random().nextBoolean());
     final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
@@ -729,13 +738,13 @@
     final IndexSearcher searcher = new IndexSearcher(reader);
     searcher.setQueryCache(null); // to still have approximations
 
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("field", "a"));
-    pq.add(new Term("field", "b"));
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("field", "a"), 0),
+        new TermAndPosition(new Term("field", "b"), 1));
 
-    BooleanQuery q = new BooleanQuery();
-    q.add(pq, Occur.MUST);
-    q.add(new TermQuery(new Term("field", "c")), Occur.SHOULD);
+    BooleanQuery q = new BooleanQuery(
+        new BooleanClause(pq, Occur.MUST),
+        new BooleanClause(new TermQuery(new Term("field", "c")), Occur.SHOULD));
 
     final Weight weight = searcher.createNormalizedWeight(q, true);
     final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
@@ -748,11 +757,11 @@
   }
   
   public void testToString() {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(new TermQuery(new Term("field", "a")), Occur.SHOULD);
-    bq.add(new TermQuery(new Term("field", "b")), Occur.MUST);
-    bq.add(new TermQuery(new Term("field", "c")), Occur.MUST_NOT);
-    bq.add(new TermQuery(new Term("field", "d")), Occur.FILTER);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "a")), Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("field", "b")), Occur.MUST),
+        new BooleanClause(new TermQuery(new Term("field", "c")), Occur.MUST_NOT),
+        new BooleanClause(new TermQuery(new Term("field", "d")), Occur.FILTER));
     assertEquals("a +b -c #d", bq.toString("field"));
   }
 }
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java	(working copy)
@@ -79,10 +79,10 @@
   }
 
   public void testDisjunctions() throws IOException {
-    BooleanQuery2 bq = new BooleanQuery2();
-    bq.add(new TermQuery(new Term(F1, "lucene")), BooleanClause.Occur.SHOULD);
-    bq.add(new TermQuery(new Term(F2, "lucene")), BooleanClause.Occur.SHOULD);
-    bq.add(new TermQuery(new Term(F2, "search")), BooleanClause.Occur.SHOULD);
+    BooleanQuery2 bq = new BooleanQuery2(
+        new BooleanClause(new TermQuery(new Term(F1, "lucene")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(F2, "lucene")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(F2, "search")), BooleanClause.Occur.SHOULD));
     Map<Integer,Integer> tfs = getDocCounts(searcher, bq);
     assertEquals(3, tfs.size()); // 3 documents
     assertEquals(3, tfs.get(0).intValue()); // f1:lucene + f2:lucene + f2:search
@@ -91,12 +91,12 @@
   }
   
   public void testNestedDisjunctions() throws IOException {
-    BooleanQuery2 bq = new BooleanQuery2();
-    bq.add(new TermQuery(new Term(F1, "lucene")), BooleanClause.Occur.SHOULD);
-    BooleanQuery2 bq2 = new BooleanQuery2();
-    bq2.add(new TermQuery(new Term(F2, "lucene")), BooleanClause.Occur.SHOULD);
-    bq2.add(new TermQuery(new Term(F2, "search")), BooleanClause.Occur.SHOULD);
-    bq.add(bq2, BooleanClause.Occur.SHOULD);
+    BooleanQuery2 bq2 = new BooleanQuery2(
+        new BooleanClause(new TermQuery(new Term(F2, "lucene")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(F2, "search")), BooleanClause.Occur.SHOULD));
+    BooleanQuery2 bq = new BooleanQuery2(
+        new BooleanClause(new TermQuery(new Term(F1, "lucene")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(bq2, BooleanClause.Occur.SHOULD));
     Map<Integer,Integer> tfs = getDocCounts(searcher, bq);
     assertEquals(3, tfs.size()); // 3 documents
     assertEquals(3, tfs.get(0).intValue()); // f1:lucene + f2:lucene + f2:search
@@ -105,9 +105,9 @@
   }
   
   public void testConjunctions() throws IOException {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(new TermQuery(new Term(F2, "lucene")), BooleanClause.Occur.MUST);
-    bq.add(new TermQuery(new Term(F2, "is")), BooleanClause.Occur.MUST);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(F2, "lucene")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(F2, "is")), BooleanClause.Occur.MUST));
     Map<Integer,Integer> tfs = getDocCounts(searcher, bq);
     assertEquals(3, tfs.size()); // 3 documents
     assertEquals(2, tfs.get(0).intValue()); // f2:lucene + f2:is
@@ -185,12 +185,11 @@
   }
 
   public void testGetChildrenMinShouldMatchSumScorer() throws IOException {
-    final BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(F2, "nutch")), Occur.SHOULD);
-    query.add(new TermQuery(new Term(F2, "web")), Occur.SHOULD);
-    query.add(new TermQuery(new Term(F2, "crawler")), Occur.SHOULD);
-    query.setMinimumNumberShouldMatch(2);
-    query.add(new MatchAllDocsQuery(), Occur.MUST);
+    final BooleanQuery query = new BooleanQuery(false, 2,
+        new BooleanClause(new TermQuery(new Term(F2, "nutch")), Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(F2, "web")), Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(F2, "crawler")), Occur.SHOULD),
+        new BooleanClause(new MatchAllDocsQuery(), Occur.MUST));
     ScorerSummarizingCollector collector = new ScorerSummarizingCollector();
     searcher.search(query, collector);
     assertEquals(1, collector.getNumHits());
@@ -208,9 +207,9 @@
   }
 
   public void testGetChildrenBoosterScorer() throws IOException {
-    final BooleanQuery2 query = new BooleanQuery2();
-    query.add(new TermQuery(new Term(F2, "nutch")), Occur.SHOULD);
-    query.add(new TermQuery(new Term(F2, "miss")), Occur.SHOULD);
+    final BooleanQuery2 query = new BooleanQuery2(
+      new BooleanClause(new TermQuery(new Term(F2, "nutch")), Occur.SHOULD),
+      new BooleanClause(new TermQuery(new Term(F2, "miss")), Occur.SHOULD));
     ScorerSummarizingCollector collector = new ScorerSummarizingCollector();
     searcher.search(query, collector);
     assertEquals(1, collector.getNumHits());
@@ -282,6 +281,10 @@
 
   static class BooleanQuery2 extends BooleanQuery {
 
+    BooleanQuery2(BooleanClause... clauses) {
+      super(clauses);
+    }
+    
     @Override
     public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
       return new BooleanWeight(this, searcher, needsScores, false) {
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java	(working copy)
@@ -46,13 +46,13 @@
     IndexReader ir = writer.getReader();
     writer.close();
 
-    BooleanQuery booleanQuery1 = new BooleanQuery();
-    booleanQuery1.add(new TermQuery(new Term(FIELD, "1")), BooleanClause.Occur.SHOULD);
-    booleanQuery1.add(new TermQuery(new Term(FIELD, "2")), BooleanClause.Occur.SHOULD);
+    BooleanQuery booleanQuery1 = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "1")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(FIELD, "2")), BooleanClause.Occur.SHOULD));
 
-    BooleanQuery query = new BooleanQuery();
-    query.add(booleanQuery1, BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term(FIELD, "9")), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(booleanQuery1, BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(FIELD, "9")), BooleanClause.Occur.MUST_NOT));
 
     IndexSearcher indexSearcher = newSearcher(ir);
     ScoreDoc[] hits = indexSearcher.search(query, 1000).scoreDocs;
@@ -123,13 +123,13 @@
     w.close();
 
     IndexSearcher s = newSearcher(r);
-    BooleanQuery q1 = new BooleanQuery();
-    q1.add(new TermQuery(new Term("field", "little")), BooleanClause.Occur.SHOULD);
-    q1.add(new TermQuery(new Term("field", "diseases")), BooleanClause.Occur.SHOULD);
+    BooleanQuery q1 = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "little")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("field", "diseases")), BooleanClause.Occur.SHOULD));
 
-    BooleanQuery q2 = new BooleanQuery();
-    q2.add(q1, BooleanClause.Occur.SHOULD);
-    q2.add(new CrazyMustUseBulkScorerQuery(), BooleanClause.Occur.SHOULD);
+    BooleanQuery q2 = new BooleanQuery(
+        new BooleanClause(q1, BooleanClause.Occur.SHOULD),
+        new BooleanClause(new CrazyMustUseBulkScorerQuery(), BooleanClause.Occur.SHOULD));
 
     assertEquals(1, s.search(q2, 10).totalHits);
     r.close();
Index: lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperQuery.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperQuery.java	(working copy)
@@ -90,9 +90,9 @@
   
   /** test iterator returns NO_MORE_DOCS */
   public void testEmpty2() throws Exception {
-    BooleanQuery expected = new BooleanQuery();
-    expected.add(new TermQuery(new Term("id", "0")), BooleanClause.Occur.MUST);
-    expected.add(new TermQuery(new Term("id", "0")), BooleanClause.Occur.MUST_NOT);
+    BooleanQuery expected = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("id", "0")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term("id", "0")), BooleanClause.Occur.MUST_NOT));
     Query cached = new CachingWrapperQuery(expected, MAYBE_CACHE_POLICY);
     assertQueryEquals(expected, cached);
   }
Index: lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java	(working copy)
@@ -17,10 +17,15 @@
  * limitations under the License.
  */
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.search.MultiPhraseQuery.TermsAndPosition;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
-import org.apache.lucene.search.spans.*;
+import org.apache.lucene.search.spans.SpanQuery;
 
 /**
  * TestExplanations subclass that builds up super crazy complex queries
@@ -58,45 +63,44 @@
   
   public void test1() throws Exception {
     
-    BooleanQuery q = new BooleanQuery();
+    List<BooleanClause> clauses = new ArrayList<>();
 
-    PhraseQuery phraseQuery = new PhraseQuery();
-    phraseQuery.setSlop(1);
-    phraseQuery.add(new Term(FIELD, "w1"));
-    phraseQuery.add(new Term(FIELD, "w2"));
-    q.add(phraseQuery, Occur.MUST);
-    q.add(snear(st("w2"),
+    PhraseQuery phraseQuery = new PhraseQuery(1,
+        new TermAndPosition(new Term(FIELD, "w1"), 0),
+        new TermAndPosition(new Term(FIELD, "w2"), 1));
+    clauses.add(new BooleanClause(phraseQuery, Occur.MUST));
+    clauses.add(new BooleanClause(snear(st("w2"),
                 sor("w5","zz"),
                 4, true),
-          Occur.SHOULD);
-    q.add(snear(sf("w3",2), st("w2"), st("w3"), 5, true),
-          Occur.SHOULD);
+          Occur.SHOULD));
+    clauses.add(new BooleanClause(snear(sf("w3",2), st("w2"), st("w3"), 5, true),
+          Occur.SHOULD));
 
     Query t = new FilteredQuery(new TermQuery(new Term(FIELD, "xx")),
                                 new QueryWrapperFilter(new ItemizedQuery(new int[] {1,3})));
     t.setBoost(1000);
-    q.add(t, Occur.SHOULD);
+    clauses.add(new BooleanClause(t, Occur.SHOULD));
     
     t = new ConstantScoreQuery(new ItemizedQuery(new int[] {0,2}));
     t.setBoost(30);
-    q.add(t, Occur.SHOULD);
+    clauses.add(new BooleanClause(t, Occur.SHOULD));
     
-    DisjunctionMaxQuery dm = new DisjunctionMaxQuery(0.2f);
-    dm.add(snear(st("w2"),
+    DisjunctionMaxQuery dm = new DisjunctionMaxQuery(0.2f,
+        snear(st("w2"),
                  sor("w5","zz"),
-                 4, true));
-    dm.add(new TermQuery(new Term(FIELD, "QQ")));
+                 4, true),
+        new TermQuery(new Term(FIELD, "QQ")));
 
-    BooleanQuery xxYYZZ = new BooleanQuery();
-    xxYYZZ.add(new TermQuery(new Term(FIELD, "xx")), Occur.SHOULD);
-    xxYYZZ.add(new TermQuery(new Term(FIELD, "yy")), Occur.SHOULD);
-    xxYYZZ.add(new TermQuery(new Term(FIELD, "zz")), Occur.MUST_NOT);
+    BooleanQuery xxYYZZ = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "xx")), Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(FIELD, "yy")), Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(FIELD, "zz")), Occur.MUST_NOT));
 
     dm.add(xxYYZZ);
 
-    BooleanQuery xxW1 = new BooleanQuery();
-    xxW1.add(new TermQuery(new Term(FIELD, "xx")), Occur.MUST_NOT);
-    xxW1.add(new TermQuery(new Term(FIELD, "w1")), Occur.MUST_NOT);
+    BooleanQuery xxW1 = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "xx")), Occur.MUST_NOT),
+        new BooleanClause(new TermQuery(new Term(FIELD, "w1")), Occur.MUST_NOT));
 
     dm.add(xxW1);
 
@@ -106,43 +110,41 @@
     dm2.add(new TermQuery(new Term(FIELD, "w3")));
     dm.add(dm2);
 
-    q.add(dm, Occur.SHOULD);
+    clauses.add(new BooleanClause(dm, Occur.SHOULD));
 
-    BooleanQuery b = new BooleanQuery();
-    b.setMinimumNumberShouldMatch(2);
-    b.add(snear("w1","w2",1,true), Occur.SHOULD);
-    b.add(snear("w2","w3",1,true), Occur.SHOULD);
-    b.add(snear("w1","w3",3,true), Occur.SHOULD);
+    BooleanQuery b = new BooleanQuery(false, 2,
+        new BooleanClause(snear("w1","w2",1,true), Occur.SHOULD),
+      new BooleanClause(snear("w2","w3",1,true), Occur.SHOULD),
+      new BooleanClause(snear("w1","w3",3,true), Occur.SHOULD));
 
-    q.add(b, Occur.SHOULD);
+    clauses.add(new BooleanClause(b, Occur.SHOULD));
     
-    qtest(q, new int[] { 0,1,2 });
+    qtest(new BooleanQuery(clauses), new int[] { 0,1,2 });
   }
 
   public void test2() throws Exception {
     
-    BooleanQuery q = new BooleanQuery();
+    List<BooleanClause> clauses = new ArrayList<>();
 
-    PhraseQuery phraseQuery = new PhraseQuery();
-    phraseQuery.setSlop(1);
-    phraseQuery.add(new Term(FIELD, "w1"));
-    phraseQuery.add(new Term(FIELD, "w2"));
-    q.add(phraseQuery, Occur.MUST);
-    q.add(snear(st("w2"),
+    PhraseQuery phraseQuery = new PhraseQuery(1,
+        new TermAndPosition(new Term(FIELD, "w1"), 0),
+        new TermAndPosition(new Term(FIELD, "w2"), 1));
+    clauses.add(new BooleanClause(phraseQuery, Occur.MUST));
+    clauses.add(new BooleanClause(snear(st("w2"),
                 sor("w5","zz"),
                 4, true),
-          Occur.SHOULD);
-    q.add(snear(sf("w3",2), st("w2"), st("w3"), 5, true),
-          Occur.SHOULD);
-    
+          Occur.SHOULD));
+    clauses.add(new BooleanClause(snear(sf("w3",2), st("w2"), st("w3"), 5, true),
+          Occur.SHOULD));
+
     Query t = new FilteredQuery(new TermQuery(new Term(FIELD, "xx")),
                                 new QueryWrapperFilter(new ItemizedQuery(new int[] {1,3})));
     t.setBoost(1000);
-    q.add(t, Occur.SHOULD);
+    clauses.add(new BooleanClause(t, Occur.SHOULD));
     
     t = new ConstantScoreQuery(new ItemizedQuery(new int[] {0,2}));
-    t.setBoost(-20.0f);
-    q.add(t, Occur.SHOULD);
+    t.setBoost(-20);
+    clauses.add(new BooleanClause(t, Occur.SHOULD));
     
     DisjunctionMaxQuery dm = new DisjunctionMaxQuery(0.2f);
     dm.add(snear(st("w2"),
@@ -150,16 +152,16 @@
                  4, true));
     dm.add(new TermQuery(new Term(FIELD, "QQ")));
 
-    BooleanQuery xxYYZZ = new BooleanQuery();
-    xxYYZZ.add(new TermQuery(new Term(FIELD, "xx")), Occur.SHOULD);
-    xxYYZZ.add(new TermQuery(new Term(FIELD, "yy")), Occur.SHOULD);
-    xxYYZZ.add(new TermQuery(new Term(FIELD, "zz")), Occur.MUST_NOT);
+    BooleanQuery xxYYZZ = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "xx")), Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(FIELD, "yy")), Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term(FIELD, "zz")), Occur.MUST_NOT));
 
     dm.add(xxYYZZ);
 
-    BooleanQuery xxW1 = new BooleanQuery();
-    xxW1.add(new TermQuery(new Term(FIELD, "xx")), Occur.MUST_NOT);
-    xxW1.add(new TermQuery(new Term(FIELD, "w1")), Occur.MUST_NOT);
+    BooleanQuery xxW1 = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "xx")), Occur.MUST_NOT),
+        new BooleanClause(new TermQuery(new Term(FIELD, "w1")), Occur.MUST_NOT));
 
     dm.add(xxW1);
 
@@ -169,18 +171,17 @@
     dm2.add(new TermQuery(new Term(FIELD, "w3")));
     dm.add(dm2);
 
-    q.add(dm, Occur.SHOULD);
+    clauses.add(new BooleanClause(dm, Occur.SHOULD));
 
-    BooleanQuery b = new BooleanQuery();
-    b.setMinimumNumberShouldMatch(2);
-    b.add(snear("w1","w2",1,true), Occur.SHOULD);
-    b.add(snear("w2","w3",1,true), Occur.SHOULD);
-    b.add(snear("w1","w3",3,true), Occur.SHOULD);
+    BooleanQuery b = new BooleanQuery(false, 2,
+        new BooleanClause(snear("w1","w2",1,true), Occur.SHOULD),
+      new BooleanClause(snear("w2","w3",1,true), Occur.SHOULD),
+      new BooleanClause(snear("w1","w3",3,true), Occur.SHOULD));
     b.setBoost(0.0f);
+
+    clauses.add(new BooleanClause(b, Occur.SHOULD));
     
-    q.add(b, Occur.SHOULD);
-    
-    qtest(q, new int[] { 0,1,2 });
+    qtest(new BooleanQuery(clauses), new int[] { 0,1,2 });
   }
   
   // :TODO: we really need more crazy complex cases.
@@ -219,11 +220,11 @@
   public void testDMQ10() throws Exception {
     DisjunctionMaxQuery q = new DisjunctionMaxQuery(0.5f);
 
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(FIELD, "yy")), Occur.SHOULD);
     TermQuery boostedQuery = new TermQuery(new Term(FIELD, "w5"));
     boostedQuery.setBoost(100);
-    query.add(boostedQuery, Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "yy")), Occur.SHOULD),
+        new BooleanClause(boostedQuery, Occur.SHOULD));
 
     q.add(query);
 
@@ -236,10 +237,9 @@
   }
   
   public void testMPQ7() throws Exception {
-    MultiPhraseQuery q = new MultiPhraseQuery();
-    q.add(ta(new String[] {"w1"}));
-    q.add(ta(new String[] {"w2"}));
-    q.setSlop(1);
+    MultiPhraseQuery q = new MultiPhraseQuery(1,
+        new TermsAndPosition(ta(new String[] {"w1"}), 0),
+        new TermsAndPosition(ta(new String[] {"w2"}), 1));
     q.setBoost(0.0f);
     bqtest(q, new int[] { 0,1,2 });
   }
@@ -246,48 +246,48 @@
   
   public void testBQ12() throws Exception {
     // NOTE: using qtest not bqtest
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(FIELD, "w1")), Occur.SHOULD);
     TermQuery boostedQuery = new TermQuery(new Term(FIELD, "w2"));
     boostedQuery.setBoost(0);
-    query.add(boostedQuery, Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "w1")), Occur.SHOULD),
+        new BooleanClause(boostedQuery, Occur.SHOULD));
     
     qtest(query, new int[] { 0,1,2,3 });
   }
   public void testBQ13() throws Exception {
     // NOTE: using qtest not bqtest
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(FIELD, "w1")), Occur.SHOULD);
     TermQuery boostedQuery = new TermQuery(new Term(FIELD, "w5"));
     boostedQuery.setBoost(0);
-    query.add(boostedQuery, Occur.MUST_NOT);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "w1")), Occur.SHOULD),
+        new BooleanClause(boostedQuery, Occur.MUST_NOT));
 
     qtest(query, new int[] { 1,2,3 });
   }
   public void testBQ18() throws Exception {
     // NOTE: using qtest not bqtest
-    BooleanQuery query = new BooleanQuery();
     TermQuery boostedQuery = new TermQuery(new Term(FIELD, "w1"));
     boostedQuery.setBoost(0);
-    query.add(boostedQuery, Occur.MUST);
-    query.add(new TermQuery(new Term(FIELD, "w2")), Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "w2")), Occur.SHOULD),
+        new BooleanClause(boostedQuery, Occur.MUST));
     
     qtest(query, new int[] { 0,1,2,3 });
   }
   public void testBQ21() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term(FIELD, "w1")), Occur.MUST);
-    query.add(new TermQuery(new Term(FIELD, "w2")), Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(FIELD, "w1")), Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(FIELD, "w2")), Occur.SHOULD));
     query.setBoost(0);
 
     bqtest(query, new int[] { 0,1,2,3 });
   }
   public void testBQ22() throws Exception {
-    BooleanQuery query = new BooleanQuery();
     TermQuery boostedQuery = new TermQuery(new Term(FIELD, "w1"));
     boostedQuery.setBoost(0);
-    query.add(boostedQuery, Occur.MUST);
-    query.add(new TermQuery(new Term(FIELD, "w2")), Occur.SHOULD);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(boostedQuery, Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(FIELD, "w2")), Occur.SHOULD));
     query.setBoost(0);
 
     bqtest(query, new int[] { 0,1,2,3 });
Index: lucene/core/src/test/org/apache/lucene/search/TestConjunctions.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestConjunctions.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestConjunctions.java	(working copy)
@@ -70,9 +70,9 @@
   }
   
   public void testTermConjunctionsWithOmitTF() throws Exception {
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(new TermQuery(new Term(F1, "nutch")), BooleanClause.Occur.MUST);
-    bq.add(new TermQuery(new Term(F2, "is")), BooleanClause.Occur.MUST);
+    BooleanQuery bq = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term(F1, "nutch")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(F2, "is")), BooleanClause.Occur.MUST));
     TopDocs td = searcher.search(bq, 3);
     assertEquals(1, td.totalHits);
     assertEquals(3F, td.scoreDocs[0].score, 0.001F); // f1:nutch + f2:is + f2:is
Index: lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java	(working copy)
@@ -26,6 +26,7 @@
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.search.PhraseQuery.TermAndPosition;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.Bits;
@@ -110,9 +111,9 @@
       final Query csq2 = new ConstantScoreQuery(csq1);
       csq2.setBoost(5.0f);
       
-      final BooleanQuery bq = new BooleanQuery();
-      bq.add(csq1, BooleanClause.Occur.SHOULD);
-      bq.add(csq2, BooleanClause.Occur.SHOULD);
+      final BooleanQuery bq = new BooleanQuery(
+          new BooleanClause(csq1, BooleanClause.Occur.SHOULD),
+          new BooleanClause(csq2, BooleanClause.Occur.SHOULD));
       
       final Query csqbq = new ConstantScoreQuery(bq);
       csqbq.setBoost(17.0f);
@@ -217,9 +218,9 @@
     final IndexSearcher searcher = newSearcher(reader);
     searcher.setQueryCache(null); // to still have approximations
 
-    PhraseQuery pq = new PhraseQuery();
-    pq.add(new Term("field", "a"));
-    pq.add(new Term("field", "b"));
+    PhraseQuery pq = new PhraseQuery(
+        new TermAndPosition(new Term("field", "a"), 0),
+        new TermAndPosition(new Term("field", "b"), 1));
 
     ConstantScoreQuery q = new ConstantScoreQuery(pq);
 
Index: lucene/core/src/test/org/apache/lucene/search/TestCustomSearcherSort.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestCustomSearcherSort.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/TestCustomSearcherSort.java	(working copy)
@@ -194,10 +194,10 @@
     @Override
     public TopFieldDocs search(Query query, int nDocs, Sort sort)
         throws IOException {
-      BooleanQuery bq = new BooleanQuery();
-      bq.add(query, BooleanClause.Occur.MUST);
-      bq.add(new TermQuery(new Term("mandant", Integer.toString(switcher))),
-          BooleanClause.Occur.MUST);
+      BooleanQuery bq = new BooleanQuery(
+          new BooleanClause(query, BooleanClause.Occur.MUST),
+          new BooleanClause(new TermQuery(new Term("mandant", Integer.toString(switcher))),
+          BooleanClause.Occur.MUST));
       return super.search(bq, nDocs, sort);
     }
     
@@ -204,10 +204,10 @@
     @Override
     public TopDocs search(Query query, int nDocs)
         throws IOException {
-      BooleanQuery bq = new BooleanQuery();
-      bq.add(query, BooleanClause.Occur.MUST);
-      bq.add(new TermQuery(new Term("mandant", Integer.toString(switcher))),
-          BooleanClause.Occur.MUST);
+      BooleanQuery bq = new BooleanQuery(
+          new BooleanClause(query, BooleanClause.Occur.MUST),
+          new BooleanClause(new TermQuery(new Term("mandant", Integer.toString(switcher))),
+          BooleanClause.Occur.MUST));
       return super.search(bq, nDocs);
     }
   }
Index: lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java	(working copy)
@@ -278,11 +278,9 @@
             new MaxPayloadFunction());
     PayloadTermQuery q2 = new PayloadTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "foo"),
             new MaxPayloadFunction());
-    BooleanClause c1 = new BooleanClause(q1, BooleanClause.Occur.MUST);
-    BooleanClause c2 = new BooleanClause(q2, BooleanClause.Occur.MUST_NOT);
-    BooleanQuery query = new BooleanQuery();
-    query.add(c1);
-    query.add(c2);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(q1, BooleanClause.Occur.MUST),
+        new BooleanClause(q2, BooleanClause.Occur.MUST_NOT));
     TopDocs hits = searcher.search(query, 100);
     assertTrue("hits is null and it shouldn't be", hits != null);
     assertTrue("hits Size: " + hits.totalHits + " is not: " + 1, hits.totalHits == 1);
Index: lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java	(working copy)
@@ -102,9 +102,9 @@
     
     for (Similarity sim : sims) {
       is.setSimilarity(sim);
-      BooleanQuery query = new BooleanQuery(true);
-      query.add(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD);
-      query.add(new TermQuery(new Term("bar", "baz")), BooleanClause.Occur.SHOULD);
+      BooleanQuery query = new BooleanQuery(true, 0,
+          new BooleanClause(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD),
+          new BooleanClause(new TermQuery(new Term("bar", "baz")), BooleanClause.Occur.SHOULD));
       assertEquals(1, is.search(query, 10).totalHits);
     }
     ir.close();
@@ -124,9 +124,9 @@
     
     for (Similarity sim : sims) {
       is.setSimilarity(sim);
-      BooleanQuery query = new BooleanQuery(true);
-      query.add(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD);
-      query.add(new TermQuery(new Term("foo", "baz")), BooleanClause.Occur.SHOULD);
+      BooleanQuery query = new BooleanQuery(true, 0,
+          new BooleanClause(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("foo", "baz")), BooleanClause.Occur.SHOULD));
       assertEquals(1, is.search(query, 10).totalHits);
     }
     ir.close();
@@ -149,8 +149,8 @@
     
     for (Similarity sim : sims) {
       is.setSimilarity(sim);
-      BooleanQuery query = new BooleanQuery(true);
-      query.add(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD);
+      BooleanQuery query = new BooleanQuery(true, 0,
+          new BooleanClause(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD));
       assertEquals(1, is.search(query, 10).totalHits);
     }
     ir.close();
@@ -174,8 +174,8 @@
     
     for (Similarity sim : sims) {
       is.setSimilarity(sim);
-      BooleanQuery query = new BooleanQuery(true);
-      query.add(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD);
+      BooleanQuery query = new BooleanQuery(true, 0,
+          new BooleanClause(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD));
       assertEquals(1, is.search(query, 10).totalHits);
     }
     ir.close();
@@ -200,8 +200,8 @@
     
     for (Similarity sim : sims) {
       is.setSimilarity(sim);
-      BooleanQuery query = new BooleanQuery(true);
-      query.add(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD);
+      BooleanQuery query = new BooleanQuery(true, 0,
+          new BooleanClause(new TermQuery(new Term("foo", "bar")), BooleanClause.Occur.SHOULD));
       assertEquals(1, is.search(query, 10).totalHits);
     }
     ir.close();
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java	(working copy)
@@ -165,9 +165,9 @@
 
   @Test
   public void testPhrase() throws Exception {
-    PhraseQuery query = new PhraseQuery();
-    query.add(new Term("field", "seventy"));
-    query.add(new Term("field", "seven"));
+    PhraseQuery query = new PhraseQuery(
+        new Term("field", "seventy"),
+        new Term("field", "seven"));
     checkHits(query, new int[]
       {77, 177, 277, 377, 477, 577, 677, 777, 877,
               977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
@@ -175,17 +175,17 @@
 
   @Test
   public void testPhrase2() throws Exception {
-    PhraseQuery query = new PhraseQuery();
-    query.add(new Term("field", "seventish"));
-    query.add(new Term("field", "sevenon"));
+    PhraseQuery query = new PhraseQuery(
+        new Term("field", "seventish"),
+        new Term("field", "sevenon"));
     checkHits(query, new int[] {});
   }
 
   @Test
   public void testBoolean() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term("field", "seventy")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term("field", "seven")), BooleanClause.Occur.MUST);
+    BooleanQuery query = new BooleanQuery(
+      new BooleanClause(new TermQuery(new Term("field", "seventy")), BooleanClause.Occur.MUST),
+      new BooleanClause(new TermQuery(new Term("field", "seven")), BooleanClause.Occur.MUST));
     checkHits(query, new int[]
       {77, 177, 277, 377, 477, 577, 677, 770, 771, 772, 773, 774, 775, 776, 777,
               778, 779, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677,
@@ -195,9 +195,9 @@
 
   @Test
   public void testBoolean2() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term("field", "sevento")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term("field", "sevenly")), BooleanClause.Occur.MUST);
+    BooleanQuery query = new BooleanQuery(
+        new BooleanClause(new TermQuery(new Term("field", "sevento")), BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term("field", "sevenly")), BooleanClause.Occur.MUST));
     checkHits(query, new int[] {});
   }
 
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java	(working copy)
@@ -19,6 +19,7 @@
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.SearchEquivalenceTestBase;
@@ -43,9 +44,9 @@
   public void testSpanOrVersusBoolean() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    BooleanQuery q1 = new BooleanQuery();
-    q1.add(new TermQuery(t1), Occur.SHOULD);
-    q1.add(new TermQuery(t2), Occur.SHOULD);
+    BooleanQuery q1 = new BooleanQuery(
+        new BooleanClause(new TermQuery(t1), Occur.SHOULD),
+        new BooleanClause(new TermQuery(t2), Occur.SHOULD));
     SpanOrQuery q2 = new SpanOrQuery(new SpanTermQuery(t1), new SpanTermQuery(t2));
     assertSameSet(q1, q2);
   }
@@ -69,9 +70,7 @@
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
     SpanNearQuery q1 = new SpanNearQuery(subquery, 0, true);
-    PhraseQuery q2 = new PhraseQuery();
-    q2.add(t1);
-    q2.add(t2);
+    PhraseQuery q2 = new PhraseQuery(t1, t2);
     assertSameSet(q1, q2);
   }
   
@@ -81,9 +80,9 @@
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
     SpanNearQuery q1 = new SpanNearQuery(subquery, Integer.MAX_VALUE, false);
-    BooleanQuery q2 = new BooleanQuery();
-    q2.add(new TermQuery(t1), Occur.MUST);
-    q2.add(new TermQuery(t2), Occur.MUST);
+    BooleanQuery q2 = new BooleanQuery(
+        new BooleanClause(new TermQuery(t1), Occur.MUST),
+        new BooleanClause(new TermQuery(t2), Occur.MUST));
     assertSameSet(q1, q2);
   }
   
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java	(working copy)
@@ -21,7 +21,6 @@
 
 import org.apache.lucene.document.Field;
 import org.apache.lucene.util.LuceneTestCase;
-
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenFilter;
 import org.apache.lucene.analysis.MockTokenizer;
@@ -110,9 +109,9 @@
       final float expectedScore) throws IOException {
     
     final Query spanQuery = new SpanTermQuery(new Term(FIELD_TEXT, "work"));
-    final BooleanQuery query = new BooleanQuery();
-    query.add(spanQuery, BooleanClause.Occur.MUST);
-    query.add(spanQuery, BooleanClause.Occur.MUST);
+    final BooleanQuery query = new BooleanQuery(
+        new BooleanClause(spanQuery, BooleanClause.Occur.MUST),
+        new BooleanClause(spanQuery, BooleanClause.Occur.MUST));
     final String[] expectedIds = new String[] {"1", "2", "3", "4"};
     final float[] expectedScores = new float[] {expectedScore, expectedScore,
         expectedScore, expectedScore};
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java	(revision 1668924)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java	(working copy)
@@ -99,9 +99,9 @@
     
     final Query spanQuery1 = new SpanTermQuery(new Term(FIELD_TEXT, "should"));
     final Query spanQuery2 = new SpanTermQuery(new Term(FIELD_TEXT, "we"));
-    final BooleanQuery query = new BooleanQuery();
-    query.add(spanQuery1, BooleanClause.Occur.MUST);
-    query.add(spanQuery2, BooleanClause.Occur.MUST);
+    final BooleanQuery query = new BooleanQuery(
+        new BooleanClause(spanQuery1, BooleanClause.Occur.MUST),
+        new BooleanClause(spanQuery2, BooleanClause.Occur.MUST));
     final String[] expectedIds = new String[] {"D", "A"};
     // these values were pre LUCENE-413
     // final float[] expectedScores = new float[] { 0.93163157f, 0.20698164f };
Index: lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java
===================================================================
--- lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java	(revision 1668924)
+++ lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java	(working copy)
@@ -20,6 +20,8 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.lucene.analysis.core.WhitespaceAnalyzer;
 import org.apache.lucene.document.Document;
@@ -49,6 +51,7 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.NumericRangeQuery;
+import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryWrapperFilter;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TopDocs;
@@ -180,28 +183,25 @@
       maxLng = Math.toRadians(180);
     }
 
-    BooleanQuery f = new BooleanQuery();
-
     // Add latitude range filter:
-    f.add(NumericRangeQuery.newDoubleRange("latitude", Math.toDegrees(minLat), Math.toDegrees(maxLat), true, true),
-          BooleanClause.Occur.FILTER);
+    final Query latFilter = NumericRangeQuery.newDoubleRange("latitude", Math.toDegrees(minLat), Math.toDegrees(maxLat), true, true);
 
     // Add longitude range filter:
+    final Query lonFilter;
     if (minLng > maxLng) {
       // The bounding box crosses the international date
       // line:
-      BooleanQuery lonF = new BooleanQuery();
-      lonF.add(NumericRangeQuery.newDoubleRange("longitude", Math.toDegrees(minLng), null, true, true),
-               BooleanClause.Occur.SHOULD);
-      lonF.add(NumericRangeQuery.newDoubleRange("longitude", null, Math.toDegrees(maxLng), true, true),
-               BooleanClause.Occur.SHOULD);
-      f.add(lonF, BooleanClause.Occur.MUST);
+      lonFilter = new BooleanQuery(
+          new BooleanClause(NumericRangeQuery.newDoubleRange("longitude", Math.toDegrees(minLng), null, true, true), BooleanClause.Occur.SHOULD),
+          new BooleanClause(NumericRangeQuery.newDoubleRange("longitude", null, Math.toDegrees(maxLng), true, true), BooleanClause.Occur.SHOULD));
+              
     } else {
-      f.add(NumericRangeQuery.newDoubleRange("longitude", Math.toDegrees(minLng), Math.toDegrees(maxLng), true, true),
-            BooleanClause.Occur.FILTER);
+      lonFilter = NumericRangeQuery.newDoubleRange("longitude", Math.toDegrees(minLng), Math.toDegrees(maxLng), true, true);
     }
 
-    return new QueryWrapperFilter(f);
+    return new QueryWrapperFilter(new BooleanQuery(
+        new BooleanClause(latFilter, BooleanClause.Occur.FILTER),
+        new BooleanClause(lonFilter, BooleanClause.Occur.FILTER)));
   }
 
   /** User runs a query and counts facets. */
Index: lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
===================================================================
--- lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java	(revision 1668924)
+++ lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java	(working copy)
@@ -88,14 +88,10 @@
     for (int i = 0; i < n; i++) {
       assertQuery(new MatchAllDocsQuery());
       assertQuery(new TermQuery(new Term("english", "one")));
-      BooleanQuery bq = new BooleanQuery();
-      bq.add(new TermQuery(new Term("english", "one")), BooleanClause.Occur.SHOULD);
-      bq.add(new TermQuery(new Term("oddeven", "even")), BooleanClause.Occur.SHOULD);
+      BooleanQuery bq = new BooleanQuery(
+          new BooleanClause(new TermQuery(new Term("english", "one")), BooleanClause.Occur.SHOULD),
+          new BooleanClause(new TermQuery(new Term("oddeven", "even")), BooleanClause.Occur.SHOULD));
       assertQuery(bq);
-      // force in order
-      bq.add(new TermQuery(new Term("english", "two")), BooleanClause.Occur.SHOULD);
-      bq.setMinimumNumberShouldMatch(2);
-      assertQuery(bq);
     }
   }
   
Index: lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery.java	(revision 1668924)
+++ lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery.java	(working copy)
@@ -60,7 +60,7 @@
 
   /** Used by clone() */
   DrillDownQuery(FacetsConfig config, BooleanQuery query, Map<String,Integer> drillDownDims) {
-    this.query = query.clone();
+    this.query = (BooleanQuery) query.clone();
     this.drillDownDims.putAll(drillDownDims);
     this.config = config;
   }
Index: lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java	(revision 1668924)
+++ lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java	(working copy)
@@ -17,6 +17,9 @@
  * limitations under the License.
  */
 
+import java.util.Arrays;
+import java.util.List;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -131,12 +134,12 @@
   }
 
   /** helper for generating MultiPhraseQueries */
-  public static Term[] ta(String[] s) {
+  public static List<Term> ta(String... s) {
     Term[] t = new Term[s.length];
     for (int i = 0; i < s.length; i++) {
       t[i] = new Term(FIELD, s[i]);
     }
-    return t;
+    return Arrays.asList(t);
   }
 
   /** MACRO for SpanTermQuery */
@@ -199,10 +202,9 @@
    * with a second prohibited clause which will never match anything
    */
   public Query optB(Query q) throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(q, BooleanClause.Occur.SHOULD);
-    bq.add(new TermQuery(new Term("NEVER","MATCH")), BooleanClause.Occur.MUST_NOT);
-    return bq;
+    return new BooleanQuery(true, 0,
+        new BooleanClause(q, BooleanClause.Occur.SHOULD),
+        new BooleanClause(new TermQuery(new Term("NEVER","MATCH")), BooleanClause.Occur.MUST_NOT));
   }
 
   /**
@@ -210,9 +212,8 @@
    * with a second optional clause which will match everything
    */
   public Query reqB(Query q) throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(q, BooleanClause.Occur.MUST);
-    bq.add(new TermQuery(new Term(FIELD,"w1")), BooleanClause.Occur.SHOULD);
-    return bq;
+    return new BooleanQuery(true, 0,
+        new BooleanClause(q, BooleanClause.Occur.MUST),
+        new BooleanClause(new TermQuery(new Term(FIELD,"w1")), BooleanClause.Occur.SHOULD));
   }
 }
Index: solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java	(revision 1668924)
+++ solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java	(working copy)
@@ -391,11 +391,9 @@
       }
 
       // exclude current document from results
-      realMLTQuery = new BooleanQuery();
-      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);
-      realMLTQuery.add(
-          new TermQuery(new Term(uniqueKeyField.getName(), uniqueKeyField.getType().storedToIndexed(doc.getField(uniqueKeyField.getName())))), 
-            BooleanClause.Occur.MUST_NOT);
+      realMLTQuery = new BooleanQuery(
+          new BooleanClause(boostedMLTQuery, BooleanClause.Occur.MUST),
+          new BooleanClause(new TermQuery(new Term(uniqueKeyField.getName(), uniqueKeyField.getType().storedToIndexed(doc.getField(uniqueKeyField.getName())))), BooleanClause.Occur.MUST_NOT));
       
       DocListAndSet results = new DocListAndSet();
       if (this.needDocSet) {
@@ -456,11 +454,9 @@
         mltquery = (BooleanQuery) getBoostedQuery(mltquery);
         
         // exclude current document from results
-        BooleanQuery mltQuery = new BooleanQuery();
-        mltQuery.add(mltquery, BooleanClause.Occur.MUST);
-        
-        mltQuery.add(
-            new TermQuery(new Term(uniqueKeyField.getName(), uniqueId)), BooleanClause.Occur.MUST_NOT);
+        BooleanQuery mltQuery = new BooleanQuery(
+            new BooleanClause(mltquery, BooleanClause.Occur.MUST),
+            new BooleanClause(new TermQuery(new Term(uniqueKeyField.getName(), uniqueId)), BooleanClause.Occur.MUST_NOT));
         result.add(uniqueId, mltQuery);
       }
 
Index: solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java	(revision 1668924)
+++ solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java	(working copy)
@@ -142,17 +142,18 @@
       this.ids = new HashSet<>();
       this.excludeIds = new HashSet<>();
 
-      this.include = new BooleanQuery();
-      this.include.setBoost(0);
       this.priority = new HashMap<>();
       int max = elevate.size() + 5;
+      final List<BooleanClause> clauses = new ArrayList<>();
       for (String id : elevate) {
         id = idSchemaFT.readableToIndexed(id);
         ids.add(id);
         TermQuery tq = new TermQuery(new Term(idField, id));
-        include.add(tq, BooleanClause.Occur.SHOULD);
+        clauses.add(new BooleanClause(tq, BooleanClause.Occur.SHOULD));
         this.priority.put(new BytesRef(id), max--);
       }
+      this.include = new BooleanQuery(clauses);
+      this.include.setBoost(0);
 
       if (exclude == null || exclude.isEmpty()) {
         this.exclude = null;
@@ -421,13 +422,13 @@
         //we only want these results
         rb.setQuery(booster.include);
       } else {
-        BooleanQuery newq = new BooleanQuery(true);
-        newq.add(query, BooleanClause.Occur.SHOULD);
-        newq.add(booster.include, BooleanClause.Occur.SHOULD);
+        List<BooleanClause> clauses = new ArrayList<>();
+        clauses.add(new BooleanClause(query, BooleanClause.Occur.SHOULD));
+        clauses.add(new BooleanClause(booster.include, BooleanClause.Occur.SHOULD));
         if (booster.exclude != null) {
           if (markExcludes == false) {
             for (TermQuery tq : booster.exclude) {
-              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));
+              clauses.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));
             }
           } else {
             //we are only going to mark items as excluded, not actually exclude them.  This works
@@ -435,7 +436,7 @@
             rb.req.getContext().put(EXCLUDED, booster.excludeIds);
           }
         }
-        rb.setQuery(newq);
+        rb.setQuery(new BooleanQuery(true, 0, clauses));
       }
 
       ElevationComparatorSource comparator = new ElevationComparatorSource(booster);
Index: solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
===================================================================
--- solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java	(revision 1668924)
+++ solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java	(working copy)
@@ -387,10 +387,12 @@
     if (subQParser == null) {
 
       if (query instanceof PhraseQuery) {
-        ((PhraseQuery) query).setSlop(slop);
+        PhraseQuery pq = (PhraseQuery) query;
+        query = new PhraseQuery(slop, pq.termAndPositions());
       }
       if (query instanceof MultiPhraseQuery) {
-        ((MultiPhraseQuery) query).setSlop(slop);
+        MultiPhraseQuery pq = (MultiPhraseQuery) query;
+        query = new MultiPhraseQuery(slop, pq.termAndPositions());
       }
 
     }
@@ -500,11 +502,7 @@
     if (clauses.size()==0) {
       return null; // all clause words were filtered away by the analyzer.
     }
-    BooleanQuery query = newBooleanQuery(disableCoord);
-    for(final BooleanClause clause: clauses) {
-      query.add(clause);
-    }
-    return query;
+    return new BooleanQuery(disableCoord, 0, clauses);
   }
 
 
Index: solr/core/src/java/org/apache/solr/schema/CurrencyField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/CurrencyField.java	(revision 1668924)
+++ solr/core/src/java/org/apache/solr/schema/CurrencyField.java	(working copy)
@@ -39,6 +39,7 @@
 import org.apache.lucene.index.StorableField;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.FieldValueQuery;
@@ -335,9 +336,9 @@
        p1 == null ? null : p1.getAmount() + "", 
        p2 == null ? null : p2.getAmount() + "",
        minInclusive, maxInclusive);
-    final BooleanQuery docsInRange = new BooleanQuery();
-    docsInRange.add(docsWithValues, Occur.FILTER);
-    docsInRange.add(vsRangeFilter, Occur.FILTER);
+    final BooleanQuery docsInRange = new BooleanQuery(
+        new BooleanClause(docsWithValues, Occur.FILTER),
+        new BooleanClause(vsRangeFilter, Occur.FILTER));
 
     return new SolrConstantScoreQuery(new QueryWrapperFilter(docsInRange));
   }
Index: solr/core/src/java/org/apache/solr/schema/LatLonType.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/LatLonType.java	(revision 1668924)
+++ solr/core/src/java/org/apache/solr/schema/LatLonType.java	(working copy)
@@ -99,12 +99,12 @@
 
     SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());
     SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());
-    BooleanQuery result = new BooleanQuery(true);
+    BooleanQuery result = new BooleanQuery(true, 0,
     // points must currently be ordered... should we support specifying any two opposite corner points?
-    result.add(latSF.getType().getRangeQuery(parser, latSF,
-        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);
-    result.add(lonSF.getType().getRangeQuery(parser, lonSF,
-        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);
+        new BooleanClause(latSF.getType().getRangeQuery(parser, latSF,
+            Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST),
+        new BooleanClause(lonSF.getType().getRangeQuery(parser, lonSF,
+            Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST));
     return result;
   }
 
@@ -114,11 +114,11 @@
 
     SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());
     SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());
-    BooleanQuery result = new BooleanQuery(true);
-    result.add(latSF.getType().getFieldQuery(parser, latSF,
-        Double.toString(p1.getY())), BooleanClause.Occur.MUST);
-    result.add(lonSF.getType().getFieldQuery(parser, lonSF,
-        Double.toString(p1.getX())), BooleanClause.Occur.MUST);
+    BooleanQuery result = new BooleanQuery(true, 0,
+        new BooleanClause(latSF.getType().getFieldQuery(parser, latSF,
+            Double.toString(p1.getY())), BooleanClause.Occur.MUST),
+        new BooleanClause(lonSF.getType().getFieldQuery(parser, lonSF,
+            Double.toString(p1.getX())), BooleanClause.Occur.MUST));
     return result;
   }
 
@@ -159,13 +159,13 @@
 
 
     if (options.bbox) {
-      BooleanQuery result = new BooleanQuery();
+      List<BooleanClause> clauses = new ArrayList<>();
 
       Query latRange = latSF.getType().getRangeQuery(parser, latSF,
                 String.valueOf(latMin),
                 String.valueOf(latMax),
                 true, true);
-      result.add(latRange, BooleanClause.Occur.MUST);
+      clauses.add(new BooleanClause(latRange, BooleanClause.Occur.MUST));
 
       if (lonMin != -180 || lonMax != 180) {
         Query lonRange = lonSF.getType().getRangeQuery(parser, lonSF,
@@ -174,22 +174,18 @@
                 true, true);
         if (lon2Min != -180 || lon2Max != 180) {
           // another valid longitude range
-          BooleanQuery bothLons = new BooleanQuery();
-          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);
-
-          lonRange = lonSF.getType().getRangeQuery(parser, lonSF,
+          lonRange = new BooleanQuery(
+              new BooleanClause(lonRange, BooleanClause.Occur.SHOULD),
+              new BooleanClause(lonSF.getType().getRangeQuery(parser, lonSF,
                 String.valueOf(lon2Min),
                 String.valueOf(lon2Max),
-                true, true);
-          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);
-
-          lonRange = bothLons;
+                true, true), BooleanClause.Occur.SHOULD));
         }
 
-        result.add(lonRange, BooleanClause.Occur.MUST);
+        clauses.add(new BooleanClause(lonRange, BooleanClause.Occur.MUST));
       }
 
-      spatial.bboxQuery = result;
+      spatial.bboxQuery = new BooleanQuery(clauses);
     }
 
 
Index: solr/core/src/java/org/apache/solr/schema/PointType.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/PointType.java	(revision 1668924)
+++ solr/core/src/java/org/apache/solr/schema/PointType.java	(working copy)
@@ -137,13 +137,13 @@
     String[] p1 = parseCommaSeparatedList(part1, dimension);
     String[] p2 = parseCommaSeparatedList(part2, dimension);
 
-    BooleanQuery result = new BooleanQuery(true);
+    List<BooleanClause> clauses = new ArrayList<>();
     for (int i = 0; i < dimension; i++) {
       SchemaField subSF = subField(field, i, schema);
       // points must currently be ordered... should we support specifying any two opposite corner points?
-      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);
+      clauses.add(new BooleanClause(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST));
     }
-    return result;
+    return new BooleanQuery(true, 0, clauses);
   }
 
   @Override
@@ -150,13 +150,13 @@
   public Query getFieldQuery(QParser parser, SchemaField field, String externalVal) {
     String[] p1 = parseCommaSeparatedList(externalVal, dimension);
     //TODO: should we assert that p1.length == dimension?
-    BooleanQuery bq = new BooleanQuery(true);
+    List<BooleanClause> clauses = new ArrayList<>();
     for (int i = 0; i < dimension; i++) {
       SchemaField sf = subField(field, i, schema);
       Query tq = sf.getType().getFieldQuery(parser, sf, p1[i]);
-      bq.add(tq, BooleanClause.Occur.MUST);
+      clauses.add(new BooleanClause(tq, BooleanClause.Occur.MUST));
     }
-    return bq;
+    return new BooleanQuery(true, 0, clauses);
   }
 
   /**
@@ -188,7 +188,7 @@
       // points must currently be ordered... should we support specifying any two opposite corner points?
       return subSF.getType().getRangeQuery(parser, subSF, lower, upper, true, true);
     } else {
-      BooleanQuery tmp = new BooleanQuery();
+      List<BooleanClause> tmp = new ArrayList<>();
       //TODO: Handle distance measures, as this assumes Euclidean
       double[] ur = vectorBoxCorner(point, null, options.distance, true);
       double[] ll = vectorBoxCorner(point, null, options.distance, false);
@@ -195,9 +195,9 @@
       for (int i = 0; i < ur.length; i++) {
         SchemaField subSF = subField(options.field, i, schema);
         Query range = subSF.getType().getRangeQuery(parser, subSF, String.valueOf(ll[i]), String.valueOf(ur[i]), true, true);
-        tmp.add(range, BooleanClause.Occur.MUST);
+        tmp.add(new BooleanClause(range, BooleanClause.Occur.MUST));
       }
-      return tmp;
+      return new BooleanQuery(tmp);
     }
   }
 
Index: solr/core/src/java/org/apache/solr/search/DisMaxQParser.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/DisMaxQParser.java	(revision 1668924)
+++ solr/core/src/java/org/apache/solr/search/DisMaxQParser.java	(working copy)
@@ -105,18 +105,18 @@
     /* the main query we will execute.  we disable the coord because
      * this query is an artificial construct
      */
-    BooleanQuery query = new BooleanQuery(true);
+    List<BooleanClause> clauses = new ArrayList<>();
 
-    boolean notBlank = addMainQuery(query, solrParams);
+    boolean notBlank = addMainQuery(clauses, solrParams);
     if (!notBlank)
       return null;
-    addBoostQuery(query, solrParams);
-    addBoostFunctions(query, solrParams);
+    addBoostQuery(clauses, solrParams);
+    addBoostFunctions(clauses, solrParams);
 
-    return query;
+    return new BooleanQuery(true, 0, clauses);
   }
 
-  protected void addBoostFunctions(BooleanQuery query, SolrParams solrParams) throws SyntaxError {
+  protected void addBoostFunctions(List<BooleanClause> clauses, SolrParams solrParams) throws SyntaxError {
     String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);
     if (null != boostFuncs && 0 != boostFuncs.length) {
       for (String boostFunc : boostFuncs) {
@@ -128,13 +128,13 @@
           if (null != b) {
             fq.setBoost(b);
           }
-          query.add(fq, BooleanClause.Occur.SHOULD);
+          clauses.add(new BooleanClause(fq, BooleanClause.Occur.SHOULD));
         }
       }
     }
   }
 
-  protected void addBoostQuery(BooleanQuery query, SolrParams solrParams) throws SyntaxError {
+  protected void addBoostQuery(List<BooleanClause> clauses, SolrParams solrParams) throws SyntaxError {
     boostParams = solrParams.getParams(DisMaxParams.BQ);
     //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);
     boostQueries = null;
@@ -154,15 +154,15 @@
           /* if the default boost was used, and we've got a BooleanQuery
            * extract the subqueries out and use them directly
            */
-          for (Object c : ((BooleanQuery) f).clauses()) {
-            query.add((BooleanClause) c);
+          for (BooleanClause c : ((BooleanQuery) f).clauses()) {
+            clauses.add(c);
           }
         } else {
-          query.add(f, BooleanClause.Occur.SHOULD);
+          clauses.add(new BooleanClause(f, BooleanClause.Occur.SHOULD));
         }
       } else {
         for (Query f : boostQueries) {
-          query.add(f, BooleanClause.Occur.SHOULD);
+          clauses.add(new BooleanClause(f, BooleanClause.Occur.SHOULD));
         }
       }
     }
@@ -169,7 +169,7 @@
   }
 
   /** Adds the main query to the query argument. If it's blank then false is returned. */
-  protected boolean addMainQuery(BooleanQuery query, SolrParams solrParams) throws SyntaxError {
+  protected boolean addMainQuery(List<BooleanClause> clauses, SolrParams solrParams) throws SyntaxError {
     Map<String, Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));
     float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);
 
@@ -190,7 +190,7 @@
       altUserQuery = getAlternateUserQuery(solrParams);
       if (altUserQuery == null)
         return false;
-      query.add(altUserQuery, BooleanClause.Occur.MUST);
+      clauses.add(new BooleanClause(altUserQuery, BooleanClause.Occur.MUST));
     } else {
       // There is a valid query string
       userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();
@@ -197,11 +197,11 @@
       userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();
 
       parsedUserQuery = getUserQuery(userQuery, up, solrParams);
-      query.add(parsedUserQuery, BooleanClause.Occur.MUST);
+      clauses.add(new BooleanClause(parsedUserQuery, BooleanClause.Occur.MUST));
 
       Query phrase = getPhraseQuery(userQuery, pp);
       if (null != phrase) {
-        query.add(phrase, BooleanClause.Occur.SHOULD);
+        clauses.add(new BooleanClause(phrase, BooleanClause.Occur.SHOULD));
       }
     }
     return true;
