diff --git a/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java b/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java
index e3ba489..3e48c39 100644
--- a/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java
+++ b/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java
@@ -37,7 +37,7 @@ public class SloppyMath {
    * specified in decimal degrees (latitude/longitude).  This works correctly
    * even if the dateline is between the two points.
    * <p>
-   * Error is around 1E-5 (0.01mm) from the actual haversine distance.
+   * Error is around 1E-4 (0.1mm) from the actual haversine distance.
    *
    * @param lat1 Latitude of the first point.
    * @param lon1 Longitude of the first point.
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestSloppyMath.java b/lucene/core/src/test/org/apache/lucene/util/TestSloppyMath.java
index 2ccf619..23b9be8 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestSloppyMath.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestSloppyMath.java
@@ -31,7 +31,7 @@ public class TestSloppyMath extends LuceneTestCase {
   // accuracy for asin()
   static double ASIN_DELTA = 1E-7;
   // accuracy for haversinMeters()
-  static double HAVERSIN_DELTA = 1E-5;
+  static double HAVERSIN_DELTA = 1E-4;
   
   public void testCos() {
     assertTrue(Double.isNaN(cos(Double.NaN)));
@@ -159,6 +159,19 @@ public class TestSloppyMath extends LuceneTestCase {
     }
   }
   
+  public void testAgainstSlowVersionSmall() {
+    for (int i = 0; i < 100_000; i++) {
+      double lat1 = -90 + 180.0 * random().nextDouble();
+      double lon1 = -180 + 360.0 * random().nextDouble();
+      double lat2 = Math.min(90,  lat1 + random().nextDouble());
+      double lon2 = Math.min(180, lon1 + random().nextDouble());
+
+      double expected = haversinMeters(lat1, lon1, lat2, lon2);
+      double actual = slowHaversin(lat1, lon1, lat2, lon2);
+      assertEquals(expected, actual, HAVERSIN_DELTA);
+    }
+  }
+  
   // simple incorporation of the wikipedia formula
   private static double slowHaversin(double lat1, double lon1, double lat2, double lon2) {
     double h1 = (1 - StrictMath.cos(StrictMath.toRadians(lat2) - StrictMath.toRadians(lat1))) / 2;
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
index 08c3615..a48142c 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
@@ -72,11 +72,16 @@ public final class GeoUtils {
     return Double.isNaN(lon) == false && lon >= MIN_LON_INCL && lon <= MAX_LON_INCL;
   }
 
+  // expand radius this additional amount internally, to ensure bounding box always
+  // covers it in case of error.
+  // TODO: this is gross at the moment, but easy to understand
+  private static final double BBOX_FUDGE = 7E-2;
+
   /** Compute Bounding Box for a circle using WGS-84 parameters */
   public static GeoRect circleToBBox(final double centerLat, final double centerLon, final double radiusMeters) {
     final double radLat = TO_RADIANS * centerLat;
     final double radLon = TO_RADIANS * centerLon;
-    double radDistance = radiusMeters / SEMIMAJOR_AXIS;
+    double radDistance = (radiusMeters + BBOX_FUDGE) / SEMIMAJOR_AXIS;
     double minLat = radLat - radDistance;
     double maxLat = radLat + radDistance;
     double minLon;
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
index 15fa29c..2cbca57 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
@@ -167,8 +167,20 @@ public class TestGeoUtils extends LuceneTestCase {
       double centerLon = randomLon(useSmallRanges);
 
       if (useSmallRanges) {
-        // Approx 4 degrees lon at the equator:
-        radiusMeters = random().nextDouble() * 444000;
+        switch (random().nextInt(3)) {
+          case 0:
+            // up to 1 meter
+            radiusMeters = random().nextDouble();
+            break;
+          case 1:
+            // up to 1 kilometer
+            radiusMeters = random().nextDouble() * 1000;
+            break;
+          default:
+            // Approx 4 degrees lon at the equator:
+            radiusMeters = random().nextDouble() * 444000;
+            break;
+        }
       } else {
         radiusMeters = random().nextDouble() * 50000000;
       }
