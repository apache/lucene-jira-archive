Index: lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java	(working copy)
@@ -0,0 +1,77 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestQueryRescorer extends LuceneTestCase {
+
+  public void testBasic() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+
+    Document doc = new Document();
+    doc.add(newStringField("id", "0", Field.Store.YES));
+    doc.add(newTextField("field", "wizard the the the the the oz", Field.Store.NO));
+    w.addDocument(doc);
+    doc = new Document();
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    // 1 extra token, but wizard and oz are close;
+    doc.add(newTextField("field", "wizard oz the the the the the the", Field.Store.NO));
+    w.addDocument(doc);
+    IndexReader r = w.getReader();
+    w.close();
+
+    // Do ordinary BooleanQuery:
+    BooleanQuery bq = new BooleanQuery();
+    bq.add(new TermQuery(new Term("field", "wizard")), Occur.SHOULD);
+    bq.add(new TermQuery(new Term("field", "oz")), Occur.SHOULD);
+    IndexSearcher searcher = newSearcher(r);
+
+    TopDocs hits = searcher.search(bq, 10);
+    assertEquals(2, hits.totalHits);
+    assertEquals("0", searcher.doc(hits.scoreDocs[0].doc).get("id"));
+    assertEquals("1", searcher.doc(hits.scoreDocs[1].doc).get("id"));
+
+    // Now, resort using PhraseQuery:
+    PhraseQuery pq = new PhraseQuery();
+    pq.setSlop(5);
+    pq.add(new Term("field", "wizard"));
+    pq.add(new Term("field", "oz"));
+
+    TopDocs hits2 = QueryRescorer.rescore(searcher, hits, pq, 2.0, 10);
+
+    // Resorting changed the order:
+    assertEquals(2, hits2.totalHits);
+    assertEquals("1", searcher.doc(hits2.scoreDocs[0].doc).get("id"));
+    assertEquals("0", searcher.doc(hits2.scoreDocs[1].doc).get("id"));
+
+    r.close();
+    dir.close();
+  }
+
+  // nocommit more, e.g. pull DocValues for scoring factors
+}

Property changes on: lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java	(revision 1576785)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java	(working copy)
@@ -29,8 +29,8 @@
   /** The number of subscorers that provide the current match. */
   protected int nrMatchers = -1;
 
-  protected double score = Float.NaN;
   private final float[] coord;
+  private final int[] matches;
   
   /** Construct a <code>DisjunctionScorer</code>.
    * @param weight The weight to be used.
@@ -43,6 +43,7 @@
     if (numScorers <= 1) {
       throw new IllegalArgumentException("There must be at least 2 subScorers");
     }
+    matches = new int[numScorers];
     this.coord = coord;
   }
 
@@ -69,23 +70,19 @@
     final Scorer sub = subScorers[0];
     doc = sub.docID();
     if (doc != NO_MORE_DOCS) {
-      score = sub.score();
+      matches[0] = 0;
       nrMatchers = 1;
-      countMatches(1);
-      countMatches(2);
+      gatherMatches(1);
+      gatherMatches(2);
     }
   }
   
-  // TODO: this currently scores, but so did the previous impl
   // TODO: remove recursion.
-  // TODO: if we separate scoring, out of here, 
-  // then change freq() to just always compute it from scratch
-  private void countMatches(int root) throws IOException {
+  private void gatherMatches(int root) throws IOException {
     if (root < numScorers && subScorers[root].docID() == doc) {
-      nrMatchers++;
-      score += subScorers[root].score();
-      countMatches((root<<1)+1);
-      countMatches((root<<1)+2);
+      matches[nrMatchers++] = root;
+      gatherMatches((root<<1)+1);
+      gatherMatches((root<<1)+2);
     }
   }
   
@@ -94,7 +91,15 @@
    */
   @Override
   public float score() throws IOException { 
-    return (float)score * coord[nrMatchers]; 
+    double score = 0.0;
+    for(int i=0;i<nrMatchers;i++) {
+      score += subScorers[matches[i]].score();
+    }
+    if (coord == null) {
+      return (float) score;
+    } else {
+      return (float) (score * coord[nrMatchers]);
+    } 
   }
    
   @Override
Index: lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java	(working copy)
@@ -0,0 +1,172 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.util.Bits;
+
+/** Re-scores the topN results from an original
+ *  query using a second query.  Typically, the first query
+ *  will be less costly and run on the entire index, and
+ *  return the top few  hundred results, then the second
+ *  more-costly query, such as {@link ProxBooleanTermQuery},
+ *  is used only to re-score those results. */
+
+public class QueryRescorer {
+
+  /** Filter accepting only the specified docIDs */
+  private static class OnlyDocIDsFilter extends Filter {
+
+    private final int[] docIDs;
+
+    /** NOTE: resorts the incoming docIDs */
+    public OnlyDocIDsFilter(int[] docIDs) {
+      this.docIDs = docIDs;
+      Arrays.sort(docIDs);
+    }
+
+    @Override
+    public DocIdSet getDocIdSet(final AtomicReaderContext context, final Bits acceptDocs) throws IOException {
+      int loc = Arrays.binarySearch(docIDs, context.docBase);
+      if (loc < 0) {
+        loc = -loc-1;
+      }
+
+      final int startLoc = loc;
+      final int endDoc = context.docBase + context.reader().maxDoc();
+
+      return new DocIdSet() {
+
+        int pos = startLoc;
+
+        @Override
+        public DocIdSetIterator iterator() throws IOException {
+          return new DocIdSetIterator() {
+
+            int docID;
+
+            @Override
+            public int docID() {
+              return docID;
+            }
+
+            @Override
+            public int nextDoc() {
+              if (pos == docIDs.length) {
+                return NO_MORE_DOCS;
+              }
+              int docID = docIDs[pos];
+              if (docID >= endDoc) {
+                return NO_MORE_DOCS;
+              }
+              pos++;
+              assert acceptDocs == null || acceptDocs.get(docID-context.docBase);
+              return docID-context.docBase;
+            }
+
+            @Override
+            public long cost() {
+              // nocommit?
+              return 0;
+            }
+
+            @Override
+            public int advance(int target) {
+              int loc = Arrays.binarySearch(docIDs, target + context.docBase);
+              if (loc < 0) {
+                loc = -loc-1;
+              }
+              pos = loc;
+              return nextDoc();
+            }
+          };
+        }
+      };
+    }
+  }
+
+  /** @params
+   * searcher {@link IndexSearcher} used to produce the
+   *   first pass topDocs
+   * topDocs Hits from the first pass search
+   * query Query to use for rescoring
+   * scoreWeight The score of the returned hits is
+   *   firstPassScore + weight * queryScore
+   * topN How many re-scored hits to return
+   */ 
+  public static TopDocs rescore(IndexSearcher searcher, TopDocs topDocs, Query query, double weight, int topN) throws IOException {
+    int[] docIDs = new int[topDocs.scoreDocs.length];
+    for(int i=0;i<docIDs.length;i++) {
+      docIDs[i] = topDocs.scoreDocs[i].doc;
+    }
+
+    TopDocs topDocs2 = searcher.search(query, new OnlyDocIDsFilter(docIDs), topDocs.scoreDocs.length);
+    
+    Map<Integer,Float> newScores = new HashMap<Integer,Float>();
+    for(ScoreDoc sd : topDocs2.scoreDocs) {
+      newScores.put(sd.doc, sd.score);
+    }
+
+    ScoreDoc[] newHits = new ScoreDoc[topDocs.scoreDocs.length];
+    for(int i=0;i<topDocs.scoreDocs.length;i++) {
+      int docID = topDocs.scoreDocs[i].doc;
+      float oldScore = topDocs.scoreDocs[i].score;
+      Float newScore = newScores.get(docID);
+      // nocommit allow null and this just means newScore is 0?
+      assert newScore != null;
+
+      // nocommit maybe allow subclass method to combine old
+      // + new scores?
+      newHits[i] = new ScoreDoc(docID, (float) (oldScore + weight * newScore));
+    }
+
+    // TODO: we should do a partial sort (of only topN)
+    // instead, but typically the number of hits is
+    // smallish:
+    Arrays.sort(newHits,
+                new Comparator<ScoreDoc>() {
+                  @Override
+                  public int compare(ScoreDoc a, ScoreDoc b) {
+                    // Sort by score descending, then docID ascending:
+                    if (a.score > b.score) {
+                      return -1;
+                    } else if (a.score < b.score) {
+                      return 1;
+                    } else {
+                      // This subtraction can't overflow int
+                      // because docIDs are >= 0:
+                      return a.doc - b.doc;
+                    }
+                  }
+                });
+
+    if (topN < newHits.length) {
+      ScoreDoc[] subset = new ScoreDoc[topN];
+      System.arraycopy(newHits, 0, subset, 0, topN);
+      newHits = subset;
+    }
+
+    return new TopDocs(topDocs.totalHits, newHits, newHits[0].score);
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(revision 1576785)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(working copy)
@@ -27,13 +27,10 @@
 class DisjunctionMaxScorer extends DisjunctionScorer {
   /* Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result. */
   private final float tieBreakerMultiplier;
+  private final int[] matches;
   private int doc = -1;
   private int freq = -1;
 
-  /* Used when scoring currently matching doc. */
-  private float scoreSum;
-  private float scoreMax;
-
   /**
    * Creates a new instance of DisjunctionMaxScorer
    * 
@@ -52,6 +49,7 @@
       Scorer[] subScorers, int numScorers) {
     super(weight, subScorers, numScorers);
     this.tieBreakerMultiplier = tieBreakerMultiplier;
+    matches = new int[subScorers.length];
   }
 
   @Override
@@ -83,28 +81,32 @@
    */
   @Override
   public float score() throws IOException {
+    float scoreSum = subScorers[matches[0]].score();
+    float scoreMax = scoreSum;
+    for(int i=1;i<freq;i++) {
+      float sub = subScorers[matches[i]].score();
+      scoreSum += sub;
+      scoreMax = Math.max(scoreMax, sub);
+    }
     return scoreMax + (scoreSum - scoreMax) * tieBreakerMultiplier;
   }
   
   private void afterNext() throws IOException {
     doc = subScorers[0].docID();
     if (doc != NO_MORE_DOCS) {
-      scoreSum = scoreMax = subScorers[0].score();
+      matches[0] = 0;
       freq = 1;
-      scoreAll(1);
-      scoreAll(2);
+      gatherMatches(1);
+      gatherMatches(2);
     }
   }
 
   // Recursively iterate all subScorers that generated last doc computing sum and max
-  private void scoreAll(int root) throws IOException {
+  private void gatherMatches(int root) throws IOException {
     if (root < numScorers && subScorers[root].docID() == doc) {
-      float sub = subScorers[root].score();
-      freq++;
-      scoreSum += sub;
-      scoreMax = Math.max(scoreMax, sub);
-      scoreAll((root<<1)+1);
-      scoreAll((root<<1)+2);
+      matches[freq++] = root;
+      gatherMatches((root<<1)+1);
+      gatherMatches((root<<1)+2);
     }
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/BooleanScorer2.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanScorer2.java	(revision 1576785)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanScorer2.java	(working copy)
@@ -171,7 +171,7 @@
         @Override 
         public float score() throws IOException {
           coordinator.nrMatchers += super.nrMatchers;
-          return (float) super.score;
+          return super.score();
         }
       };
     }
Index: lucene/misc/src/test/org/apache/lucene/search/TestSwitchingSimilarityCollector.java
===================================================================
--- lucene/misc/src/test/org/apache/lucene/search/TestSwitchingSimilarityCollector.java	(revision 0)
+++ lucene/misc/src/test/org/apache/lucene/search/TestSwitchingSimilarityCollector.java	(working copy)
@@ -0,0 +1,114 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.similarities.BM25Similarity;
+import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.LMJelinekMercerSimilarity;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestSwitchingSimilarityCollector extends LuceneTestCase {
+
+  public void testBasic() throws Exception {
+    Directory dir = newDirectory();
+
+    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT,
+                                                 new MockAnalyzer(random()));
+    iwc.setSimilarity(new SwitchingSimilarity(new DefaultSimilarity(),
+                                              new BM25Similarity()));
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);
+
+    Document doc = new Document();
+    doc.add(newTextField("field", "a x", Field.Store.NO));
+    w.addDocument(doc);
+
+    doc.add(newTextField("field", "a y", Field.Store.NO));
+    w.addDocument(doc);
+
+    doc.add(newTextField("field", "b x", Field.Store.NO));
+    w.addDocument(doc);
+    
+    IndexReader r = w.getReader();
+    w.close();
+
+    // TermQuery
+    runQuery(r, new TermQuery(new Term("field", "a")));
+
+    // BooleanQuery
+    BooleanQuery bq = new BooleanQuery();
+    bq.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
+    bq.add(new TermQuery(new Term("field", "y")), BooleanClause.Occur.SHOULD);
+    runQuery(r, bq);
+
+    r.close();
+    dir.close();
+  }
+
+  private void runQuery(IndexReader r, Query q) throws Exception {
+    if (VERBOSE) {
+      System.out.println("\nTEST: run query=" + q);
+    }
+
+    TopScoreDocCollector c1 = TopScoreDocCollector.create(10, true);
+    TopScoreDocCollector c2 = TopScoreDocCollector.create(10, true);
+    TopScoreDocCollector c3 = TopScoreDocCollector.create(10, true);
+    SwitchingSimilarity sim = new SwitchingSimilarity(new DefaultSimilarity(),
+                                                      new BM25Similarity(),
+                                                      new LMJelinekMercerSimilarity(0.3f));
+
+    // NOTE: we must make a new searcher for every query,
+    // because SwitchingSimilarity has per-hit state.  This
+    // is fine (it's cheap: basically just wraps the
+    // reader):
+    IndexSearcher s = newSearcher(r);
+    s.setSimilarity(sim);
+    s.search(q,
+             new SwitchingSimilarityCollector(sim, c1, c2, c3));
+
+    TopDocs hits1 = c1.topDocs();
+    TopDocs hits2 = c2.topDocs();
+    TopDocs hits3 = c3.topDocs();
+
+    assertEquals(hits1.totalHits, hits2.totalHits);
+    assertEquals(hits1.totalHits, hits3.totalHits);
+    assertEquals(hits1.scoreDocs.length, hits2.scoreDocs.length);
+    assertEquals(hits1.scoreDocs.length, hits3.scoreDocs.length);
+    boolean sawDifference = false;
+    for(int i=0;i<hits1.scoreDocs.length;i++) {
+      ScoreDoc hit1 = hits1.scoreDocs[i];
+      ScoreDoc hit2 = hits2.scoreDocs[i];
+      ScoreDoc hit3 = hits3.scoreDocs[i];
+      System.out.println("  hit " + i);
+      System.out.println("    one: doc=" + hit1.doc + " score=" + hit1.score);
+      System.out.println("    two: doc=" + hit2.doc + " score=" + hit2.score);
+      System.out.println("    three: doc=" + hit3.doc + " score=" + hit3.score);
+      if (hit1.score != hit2.score || hit1.score != hit3.score) {
+        sawDifference = true;
+      }
+    }
+    assertTrue(sawDifference);
+  }
+}

Property changes on: lucene/misc/src/test/org/apache/lucene/search/TestSwitchingSimilarityCollector.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/misc/src/java/org/apache/lucene/search/SwitchingSimilarity.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/search/SwitchingSimilarity.java	(revision 0)
+++ lucene/misc/src/java/org/apache/lucene/search/SwitchingSimilarity.java	(working copy)
@@ -0,0 +1,159 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.FieldInvertState;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.util.BytesRef;
+
+/** When used along with {@link SwitchingSimilarityCollector}, a
+ *  single query can be used to collect hits with multiple
+ *  similarities.  Note that only sims[0] is used to compute
+ *  the norm, so all sims must "agree" on how the norm is
+ *  computed.  Note that to use this, you must
+ *  make a new IndexSearcher per-request, because this class
+ *  has state per query/hit.
+ *
+ * @lucene.experimental */
+public final class SwitchingSimilarity extends Similarity {
+
+  /** the sub-similarities */
+  private final Similarity sims[];
+  
+  /** Which scorer we are currently scoring. */
+  int scorerIndex;
+
+  /** Creates a MultiSimilarity which will sum the scores
+   * of the provided <code>sims</code>. */
+  public SwitchingSimilarity(Similarity... sims) {
+    this.sims = sims;
+  }
+  
+  @Override
+  public long computeNorm(FieldInvertState state) {
+    return sims[0].computeNorm(state);
+  }
+
+  @Override
+  public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {
+    SimWeight subStats[] = new SimWeight[sims.length];
+    for (int i = 0; i < subStats.length; i++) {
+      subStats[i] = sims[i].computeWeight(queryBoost, collectionStats, termStats);
+    }
+    return new SwitchingStats(subStats);
+  }
+
+  @Override
+  public ExactSimScorer exactSimScorer(SimWeight stats, AtomicReaderContext context) throws IOException {
+    ExactSimScorer subScorers[] = new ExactSimScorer[sims.length];
+    for (int i = 0; i < subScorers.length; i++) {
+      subScorers[i] = sims[i].exactSimScorer(((SwitchingStats)stats).subStats[i], context);
+    }
+    return new SwitchingExactSimScorer(subScorers);
+  }
+
+  @Override
+  public SloppySimScorer sloppySimScorer(SimWeight stats, AtomicReaderContext context) throws IOException {
+    SloppySimScorer subScorers[] = new SloppySimScorer[sims.length];
+    for (int i = 0; i < subScorers.length; i++) {
+      subScorers[i] = sims[i].sloppySimScorer(((SwitchingStats)stats).subStats[i], context);
+    }
+    return new SwitchingSloppySimScorer(subScorers);
+  }
+  
+  /** Moves to the next sub-scorer. */
+  public void switchScorer() {
+    scorerIndex++;
+    if (scorerIndex == sims.length) {
+      scorerIndex = 0;
+    }
+  }
+    
+  public class SwitchingExactSimScorer extends ExactSimScorer {
+    private final ExactSimScorer subScorers[];
+    
+    SwitchingExactSimScorer(ExactSimScorer subScorers[]) {
+      this.subScorers = subScorers;
+    }
+
+    @Override
+    public float score(int doc, int freq) {
+      return subScorers[scorerIndex].score(doc, freq);
+    }
+
+    @Override
+    public Explanation explain(int doc, Explanation freq) {
+      return subScorers[scorerIndex].explain(doc, freq);
+    }
+  }
+
+  public class SwitchingSloppySimScorer extends SloppySimScorer {
+    private final SloppySimScorer subScorers[];
+    
+    SwitchingSloppySimScorer(SloppySimScorer subScorers[]) {
+      this.subScorers = subScorers;
+    }
+
+    @Override
+    public float score(int doc, float freq) {
+      return subScorers[scorerIndex].score(doc, freq);
+    }
+
+    @Override
+    public Explanation explain(int doc, Explanation freq) {
+      return subScorers[scorerIndex].explain(doc, freq);
+    }
+
+    @Override
+    public float computeSlopFactor(int distance) {
+      return subScorers[0].computeSlopFactor(distance);
+    }
+
+    @Override
+    public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {
+      return subScorers[0].computePayloadFactor(doc, start, end, payload);
+    }
+  }
+
+  static class SwitchingStats extends SimWeight {
+    final SimWeight subStats[];
+    
+    SwitchingStats(SimWeight subStats[]) {
+      this.subStats = subStats;
+    }
+    
+    @Override
+    public float getValueForNormalization() {
+      float sum = 0.0f;
+      for (SimWeight stat : subStats) {
+        sum += stat.getValueForNormalization();
+      }
+      return sum / subStats.length;
+    }
+
+    @Override
+    public void normalize(float queryNorm, float topLevelBoost) {
+      for (SimWeight stat : subStats) {
+        stat.normalize(queryNorm, topLevelBoost);
+      }
+    }
+  }
+}

Property changes on: lucene/misc/src/java/org/apache/lucene/search/SwitchingSimilarity.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/misc/src/java/org/apache/lucene/search/SwitchingSimilarityCollector.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/search/SwitchingSimilarityCollector.java	(revision 0)
+++ lucene/misc/src/java/org/apache/lucene/search/SwitchingSimilarityCollector.java	(working copy)
@@ -0,0 +1,77 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.AtomicReaderContext;
+
+/** When used with {@link SwitchingSimilarity}, lets you collect
+ *  hits for a single query using multiple similarities into
+ *  separate collectors.  Be sure the number of collectors
+ *  you pass here matches exactly the number of
+ *  similarities you pass to {@link SwitchingSimilarity}.
+ *
+ * <p>There can easily be cases where this does not work,
+ * e.g. if the {@link ScoreCachingWrapperScorer} is involved
+ * in the scoring chain.
+ *
+ * @lucene.experimental */
+
+public final class SwitchingSimilarityCollector extends Collector {
+  private final Collector[] subs;
+  private final SwitchingSimilarity switchingSim;
+  private Scorer scorer;
+
+  public SwitchingSimilarityCollector(SwitchingSimilarity switchingSim, Collector... subs) {
+    this.subs = subs;
+    this.switchingSim = switchingSim;
+  }
+
+  @Override
+  public void setScorer(Scorer scorer) throws IOException {
+    this.scorer = scorer;
+    for(Collector sub : subs) {
+      sub.setScorer(scorer);
+    }
+  }
+
+  @Override
+  public void collect(int docID) throws IOException {
+    System.out.println("collect doc=" + docID + " scorer=" + scorer);
+    for(Collector sub : subs) {
+      switchingSim.switchScorer();
+      System.out.println("  score=" + scorer.score());
+      sub.collect(docID);
+    }
+  }
+
+  @Override
+  public void setNextReader(AtomicReaderContext context) throws IOException {
+    for(Collector sub : subs) {
+      sub.setNextReader(context);
+    }
+  }
+
+  @Override
+  public boolean acceptsDocsOutOfOrder() {
+    // We must return false here, because we need the
+    // .score() to not be cached for each hit:
+    return false;
+  }
+}

Property changes on: lucene/misc/src/java/org/apache/lucene/search/SwitchingSimilarityCollector.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
