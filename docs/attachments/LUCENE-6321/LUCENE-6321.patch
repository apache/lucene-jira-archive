Index: lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java	(working copy)
@@ -246,7 +246,10 @@
   @Override @SuppressWarnings("unchecked")
   public BooleanQuery clone() {
     BooleanQuery clone = (BooleanQuery)super.clone();
-    clone.clauses = new ArrayList<>(clauses);
+    clone.clauses = new ArrayList<>(clauses.size());
+    for (BooleanClause clause : clauses()) {
+      clone.add(clause.getQuery().clone(), clause.getOccur());
+    }
     return clone;
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java	(working copy)
@@ -34,7 +34,7 @@
  * It therefore simply strips of all scores and returns a constant one.
  */
 public class ConstantScoreQuery extends Query {
-  protected final Query query;
+  protected Query query;
 
   /** Strips off scores from the passed in Query. The hits will get a constant score
    * dependent on the boost factor of this query. */
@@ -285,4 +285,12 @@
     return 31 * super.hashCode() + query.hashCode();
   }
 
+  @Override
+  public Query clone() {
+    ConstantScoreQuery clone = (ConstantScoreQuery) super.clone();
+    if (query instanceof Filter == false) {
+      clone.query = query.clone();
+    }
+    return clone;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(working copy)
@@ -233,7 +233,10 @@
   @Override @SuppressWarnings("unchecked")
   public DisjunctionMaxQuery clone() {
     DisjunctionMaxQuery clone = (DisjunctionMaxQuery)super.clone();
-    clone.disjuncts = (ArrayList<Query>) this.disjuncts.clone();
+    clone.disjuncts = new ArrayList<>(disjuncts.size());
+    for (Query q : disjuncts) {
+      clone.add(q.clone());
+    }
     return clone;
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java	(working copy)
@@ -91,6 +91,9 @@
   public DocValuesTermsQuery(String field, Collection<BytesRef> terms) {
     this.field = Objects.requireNonNull(field);
     this.terms = terms.toArray(new BytesRef[terms.size()]);
+    for (int i = 0; i < this.terms.length; ++i) {
+      this.terms[i] = BytesRef.deepCopyOf(this.terms[i]);
+    }
     ArrayUtil.timSort(this.terms, BytesRef.getUTF8SortedAsUnicodeComparator());
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(working copy)
@@ -40,7 +40,7 @@
  * @since   1.4
  * @see     CachingWrapperQuery
  */
-public class FilteredQuery extends Query {
+public final class FilteredQuery extends Query {
 
   private final Query query;
   private final Filter filter;
@@ -638,5 +638,11 @@
       return scorer == null ? null : new QueryFirstBulkScorer(scorer, filterAcceptDocs);
     }
   }
-  
+
+  @Override
+  public Query clone() {
+    FilteredQuery clone = new FilteredQuery(query.clone(), filter, strategy);
+    clone.setBoost(getBoost());
+    return clone;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.ConcurrentModificationException;
 import java.util.IdentityHashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -269,10 +270,20 @@
   synchronized void evictIfNecessary() {
     // under a lock to make sure that mostRecentlyUsedQueries and cache keep sync'ed
     if (requiresEviction()) {
+      
       Iterator<Query> iterator = mostRecentlyUsedQueries.iterator();
       do {
         final Query query = iterator.next();
+        final int size = mostRecentlyUsedQueries.size();
         iterator.remove();
+        if (size == mostRecentlyUsedQueries.size()) {
+          // size did not decrease, because the hash of the query changed since it has been
+          // put into the cache
+          throw new ConcurrentModificationException("Removal from the cache failed! This " +
+              "is probably due to a query which has been modified after having been put into " +
+              " the cache or a badly implemented clone(). Query class: [" + query.getClass() +
+              "], query: [" + query + "]");
+        }
         onEviction(query);
       } while (iterator.hasNext() && requiresEviction());
     }
Index: lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -400,6 +400,14 @@
     }
     return true;
   }
+
+  @Override
+  public Query clone() {
+    MultiPhraseQuery clone = (MultiPhraseQuery) super.clone();
+    clone.positions = new ArrayList<>(positions);
+    clone.termArrays = new ArrayList<>(termArrays);
+    return clone;
+  }
 }
 
 /**
Index: lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java	(working copy)
@@ -84,6 +84,13 @@
   public final String getField() { return query.getField(); }
 
   @Override
+  public Query clone() {
+    MultiTermQueryConstantScoreWrapper<Q> clone = new MultiTermQueryConstantScoreWrapper<Q>((Q) query.clone());
+    clone.setBoost(getBoost());
+    return clone;
+  }
+
+  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     return new ConstantScoreWeight(this) {
       @Override
Index: lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java	(working copy)
@@ -36,6 +36,7 @@
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 /** A Query that matches documents containing a particular sequence of terms.
@@ -126,7 +127,7 @@
       throw new IllegalArgumentException("All phrase terms must be in the same field: " + term);
     }
 
-    terms.add(term);
+    terms.add(new Term(term.field(), BytesRef.deepCopyOf(term.bytes())));
     positions.add(Integer.valueOf(position));
   }
 
@@ -443,4 +444,11 @@
       ^ positions.hashCode();
   }
 
+  @Override
+  public Query clone() {
+    PhraseQuery clone = (PhraseQuery) super.clone();
+    clone.positions = new ArrayList<>(positions);
+    clone.terms = new ArrayList<>(terms);
+    return clone;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/TermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TermQuery.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/TermQuery.java	(working copy)
@@ -32,6 +32,7 @@
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 /**
@@ -146,7 +147,7 @@
    * of looking up the docFreq against the searcher.
    */
   public TermQuery(Term t, int docFreq) {
-    term = t;
+    term = new Term(t.field(), BytesRef.deepCopyOf(t.bytes()));
     this.docFreq = docFreq;
     perReaderTermState = null;
   }
@@ -157,7 +158,7 @@
    */
   public TermQuery(Term t, TermContext states) {
     assert states != null;
-    term = t;
+    term = new Term(t.field(), BytesRef.deepCopyOf(t.bytes()));
     docFreq = states.docFreq();
     perReaderTermState = states;
   }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(revision 1664053)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 /** Matches spans containing a term. */
@@ -36,7 +37,9 @@
   protected Term term;
 
   /** Construct a SpanTermQuery matching the named term's spans. */
-  public SpanTermQuery(Term term) { this.term = term; }
+  public SpanTermQuery(Term term) {
+    this.term = new Term(term.field(), BytesRef.deepCopyOf(term.bytes()));
+  }
 
   /** Return the term whose spans are matched. */
   public Term getTerm() { return term; }
Index: lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java	(revision 1664053)
+++ lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java	(working copy)
@@ -22,6 +22,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.ConcurrentModificationException;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
@@ -45,6 +46,7 @@
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.RamUsageTester;
 import org.apache.lucene.util.TestUtil;
@@ -913,4 +915,56 @@
     queryCache.assertConsistent();
   }
 
+  private static class BadQuery extends Query {
+
+    int[] i = new int[] {42}; // an array so that clone keeps the reference
+    
+    @Override
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      return new ConstantScoreWeight(this) {
+        
+        @Override
+        Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {
+          return null;
+        }
+      };
+    }
+    
+    @Override
+    public String toString(String field) {
+      return "BadQuery";
+    }
+    
+    @Override
+    public int hashCode() {
+      return super.hashCode() ^ i[0];
+    }
+    
+  }
+
+  public void testDetectMutatedQueries() throws IOException {
+    Directory dir = newDirectory();
+    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    w.addDocument(new Document());
+    IndexReader reader = w.getReader();
+
+    // size of 1 so that 2nd query evicts from the cache
+    final LRUQueryCache queryCache = new LRUQueryCache(1, 10000);
+    final IndexSearcher searcher = newSearcher(reader);
+    searcher.setQueryCache(queryCache);
+    searcher.setQueryCachingPolicy(QueryCachingPolicy.ALWAYS_CACHE);
+    
+    BadQuery query = new BadQuery();
+    searcher.count(query);
+    query.i[0] += 1; // change the hashCode!
+    try {
+      // trigger an eviction
+      searcher.count(new MatchAllDocsQuery());
+      fail();
+    } catch (ConcurrentModificationException e) {
+      // expected
+    }
+    
+    IOUtils.close(w, reader, dir);
+  }
 }
Index: lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java	(revision 1664053)
+++ lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java	(working copy)
@@ -43,7 +43,7 @@
  * @lucene.experimental
  */
 
-public class ToChildBlockJoinQuery extends Query {
+public final class ToChildBlockJoinQuery extends Query {
 
   /** Message thrown from {@link
    *  ToChildBlockJoinScorer#validateParentDoc} on mis-use,
@@ -342,6 +342,7 @@
     if (_other instanceof ToChildBlockJoinQuery) {
       final ToChildBlockJoinQuery other = (ToChildBlockJoinQuery) _other;
       return origParentQuery.equals(other.origParentQuery) &&
+        parentQuery.equals(other.parentQuery) &&
         parentsFilter.equals(other.parentsFilter) &&
         super.equals(other);
     } else {
@@ -360,7 +361,10 @@
 
   @Override
   public ToChildBlockJoinQuery clone() {
-    return new ToChildBlockJoinQuery(origParentQuery.clone(),
+    ToChildBlockJoinQuery clone = new ToChildBlockJoinQuery(origParentQuery.clone(),
+                                     parentQuery.clone(),
                                      parentsFilter);
+    clone.setBoost(getBoost());
+    return clone;
   }
 }
Index: lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java	(revision 1664053)
+++ lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java	(working copy)
@@ -474,4 +474,11 @@
     hash = prime * hash + parentsFilter.hashCode();
     return hash;
   }
+
+  @Override
+  public Query clone() {
+    ToParentBlockJoinQuery clone = new ToParentBlockJoinQuery(origChildQuery.clone(), childQuery.clone(), parentsFilter, scoreMode);
+    clone.setBoost(getBoost());
+    return clone;
+  }
 }
Index: lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
===================================================================
--- lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java	(revision 1664053)
+++ lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java	(working copy)
@@ -423,6 +423,11 @@
     dir.close();
   }
 
+  public void testQueries() {
+    QueryUtils.check(new ToParentBlockJoinQuery(new MatchAllDocsQuery(), new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new MatchAllDocsQuery())), ScoreMode.Avg));
+    QueryUtils.check(new ToChildBlockJoinQuery(new MatchAllDocsQuery(), new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new MatchAllDocsQuery()))));
+  }
+
   public void testNestedDocScoringWithDeletes() throws Exception {
     final Directory dir = newDirectory();
     final RandomIndexWriter w = new RandomIndexWriter(
Index: lucene/queries/src/java/org/apache/lucene/queries/BoostingQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/BoostingQuery.java	(revision 1664053)
+++ lucene/queries/src/java/org/apache/lucene/queries/BoostingQuery.java	(working copy)
@@ -40,8 +40,8 @@
  */
 public class BoostingQuery extends Query {
     private final float boost;                            // the amount to boost by
-    private final Query match;                            // query to match
-    private final Query context;                          // boost when matches too
+    private Query match;                            // query to match
+    private Query context;                          // boost when matches too
 
     public BoostingQuery(Query match, Query context, float boost) {
       this.match = match;
@@ -135,4 +135,12 @@
     public String toString(String field) {
       return match.toString(field) + "/" + context.toString(field);
     }
-  }
+
+    @Override
+    public Query clone() {
+      BoostingQuery clone = (BoostingQuery) super.clone();
+      clone.match = match.clone();
+      clone.context = context.clone();
+      return clone;
+    }
+}
Index: lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery.java	(revision 1664053)
+++ lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 import java.io.IOException;
@@ -67,7 +68,7 @@
    * rewrite to dismax rather than boolean. Yet, this can already be subclassed
    * to do so.
    */
-  protected final List<Term> terms = new ArrayList<>();
+  protected List<Term> terms = new ArrayList<>();
   protected final boolean disableCoord;
   protected final float maxTermFrequency;
   protected final Occur lowFreqOccur;
@@ -141,7 +142,7 @@
     if (term == null) {
       throw new IllegalArgumentException("Term must not be null");
     }
-    this.terms.add(term);
+    this.terms.add(new Term(term.field(), BytesRef.deepCopyOf(term.bytes())));
   }
   
   @Override
@@ -418,4 +419,11 @@
   protected Query newTermQuery(Term term, TermContext context) {
     return context == null ? new TermQuery(term) : new TermQuery(term, context);
   }
+
+  @Override
+  public Query clone() {
+    CommonTermsQuery clone = (CommonTermsQuery) super.clone();
+    clone.terms = new ArrayList<>(terms);
+    return clone;
+  }
 }
Index: lucene/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java	(revision 1664053)
+++ lucene/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java	(working copy)
@@ -196,4 +196,10 @@
     return h;
   }
 
+  @Override
+  public Query clone() {
+    BoostedQuery clone = (BoostedQuery) super.clone();
+    clone.q = q.clone();
+    return clone;
+  }
 }
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java	(revision 1664053)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java	(working copy)
@@ -21,7 +21,7 @@
 import org.apache.lucene.search.Query;
 
 abstract class RewriteQuery<SQ extends SrndQuery> extends Query {
-  protected final SQ srndQuery;
+  protected SQ srndQuery;
   protected final String fieldName;
   protected final BasicQueryFactory qf;
 
@@ -72,7 +72,9 @@
    * @throws UnsupportedOperationException always: clone is not supported. */
   @Override
   public RewriteQuery clone() {
-    throw new UnsupportedOperationException();
+    RewriteQuery clone = (RewriteQuery) super.clone();
+    clone.srndQuery = srndQuery.clone();
+    return clone;
   }
 }
 
Index: lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(revision 1664053)
+++ lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(working copy)
@@ -439,6 +439,12 @@
       final BulkScorer bulkScorer = weight.bulkScorer(context, context.reader().getLiveDocs());
       if (scorer == null && bulkScorer == null) {
         continue;
+      } else if (scorer == null) {
+        Assert.assertEquals(DocIdSetIterator.NO_MORE_DOCS, bulkScorer.score(new TotalHitCountCollector().getLeafCollector(context), 0, 0));
+        continue;
+      } else if (bulkScorer == null) {
+        Assert.assertEquals(DocIdSetIterator.NO_MORE_DOCS, scorer.nextDoc());
+        continue;
       }
       int upTo = 0;
       while (true) {
Index: lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java	(revision 1664053)
+++ lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java	(working copy)
@@ -43,6 +43,8 @@
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
+import com.carrotsearch.ant.tasks.junit4.dependencies.com.google.common.base.Objects;
+
 /**
  * Simple base class for checking search equivalence.
  * Extend it, and write tests that create {@link #randomTerm()}s
@@ -184,6 +186,27 @@
     }
 
     @Override
+    public Query clone() {
+      SlowWrapperFilter clone = new SlowWrapperFilter(query.clone(), useBits);
+      clone.setBoost(getBoost());
+      return clone;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof SlowWrapperFilter == false) {
+        return false;
+      }
+      SlowWrapperFilter that = (SlowWrapperFilter) obj;
+      return query.equals(that.query) && useBits == that.useBits;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hashCode(query, useBits, getBoost());
+    }
+
+    @Override
     public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
       // get a private context that is used to rewrite, createWeight and score eventually
       final LeafReaderContext privateContext = context.reader().getContext();
Index: lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(revision 1664053)
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -96,6 +96,7 @@
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.LRUQueryCache;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryCache;
 import org.apache.lucene.search.QueryCachingPolicy;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.QueryUtils.FCInvisibleMultiReader;
@@ -1660,7 +1661,15 @@
   public static void resetDefaultQueryCache() {
     // we need to reset the query cache in an @BeforeClass so that tests that
     // instantiate an IndexSearcher in an @BeforeClass method use a fresh new cache
-    IndexSearcher.setDefaultQueryCache(new LRUQueryCache(10000, 1 << 25));
+    final QueryCache queryCache;
+    if (rarely()) {
+      queryCache = null;
+    } else {
+      final int maxSize = TestUtil.nextInt(random(), 1, 100);
+      final long maxRamBytesUsed = TestUtil.nextLong(random(), 1, 100000);
+      queryCache = new LRUQueryCache(maxSize, maxRamBytesUsed);
+    }
+    IndexSearcher.setDefaultQueryCache(queryCache);
     IndexSearcher.setDefaultQueryCachingPolicy(MAYBE_CACHE_POLICY);
   }
 
