Index: lucene/queryparser/src/test/org/apache/lucene/queryparser/spans/TestSpanQPBasedOnQPTestBase.java
===================================================================
--- lucene/queryparser/src/test/org/apache/lucene/queryparser/spans/TestSpanQPBasedOnQPTestBase.java	(revision 1570510)
+++ lucene/queryparser/src/test/org/apache/lucene/queryparser/spans/TestSpanQPBasedOnQPTestBase.java	(working copy)
@@ -107,6 +107,24 @@
     return exception instanceof ParseException;
   }
 
+  @Override
+  protected String escapeDateString(String s) {
+    if (s.indexOf(" ") > -1 || s.indexOf("/") > -1 || s.indexOf("-") > -1) {
+      return "\'" + s + "\'";
+    } else {
+      return s;
+    }
+  }
+
+  @Override
+  public void assertQueryEquals(CommonQueryParserConfiguration cqpC, String field, String query, String result) throws Exception {
+    Query q = getQuery(query, cqpC);
+    if (q instanceof SpanMultiTermQueryWrapper){
+      q = ((SpanMultiTermQueryWrapper)q).getWrappedQuery();
+    }
+    assertEquals(result, q.toString(field));
+  }
+
   public void assertBoostEquals(String query, float b) throws Exception {
     Query q = getQuery(query);
     assertEquals(b, q.getBoost(), 0.00001);
@@ -532,8 +550,6 @@
     assertQueryEquals("[\"*\" TO *]",null,"SpanMultiTermQueryWrapper([\\* TO *])");
   }
 
-  // nocommit: what is happening here (fails under some locales)
-  @Ignore
   public void testDateRange() throws Exception {
     String startDate = getLocalizedDate(2002, 1, 1);
     String endDate = getLocalizedDate(2002, 1, 4);
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/SpanQueryParserBase.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/SpanQueryParserBase.java	(revision 1570510)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/SpanQueryParserBase.java	(working copy)
@@ -66,7 +66,7 @@
  * This should also allow for an easy transfer to javacc or similar.
  * 
  */
-public abstract class SpanQueryParserBase extends AnalyzingQueryParserBase {
+abstract class SpanQueryParserBase extends AnalyzingQueryParserBase {
 
   //better to make these public in QueryParserBase
 
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/SpanQueryParser.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/SpanQueryParser.java	(revision 1570510)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/SpanQueryParser.java	(working copy)
@@ -17,7 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -206,8 +205,6 @@
    *  separate parameter for whether or not to do this.  
    */  
 
-  private static final int MAX_QUERY_LENGTH_CHARS = 30000;
-
   private String topLevelQueryString;
 
   public SpanQueryParser(Version matchVersion, String f, Analyzer a) {
@@ -218,41 +215,47 @@
     init(matchVersion, f, a, multitermAnalyzer);
   }
 
+  /**
+   * This is an artifact of extending QueryParserBase. 
+   * Do not use this.  It will always assert(false) and fail to set the stream.
+   * Instead, set the default field in the initializer and 
+   * use {@link #parse(String)}.
+   */
+  @Deprecated
   @Override
   public void ReInit(CharStream stream) {
-    //this is crazy...convert string to char stream then back to string for processing.
-    //The value from extending QueryParserBase was greater than this
-    //bit of craziness.  This shouldn't actually ever be called.
-    try {
-      int i = 0;
-      while(i++ <  MAX_QUERY_LENGTH_CHARS) {
-        stream.readChar();
-      }
-    } catch (IOException e) {}
-    topLevelQueryString = stream.GetImage();
+    assert(false);
   }
 
+  /**
+   * This is an artifact of extending QueryParserBase. 
+   * Do not use this.  It will always assert(false) and return null.
+   * Instead, set the default field in the initializer and 
+   * use {@link #parse(String)}.
+   */
+  @Deprecated
   @Override
   public Query TopLevelQuery(String field) throws ParseException {
-    Query q = _parse(field);
-    q = rewriteAllNegative(q);
-    return q;
+    assert(false);
+    return null;
   }
 
   @Override
   public Query parse(String s) throws ParseException {
     topLevelQueryString = s;
-    return TopLevelQuery(getField());
+    Query q = _parse(s);
+    q = rewriteAllNegative(q);
+    return q;
   }
 
-  private Query _parse(String field) throws ParseException {
-    if (topLevelQueryString == null || topLevelQueryString.equals("")) {
+  private Query _parse(String queryString) throws ParseException {
+    if (queryString == null || queryString.equals("")) {
       return getEmptySpanQuery();
     }
     SpanQueryLexer lexer = new SpanQueryLexer();
-    List<SQPToken> tokens = lexer.getTokens(topLevelQueryString);
+    List<SQPToken> tokens = lexer.getTokens(queryString);
     SQPClause overallClause = new SQPOrClause(0, tokens.size());
-    return parseRecursively(tokens, field, overallClause);
+    return parseRecursively(tokens, getField(), overallClause);
   }
 
   private Query parseRecursively(final List<SQPToken> tokens, 
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/SpanOnlyParser.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/SpanOnlyParser.java	(revision 1570510)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/SpanOnlyParser.java	(working copy)
@@ -16,7 +16,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
 import java.util.List;
 
 import org.apache.lucene.analysis.Analyzer;
@@ -36,57 +35,68 @@
  * The functionality of this class was the initial offering in LUCENE-5205.
  * 
  *
+
  * @see SpanQueryParser
  */
 public class SpanOnlyParser extends AbstractSpanQueryParser{
 
-
-  private static final int MAX_QUERY_LENGTH_CHARS = 30000;
-
-
-  private String topLevelQueryString = "";
-
+  /**
+   * Initializes the SpanOnlyParser.
+   * @param matchVersion
+   * @param f default field
+   * @param a analyzer to use
+   */
   public SpanOnlyParser(Version matchVersion, String f, Analyzer a) {
     init(matchVersion, f, a);
   }
 
+  /**
+   * Initializes SpanOnlyParser.
+   * @param matchVersion
+   * @param f default field
+   * @param a analyzer to use for full terms
+   * @param multitermAnalyzer analyzer to use for multiterm analysis
+   */
   public SpanOnlyParser(Version matchVersion, String f, Analyzer a, Analyzer multitermAnalyzer) {
     init(matchVersion, f, a, multitermAnalyzer);
   }
 
   @Override
   public Query parse(String s) throws ParseException{
-    topLevelQueryString = s;
-    Query q = TopLevelQuery(getField());
+    Query q = _parsePureSpan(getField(), s);
     assert(q == null || q instanceof SpanQuery);
     return q;
   }
 
+  /**
+   * This is an artifact of extending QueryParserBase. 
+   * Do not use this.  It will always assert(false) and fail to set the stream.
+   * Instead, set the default field in the initializer and 
+   * use {@link #parse(String)}.
+   */
+  @Deprecated
   @Override
   public void ReInit(CharStream stream) {
-    //this is crazy...convert string to char stream then back to string for processing
-    //the value from extending QueryParserBase was greater than this
-    //bit of craziness.
-    try {
-      int i = 0;
-      while(i++ <  MAX_QUERY_LENGTH_CHARS) {
-        stream.readChar();
-      }
-    } catch (IOException e) {}
-    topLevelQueryString = stream.GetImage();
-
+    assert(false);
   }
 
+  /**
+   * This is an artifact of extending QueryParserBase. 
+   * Do not use this.  It will always assert(false) and return null.
+   * Instead, set the default field in the initializer and 
+   * use {@link #parse(String)}.
+   */
+  @Deprecated
   @Override
   public Query TopLevelQuery(String field) throws ParseException {
-
-    return _parsePureSpan(field, topLevelQueryString);
+    assert(false);
+    return null;
   }
 
 
   protected Query _parsePureSpan(String field, String queryString) throws ParseException{
     SpanQueryLexer lexer = new SpanQueryLexer();
-    List<SQPToken> tokens = lexer.getTokens(topLevelQueryString);
+    List<SQPToken> tokens = lexer.getTokens(queryString);
     SQPClause overallClause = new SQPOrClause(0, tokens.size());
     return _parsePureSpanClause(tokens, field, overallClause);
   }
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/AbstractSpanQueryParser.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/AbstractSpanQueryParser.java	(revision 1570510)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/AbstractSpanQueryParser.java	(working copy)
@@ -27,7 +27,7 @@
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 
-public abstract class AbstractSpanQueryParser extends SpanQueryParserBase {
+abstract class AbstractSpanQueryParser extends SpanQueryParserBase {
 
   @Override
   abstract public Query parse(String s) throws ParseException;
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/AnalyzingQueryParserBase.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/AnalyzingQueryParserBase.java	(revision 1570510)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/spans/AnalyzingQueryParserBase.java	(working copy)
@@ -37,7 +37,7 @@
  * This class also has hooks to allow subclassing to enable different
  * strategies of per field analyzer handling.
  */
-public abstract class AnalyzingQueryParserBase extends QueryParserBase {
+abstract class AnalyzingQueryParserBase extends QueryParserBase {
 
   public enum NORM_MULTI_TERMS {
     ANALYZE,
