diff --git a/lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java b/lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java
index ea02af3..abf528c 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java
@@ -587,7 +587,7 @@ public final class MoreLikeThis {
    * @param filteredDocument Document with field values extracted for selected fields.
    * @return More Like This query for the passed document.
    */
-  public Query like(Map<String, Collection<Object>> filteredDocument) throws IOException {
+  public Query like(Map<String, Collection<String>> filteredDocument) throws IOException {
     if (fieldNames == null) {
       // gather list of valid fields from lucene
       Collection<String> fields = MultiFields.getIndexedFields(ir);
@@ -757,19 +757,15 @@ public final class MoreLikeThis {
   }
 
 
-  private PriorityQueue<ScoreTerm> retrieveTerms(Map<String, Collection<Object>> field2fieldValues) throws
+  private PriorityQueue<ScoreTerm> retrieveTerms(Map<String, Collection<String>> field2fieldValues) throws
       IOException {
     Map<String, Map<String, Int>> field2termFreqMap = new HashMap<>();
     for (String fieldName : fieldNames) {
-      for (String field : field2fieldValues.keySet()) {
-        Collection<Object> fieldValues = field2fieldValues.get(field);
-        if(fieldValues == null)
-          continue;
-        for(Object fieldValue:fieldValues) {
-          if (fieldValue != null) {
-            addTermFrequencies(new StringReader(String.valueOf(fieldValue)), field2termFreqMap,
+      Collection<String> fieldValues = field2fieldValues.get(fieldName);
+      if (fieldValues != null) {
+        for (String fieldValue : fieldValues) {
+          addTermFrequencies(new StringReader(fieldValue), field2termFreqMap,
                 fieldName);
-          }
         }
       }
     }
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/mlt/TestMoreLikeThis.java b/lucene/queries/src/test/org/apache/lucene/queries/mlt/TestMoreLikeThis.java
index 89722db..cdd9253 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/mlt/TestMoreLikeThis.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/mlt/TestMoreLikeThis.java
@@ -21,6 +21,7 @@ import java.io.StringReader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -29,6 +30,8 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.index.IndexOptions;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
@@ -162,6 +165,40 @@ public class TestMoreLikeThis extends LuceneTestCase {
     mlt.setFieldNames(new String[] {"text", "foobar"});
     mlt.like("foobar", new StringReader("this is a test"));
     analyzer.close();
+    //TODO: Where's the actual test here?
+  }
+
+  public void testMapObject() throws Exception {
+    MoreLikeThis mlt = new MoreLikeThis(reader);
+    Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);
+    mlt.setAnalyzer(analyzer);
+    mlt.setMinDocFreq(1);
+    mlt.setMinTermFreq(1);
+    mlt.setMinWordLen(1);
+    mlt.setFieldNames(new String[] {"text"});
+    Map<String, Collection<String>> filteredDocument = new HashMap<>();
+
+    FieldType type = new FieldType();
+    type.setIndexOptions(IndexOptions.DOCS_AND_FREQS);
+    type.setStored(true);
+    filteredDocument.put("text", Collections.singletonList("lucene"));
+    filteredDocument.put("other", Collections.singletonList("release"));
+    BooleanQuery query = (BooleanQuery) mlt.like(filteredDocument);
+    Collection<BooleanClause> clauses = query.clauses();
+    assertEquals(1, clauses.size());
+    for (BooleanClause clause : clauses) {
+      Term term = ((TermQuery) clause.getQuery()).getTerm();
+      assertTrue(Arrays.asList(new Term("text", "lucene")).contains(term));
+    }
+
+    //remove the text one, which is the only field name set
+    filteredDocument.remove("text");
+    query = (BooleanQuery) mlt.like(filteredDocument);
+    clauses = query.clauses();
+    assertEquals(clauses.size(), 0);
+
+    analyzer.close();
+
   }
 
   // LUCENE-5725
diff --git a/solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java b/solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java
index 7491653..7c01358 100644
--- a/solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java
+++ b/solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java
@@ -22,6 +22,7 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.regex.Pattern;
 
+import org.apache.lucene.document.Field;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queries.mlt.MoreLikeThis;
 import org.apache.lucene.search.BooleanClause;
@@ -97,7 +98,7 @@ public class CloudMLTQParser extends QParser {
 
     mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());
 
-    Map<String, Collection<Object>> filteredDocument = new HashMap<>();
+    Map<String, Collection<String>> filteredDocument = new HashMap<>();
     ArrayList<String> fieldNames = new ArrayList<>();
 
     if (qf != null) {
@@ -130,7 +131,21 @@ public class CloudMLTQParser extends QParser {
 
     mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));
     for (String field : fieldNames) {
-      filteredDocument.put(field, doc.getFieldValues(field));
+      Collection<Object> fieldValues = doc.getFieldValues(field);
+      if (fieldValues != null) {
+        Collection<String> strings = new ArrayList<>(fieldValues.size());
+        for (Object value : fieldValues) {
+          if (value instanceof Field){
+            String sv = ((Field) value).stringValue();
+            if (sv != null) {
+              strings.add(sv);
+            }//TODO: nocommit: what to do when we don't have StringValue? I don't think it is possible in this case, but need to check on this
+          } else {
+            strings.add(value.toString());
+          }
+        }
+        filteredDocument.put(field, strings);
+      }
     }
 
     try {
