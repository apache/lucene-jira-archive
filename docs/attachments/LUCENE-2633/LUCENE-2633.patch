Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 992264)
+++ lucene/CHANGES.txt	(working copy)
@@ -414,6 +414,9 @@
   
 Bug fixes
 
+* LUCENE-2633: PackedInts Packed32 and Packed64 did not support internal
+  structures larger than 256MB (Toke Eskildsen)
+
 * LUCENE-2216: OpenBitSet.hashCode returned different hash codes for
   sets that only differed by trailing zeros. (Dawid Weiss, yonik)
 
Index: lucene/src/test/org/apache/lucene/util/packed/TestPackedInts.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/packed/TestPackedInts.java	(revision 992264)
+++ lucene/src/test/org/apache/lucene/util/packed/TestPackedInts.java	(working copy)
@@ -232,4 +232,24 @@
     mutable.set(4, 16);
     assertEquals("The value #24 should remain unchanged", 31, mutable.get(24));
   }
+
+  /*
+  Check if the structures properly handle the case where
+  index * bitsPerValue > Integer.MAX_VALUE
+   */
+  public void testIntOverflow() {
+    int INDEX = (int)Math.pow(2, 30)+1;
+    int BITS = 2;
+
+    Packed32 p32 = new Packed32(INDEX, BITS);
+    p32.set(INDEX-1, 1);
+    assertEquals("The value at position " + (INDEX-1)
+        + " should be correct for Packed32", 1, p32.get(INDEX-1));
+    p32 = null; // To free the 256MB used
+
+    Packed64 p64 = new Packed64(INDEX, BITS);
+    p64.set(INDEX-1, 1);
+    assertEquals("The value at position " + (INDEX-1)
+        + " should be correct for Packed64", 1, p64.get(INDEX-1));
+  }
 }
Index: lucene/src/java/org/apache/lucene/util/packed/Packed64.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/packed/Packed64.java	(revision 992264)
+++ lucene/src/java/org/apache/lucene/util/packed/Packed64.java	(working copy)
@@ -177,7 +177,7 @@
    * @return the value at the given index.
    */
   public long get(final int index) {
-    final long majorBitPos = index * bitsPerValue;
+      final long majorBitPos = (long)index * bitsPerValue;
     final int elementPos = (int)(majorBitPos >>> BLOCK_BITS); // / BLOCK_SIZE
     final int bitPos =     (int)(majorBitPos & MOD_MASK); // % BLOCK_SIZE);
 
@@ -188,7 +188,7 @@
   }
 
   public void set(final int index, final long value) {
-    final long majorBitPos = index * bitsPerValue;
+      final long majorBitPos = (long)index * bitsPerValue;
     final int elementPos = (int)(majorBitPos >>> BLOCK_BITS); // / BLOCK_SIZE
     final int bitPos =     (int)(majorBitPos & MOD_MASK); // % BLOCK_SIZE);
     final int base = bitPos * FAC_BITPOS;
Index: lucene/src/java/org/apache/lucene/util/packed/Packed32.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/packed/Packed32.java	(revision 992264)
+++ lucene/src/java/org/apache/lucene/util/packed/Packed32.java	(working copy)
@@ -186,7 +186,7 @@
    * @return the value at the given index.
    */
   public long get(final int index) {
-    final long majorBitPos = index * bitsPerValue;
+      final long majorBitPos = (long)index * bitsPerValue;
     final int elementPos = (int)(majorBitPos >>> BLOCK_BITS); // / BLOCK_SIZE
     final int bitPos =     (int)(majorBitPos & MOD_MASK); // % BLOCK_SIZE);
 
@@ -198,7 +198,7 @@
 
   public void set(final int index, final long value) {
     final int intValue = (int)value;
-    final long majorBitPos = index * bitsPerValue;
+    final long majorBitPos = (long)index * bitsPerValue;
     final int elementPos = (int)(majorBitPos >>> BLOCK_BITS); // / BLOCK_SIZE
     final int bitPos =     (int)(majorBitPos & MOD_MASK); // % BLOCK_SIZE);
     final int base = bitPos * FAC_BITPOS;
