Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircle.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircle.java	(revision 1686845)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircle.java	(working copy)
@@ -62,16 +62,17 @@
     }
     final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);
     final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);
+    if (Math.abs(cutoffAngle - Math.PI) < Vector.MINIMUM_RESOLUTION) {
+      // Circle is the whole world
+      this.circlePlane = null;
+      this.edgePoints = new GeoPoint[0];
+    } else {
     // Construct normal plane
-    final Plane normalPlane = new Plane(upperPoint, center);
-    // Construct a sided plane that goes through the two points and whose normal is in the normalPlane.
-    this.circlePlane = SidedPlane.constructNormalizedPerpendicularSidedPlane(center, normalPlane, upperPoint, lowerPoint);
-    if (circlePlane == null)
-      throw new RuntimeException("Couldn't construct circle plane.  Cutoff angle = "+cutoffAngle+"; upperPoint = "+upperPoint+"; lowerPoint = "+lowerPoint);
-    // Compute a point on the circle boundary.
-    if (cutoffAngle == Math.PI)
-      this.edgePoints = new GeoPoint[0];
-    else {
+      final Plane normalPlane = new Plane(upperPoint, center);
+      // Construct a sided plane that goes through the two points and whose normal is in the normalPlane.
+      this.circlePlane = SidedPlane.constructNormalizedPerpendicularSidedPlane(center, normalPlane, upperPoint, lowerPoint);
+      if (circlePlane == null)
+        throw new RuntimeException("Couldn't construct circle plane.  Cutoff angle = "+cutoffAngle+"; upperPoint = "+upperPoint+"; lowerPoint = "+lowerPoint);
       this.edgePoints = new GeoPoint[]{upperPoint};
     }
   }
@@ -194,6 +195,9 @@
 
   @Override
   public boolean isWithin(final Vector point) {
+    if (circlePlane == null) {
+      return true;
+    }
     // Fastest way of determining membership
     return circlePlane.isWithin(point);
   }
@@ -200,6 +204,9 @@
 
   @Override
   public boolean isWithin(final double x, final double y, final double z) {
+    if (circlePlane == null) {
+      return true;
+    }
     // Fastest way of determining membership
     return circlePlane.isWithin(x, y, z);
   }
@@ -211,6 +218,9 @@
 
   @Override
   public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {
+    if (circlePlane == null) {
+      return false;
+    }
     return circlePlane.intersects(planetModel, p, notablePoints, circlePoints, bounds);
   }
 
@@ -226,6 +236,11 @@
   @Override
   public Bounds getBounds(Bounds bounds) {
     bounds = super.getBounds(bounds);
+    if (circlePlane == null) {
+      // Entire world
+      bounds.noTopLatitudeBound().noBottomLatitudeBound().noLongitudeBound();
+      return bounds;
+    }
     bounds.addPoint(center);
     circlePlane.recordBounds(planetModel, bounds);
     return bounds;
Index: lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircleTest.java
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircleTest.java	(revision 1686845)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircleTest.java	(working copy)
@@ -46,6 +46,30 @@
   }
 
   @Test
+  public void testCircleFullWorld() {
+    GeoCircle c;
+    GeoPoint gp;
+    c = new GeoCircle(PlanetModel.SPHERE, 0.0, -0.5, Math.PI);
+    gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.0);
+    assertTrue(c.isWithin(gp));
+    gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.5);
+    assertTrue(c.isWithin(gp));
+    gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.55);
+    assertTrue(c.isWithin(gp));
+    gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.45);
+    assertTrue(c.isWithin(gp));
+    gp = new GeoPoint(PlanetModel.SPHERE, Math.PI * 0.5, 0.0);
+    assertTrue(c.isWithin(gp));
+    gp = new GeoPoint(PlanetModel.SPHERE, 0.0, Math.PI);
+    assertTrue(c.isWithin(gp));
+    Bounds b = c.getBounds(null);
+    assertTrue(b.checkNoLongitudeBound());
+    assertTrue(b.checkNoTopLatitudeBound());
+    assertTrue(b.checkNoBottomLatitudeBound());
+
+  }
+
+  @Test
   public void testCirclePointWithin() {
     GeoCircle c;
     GeoPoint gp;
