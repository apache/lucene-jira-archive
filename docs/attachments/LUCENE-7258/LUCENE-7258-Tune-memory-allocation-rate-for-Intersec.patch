diff --git a/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java b/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
index c88022a..b7eed61 100644
--- a/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
@@ -139,6 +139,18 @@ public final class ArrayUtil {
    *  over-allocating exponentially to achieve amortized
    *  linear-time cost as the array grows.
    *
+   * @param minTargetSize Minimum required value to be returned.
+   * @param bytesPerElement Bytes used by each element of
+   * the array.  See constants in {@link RamUsageEstimator}.
+   * @lucene.internal
+   */
+  public static int oversize(int minTargetSize, int bytesPerElement) {
+    return oversize(minTargetSize, bytesPerElement, 3);
+  }
+  /** Returns an array size &gt;= minTargetSize, generally
+   *  over-allocating exponentially to achieve amortized
+   *  linear-time cost as the array grows.
+   *
    *  NOTE: this was originally borrowed from Python 2.4.2
    *  listobject.c sources (attribution in LICENSE.txt), but
    *  has now been substantially changed based on
@@ -149,11 +161,15 @@ public final class ArrayUtil {
    * @param minTargetSize Minimum required value to be returned.
    * @param bytesPerElement Bytes used by each element of
    * the array.  See constants in {@link RamUsageEstimator}.
-   *
+   * @param scalingFactor Add array size in increments of 1/(2^scalingFactor). Typically 0-3.
+   *                      Generally, a larger scalingFactor will be preferred for long-lived
+   *                      arrays, or arrays that do not need rescaling much, because the allocated size
+   *                      stays closer to the required size. Smaller scalingFactors are useful
+   *                      if an array needs to be scaled many times, because they scale up faster which
+   *                      generates less garbage and requires fewer array copies.
    * @lucene.internal
    */
-
-  public static int oversize(int minTargetSize, int bytesPerElement) {
+  public static int oversize(int minTargetSize, int bytesPerElement, int scalingFactor) {
 
     if (minTargetSize < 0) {
       // catch usage that accidentally overflows int
@@ -169,10 +185,8 @@ public final class ArrayUtil {
       throw new IllegalArgumentException("requested array size " + minTargetSize + " exceeds maximum array in java (" + MAX_ARRAY_LENGTH + ")");
     }
 
-    // asymptotic exponential growth by 1/8th, favors
-    // spending a bit more CPU to not tie up too much wasted
-    // RAM:
-    int extra = minTargetSize >> 3;
+    // asymptotic exponential growth by 1/(2^scalingFactor)
+    int extra = minTargetSize >> scalingFactor;
 
     if (extra < 3) {
       // for very small arrays, where constant overhead of
diff --git a/lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder.java b/lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder.java
index 8f23847..ca9b25f 100644
--- a/lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder.java
@@ -18,6 +18,7 @@ package org.apache.lucene.util;
  */
 
 import java.io.IOException;
+import java.util.Arrays;
 
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
@@ -32,6 +33,7 @@ public final class DocIdSetBuilder {
 
   private final int maxDoc;
   private final int threshold;
+  private final int scalingHint;
 
   private int[] buffer;
   private int bufferSize;
@@ -42,12 +44,27 @@ public final class DocIdSetBuilder {
    * Create a builder that can contain doc IDs between {@code 0} and {@code maxDoc}.
    */
   public DocIdSetBuilder(int maxDoc) {
+    this(maxDoc, 7, 3);
+  }
+
+  /**
+   * Create a builder to store doc IDs
+   * Contains an optimization where storing some small fraction of maxDoc consumes less
+   * memory. The usefulness of this optimization depends on how frequently you think
+   * you'll be storing fewer than maxDoc documents.
+   * @param maxDoc This builder can store IDs between 0 and maxDoc
+   * @param thresholdHint Typically 6-11. Use the small allocation optimization until you've stored maxDoc * 1/(2^thresholdHint) docs.
+   * @param scalingHint Typically 0-3. Controls how aggressive the small allocation optimization is in claiming memory.
+   *                    Choose a larger hint if you believe this builder will be long-lived.
+   */
+  public DocIdSetBuilder(int maxDoc, int thresholdHint, int scalingHint) {
     this.maxDoc = maxDoc;
     // For ridiculously small sets, we'll just use a sorted int[]
     // maxDoc >>> 7 is a good value if you want to save memory, lower values
     // such as maxDoc >>> 11 should provide faster building but at the expense
     // of using a full bitset even for quite sparse data
-    this.threshold = maxDoc >>> 7;
+    this.threshold = maxDoc >>> thresholdHint;
+    this.scalingHint = scalingHint;
 
     this.buffer = new int[0];
     this.bufferSize = 0;
@@ -68,7 +85,7 @@ public final class DocIdSetBuilder {
   private void growBuffer(int minSize) {
     assert minSize < threshold;
     if (buffer.length < minSize) {
-      int nextSize = Math.min(threshold, ArrayUtil.oversize(minSize, RamUsageEstimator.NUM_BYTES_INT));
+      int nextSize = Math.min(threshold, ArrayUtil.oversize(minSize, RamUsageEstimator.NUM_BYTES_INT, scalingHint));
       int[] newBuffer = new int[nextSize];
       System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
       buffer = newBuffer;
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery.java
index 4bda2e3..f4bc116 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery.java
@@ -59,7 +59,10 @@ public class IntersectsPrefixTreeQuery extends AbstractVisitingPrefixTreeQuery {
 
       @Override
       protected void start() {
-        results = new DocIdSetBuilder(maxDoc);
+        // Geospatial queries generally have very non-uniform distributions, so
+        // it makes sense for the DocIdSetBuilder to expand fast, but not very
+        // far before using a FixedBitSet.
+        results = new DocIdSetBuilder(maxDoc, 8, 0);
       }
 
       @Override
