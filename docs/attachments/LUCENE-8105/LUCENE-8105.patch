diff --git a/lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java b/lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java
index 35de51a..6b2ace8 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java
@@ -27,9 +27,14 @@ class ReqOptSumScorer extends Scorer {
   /** The scorers passed from the constructor.
    * These are set to null as soon as their next() or skipTo() returns false.
    */
-  protected final Scorer reqScorer;
-  protected final Scorer optScorer;
-  protected final DocIdSetIterator optIterator;
+  private final Scorer reqScorer;
+  private final Scorer optScorer;
+  private final float reqMaxScore;
+  private final DocIdSetIterator optApproximation;
+  private final TwoPhaseIterator optTwoPhase;
+  private boolean optIsRequired;
+  private final DocIdSetIterator approximation;
+  private final TwoPhaseIterator twoPhase;
 
   /** Construct a <code>ReqOptScorer</code>.
    * @param reqScorer The required scorer. This must match.
@@ -44,17 +49,136 @@ class ReqOptSumScorer extends Scorer {
     assert optScorer != null;
     this.reqScorer = reqScorer;
     this.optScorer = optScorer;
-    this.optIterator = optScorer.iterator();
+
+    this.reqMaxScore = reqScorer.maxScore();
+
+    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();
+    this.optTwoPhase = optScorer.twoPhaseIterator();
+    final DocIdSetIterator reqApproximation;
+    if (reqTwoPhase == null) {
+      reqApproximation = reqScorer.iterator();
+    } else {
+      reqApproximation= reqTwoPhase.approximation();
+    }
+    if (optTwoPhase == null) {
+      optApproximation = optScorer.iterator();
+    } else {
+      optApproximation= optTwoPhase.approximation();
+    }
+
+    approximation = new DocIdSetIterator() {
+
+      private int nextCommonDoc(int reqDoc) throws IOException {
+        int optDoc = optApproximation.docID();
+        if (optDoc > reqDoc) {
+          reqDoc = reqApproximation.advance(optDoc);
+        }
+
+        while (true) { // invariant: reqDoc >= optDoc
+          if (reqDoc == optDoc) {
+            return reqDoc;
+          }
+
+          optDoc = optApproximation.advance(reqDoc);
+          if (optDoc == reqDoc) {
+            return reqDoc;
+          }
+          reqDoc = reqApproximation.advance(optDoc);
+        }
+      }
+
+      @Override
+      public int nextDoc() throws IOException {
+        int doc = reqApproximation.nextDoc();
+        if (optIsRequired) {
+          doc = nextCommonDoc(doc);
+        }
+        return doc;
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+        int doc = reqApproximation.advance(target);
+        if (optIsRequired) {
+          doc = nextCommonDoc(doc);
+        }
+        return doc;
+      }
+
+      @Override
+      public int docID() {
+        return reqApproximation.docID();
+      }
+
+      @Override
+      public long cost() {
+        return reqApproximation.cost();
+      }
+
+    };
+
+    if (reqTwoPhase == null && optTwoPhase == null) {
+      this.twoPhase = null;
+    } else {
+      this.twoPhase = new TwoPhaseIterator(approximation) {
+
+        @Override
+        public boolean matches() throws IOException {
+          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {
+            return false;
+          }
+          if (optTwoPhase != null) {
+            if (optIsRequired) {
+              // The below condition is rare and can only happen if we transitioned to optIsRequired=true
+              // after the opt approximation was advanced and before it was confirmed.
+              if (reqScorer.docID() != optApproximation.docID()) {
+                if (optApproximation.docID() < reqScorer.docID()) {
+                  optApproximation.advance(reqScorer.docID());
+                }
+                if (reqScorer.docID() != optApproximation.docID()) {
+                  return false;
+                }
+              }
+              if (optTwoPhase.matches() == false) {
+                // Advance the iterator to make it clear it doesn't match the current doc id
+                optApproximation.nextDoc();
+                return false;
+              }
+            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {
+              // Advance the iterator to make it clear it doesn't match the current doc id
+              optApproximation.nextDoc();
+            }
+          }
+          return true;
+        }
+
+        @Override
+        public float matchCost() {
+          float matchCost = 1;
+          if (reqTwoPhase != null) {
+            matchCost += reqTwoPhase.matchCost();
+          }
+          if (optTwoPhase != null) {
+            matchCost += optTwoPhase.matchCost();
+          }
+          return matchCost;
+        }
+      };
+    }
   }
 
   @Override
   public TwoPhaseIterator twoPhaseIterator() {
-    return reqScorer.twoPhaseIterator();
+    return twoPhase;
   }
 
   @Override
   public DocIdSetIterator iterator() {
-    return reqScorer.iterator();
+    if (twoPhase == null) {
+      return approximation;
+    } else {
+      return TwoPhaseIterator.asDocIdSetIterator(twoPhase);
+    }
   }
 
   @Override
@@ -62,26 +186,23 @@ class ReqOptSumScorer extends Scorer {
     return reqScorer.docID();
   }
 
-  /** Returns the score of the current document matching the query.
-   * Initially invalid, until the {@link #iterator()} is advanced the first time.
-   * @return The score of the required scorer, eventually increased by the score
-   * of the optional scorer when it also matches the current document.
-   */
   @Override
   public float score() throws IOException {
     // TODO: sum into a double and cast to float if we ever send required clauses to BS1
     int curDoc = reqScorer.docID();
     float score = reqScorer.score();
 
-    int optScorerDoc = optIterator.docID();
+    int optScorerDoc = optApproximation.docID();
     if (optScorerDoc < curDoc) {
-      optScorerDoc = optIterator.advance(curDoc);
+      optScorerDoc = optApproximation.advance(curDoc);
+      if (optTwoPhase != null && optScorerDoc == curDoc && optTwoPhase.matches() == false) {
+        optScorerDoc = optApproximation.nextDoc();
+      }
     }
-    
     if (optScorerDoc == curDoc) {
       score += optScorer.score();
     }
-    
+
     return score;
   }
 
@@ -91,6 +212,13 @@ class ReqOptSumScorer extends Scorer {
   }
 
   @Override
+  public void setMinCompetitiveScore(float minScore) {
+    if (optIsRequired == false && minScore > reqMaxScore) {
+      optIsRequired = true;
+    }
+  }
+
+  @Override
   public Collection<ChildScorer> getChildren() {
     ArrayList<ChildScorer> children = new ArrayList<>(2);
     children.add(new ChildScorer(reqScorer, "MUST"));
@@ -99,4 +227,3 @@ class ReqOptSumScorer extends Scorer {
   }
 
 }
-
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestReqOptSumScorer.java b/lucene/core/src/test/org/apache/lucene/search/TestReqOptSumScorer.java
new file mode 100644
index 0000000..d241e72
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestReqOptSumScorer.java
@@ -0,0 +1,190 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestReqOptSumScorer extends LuceneTestCase {
+
+  public void testBasics() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir, newIndexWriterConfig().setMergePolicy(
+        // retain doc id order
+        newLogMergePolicy(random().nextBoolean())));
+    Document doc = new Document();
+    doc.add(new StringField("f", "foo", Store.NO));
+    w.addDocument(doc);
+    doc = new Document();
+    doc.add(new StringField("f", "foo", Store.NO));
+    doc.add(new StringField("f", "bar", Store.NO));
+    w.addDocument(doc);
+    doc = new Document();
+    doc.add(new StringField("f", "foo", Store.NO));
+    w.addDocument(doc);
+    doc = new Document();
+    doc.add(new StringField("f", "bar", Store.NO));
+    w.addDocument(doc);
+    doc = new Document();
+    doc.add(new StringField("f", "foo", Store.NO));
+    doc.add(new StringField("f", "bar", Store.NO));
+    w.addDocument(doc);
+    w.forceMerge(1);
+
+    IndexReader reader = w.getReader();
+    w.close();
+    IndexSearcher searcher = newSearcher(reader);
+    Query query = new BooleanQuery.Builder()
+        .add(new ConstantScoreQuery(new TermQuery(new Term("f", "foo"))), Occur.MUST)
+        .add(new ConstantScoreQuery(new TermQuery(new Term("f", "bar"))), Occur.SHOULD)
+        .build();
+    Weight weight = searcher.createNormalizedWeight(query, ScoreMode.TOP_SCORES);
+    LeafReaderContext context = searcher.getIndexReader().leaves().get(0);
+
+    Scorer scorer = weight.scorer(context);
+    assertEquals(0, scorer.iterator().nextDoc());
+    assertEquals(1, scorer.iterator().nextDoc());
+    assertEquals(2, scorer.iterator().nextDoc());
+    assertEquals(4, scorer.iterator().nextDoc());
+    assertEquals(DocIdSetIterator.NO_MORE_DOCS, scorer.iterator().nextDoc());
+
+    scorer = weight.scorer(context);
+    scorer.setMinCompetitiveScore(Math.nextDown(1f));
+    assertEquals(0, scorer.iterator().nextDoc());
+    assertEquals(1, scorer.iterator().nextDoc());
+    assertEquals(2, scorer.iterator().nextDoc());
+    assertEquals(4, scorer.iterator().nextDoc());
+    assertEquals(DocIdSetIterator.NO_MORE_DOCS, scorer.iterator().nextDoc());
+
+    scorer = weight.scorer(context);
+    scorer.setMinCompetitiveScore(Math.nextUp(1f));
+    assertEquals(1, scorer.iterator().nextDoc());
+    assertEquals(4, scorer.iterator().nextDoc());
+    assertEquals(DocIdSetIterator.NO_MORE_DOCS, scorer.iterator().nextDoc());
+
+    scorer = weight.scorer(context);
+    assertEquals(0, scorer.iterator().nextDoc());
+    scorer.setMinCompetitiveScore(Math.nextUp(1f));
+    assertEquals(1, scorer.iterator().nextDoc());
+    assertEquals(4, scorer.iterator().nextDoc());
+    assertEquals(DocIdSetIterator.NO_MORE_DOCS, scorer.iterator().nextDoc());
+
+    reader.close();
+    dir.close();
+  }
+
+  public void testRandomFrequentOpt() throws IOException {
+    doTestRandom(0.5);
+  }
+
+  public void testRandomRareOpt() throws IOException {
+    doTestRandom(0.05);
+  }
+
+  private void doTestRandom(double optFreq) throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir, newIndexWriterConfig());
+    int numDocs = atLeast(1000);
+    for (int i = 0; i < numDocs; ++i) {
+      int numAs = random().nextBoolean() ? 0 : 1 + random().nextInt(5);
+      int numBs = random().nextDouble() < optFreq ? 0 : 1 + random().nextInt(5);
+      Document doc = new Document();
+      for (int j = 0; j < numAs; ++j) {
+        doc.add(new StringField("f", "A", Store.NO));
+      }
+      for (int j = 0; j < numBs; ++j) {
+        doc.add(new StringField("f", "B", Store.NO));
+      }
+      if (random().nextBoolean()) {
+        doc.add(new StringField("f", "C", Store.NO));
+      }
+      w.addDocument(doc);
+    }
+    IndexReader r = w.getReader();
+    w.close();
+    IndexSearcher searcher = newSearcher(r);
+
+    Query mustTerm = new TermQuery(new Term("f", "A"));
+    Query shouldTerm = new TermQuery(new Term("f", "B"));
+    Query query = new BooleanQuery.Builder()
+        .add(mustTerm, Occur.MUST)
+        .add(shouldTerm, Occur.SHOULD)
+        .build();
+
+    TopScoreDocCollector coll = TopScoreDocCollector.create(10, null, true);
+    searcher.search(query, coll);
+    ScoreDoc[] expected = coll.topDocs().scoreDocs;
+
+    // Also test a filtered query, since it does not compute the score on all
+    // matches.
+    query = new BooleanQuery.Builder()
+        .add(query, Occur.MUST)
+        .add(new TermQuery(new Term("f", "C")), Occur.FILTER)
+        .build();
+
+    coll = TopScoreDocCollector.create(10, null, true);
+    searcher.search(query, coll);
+    ScoreDoc[] expectedFiltered = coll.topDocs().scoreDocs;
+
+    for (int i = 0; i < 4; ++i) {
+      Query must = mustTerm;
+      if (i % 2 == 1) {
+        must = new RandomApproximationQuery(must, random());
+      }
+      Query should = shouldTerm;
+      if (i >= 2) {
+        should = new RandomApproximationQuery(should, random());
+      }
+    
+      query = new BooleanQuery.Builder()
+          .add(must, Occur.MUST)
+          .add(should, Occur.SHOULD)
+          .build();
+
+      coll = TopScoreDocCollector.create(10, null, false);
+      searcher.search(query, coll);
+      ScoreDoc[] actual = coll.topDocs().scoreDocs;
+
+      CheckHits.checkEqual(query, expected, actual);
+
+      query = new BooleanQuery.Builder()
+          .add(query, Occur.MUST)
+          .add(new RandomApproximationQuery(new TermQuery(new Term("f", "C")), random()), Occur.FILTER)
+          .build();
+
+      coll = TopScoreDocCollector.create(10, null, false);
+      searcher.search(query, coll);
+      ScoreDoc[] actualFiltered = coll.topDocs().scoreDocs;
+
+      CheckHits.checkEqual(query, expectedFiltered, actualFiltered);
+    }
+
+    r.close();
+    dir.close();
+  }
+
+}
