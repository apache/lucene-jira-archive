Index: solr/core/src/java/org/apache/solr/analysis/TypeTokenFilterFactory.java
===================================================================
--- solr/core/src/java/org/apache/solr/analysis/TypeTokenFilterFactory.java	(revisión: 1239515)
+++ solr/core/src/java/org/apache/solr/analysis/TypeTokenFilterFactory.java	(copia de trabajo)
@@ -51,6 +51,7 @@
   public void inform(ResourceLoader loader) {
     String stopTypesFiles = args.get("types");
     enablePositionIncrements = getBoolean("enablePositionIncrements", false);
+    useWhitelist = getBoolean("useWhitelist", false);
 
     if (stopTypesFiles != null) {
       try {
@@ -72,6 +73,7 @@
 
   private Set<String> stopTypes;
   private boolean enablePositionIncrements;
+  private boolean useWhitelist;
 
   public boolean isEnablePositionIncrements() {
     return enablePositionIncrements;
@@ -83,6 +85,6 @@
 
   // @Override
   public TokenStream create(TokenStream input) {
-    return new TypeTokenFilter(enablePositionIncrements, input, stopTypes);
+    return new TypeTokenFilter(enablePositionIncrements, input, stopTypes, useWhitelist);
   }
 }
Index: lucene/src/test/org/apache/lucene/analysis/TestTypeTokenFilter.java
===================================================================
--- lucene/src/test/org/apache/lucene/analysis/TestTypeTokenFilter.java	(revisión: 1239515)
+++ lucene/src/test/org/apache/lucene/analysis/TestTypeTokenFilter.java	(copia de trabajo)
@@ -38,6 +38,14 @@
     assertTokenStreamContents(stream, new String[]{"is", "palindrome", "while", "is", "not"});
   }
 
+  public void testTypeFilterWhitelist() throws IOException {
+    StringReader reader = new StringReader("121 is palindrome, while 123 is not");
+    Set<String> stopTypes = Collections.singleton("<NUM>");
+    TokenStream stream = new TypeTokenFilter(true, new StandardTokenizer(TEST_VERSION_CURRENT, reader), stopTypes, true);
+    assertTokenStreamContents(stream, new String[]{"121", "123"});
+  }
+
+
   /**
    * Test Position increments applied by TypeTokenFilter with and without enabling this option.
    */
Index: lucene/src/java/org/apache/lucene/analysis/TypeTokenFilter.java
===================================================================
--- lucene/src/java/org/apache/lucene/analysis/TypeTokenFilter.java	(revisión: 1239515)
+++ lucene/src/java/org/apache/lucene/analysis/TypeTokenFilter.java	(copia de trabajo)
@@ -29,17 +29,27 @@
 
   private final Set<String> stopTypes;
   private final TypeAttribute typeAttribute = addAttribute(TypeAttribute.class);
+  private final boolean useWhitelist;
 
-  public TypeTokenFilter(boolean enablePositionIncrements, TokenStream input, Set<String> stopTypes) {
+  public TypeTokenFilter(boolean enablePositionIncrements, TokenStream input, Set<String> stopTypes, boolean useWhitelist) {
     super(enablePositionIncrements, input);
     this.stopTypes = stopTypes;
+    this.useWhitelist = useWhitelist;
   }
 
+  public TypeTokenFilter(boolean enablePositionIncrements, TokenStream input, Set<String> stopTypes) {
+    this(enablePositionIncrements, input, stopTypes, false);
+  }
+
   /**
    * Returns the next input Token whose typeAttribute.type() is not a stop type.
    */
   @Override
   protected boolean accept() throws IOException {
-    return !stopTypes.contains(typeAttribute.type());
+    if (useWhitelist) {
+      return stopTypes.contains(typeAttribute.type());
+    } else {
+      return !stopTypes.contains(typeAttribute.type());
+    }
   }
 }
