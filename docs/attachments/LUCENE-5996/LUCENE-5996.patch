Index: lucene/core/src/java/org/apache/lucene/util/StringHelper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/StringHelper.java	(revision 1629897)
+++ lucene/core/src/java/org/apache/lucene/util/StringHelper.java	(working copy)
@@ -162,10 +162,7 @@
     if (prop != null) {
       // So if there is a test failure that relied on hash
       // order, we remain reproducible based on the test seed:
-      if (prop.length() > 8) {
-        prop = prop.substring(prop.length()-8);
-      }
-      GOOD_FAST_HASH_SEED = (int) Long.parseLong(prop, 16);
+      GOOD_FAST_HASH_SEED = prop.hashCode();
     } else {
       GOOD_FAST_HASH_SEED = (int) System.currentTimeMillis();
     }
Index: lucene/core/src/test/org/apache/lucene/index/Test2BTerms.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/Test2BTerms.java	(revision 1629897)
+++ lucene/core/src/test/org/apache/lucene/index/Test2BTerms.java	(working copy)
@@ -261,7 +261,7 @@
   private void testSavedTerms(IndexReader r, List<BytesRef> terms) throws IOException {
     System.out.println("TEST: run " + terms.size() + " terms on reader=" + r);
     IndexSearcher s = newSearcher(r);
-    Collections.shuffle(terms);
+    Collections.shuffle(terms, random());
     TermsEnum termsEnum = MultiFields.getTerms(r, "field").iterator(null);
     boolean failed = false;
     for(int iter=0;iter<10*terms.size();iter++) {
Index: lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose.java	(revision 1629897)
+++ lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose.java	(working copy)
@@ -122,7 +122,7 @@
       leafReader.addCoreClosedListener(listeners.get(random().nextInt(listeners.size())));
     }
     final int removed = random().nextInt(numListeners);
-    Collections.shuffle(listeners);
+    Collections.shuffle(listeners, random());
     for (int i = 0; i < removed; ++i) {
       leafReader.removeCoreClosedListener(listeners.get(i));
     }
Index: lucene/core/src/test/org/apache/lucene/search/TestSameScoresWithThreads.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestSameScoresWithThreads.java	(revision 1629897)
+++ lucene/core/src/test/org/apache/lucene/search/TestSameScoresWithThreads.java	(working copy)
@@ -93,7 +93,7 @@
                 startingGun.await();
                 for(int i=0;i<20;i++) {
                   List<Map.Entry<BytesRef,TopDocs>> shuffled = new ArrayList<>(answers.entrySet());
-                  Collections.shuffle(shuffled);
+                  Collections.shuffle(shuffled, random());
                   for(Map.Entry<BytesRef,TopDocs> ent : shuffled) {
                     TopDocs actual = s.search(new TermQuery(new Term("body", ent.getKey())), 100);
                     TopDocs expected = ent.getValue();
Index: lucene/core/src/test/org/apache/lucene/util/TestSparseFixedBitSet.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/TestSparseFixedBitSet.java	(revision 1629897)
+++ lucene/core/src/test/org/apache/lucene/util/TestSparseFixedBitSet.java	(working copy)
@@ -34,7 +34,7 @@
     for (int doc = bs.nextSetBit(0); doc != -1; doc = bs.nextSetBit(doc + 1)) {
       buffer.add(doc);
       if (buffer.size() >= 100000) {
-        Collections.shuffle(buffer);
+        Collections.shuffle(buffer, random());
         for (int i : buffer) {
           set.set(i);
         }
@@ -41,7 +41,7 @@
         buffer.clear();
       }
     }
-    Collections.shuffle(buffer);
+    Collections.shuffle(buffer, random());
     for (int i : buffer) {
       set.set(i);
     }
Index: lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java	(revision 1629897)
+++ lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java	(working copy)
@@ -125,7 +125,7 @@
       w.addDocument(doc);
       if (rand.nextInt(50) == 17) {
         // mixup binding of field name -> Number every so often
-        Collections.shuffle(fieldIDs);
+        Collections.shuffle(fieldIDs, random());
       }
       if (rand.nextInt(5) == 3 && i > 0) {
         final String delID = ""+rand.nextInt(i);
Index: lucene/tools/forbiddenApis/base.txt
===================================================================
--- lucene/tools/forbiddenApis/base.txt	(revision 1629897)
+++ lucene/tools/forbiddenApis/base.txt	(working copy)
@@ -31,3 +31,6 @@
 java.lang.Character#codePointAt(char[],int) @ Implicit end offset is error-prone when the char[] is a buffer and the last chars are random chars
 
 java.io.File#delete() @ use Files.delete for real exception, IOUtils.deleteFilesIgnoringExceptions if you dont care
+
+@defaultMessage Use shuffle(List, Random) instead so that it can be reproduced
+java.util.Collections#shuffle(java.util.List)
Index: solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java
===================================================================
--- solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java	(revision 1629897)
+++ solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java	(working copy)
@@ -23,7 +23,6 @@
 import static org.apache.solr.common.cloud.ZkStateReader.PROPERTY_PROP;
 import static org.apache.solr.common.cloud.ZkStateReader.PROPERTY_VALUE_PROP;
 import static org.apache.solr.common.cloud.ZkStateReader.SHARD_ID_PROP;
-
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.ADDREPLICA;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.ADDREPLICAPROP;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.ADDROLE;
@@ -48,6 +47,7 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.SynchronousQueue;
@@ -164,6 +164,18 @@
       ZkStateReader.MAX_SHARDS_PER_NODE, "1",
       ZkStateReader.AUTO_ADD_REPLICAS, "false");
 
+  private static final Random RANDOM;
+  static {
+    // We try to make things reproducible in the context of our tests by initializing the random instance
+    // based on the current seed
+    String seed = System.getProperty("tests.seed");
+    if (seed == null) {
+      RANDOM = new Random();
+    } else {
+      RANDOM = new Random(seed.hashCode());
+    }
+  }
+
   public ExecutorService tpe ;
   
   private static Logger log = LoggerFactory
@@ -1623,9 +1635,9 @@
       Set<String> nodes = clusterState.getLiveNodes();
       List<String> nodeList = new ArrayList<>(nodes.size());
       nodeList.addAll(nodes);
-      
-      Collections.shuffle(nodeList);
 
+      Collections.shuffle(nodeList, RANDOM);
+
       // TODO: Have maxShardsPerNode param for this operation?
 
       // Remove the node that hosts the parent shard for replica creation.
@@ -1634,7 +1646,7 @@
       // TODO: change this to handle sharding a slice into > 2 sub-shards.
 
       for (int i = 1; i <= subSlices.size(); i++) {
-        Collections.shuffle(nodeList);
+        Collections.shuffle(nodeList, RANDOM);
         String sliceName = subSlices.get(i - 1);
         for (int j = 2; j <= repFactor; j++) {
           String subShardNodeName = nodeList.get((repFactor * (i - 1) + (j - 2)) % nodeList.size());
@@ -2284,7 +2296,7 @@
       List<String> nodeList = new ArrayList<>(nodes.size());
       nodeList.addAll(nodes);
       if (createNodeList != null) nodeList.retainAll(createNodeList);
-      Collections.shuffle(nodeList);
+      Collections.shuffle(nodeList, RANDOM);
       
       if (nodeList.size() <= 0) {
         throw new SolrException(ErrorCode.BAD_REQUEST, "Cannot create collection " + collectionName
Index: solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest.java
===================================================================
--- solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest.java	(revision 1629897)
+++ solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest.java	(working copy)
@@ -1266,7 +1266,7 @@
       createCollection(collectionName, client, 2, 2);
       String newReplicaName = Assign.assignNode(collectionName, client.getZkStateReader().getClusterState());
       ArrayList<String> nodeList = new ArrayList<>(client.getZkStateReader().getClusterState().getLiveNodes());
-      Collections.shuffle(nodeList);
+      Collections.shuffle(nodeList, random());
       CollectionAdminRequest.AddReplica addReplica = new CollectionAdminRequest.AddReplica();
       addReplica.setCollectionName(collectionName);
       addReplica.setShardName("shard1");
Index: solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java
===================================================================
--- solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java	(revision 1629897)
+++ solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java	(working copy)
@@ -137,7 +137,7 @@
     log.info("Current leader {} ", currentLeader);
     l.remove(currentLeader);
 
-    Collections.shuffle(l);
+    Collections.shuffle(l, random());
     String overseerDesignate = l.get(0);
     log.info("overseerDesignate {}",overseerDesignate);
     setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);
@@ -165,7 +165,7 @@
 
     l.remove(overseerDesignate);
 
-    Collections.shuffle(l);
+    Collections.shuffle(l, random());
 
     String anotherOverseer = l.get(0);
     log.info("Adding another overseer designate {}", anotherOverseer);
Index: solr/core/src/test/org/apache/solr/update/AddBlockUpdateTest.java
===================================================================
--- solr/core/src/test/org/apache/solr/update/AddBlockUpdateTest.java	(revision 1629897)
+++ solr/core/src/test/org/apache/solr/update/AddBlockUpdateTest.java	(working copy)
@@ -198,7 +198,7 @@
         block("Y"),
         block("Z")));
     
-    Collections.shuffle(blocks);
+    Collections.shuffle(blocks, random());
     
     log.trace("{}", blocks);
     
