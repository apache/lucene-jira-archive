/*
 * Copyright 2011 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.util.Random;
import org.apache.lucene.store.FSDirectory;
import org.apache.lucene.util.Version;
import java.util.logging.Logger;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.Tokenizer;
import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.FieldType;
import org.apache.lucene.index.codecs.CodecProvider;
import org.apache.lucene.index.*;
import org.apache.lucene.index.codecs.CoreCodecProvider;
import org.apache.lucene.index.codecs.standard.StandardCodec;

// javac -cp build/classes/java TestGenerationTime.java; java -cp .:build/classes/java TestGenerationTime

public class TestGenerationTime {

  public static final String CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  public static final int NUM_DOCS = 1000000;
  public static final int MAX_CHARS = 5;
  public static final int WORDS_TITLE = 5;
  public static final int WORDS_CONTENT = 58;
  protected static final Logger log = Logger.getLogger("TestGenerationTime.class");
  
  public static void main(String[] args) throws InterruptedException, IOException {
    genearte("/q/tmp/index-4.0");
  }

  private static void genearte(String indexPath) throws InterruptedException, IOException {
    File folder = new File(indexPath);
    if (folder.exists()) folder.delete();
      
    FSDirectory dir = FSDirectory.open(new File(indexPath));
    TieredMergePolicy mergePolicy = new TieredMergePolicy();
    mergePolicy.setSegmentsPerTier(10.0);
    mergePolicy.setUseCompoundFile(false);
    mergePolicy.setMaxMergeAtOnce(10);
    mergePolicy.setMaxMergeAtOnceExplicit(30);
    Analyzer analyzer = new StringSplitAnalyzer();
    CodecProvider cp = new CoreCodecProvider();
    //cp.register(new MockSepCodec());
    //cp.register(new StandardCodec());
    IndexWriterConfig conf = new IndexWriterConfig(Version.LUCENE_40, analyzer);
    conf.setMergePolicy(mergePolicy);
    conf.setRAMBufferSizeMB(32);
    conf.setOpenMode(IndexWriterConfig.OpenMode.CREATE);
    conf.setWriteLockTimeout(1000);
    conf.setMergeScheduler(new ConcurrentMergeScheduler());
    conf.setIndexerThreadPool(new ThreadAffinityDocumentsWriterThreadPool(1));
    //conf.setCodecProvider(cp);
    System.out.println("IndexWriterConfig: " + conf.toString());
    IndexWriter w = new IndexWriter(dir, conf);   
    w.setInfoStream(System.out);
    long start = System.currentTimeMillis();
    
    for (int i = 0; i < NUM_DOCS; i++) {
      Document doc = new Document();
      FieldType ft = new FieldType();
      ft.setIndexed(true);
      ft.setOmitNorms(true);
      ft.setTokenized(true);
      ft.setStored(true);
      ft.setStoreTermVectors(false);
      doc.add(new Field("id", String.valueOf(System.currentTimeMillis() + i), ft));
      doc.add(new Field("title", buildField(WORDS_TITLE), ft));
      doc.add(new Field("content", buildField(WORDS_CONTENT) + " laz", ft));
      w.addDocument(doc);
    }
    System.out.println("Time taken indexing: " + getSecs(System.currentTimeMillis() - start));
    long startClose = System.currentTimeMillis();
    w.close();
    System.out.println("Time taken closing: " + getSecs(System.currentTimeMillis() - startClose));
    System.out.println("Time taken whole process: " + getSecs(System.currentTimeMillis() - start));
  }
  
  private static long getSecs(long time) {
    return time / 1000;
  }
  
  private static String generateString(int length) {
    Random r = new Random();
    char[] text = new char[length];
    for (int i = 0; i < length; i++) {
      text[i] = CHARS.charAt(r.nextInt(CHARS.length()));
    }
    return new String(text);
  }

  private static String buildField(int numWords) {
    StringBuilder b = new StringBuilder();
    for (int i = 0; i < numWords; i++) {
      b.append(" ").append(generateString(MAX_CHARS));
    }
    return b.toString();

  }

  static final class StringSplitAnalyzer extends Analyzer {
    @Override
    public TokenStreamComponents createComponents(String fieldName, Reader reader) {
      return new TokenStreamComponents(new StringSplitTokenizer(reader));
    }
  }

  private static class StringSplitTokenizer extends Tokenizer {
    private String[] tokens;
    private int upto;
    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);

    public StringSplitTokenizer(Reader r) {
      try {
        reset(r);
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }

    @Override
    public final boolean incrementToken() throws IOException {
      clearAttributes();
      if (upto < tokens.length) {
        termAtt.setEmpty();
        termAtt.append(tokens[upto]);
        upto++;
        return true;
      } else {
        return false;
      }
    }

    @Override
    public void reset(Reader input) throws IOException {
      this.upto = 0;
      final StringBuilder b = new StringBuilder();
      final char[] buffer = new char[1024];
      int n;
      while ((n = input.read(buffer)) != -1) {
        b.append(buffer, 0, n);
      }
      this.tokens = b.toString().split(" ");
    }
  }
}
