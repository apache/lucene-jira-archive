 .../src/java/org/apache/lucene/util/BytesRef.java  | 108 ++++-----------------
 .../org/apache/lucene/util/LegacyNumericUtils.java |   4 -
 .../org/apache/lucene/index/TestMultiFields.java   |   4 +-
 .../org/apache/lucene/util/TestBytesRefArray.java  |  16 ++-
 .../org/apache/lucene/util/TestBytesRefHash.java   |  34 +++----
 .../lucene/search/suggest/tst/TSTLookup.java       |  49 +++++++++-
 .../lucene/search/suggest/TestInputIterator.java   |   2 +-
 7 files changed, 93 insertions(+), 124 deletions(-)

diff --git a/lucene/core/src/java/org/apache/lucene/util/BytesRef.java b/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
index c30c0db..c2d47e6 100644
--- a/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
@@ -172,102 +172,30 @@ public final class BytesRef implements Comparable<BytesRef>,Cloneable {
     return utf8SortedAsUnicodeSortOrder.compare(this, other);
   }
   
-  private final static Comparator<BytesRef> utf8SortedAsUnicodeSortOrder = new UTF8SortedAsUnicodeComparator();
-
   public static Comparator<BytesRef> getUTF8SortedAsUnicodeComparator() {
     return utf8SortedAsUnicodeSortOrder;
   }
 
-  private static class UTF8SortedAsUnicodeComparator implements Comparator<BytesRef> {
-    // Only singleton
-    private UTF8SortedAsUnicodeComparator() {};
-
-    @Override
-    public int compare(BytesRef a, BytesRef b) {
-      final byte[] aBytes = a.bytes;
-      int aUpto = a.offset;
-      final byte[] bBytes = b.bytes;
-      int bUpto = b.offset;
-      
-      final int aStop = aUpto + Math.min(a.length, b.length);
-      while(aUpto < aStop) {
-        int aByte = aBytes[aUpto++] & 0xff;
-        int bByte = bBytes[bUpto++] & 0xff;
-
-        int diff = aByte - bByte;
-        if (diff != 0) {
-          return diff;
-        }
-      }
-
-      // One is a prefix of the other, or, they are equal:
-      return a.length - b.length;
-    }    
-  }
-
-  /** @deprecated This comparator is only a transition mechanism */
-  @Deprecated
-  private final static Comparator<BytesRef> utf8SortedAsUTF16SortOrder = new UTF8SortedAsUTF16Comparator();
-
-  /** @deprecated This comparator is only a transition mechanism */
-  @Deprecated
-  public static Comparator<BytesRef> getUTF8SortedAsUTF16Comparator() {
-    return utf8SortedAsUTF16SortOrder;
-  }
-
-  /** @deprecated This comparator is only a transition mechanism */
-  @Deprecated
-  private static class UTF8SortedAsUTF16Comparator implements Comparator<BytesRef> {
-    // Only singleton
-    private UTF8SortedAsUTF16Comparator() {};
-
-    @Override
-    public int compare(BytesRef a, BytesRef b) {
-
-      final byte[] aBytes = a.bytes;
-      int aUpto = a.offset;
-      final byte[] bBytes = b.bytes;
-      int bUpto = b.offset;
-      
-      final int aStop;
-      if (a.length < b.length) {
-        aStop = aUpto + a.length;
-      } else {
-        aStop = aUpto + b.length;
+  private final static Comparator<BytesRef> utf8SortedAsUnicodeSortOrder = (a, b) -> {
+    final byte[] aBytes = a.bytes;
+    int aUpto = a.offset;
+    final byte[] bBytes = b.bytes;
+    int bUpto = b.offset;
+    
+    final int aStop = aUpto + Math.min(a.length, b.length);
+    while(aUpto < aStop) {
+      int aByte = aBytes[aUpto++] & 0xff;
+      int bByte = bBytes[bUpto++] & 0xff;
+
+      int diff = aByte - bByte;
+      if (diff != 0) {
+        return diff;
       }
-
-      while(aUpto < aStop) {
-        int aByte = aBytes[aUpto++] & 0xff;
-        int bByte = bBytes[bUpto++] & 0xff;
-
-        if (aByte != bByte) {
-
-          // See http://icu-project.org/docs/papers/utf16_code_point_order.html#utf-8-in-utf-16-order
-
-          // We know the terms are not equal, but, we may
-          // have to carefully fixup the bytes at the
-          // difference to match UTF16's sort order:
-          
-          // NOTE: instead of moving supplementary code points (0xee and 0xef) to the unused 0xfe and 0xff, 
-          // we move them to the unused 0xfc and 0xfd [reserved for future 6-byte character sequences]
-          // this reserves 0xff for preflex's term reordering (surrogate dance), and if unicode grows such
-          // that 6-byte sequences are needed we have much bigger problems anyway.
-          if (aByte >= 0xee && bByte >= 0xee) {
-            if ((aByte & 0xfe) == 0xee) {
-              aByte += 0xe;
-            }
-            if ((bByte&0xfe) == 0xee) {
-              bByte += 0xe;
-            }
-          }
-          return aByte - bByte;
-        }
-      }
-
-      // One is a prefix of the other, or, they are equal:
-      return a.length - b.length;
     }
-  }
+
+    // One is a prefix of the other, or, they are equal:
+    return a.length - b.length;
+  };
   
   /**
    * Creates a new BytesRef that points to a copy of the bytes from 
diff --git a/lucene/core/src/java/org/apache/lucene/util/LegacyNumericUtils.java b/lucene/core/src/java/org/apache/lucene/util/LegacyNumericUtils.java
index b41b5f0..f338d25 100644
--- a/lucene/core/src/java/org/apache/lucene/util/LegacyNumericUtils.java
+++ b/lucene/core/src/java/org/apache/lucene/util/LegacyNumericUtils.java
@@ -53,10 +53,6 @@ import org.apache.lucene.index.TermsEnum;
  * {@link org.apache.lucene.search.LegacyNumericRangeQuery} implements the query part
  * for the same data types.
  *
- * <p>This class can also be used, to generate lexicographically sortable (according to
- * {@link BytesRef#getUTF8SortedAsUTF16Comparator()}) representations of numeric data
- * types for other usages (e.g. sorting).
- *
  * @lucene.internal
  *
  * @deprecated Please use {@link org.apache.lucene.index.PointValues} instead.
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestMultiFields.java b/lucene/core/src/test/org/apache/lucene/index/TestMultiFields.java
index f0954f3..ffb9be1 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestMultiFields.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestMultiFields.java
@@ -104,8 +104,8 @@ public class TestMultiFields extends LuceneTestCase {
 
       if (VERBOSE) {
         List<BytesRef> termsList = new ArrayList<>(uniqueTerms);
-        Collections.sort(termsList, BytesRef.getUTF8SortedAsUTF16Comparator());
-        System.out.println("TEST: terms in UTF16 order:");
+        Collections.sort(termsList, BytesRef.getUTF8SortedAsUnicodeComparator());
+        System.out.println("TEST: terms in UTF-8 order:");
         for(BytesRef b : termsList) {
           System.out.println("  " + UnicodeUtil.toHexString(b.utf8ToString()) + " " + b);
           for(int docID : docs.get(b)) {
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestBytesRefArray.java b/lucene/core/src/test/org/apache/lucene/util/TestBytesRefArray.java
index f2e7b60..3277ea0 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestBytesRefArray.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestBytesRefArray.java
@@ -90,9 +90,19 @@ public class TestBytesRefArray extends LuceneTestCase {
         stringList.add(randomRealisticUnicodeString);
       }
       
-      Collections.sort(stringList);
-      BytesRefIterator iter = list.iterator(BytesRef
-          .getUTF8SortedAsUTF16Comparator());
+      Collections.sort(stringList, (a, b) -> {
+        int[] aCodePoints = a.codePoints().toArray();
+        int[] bCodePoints = b.codePoints().toArray();
+        for(int i=0;i<Math.min(aCodePoints.length, bCodePoints.length);i++) {
+          if (aCodePoints[i] < bCodePoints[i]) {
+            return -1;
+          } else if (aCodePoints[i] > bCodePoints[i]) {
+            return 1;
+          }
+        }
+        return aCodePoints.length - bCodePoints.length;
+      });
+      BytesRefIterator iter = list.iterator(BytesRef.getUTF8SortedAsUnicodeComparator());
       int i = 0;
       BytesRef next;
       while ((next = iter.next()) != null) {
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestBytesRefHash.java b/lucene/core/src/test/org/apache/lucene/util/TestBytesRefHash.java
index 50d921b..9202987 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestBytesRefHash.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestBytesRefHash.java
@@ -168,15 +168,6 @@ public class TestBytesRefHash extends LuceneTestCase {
     }
   }
 
-  private static int[] codePoints(String input) {
-    int length = Character.codePointCount(input, 0, input.length());
-    int word[] = new int[length];
-    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {
-      word[j++] = cp = input.codePointAt(i);
-    }
-    return word;
-  }
-
   /**
    * Test method for
    * {@link org.apache.lucene.util.BytesRefHash#sort()}.
@@ -188,21 +179,18 @@ public class TestBytesRefHash extends LuceneTestCase {
     for (int j = 0; j < num; j++) {
 
       // Sorts by unicode code point order (is there a simple way, e.g. a Collator?)
-      SortedSet<String> strings = new TreeSet<>(new Comparator<String>() {
-          @Override
-          public int compare(String a, String b) {
-            int[] aCodePoints = codePoints(a);
-            int[] bCodePoints = codePoints(b);
-            for(int i=0;i<Math.min(aCodePoints.length, bCodePoints.length);i++) {
-              if (aCodePoints[i] < bCodePoints[i]) {
-                return -1;
-              } else if (aCodePoints[i] > bCodePoints[i]) {
-                return 1;
-              }
-            }
-            return aCodePoints.length - bCodePoints.length;
+      SortedSet<String> strings = new TreeSet<>((a, b) -> {
+        int[] aCodePoints = a.codePoints().toArray();
+        int[] bCodePoints = b.codePoints().toArray();
+        for(int i=0;i<Math.min(aCodePoints.length, bCodePoints.length);i++) {
+          if (aCodePoints[i] < bCodePoints[i]) {
+            return -1;
+          } else if (aCodePoints[i] > bCodePoints[i]) {
+            return 1;
           }
-        });
+        }
+        return aCodePoints.length - bCodePoints.length;
+      });
       for (int i = 0; i < 797; i++) {
         String str;
         do {
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/tst/TSTLookup.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/tst/TSTLookup.java
index 1196917..e3fc27d 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/tst/TSTLookup.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/tst/TSTLookup.java
@@ -18,6 +18,7 @@ package org.apache.lucene.search.suggest.tst;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Comparator;
 import java.util.List;
 import java.util.Set;
 
@@ -63,6 +64,52 @@ public class TSTLookup extends Lookup {
     this.tempDir = tempDir;
     this.tempFileNamePrefix = tempFileNamePrefix;
   }
+  
+  /** TST uses UTF-16 soring, so we need a BytesRef comparator to do this */
+  private final static Comparator<BytesRef> utf8SortedAsUTF16SortOrder = (a, b) -> {
+    final byte[] aBytes = a.bytes;
+    int aUpto = a.offset;
+    final byte[] bBytes = b.bytes;
+    int bUpto = b.offset;
+    
+    final int aStop;
+    if (a.length < b.length) {
+      aStop = aUpto + a.length;
+    } else {
+      aStop = aUpto + b.length;
+    }
+
+    while(aUpto < aStop) {
+      int aByte = aBytes[aUpto++] & 0xff;
+      int bByte = bBytes[bUpto++] & 0xff;
+
+      if (aByte != bByte) {
+
+        // See http://icu-project.org/docs/papers/utf16_code_point_order.html#utf-8-in-utf-16-order
+
+        // We know the terms are not equal, but, we may
+        // have to carefully fixup the bytes at the
+        // difference to match UTF16's sort order:
+        
+        // NOTE: instead of moving supplementary code points (0xee and 0xef) to the unused 0xfe and 0xff, 
+        // we move them to the unused 0xfc and 0xfd [reserved for future 6-byte character sequences]
+        // this reserves 0xff for preflex's term reordering (surrogate dance), and if unicode grows such
+        // that 6-byte sequences are needed we have much bigger problems anyway.
+        if (aByte >= 0xee && bByte >= 0xee) {
+          if ((aByte & 0xfe) == 0xee) {
+            aByte += 0xe;
+          }
+          if ((bByte&0xfe) == 0xee) {
+            bByte += 0xe;
+          }
+        }
+        return aByte - bByte;
+      }
+    }
+
+    // One is a prefix of the other, or, they are equal:
+    return a.length - b.length;
+  };
 
   @Override
   public void build(InputIterator iterator) throws IOException {
@@ -75,7 +122,7 @@ public class TSTLookup extends Lookup {
     root = new TernaryTreeNode();
 
     // make sure it's sorted and the comparator uses UTF16 sort order
-    iterator = new SortedInputIterator(tempDir, tempFileNamePrefix, iterator, BytesRef.getUTF8SortedAsUTF16Comparator());
+    iterator = new SortedInputIterator(tempDir, tempFileNamePrefix, iterator, utf8SortedAsUTF16SortOrder);
     count = 0;
     ArrayList<String> tokens = new ArrayList<>();
     ArrayList<Number> vals = new ArrayList<>();
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/TestInputIterator.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/TestInputIterator.java
index 0c80bb3..d5cd226 100644
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/TestInputIterator.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/suggest/TestInputIterator.java
@@ -47,7 +47,7 @@ public class TestInputIterator extends LuceneTestCase {
     Random random = random();
     int num = atLeast(10000);
     
-    Comparator<BytesRef> comparator = random.nextBoolean() ? BytesRef.getUTF8SortedAsUnicodeComparator() : BytesRef.getUTF8SortedAsUTF16Comparator();
+    Comparator<BytesRef> comparator = BytesRef.getUTF8SortedAsUnicodeComparator();
     TreeMap<BytesRef, SimpleEntry<Long, BytesRef>> sorted = new TreeMap<>(comparator);
     TreeMap<BytesRef, Long> sortedWithoutPayload = new TreeMap<>(comparator);
     TreeMap<BytesRef, SimpleEntry<Long, Set<BytesRef>>> sortedWithContext = new TreeMap<>(comparator);
