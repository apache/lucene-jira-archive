Index: lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java	(revision 1685182)
+++ lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java	(working copy)
@@ -96,7 +96,7 @@
   public static final RewriteMethod CONSTANT_SCORE_REWRITE = new RewriteMethod() {
     @Override
     public Query rewrite(IndexReader reader, MultiTermQuery query) {
-      Query result = new MultiTermQueryConstantScoreWrapper<>(query);
+      Query result = new MultiTermQueryConstantScoreWrapper<>(query, this);
       result.setBoost(query.getBoost());
       return result;
     }
Index: lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java	(revision 1685182)
+++ lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java	(working copy)
@@ -17,11 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Objects;
-
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
@@ -30,10 +25,16 @@
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BitDocIdSet;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+
 /**
  * This class also provides the functionality behind
  * {@link MultiTermQuery#CONSTANT_SCORE_REWRITE}.
@@ -78,11 +79,14 @@
 
   protected final Q query;
 
+  protected final MultiTermQuery.RewriteMethod rewriteMethod;
+
   /**
    * Wrap a {@link MultiTermQuery} as a Filter.
    */
-  protected MultiTermQueryConstantScoreWrapper(Q query) {
-      this.query = query;
+  protected MultiTermQueryConstantScoreWrapper(Q query, MultiTermQuery.RewriteMethod rewriteMethod) {
+    this.query = query;
+    this.rewriteMethod = rewriteMethod;
   }
 
   @Override
@@ -106,7 +110,9 @@
   }
 
   /** Returns the field name for this query */
-  public final String getField() { return query.getField(); }
+  public final String getField() {
+    return query.getField();
+  }
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
@@ -142,8 +148,7 @@
           // field does not exist
           return new WeightOrBitSet((BitDocIdSet) null);
         }
-
-        final TermsEnum termsEnum = query.getTermsEnum(terms);
+        final TermsEnum termsEnum = rewriteMethod.getTermsEnum(query, terms, new AttributeSource());
         assert termsEnum != null;
 
         PostingsEnum docs = null;
Index: lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInBBoxQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInBBoxQuery.java	(revision 1685182)
+++ lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInBBoxQuery.java	(working copy)
@@ -17,8 +17,7 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.AttributeSource;
@@ -25,6 +24,11 @@
 import org.apache.lucene.util.GeoUtils;
 import org.apache.lucene.util.ToStringUtils;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+
 /** Implements a simple bounding box query on a GeoPoint field. This is inspired by
  * {@link org.apache.lucene.search.NumericRangeQuery} and is implemented using a
  * two phase approach. First, candidate terms are queried using a numeric
@@ -78,16 +82,28 @@
     this.minLat = minLat;
     this.maxLon = maxLon;
     this.maxLat = maxLat;
+
+    // We need our own rewrite method to ensure the ranges are computed only once across segments
+    rewriteMethod = new RewriteMethod() {
+
+      final List<GeoPointTermsEnum.Range> ranges = new ArrayList<>();
+
+      @Override
+      public Query rewrite(IndexReader reader, MultiTermQuery query) {
+        Query result = new MultiTermQueryConstantScoreWrapper<>(query, this);
+        result.setBoost(query.getBoost());
+        return result;
+      }
+
+      @Override
+      protected TermsEnum getTermsEnum(MultiTermQuery query, Terms terms, AttributeSource atts) throws IOException {
+        return new GeoPointTermsEnum(ranges, terms.iterator(), minLon, minLat, maxLon, maxLat);
+      }
+    };
   }
 
-  @Override @SuppressWarnings("unchecked")
   protected TermsEnum getTermsEnum(final Terms terms, AttributeSource atts) throws IOException {
-    final Long min = GeoUtils.mortonHash(minLon, minLat);
-    final Long max = Math.abs(GeoUtils.mortonHash(maxLon, maxLat));
-    if (min != null && max != null &&  min.compareTo(max) > 0) {
-      return TermsEnum.EMPTY;
-    }
-    return new GeoPointTermsEnum(terms.iterator(), atts, minLon, minLat, maxLon, maxLat);
+    throw new UnsupportedOperationException();
   }
 
   @Override
@@ -145,4 +161,9 @@
         .append(ToStringUtils.boost(getBoost()))
         .toString();
   }
+
+  @Override
+  public void setRewriteMethod(RewriteMethod method) {
+    throw new UnsupportedOperationException("cannot change rewrite method");
+  }
 }
Index: lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java	(revision 1685182)
+++ lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.AttributeSource;
@@ -26,7 +27,9 @@
 import org.apache.lucene.util.ToStringUtils;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 
 /** Implements a simple point in polygon query on a GeoPoint field. This is based on
  * {@link GeoPointInBBoxQuery} and is implemented using a
@@ -101,6 +104,24 @@
     // convert polygon vertices to coordinates within tolerance
     this.x = toleranceConversion(polyLons);
     this.y = toleranceConversion(polyLats);
+
+    // We need our own rewrite method to ensure the ranges are computed only once across segments
+    rewriteMethod = new RewriteMethod() {
+
+      final List<GeoPointTermsEnum.Range> ranges = new ArrayList<>();
+
+      @Override
+      public Query rewrite(IndexReader reader, MultiTermQuery query) {
+        Query result = new MultiTermQueryConstantScoreWrapper<>(query, this);
+        result.setBoost(query.getBoost());
+        return result;
+      }
+
+      @Override
+      protected TermsEnum getTermsEnum(MultiTermQuery query, Terms terms, AttributeSource atts) throws IOException {
+        return new GeoPolygonTermsEnum(ranges, terms.iterator(), minLon, minLat, maxLon, maxLat);
+      }
+    };
   }
 
   private double[] toleranceConversion(double[] vals) {
@@ -110,14 +131,8 @@
     return vals;
   }
 
-  @Override @SuppressWarnings("unchecked")
   protected TermsEnum getTermsEnum(final Terms terms, AttributeSource atts) throws IOException {
-    final Long min = GeoUtils.mortonHash(minLon, minLat);
-    final Long max = Math.abs(GeoUtils.mortonHash(maxLon, maxLat));
-    if (min != null && max != null &&  min.compareTo(max) > 0) {
-      return TermsEnum.EMPTY;
-    }
-    return new GeoPolygonTermsEnum(terms.iterator(), atts, minLon, minLat, maxLon, maxLat);
+    throw new UnsupportedOperationException();
   }
 
   @Override
@@ -168,9 +183,9 @@
   }
 
   private final class GeoPolygonTermsEnum extends GeoPointTermsEnum {
-    GeoPolygonTermsEnum(final TermsEnum tenum, AttributeSource atts, final double minLon, final double minLat,
+    GeoPolygonTermsEnum(final List<GeoPointTermsEnum.Range> ranges, final TermsEnum tenum, final double minLon, final double minLat,
                         final double maxLon, final double maxLat) {
-      super(tenum, atts, minLon, minLat, maxLon, maxLat);
+      super(ranges, tenum, minLon, minLat, maxLon, maxLat);
     }
 
     @Override
Index: lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java	(revision 1685182)
+++ lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java	(working copy)
@@ -17,21 +17,17 @@
  * limitations under the License.
  */
 
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-
 import org.apache.lucene.document.GeoPointField;
 import org.apache.lucene.index.FilteredTermsEnum;
 import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.util.Attribute;
-import org.apache.lucene.util.AttributeImpl;
-import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.util.GeoUtils;
 import org.apache.lucene.util.NumericUtils;
 
+import java.util.Collections;
+import java.util.List;
+
 /**
  * computes all ranges along a space-filling curve that represents
  * the given bounding box and enumerates all terms contained within those ranges
@@ -45,13 +41,16 @@
   private Range currentRange;
   private BytesRef currentLowerBound, currentUpperBound;
 
-  private final ComputedRangesAttribute rangesAtt;
+  private final List<Range> rangeBounds;
+  private int nextRange;
 
-  private final LinkedList<Range> rangeBounds;
-
   private static final short DETAIL_LEVEL = 16;
 
-  GeoPointTermsEnum(final TermsEnum tenum, AttributeSource atts, final double minLon, final double minLat,
+  // Used for testing
+  static int computeRangeCount;
+
+  GeoPointTermsEnum(final List<Range> rangeBounds,
+                    final TermsEnum tenum, final double minLon, final double minLat,
                     final double maxLon, final double maxLat) {
     super(tenum);
     final long rectMinHash = GeoUtils.mortonHash(minLon, minLat);
@@ -61,10 +60,10 @@
     this.maxLon = GeoUtils.mortonUnhashLon(rectMaxHash);
     this.maxLat = GeoUtils.mortonUnhashLat(rectMaxHash);
 
-    this.rangesAtt = atts.addAttribute(ComputedRangesAttribute.class);
-    this.rangeBounds = rangesAtt.ranges();
+    this.rangeBounds = rangeBounds;
 
     if (rangeBounds.isEmpty()) {
+      computeRangeCount++;
       computeRange(0L, (short) (((GeoUtils.BITS) << 1) - 1));
       Collections.sort(rangeBounds);
     }
@@ -122,7 +121,7 @@
   }
 
   private void nextRange() {
-    currentRange = rangeBounds.removeFirst();
+    currentRange = rangeBounds.get(nextRange++);
     currentLowerBound = currentRange.lower;
     assert currentUpperBound == null || currentUpperBound.compareTo(currentRange.lower) <= 0 :
         "The current upper bound must be <= the new lower bound";
@@ -132,7 +131,7 @@
 
   @Override
   protected final BytesRef nextSeekTerm(BytesRef term) {
-    while (!rangeBounds.isEmpty()) {
+    while (nextRange < rangeBounds.size()) {
       if (currentRange == null) {
         nextRange();
       }
@@ -140,7 +139,7 @@
       // if the new upper bound is before the term parameter, the sub-range is never a hit
       if (term != null && term.compareTo(currentUpperBound) > 0) {
         nextRange();
-        if (!rangeBounds.isEmpty()) {
+        if (nextRange < rangeBounds.size()) {
           continue;
         }
       }
@@ -167,10 +166,11 @@
   protected AcceptStatus accept(BytesRef term) {
     // validate value is in range
     while (currentUpperBound == null || term.compareTo(currentUpperBound) > 0) {
-      if (rangeBounds.isEmpty())
+      if (nextRange >= rangeBounds.size()) {
         return AcceptStatus.END;
+      }
       // peek next sub-range, only seek if the current term is smaller than next lower bound
-      if (term.compareTo(rangeBounds.getFirst().lower) < 0)
+      if (term.compareTo(rangeBounds.get(nextRange).lower) < 0)
         return AcceptStatus.NO_AND_SEEK;
       // step forward to next range without seeking, as next lower range bound is less or equal current term
       nextRange();
@@ -188,50 +188,10 @@
     return AcceptStatus.YES;
   }
 
-  public static interface ComputedRangesAttribute extends Attribute {
-    public LinkedList<Range> ranges();
-  }
-
-  @SuppressWarnings({"unchecked","rawtypes"})
-  public static final class ComputedRangesAttributeImpl extends AttributeImpl implements ComputedRangesAttribute {
-    public final LinkedList<Range> rangeBounds = new LinkedList();
-
-    @Override
-    public LinkedList<Range> ranges() {
-      return rangeBounds;
-    }
-
-    @Override
-    public void clear() {
-      rangeBounds.clear();
-    }
-
-    @Override
-    public int hashCode() {
-      return rangeBounds.hashCode();
-    }
-
-    @Override
-    public boolean equals(Object other) {
-      if (this == other)
-        return true;
-      if (!(other instanceof ComputedRangesAttributeImpl))
-        return false;
-      return rangeBounds.equals(((ComputedRangesAttributeImpl)other).rangeBounds);
-    }
-
-    @Override
-    public void copyTo(AttributeImpl target) {
-      final List<Range> targetRanges = ((ComputedRangesAttribute)target).ranges();
-      targetRanges.clear();
-      targetRanges.addAll(rangeBounds);
-    }
-  }
-
   /**
    * Internal class to represent a range along the space filling curve
    */
-  private final class Range implements Comparable<Range> {
+  final class Range implements Comparable<Range> {
     final BytesRef lower;
     final BytesRef upper;
     final short level;
Index: lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java	(revision 1685182)
+++ lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java	(working copy)
@@ -471,4 +471,27 @@
   private static double randomLon() {
     return originLon + range * (random().nextDouble()-0.5);
   }
+
+  public void testRangesSharedAcrossSegments() throws Exception {
+    Directory dir = newDirectory();
+    IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(new MockAnalyzer(random())));
+    Document doc = new Document();
+    doc.add(new GeoPointField("field", -90, 30, Field.Store.NO));
+    w.addDocument(doc);
+    w.commit();
+    doc = new Document();
+    doc.add(new GeoPointField("field", -95, 25, Field.Store.NO));
+    w.addDocument(doc);
+
+    IndexReader r = DirectoryReader.open(w, true);
+    IndexSearcher s = new IndexSearcher(r);
+
+    GeoPointInBBoxQuery q = new GeoPointInBBoxQuery("field", -100, 10, -80, 40);
+    GeoPointTermsEnum.computeRangeCount = 0;
+    TopDocs hits = s.search(q, 10);
+    assertEquals(2, hits.totalHits);
+    assertEquals(1, GeoPointTermsEnum.computeRangeCount);
+
+    IOUtils.close(r, w, dir);
+  }
 }
