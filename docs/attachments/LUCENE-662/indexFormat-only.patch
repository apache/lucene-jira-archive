Index: src/test/org/apache/lucene/index/TestIndexFormat.java
===================================================================
--- src/test/org/apache/lucene/index/TestIndexFormat.java	(révision 0)
+++ src/test/org/apache/lucene/index/TestIndexFormat.java	(révision 0)
@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.index;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.store.RAMDirectory;
+
+/**
+ * Tests related to the {@link IndexFormat} management
+ * 
+ * $Id$
+ */
+public class TestIndexFormat extends TestCase {
+
+  public void testSetIndexFmt() throws Exception {
+    RAMDirectory dir = new RAMDirectory();
+    try {
+      dir.setIndexFormat(new FakeIndexFmt());
+      fail("We must not be able to set the index format twice");
+    } catch (IllegalStateException e) {
+      // catched : OK
+    }
+  }
+
+  public void testWriteIndexFmt() throws Exception {
+    RAMDirectory dir = new RAMDirectory(new DefaultIndexFormat());
+    SegmentInfos infos = new SegmentInfos();
+    infos.writeIndexFormat(dir);
+    assertEquals(DefaultIndexFormat.ID, infos.readIndexFormat(dir));
+
+    dir = new RAMDirectory(new FakeIndexFmt());
+    infos = new SegmentInfos();
+    infos.writeIndexFormat(dir);
+    assertEquals(FakeIndexFmt.ID, infos.readIndexFormat(dir));
+  }
+
+  public void testInit() throws Exception {
+    RAMDirectory dir = new RAMDirectory(new DefaultIndexFormat());
+    new IndexWriter(dir, new StandardAnalyzer(), true).close();
+    SegmentInfos infos = new SegmentInfos();
+    assertEquals(DefaultIndexFormat.ID, infos.readIndexFormat(dir));
+    infos.checkIndexFormat(dir);
+  }
+
+  public void testConflictIndexFmt() throws Exception {
+    RAMDirectory dir = new RAMDirectory(new DefaultIndexFormat());
+    new IndexWriter(dir, new StandardAnalyzer(), true).close();
+    //simulate another index format
+    if (dir.fileExists(IndexFileNames.INDEXFORMAT)) {
+      dir.deleteFile(IndexFileNames.INDEXFORMAT);
+    }
+    IndexOutput out = dir.createOutput(IndexFileNames.INDEXFORMAT);
+    out.writeString(FakeIndexFmt.ID);
+    out.close();
+
+    SegmentInfos infos = new SegmentInfos();
+    assertEquals(FakeIndexFmt.ID, infos.readIndexFormat(dir));
+    try {
+      infos.checkIndexFormat(dir);
+      fail("checking the index format must fail if the index format is not compatible");
+    } catch (IllegalStateException e) {
+      // catched  : OK
+    }
+  }
+
+  public void testExtendingIndexFmt() throws Exception {
+    RAMDirectory dir = new RAMDirectory(new ExtendDefaultIndexFmt());
+    new IndexWriter(dir, new StandardAnalyzer(), true).close();
+    //simulate another index format
+    if (dir.fileExists(IndexFileNames.INDEXFORMAT)) {
+      dir.deleteFile(IndexFileNames.INDEXFORMAT);
+    }
+    IndexOutput out = dir.createOutput(IndexFileNames.INDEXFORMAT);
+    out.writeString(DefaultIndexFormat.ID);
+    out.close();
+
+    SegmentInfos infos = new SegmentInfos();
+    assertEquals(DefaultIndexFormat.ID, infos.readIndexFormat(dir));
+    infos.checkIndexFormat(dir); // ExtendDefaultIndexFmt extends DefaultIndexFormat : should be OK
+
+    //now check the reverse : must fail
+    dir = new RAMDirectory(new DefaultIndexFormat());
+    new IndexWriter(dir, new StandardAnalyzer(), true).close();
+    //simulate another index format
+    if (dir.fileExists(IndexFileNames.INDEXFORMAT)) {
+      dir.deleteFile(IndexFileNames.INDEXFORMAT);
+    }
+    out = dir.createOutput(IndexFileNames.INDEXFORMAT);
+    out.writeString("org.apache.lucene.index.TestIndexFormat.ExtendDefaultIndexFmt");
+    out.close();
+
+    infos = new SegmentInfos();
+    assertEquals("org.apache.lucene.index.TestIndexFormat.ExtendDefaultIndexFmt", infos.readIndexFormat(dir));
+    try {
+      infos.checkIndexFormat(dir);
+      fail("checking the index format must fail if the index format is not compatible");
+    } catch (IllegalStateException e) {
+      // catched  : OK
+    }
+  }
+
+  public void testMerge() throws Exception {
+    RAMDirectory dir = new RAMDirectory(new DefaultIndexFormat());
+    new IndexWriter(dir, new StandardAnalyzer(), true).close();
+
+    RAMDirectory dirDefault = new RAMDirectory(new DefaultIndexFormat());
+    new IndexWriter(dirDefault, new StandardAnalyzer(), true).close();
+
+    RAMDirectory dirFake = new RAMDirectory(new FakeIndexFmt());
+    new IndexWriter(dirFake, new StandardAnalyzer(), true).close();
+
+    RAMDirectory dirExtend = new RAMDirectory(new ExtendDefaultIndexFmt());
+    new IndexWriter(dirExtend, new StandardAnalyzer(), true).close();
+
+    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), false);
+    writer.addIndexes(new Directory[] { dirDefault });
+    writer.close();
+
+    writer = new IndexWriter(dir, new StandardAnalyzer(), false);
+    try {
+      writer.addIndexes(new Directory[] { dirFake });
+      fail("merging incomaptible directory must fail");
+    } catch (IncompatibleFormatException e) {
+      //catched : OK
+    }
+    writer.close();
+
+    writer = new IndexWriter(dirExtend, new StandardAnalyzer(), false);
+    writer.addIndexes(new Directory[] { dir });
+    writer.close();
+
+    //now test with readers
+
+    writer = new IndexWriter(dir, new StandardAnalyzer(), false);
+    writer.addIndexes(new IndexReader[] { IndexReader.open(dirDefault) });
+    writer.close();
+
+    writer = new IndexWriter(dir, new StandardAnalyzer(), false);
+    try {
+      writer.addIndexes(new IndexReader[] { IndexReader.open(dirFake) });
+      fail("merging incomaptible directory must fail");
+    } catch (IncompatibleFormatException e) {
+      //catched : OK
+    }
+    writer.close();
+
+    writer = new IndexWriter(dirExtend, new StandardAnalyzer(), false);
+    writer.addIndexes(new IndexReader[] { IndexReader.open(dir) });
+    writer.close();
+
+    //now test without optimization
+
+    writer = new IndexWriter(dir, new StandardAnalyzer(), false);
+    writer.addIndexesNoOptimize(new Directory[] { dirDefault });
+    writer.close();
+
+    writer = new IndexWriter(dir, new StandardAnalyzer(), false);
+    try {
+      writer.addIndexesNoOptimize(new Directory[] { dirFake });
+      fail("merging incomaptible directory must fail");
+    } catch (IncompatibleFormatException e) {
+      //catched : OK
+    }
+    writer.close();
+
+    writer = new IndexWriter(dirExtend, new StandardAnalyzer(), false);
+    writer.addIndexesNoOptimize(new Directory[] { dir });
+    writer.close();
+  }
+
+  class FakeIndexFmt extends DefaultIndexFormat {
+
+    public static final String ID = "This is fake !!";
+
+    public boolean canRead(String indexFmtName) {
+      return getID().equals(indexFmtName);
+    }
+
+    public String getID() {
+      return ID;
+    }
+
+  }
+
+  class ExtendDefaultIndexFmt extends DefaultIndexFormat {
+
+    public boolean canRead(String indexFmtName) {
+      return getID().equals(indexFmtName) || DefaultIndexFormat.ID.equals(indexFmtName);
+    }
+
+  }
+}

Modification de propriétés sur src/test/org/apache/lucene/index/TestIndexFormat.java
___________________________________________________________________
Nom : svn:keywords
   + Date Revision Author HeadURL Id
Nom : svn:eol-style
   + native

Index: src/java/org/apache/lucene/index/CompoundFileReader.java
===================================================================
--- src/java/org/apache/lucene/index/CompoundFileReader.java	(révision 524580)
+++ src/java/org/apache/lucene/index/CompoundFileReader.java	(copie de travail)
@@ -55,6 +55,7 @@
     throws IOException
     {
         directory = dir;
+        setIndexFormat(dir.getIndexFormat());
         fileName = name;
 
         boolean success = false;
Index: src/java/org/apache/lucene/index/IndexFormat.java
===================================================================
--- src/java/org/apache/lucene/index/IndexFormat.java	(révision 0)
+++ src/java/org/apache/lucene/index/IndexFormat.java	(révision 0)
@@ -0,0 +1,96 @@
+package org.apache.lucene.index;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.store.Directory;
+
+/**
+ * Specify the format of index.
+ * <p>
+ * The implementation of the {@link FieldsReader} and {@link FieldsWriter} returned by
+ * the function getFieldsReader and getFieldsWriter will specify how the data of fields are
+ * serialized, and also the kind of {@link Fieldable} used.
+ * <p>
+ * The implementation of the {@link PostingReader} and {@link PostingWriter} returned by
+ * the function getPostingReader and getPostingWriter will specify how the indexed data are
+ * serialized and retreived.
+ *
+ * $Id$
+ */
+public interface IndexFormat {
+
+  /**
+   * Get the ID of the index format. The ID must be unique, the use of the canonical
+   * class name is prefered.
+   * 
+   * @return the ID
+   */
+  String getID();
+
+  /**
+   * State if the current index format can read a segment from the other specified index format
+   * 
+   * @param indexFmtID the other index format ID 
+   * @return <code>true</code> if it can read it
+   */
+  boolean canRead(String indexFmtID);
+
+  /**
+   * This array contains all filename extensions used by
+   * Lucene's index files, with two exceptions, namely the
+   * extension made up from <code>.f</code> + a number and
+   * from <code>.s</code> + a number.  Also note that
+   * Lucene's <code>segments_N</code> files do not have any
+   * filename extension.
+   * 
+   * @return a List of String
+   */
+  Set getIndexExtensions();
+
+  /**
+   * File extensions that are added to a compound file
+   * (same as above, minus "del", "gen", "cfs").
+   * 
+   * @return a List of String
+   */
+  Set getIndexExtensionsInCounpoundFile();
+
+  /**
+   * File extensions of old-style index files
+   * 
+   * @return a List of String
+   */
+  Set getCompoundExtensions();
+
+  /**
+   * File extensions for term vector support
+   * 
+   * @return a List of String
+   */
+  Set getVectorExtensions();
+
+  /**
+   * 
+   * @return the index file name filter associated to this index format
+   */
+  IndexFileNameFilter getIndexFileNameFilter();
+}
Index: src/java/org/apache/lucene/index/DefaultIndexFormat.java
===================================================================
--- src/java/org/apache/lucene/index/DefaultIndexFormat.java	(révision 0)
+++ src/java/org/apache/lucene/index/DefaultIndexFormat.java	(révision 0)
@@ -0,0 +1,94 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.index;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.lucene.store.Directory;
+
+/**
+ * The default implementation of the index format
+ * 
+ * $Id$
+ */
+public class DefaultIndexFormat implements IndexFormat {
+
+  protected static final Set INDEX_EXTENSIONS = new HashSet(Arrays.asList(new String[] {
+      "cfs", "fnm", "fdx", "fdt", "tii", "tis", "frq", "prx", "del",
+      "tvx", "tvd", "tvf", "gen", "nrm" 
+  }));
+
+  protected static final Set INDEX_EXTENSIONS_IN_COMPOUND_FILE = new HashSet(Arrays.asList(new String[] {
+      "fnm", "fdx", "fdt", "tii", "tis", "frq", "prx",
+      "tvx", "tvd", "tvf", "nrm" 
+  }));
+
+  protected static final Set COMPOUND_EXTENSIONS = new HashSet(Arrays.asList(new String[] {
+      "fnm", "frq", "prx", "fdx", "fdt", "tii", "tis"
+  }));
+
+  protected static final Set VECTOR_EXTENSIONS = new HashSet(Arrays.asList(new String[] {
+      "tvx", "tvd", "tvf"
+  }));
+
+  private IndexFileNameFilter indexFileNameFilter;
+
+  /** the ID of the default format */
+  public static final String ID = DefaultIndexFormat.class.getName();
+
+  /**
+   * Can only read indexes of the exact same format.
+   */
+  public boolean canRead(String indexFmtName) {
+    return getID().equals(indexFmtName);
+  }
+
+  /**
+   * The ID is the canonical class name
+   */
+  public String getID() {
+    return getClass().getName();
+  }
+
+  public Set getIndexExtensions() {
+    return INDEX_EXTENSIONS;
+  }
+
+  public Set getIndexExtensionsInCounpoundFile() {
+    return INDEX_EXTENSIONS_IN_COMPOUND_FILE;
+  }
+
+  public Set getCompoundExtensions() {
+    return COMPOUND_EXTENSIONS;
+  }
+
+  public Set getVectorExtensions() {
+    return VECTOR_EXTENSIONS;
+  }
+
+  public IndexFileNameFilter getIndexFileNameFilter() {
+    if (indexFileNameFilter == null) {
+      indexFileNameFilter = new IndexFileNameFilter(this);
+    }
+    return indexFileNameFilter;
+  }
+
+}

Modification de propriétés sur src/java/org/apache/lucene/index/DefaultIndexFormat.java
___________________________________________________________________
Nom : svn:mime-type
   + text/plain
Nom : svn:keywords
   + Date Revision Author HeadURL Id
Nom : svn:eol-style
   + native

Index: src/java/org/apache/lucene/index/IndexFileNames.java
===================================================================
--- src/java/org/apache/lucene/index/IndexFileNames.java	(révision 524583)
+++ src/java/org/apache/lucene/index/IndexFileNames.java	(copie de travail)
@@ -49,36 +49,9 @@
 
   /** Extension of separate norms */
   static final String SEPARATE_NORMS_EXTENSION = "s";
-
-  /**
-   * This array contains all filename extensions used by
-   * Lucene's index files, with two exceptions, namely the
-   * extension made up from <code>.f</code> + a number and
-   * from <code>.s</code> + a number.  Also note that
-   * Lucene's <code>segments_N</code> files do not have any
-   * filename extension.
-   */
-  static final String INDEX_EXTENSIONS[] = new String[] {
-      "cfs", "fnm", "fdx", "fdt", "tii", "tis", "frq", "prx", "del",
-      "tvx", "tvd", "tvf", "gen", "nrm" 
-  };
-
-  /** File extensions that are added to a compound file
-   * (same as above, minus "del", "gen", "cfs"). */
-  static final String[] INDEX_EXTENSIONS_IN_COMPOUND_FILE = new String[] {
-      "fnm", "fdx", "fdt", "tii", "tis", "frq", "prx",
-      "tvx", "tvd", "tvf", "nrm" 
-  };
   
-  /** File extensions of old-style index files */
-  static final String COMPOUND_EXTENSIONS[] = new String[] {
-    "fnm", "frq", "prx", "fdx", "fdt", "tii", "tis"
-  };
-  
-  /** File extensions for term vector support */
-  static final String VECTOR_EXTENSIONS[] = new String[] {
-    "tvx", "tvd", "tvf"
-  };
+  /** Name of the index format file */
+  static public final String INDEXFORMAT = "indexformat";
 
   /**
    * Computes the full file name from base, extension and
Index: src/java/org/apache/lucene/index/IncompatibleFormatException.java
===================================================================
--- src/java/org/apache/lucene/index/IncompatibleFormatException.java	(révision 0)
+++ src/java/org/apache/lucene/index/IncompatibleFormatException.java	(révision 0)
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.index;
+
+
+/**
+ * Exception raised when some Lucene operation cannot be realized due
+ * to incompatible index formats. It can appear while trying to merge.
+ * 
+ * $Id$
+ */
+public class IncompatibleFormatException extends RuntimeException {
+
+  public IncompatibleFormatException() {
+    super();
+  }
+
+  public IncompatibleFormatException(String message) {
+    super(message);
+  }
+}

Modification de propriétés sur src/java/org/apache/lucene/index/IncompatibleFormatException.java
___________________________________________________________________
Nom : svn:mime-type
   + text/plain
Nom : svn:keywords
   + Date Revision Author HeadURL Id
Nom : svn:eol-style
   + native

Index: src/java/org/apache/lucene/index/SegmentInfos.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfos.java	(révision 524580)
+++ src/java/org/apache/lucene/index/SegmentInfos.java	(copie de travail)
@@ -17,16 +17,16 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.store.IndexOutput;
-
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.Vector;
 
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+
 final class SegmentInfos extends Vector {
   
   
@@ -179,6 +179,65 @@
   }
 
   /**
+   * Check the index format of the directory.
+   * <ul>
+   *   <li>if there is no index format written in the directory : write the instanciated one</li>
+   *   <li>else : check that the instanciated one can read the written one</li>
+   * </ul>
+   * 
+   * @param dir the directory to check
+   * @throws IOException
+   */
+  void checkIndexFormat(Directory dir) throws IOException {
+    String indexFormatName = readIndexFormat(dir);
+    if (dir.getIndexFormat() == null) {
+      throw new IllegalStateException("A directory must have an index format declared");
+    }
+    if (indexFormatName == null) { // no written index format
+      writeIndexFormat(dir); // so write it
+    } else {
+      // an format has been written, check the compatibility
+      if (!dir.getIndexFormat().canRead(indexFormatName)) {
+        throw new IllegalStateException("The IndexFormat instanciated with the directory '"
+            + dir.getIndexFormat().getClass().getCanonicalName()
+            + "' is not compatible with the actual format of the index : '" + indexFormatName + "'");
+      }
+    }
+  }
+
+  /**
+   * Write the index format in the directory
+   * 
+   * @param dir the directory to write in
+   * @throws IOException
+   */
+  void writeIndexFormat(Directory dir) throws IOException {
+    if (dir.fileExists(IndexFileNames.INDEXFORMAT)) {
+      dir.deleteFile(IndexFileNames.INDEXFORMAT);
+    }
+    IndexOutput out = dir.createOutput(IndexFileNames.INDEXFORMAT);
+    out.writeString(dir.getIndexFormat().getID());
+    out.close();
+  }
+
+  /**
+   * Read the index format from the directory
+   * 
+   * @param dir the directory to read
+   * @return the canonical class name of the index format
+   * @throws IOException
+   */
+  String readIndexFormat(Directory dir) throws IOException {
+    if (!dir.fileExists(IndexFileNames.INDEXFORMAT)) {
+      return null;
+    }
+    IndexInput in = dir.openInput(IndexFileNames.INDEXFORMAT);
+    String fmt = in.readString();
+    in.close();
+    return fmt;
+  }
+
+  /**
    * Read a particular segmentFileName.  Note that this may
    * throw an IOException if a commit is in process.
    *
@@ -235,9 +294,12 @@
    * commits) to find the right segments file to load.
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
+   * @throws ClassNotFoundException when the written index format doesn't exist in the classpath
    */
   public final void read(Directory directory) throws CorruptIndexException, IOException {
 
+    checkIndexFormat(directory);
+
     generation = lastGeneration = -1;
 
     new FindSegmentsFile(directory) {
Index: src/java/org/apache/lucene/index/SegmentMerger.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentMerger.java	(révision 524584)
+++ src/java/org/apache/lucene/index/SegmentMerger.java	(copie de travail)
@@ -17,10 +17,11 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Set;
 import java.util.Vector;
-import java.util.Iterator;
-import java.util.Collection;
-import java.io.IOException;
 
 import org.apache.lucene.document.FieldSelector;
 import org.apache.lucene.document.FieldSelectorResult;
@@ -51,7 +52,7 @@
   private Vector readers = new Vector();
   private FieldInfos fieldInfos;
 
-  /** This ctor used only by test code.
+  /** This constructor is used only by test code.
    * 
    * @param dir The Directory to merge the other segments into
    * @param name The name of the new segment
@@ -120,12 +121,14 @@
     CompoundFileWriter cfsWriter =
             new CompoundFileWriter(directory, fileName);
 
-    Vector files =
-      new Vector(IndexFileNames.COMPOUND_EXTENSIONS.length + 1);    
-    
+    Set compoundExtensions = directory.getIndexFormat().getCompoundExtensions();
+
+    Vector files = new Vector(compoundExtensions.size() + 1);
+
     // Basic files
-    for (int i = 0; i < IndexFileNames.COMPOUND_EXTENSIONS.length; i++) {
-      files.add(segment + "." + IndexFileNames.COMPOUND_EXTENSIONS[i]);
+    Iterator cpompoundIt = compoundExtensions.iterator();
+    while (cpompoundIt.hasNext()) {
+      files.add(segment + "." + cpompoundIt.next());
     }
 
     // Fieldable norm files
@@ -137,10 +140,13 @@
       }
     }
 
+    Set vectorExtensions = directory.getIndexFormat().getVectorExtensions();
+
     // Vector files
     if (fieldInfos.hasVectors()) {
-      for (int i = 0; i < IndexFileNames.VECTOR_EXTENSIONS.length; i++) {
-        files.add(segment + "." + IndexFileNames.VECTOR_EXTENSIONS[i]);
+      Iterator vectorIt = vectorExtensions.iterator();
+      while (vectorIt.hasNext()) {
+        files.add(segment + "." + vectorIt.next());
       }
     }
 
Index: src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexWriter.java	(révision 524584)
+++ src/java/org/apache/lucene/index/IndexWriter.java	(copie de travail)
@@ -209,7 +209,7 @@
 
   SegmentInfos segmentInfos = new SegmentInfos();       // the segments
   SegmentInfos ramSegmentInfos = new SegmentInfos();    // the segments in ramDirectory
-  private final RAMDirectory ramDirectory = new RAMDirectory(); // for temp segs
+  private RAMDirectory ramDirectory; // for temp segs
   private IndexFileDeleter deleter;
 
   private Lock writeLock;
@@ -565,6 +565,7 @@
 
   private void init(Directory d, Analyzer a, final boolean create, boolean closeDir, IndexDeletionPolicy deletionPolicy, boolean autoCommit)
     throws CorruptIndexException, LockObtainFailedException, IOException {
+    ramDirectory = new RAMDirectory(d.getIndexFormat());
     this.closeDir = closeDir;
     directory = d;
     analyzer = a;
@@ -1370,11 +1371,23 @@
    * for details.</p>
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
+   * @throws IncompatibleFormatException if one of the directory
+   * cannot be read by the index format of the writer
    */
   public synchronized void addIndexes(Directory[] dirs)
-    throws CorruptIndexException, IOException {
+    throws CorruptIndexException, IOException, IncompatibleFormatException {
 
     ensureOpen();
+
+    //check that every reader can be read 
+    for (int i = 0; i < dirs.length; i++) {
+      String dirFmtID = dirs[i].getIndexFormat().getID();
+      if (!directory.getIndexFormat().canRead(dirFmtID)) {
+        throw new IncompatibleFormatException("The " + i + "th directory has the index format '" + dirFmtID
+            + "' which is incompatible with the writer's index format + '" + directory.getIndexFormat().getID() + "'");
+      }
+    }
+
     optimize();					  // start with zero or 1 seg
 
     int start = segmentInfos.size();
@@ -1429,9 +1442,11 @@
    * on an Exception.</p>
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
+   * @throws IncompatibleFormatException if one of the directory
+   * cannot be read by the index format of the writer
    */
   public synchronized void addIndexesNoOptimize(Directory[] dirs)
-      throws CorruptIndexException, IOException {
+      throws CorruptIndexException, IOException, IncompatibleFormatException {
     // Adding indexes can be viewed as adding a sequence of segments S to
     // a sequence of segments T. Segments in T follow the invariants but
     // segments in S may not since they could come from multiple indexes.
@@ -1458,6 +1473,15 @@
     // copy a segment, which may cause doc count to change because deleted
     // docs are garbage collected.
 
+    // 0 check that every reader can be read 
+    for (int i = 0; i < dirs.length; i++) {
+      String dirFmtID = dirs[i].getIndexFormat().getID();
+      if (!directory.getIndexFormat().canRead(dirFmtID)) {
+        throw new IncompatibleFormatException("The " + i + "th directory has the index format '" + dirFmtID
+            + "' which is incompatible with the writer's index format + '" + directory.getIndexFormat().getID() + "'");
+      }
+    }
+
     // 1 flush ram segments
 
     ensureOpen();
@@ -1560,11 +1584,23 @@
    * on an Exception.</p>
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
+   * @throws IncompatibleFormatException if one of the reader
+   * cannot be read by the index format of the writer
    */
   public synchronized void addIndexes(IndexReader[] readers)
-    throws CorruptIndexException, IOException {
+    throws CorruptIndexException, IOException, IncompatibleFormatException {
 
     ensureOpen();
+
+    //check that every reader can be read 
+    for (int i = 0; i < readers.length; i++) {
+      String readerFmtID = readers[i].directory().getIndexFormat().getID();
+      if (!directory.getIndexFormat().canRead(readerFmtID)) {
+        throw new IncompatibleFormatException("The " + i + "th reader has the index format '" + readerFmtID
+            + "' which is incompatible with the writer's index format + '" + directory.getIndexFormat().getID() + "'");
+      }
+    }
+
     optimize();					  // start with zero or 1 seg
 
     final String mergedName = newSegmentName();
Index: src/java/org/apache/lucene/index/IndexFileDeleter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexFileDeleter.java	(révision 524580)
+++ src/java/org/apache/lucene/index/IndexFileDeleter.java	(copie de travail)
@@ -126,7 +126,7 @@
     // First pass: walk the files and initialize our ref
     // counts:
     long currentGen = segmentInfos.getGeneration();
-    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();
+    IndexFileNameFilter filter = directory.getIndexFormat().getIndexFileNameFilter();
 
     String[] files = directory.list();
     if (files == null)
@@ -258,7 +258,7 @@
     String[] files = directory.list();
     if (files == null)
       throw new IOException("cannot read directory " + directory + ": list() returned null");
-    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();
+    IndexFileNameFilter filter = directory.getIndexFormat().getIndexFileNameFilter();
     for(int i=0;i<files.length;i++) {
       String fileName = files[i];
       if (filter.accept(null, fileName) && !refCounts.containsKey(fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {
Index: src/java/org/apache/lucene/index/SegmentInfo.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfo.java	(révision 524580)
+++ src/java/org/apache/lucene/index/SegmentInfo.java	(copie de travail)
@@ -21,8 +21,10 @@
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.IndexInput;
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.List;
 import java.util.ArrayList;
+import java.util.Set;
 
 final class SegmentInfo {
 
@@ -409,8 +411,9 @@
     if (useCompoundFile) {
       files.add(name + "." + IndexFileNames.COMPOUND_FILE_EXTENSION);
     } else {
-      for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE.length; i++) {
-        String ext = IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE[i];
+      Iterator extensionsIt = dir.getIndexFormat().getIndexExtensionsInCounpoundFile().iterator();
+      while (extensionsIt.hasNext()) {
+        String ext = (String) extensionsIt.next();
         String fileName = name + "." + ext;
         if (dir.fileExists(fileName)) {
           files.add(fileName);
Index: src/java/org/apache/lucene/index/IndexFileNameFilter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexFileNameFilter.java	(révision 524580)
+++ src/java/org/apache/lucene/index/IndexFileNameFilter.java	(copie de travail)
@@ -19,7 +19,7 @@
 
 import java.io.File;
 import java.io.FilenameFilter;
-import java.util.HashSet;
+import java.util.Set;
 
 /**
  * Filename filter that accept filenames and extensions only created by Lucene.
@@ -29,19 +29,17 @@
  */
 public class IndexFileNameFilter implements FilenameFilter {
 
-  static IndexFileNameFilter singleton = new IndexFileNameFilter();
-  private HashSet extensions;
-  private HashSet extensionsInCFS;
+  private Set extensions;
+  private Set extensionsInCFS;
 
-  public IndexFileNameFilter() {
-    extensions = new HashSet();
-    for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS.length; i++) {
-      extensions.add(IndexFileNames.INDEX_EXTENSIONS[i]);
-    }
-    extensionsInCFS = new HashSet();
-    for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE.length; i++) {
-      extensionsInCFS.add(IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE[i]);
-    }
+  /**
+   * Contructor
+   * 
+   * @param indexFormat the format of the index
+   */
+  public IndexFileNameFilter(IndexFormat indexFormat) {
+    extensions = indexFormat.getIndexExtensions();
+    extensionsInCFS = indexFormat.getIndexExtensionsInCounpoundFile();
   }
 
   /* (non-Javadoc)
@@ -87,8 +85,4 @@
     }
     return false;
   }
-
-  public static IndexFileNameFilter getFilter() {
-    return singleton;
-  }
 }
Index: src/java/org/apache/lucene/store/RAMDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/RAMDirectory.java	(révision 524580)
+++ src/java/org/apache/lucene/store/RAMDirectory.java	(copie de travail)
@@ -17,14 +17,17 @@
  * limitations under the License.
  */
 
+import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.io.FileNotFoundException;
-import java.io.File;
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Set;
 
+import org.apache.lucene.index.DefaultIndexFormat;
+import org.apache.lucene.index.IndexFormat;
+
 /**
  * A memory-resident {@link Directory} implementation.  Locking
  * implementation is by default the {@link SingleInstanceLockFactory}
@@ -43,8 +46,21 @@
   // Lock acquisition sequence:  RAMDirectory, then RAMFile
   // *****
 
-  /** Constructs an empty {@link Directory}. */
+  /**
+   * Constructs an empty {@link Directory}.
+   * The index format used the the default one 
+   */
   public RAMDirectory() {
+    this(new DefaultIndexFormat());
+  }
+
+  /**
+   * Contructor
+   * 
+   * @param indexFormat the format of the index
+   */
+  public RAMDirectory(IndexFormat indexFormat) {
+    setIndexFormat(indexFormat);
     setLockFactory(new SingleInstanceLockFactory());
   }
 
@@ -67,9 +83,9 @@
   public RAMDirectory(Directory dir) throws IOException {
     this(dir, false);
   }
-  
+
   private RAMDirectory(Directory dir, boolean closeDir) throws IOException {
-    this();
+    this(dir.getIndexFormat());
     Directory.copy(dir, this, closeDir);
   }
 
@@ -239,6 +255,22 @@
   public void close() {
     fileMap = null;
   }
+  
+  /**
+   * For debug purpose, list every files name of this directory.
+   * The code was commented because the lockID is based on the toString() function
+   */
+//  public String toString() {
+//    String[] f = list();
+//    StringBuffer buffer = new StringBuffer();
+//    for (int i = 0; i< f.length; i++) {
+//      buffer.append(f[i]);
+//      if (i != f.length - 1) {
+//        buffer.append(", ");
+//      }
+//    }
+//    return buffer.toString();
+//  }
 
   /**
    * @throws AlreadyClosedException if this IndexReader is closed
Index: src/java/org/apache/lucene/store/Directory.java
===================================================================
--- src/java/org/apache/lucene/store/Directory.java	(révision 524580)
+++ src/java/org/apache/lucene/store/Directory.java	(copie de travail)
@@ -19,6 +19,8 @@
 
 import java.io.IOException;
 
+import org.apache.lucene.index.IndexFormat;
+
 /** A Directory is a flat list of files.  Files may be written once, when they
  * are created.  Once a file is created it may only be opened for read, or
  * deleted.  Random access is permitted both when reading and writing.
@@ -42,6 +44,19 @@
    * this Directory instance). */
   protected LockFactory lockFactory;
 
+  private IndexFormat indexFormat;
+
+  public IndexFormat getIndexFormat() {
+    return indexFormat;
+  }
+
+  public void setIndexFormat(IndexFormat indexFormat) {
+    if (this.indexFormat != null) {
+      throw new IllegalStateException("The index format has already been set on the directory");
+    }
+    this.indexFormat = indexFormat;
+  }
+
   /** Returns an array of strings, one for each file in the
    * directory.  This method may return null (for example for
    * {@link FSDirectory} if the underlying directory doesn't
Index: src/java/org/apache/lucene/store/FSDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/FSDirectory.java	(révision 524580)
+++ src/java/org/apache/lucene/store/FSDirectory.java	(copie de travail)
@@ -26,9 +26,9 @@
 import java.security.NoSuchAlgorithmException;
 import java.util.Hashtable;
 
-import org.apache.lucene.index.IndexFileNameFilter;
-
-// Used only for WRITE_LOCK_NAME in deprecated create=true case:
+import org.apache.lucene.index.DefaultIndexFormat;
+import org.apache.lucene.index.IndexFormat;
+//Used only for WRITE_LOCK_NAME in deprecated create=true case:
 import org.apache.lucene.index.IndexWriter;
 
 /**
@@ -165,6 +165,16 @@
   public static FSDirectory getDirectory(File file, LockFactory lockFactory)
     throws IOException
   {
+    return getDirectory(file, lockFactory, new DefaultIndexFormat());
+  }
+  /** Returns the directory instance for the named location.
+   * @param file the path to the directory.
+   * @param lockFactory instance of {@link LockFactory} providing the
+   *        locking implementation.
+   * @return the FSDirectory for the named file.  */
+  public static FSDirectory getDirectory(File file, LockFactory lockFactory, IndexFormat indexFormat)
+    throws IOException
+  {
     file = new File(file.getCanonicalPath());
 
     if (file.exists() && !file.isDirectory())
@@ -183,7 +193,7 @@
         } catch (Exception e) {
           throw new RuntimeException("cannot load FSDirectory class: " + e.toString(), e);
         }
-        dir.init(file, lockFactory);
+        dir.init(file, lockFactory, indexFormat);
         DIRECTORIES.put(file, dir);
       } else {
         // Catch the case where a Directory is pulled from the cache, but has a
@@ -237,7 +247,7 @@
 
   private void create() throws IOException {
     if (directory.exists()) {
-      String[] files = directory.list(IndexFileNameFilter.getFilter());            // clear old files
+      String[] files = directory.list(getIndexFormat().getIndexFileNameFilter());            // clear old files
       if (files == null)
         throw new IOException("cannot read directory " + directory.getAbsolutePath() + ": list() returned null");
       for (int i = 0; i < files.length; i++) {
@@ -254,13 +264,14 @@
 
   protected FSDirectory() {};                     // permit subclassing
 
-  private void init(File path, LockFactory lockFactory) throws IOException {
+  private void init(File path, LockFactory lockFactory, IndexFormat indexFormat) throws IOException {
 
     // Set up lockFactory with cascaded defaults: if an instance was passed in,
     // use that; else if locks are disabled, use NoLockFactory; else if the
     // system property org.apache.lucene.store.FSDirectoryLockFactoryClass is set,
     // instantiate that; else, use SimpleFSLockFactory:
 
+    setIndexFormat(indexFormat);
     directory = path;
 
     boolean doClearLockID = false;
@@ -317,7 +328,7 @@
 
   /** Returns an array of strings, one for each Lucene index file in the directory. */
   public String[] list() {
-    return directory.list(IndexFileNameFilter.getFilter());
+    return directory.list(getIndexFormat().getIndexFileNameFilter());
   }
 
   /** Returns true iff a file with the given name exists. */
