diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java
index 54ec424fdcb..1f0c875a301 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java
@@ -23,9 +23,7 @@ import java.util.Iterator;
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.DocValuesConsumer;
 import org.apache.lucene.codecs.DocValuesProducer;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentWriteState;
+import org.apache.lucene.index.*;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
@@ -38,6 +36,8 @@ import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.SORTED_NUM
 import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.SORTED_SET;
 import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.SORTED_SET_SINGLETON;
 import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.VERSION_CURRENT;
+import static org.apache.lucene.index.SortedSetDocValues.NO_MORE_ORDS;
+import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;
 
 /**
  * Writer for {@link DirectDocValuesFormat}
@@ -69,7 +69,46 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
   public void addNumericField(FieldInfo field, DocValuesProducer valuesProducer) throws IOException {
     meta.writeVInt(field.number);
     meta.writeByte(NUMBER);
-    addNumericFieldValues(field, LegacyDocValuesIterables.numericIterable(field, valuesProducer, maxDoc));
+    addNumericFieldValues(field, () -> {
+      final NumericDocValues values;
+      try {
+        values = valuesProducer.getNumeric(field);
+      } catch (IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
+
+      return new Iterator<Number>() {
+        private int docIDUpto = -1;
+
+        @Override
+        public boolean hasNext() {
+          return docIDUpto + 1 < maxDoc;
+        }
+
+        @Override
+        public Number next() {
+          docIDUpto++;
+          if (docIDUpto > values.docID()) {
+            try {
+              values.nextDoc();
+            } catch (IOException ioe) {
+              throw new RuntimeException(ioe);
+            }
+          }
+          Number result;
+          if (docIDUpto == values.docID()) {
+            try {
+              result = values.longValue();
+            } catch (IOException ioe) {
+              throw new RuntimeException(ioe);
+            }
+          } else {
+            result = null;
+          }
+          return result;
+        }
+      };
+    });
   }
 
   private void addNumericFieldValues(FieldInfo field, Iterable<Number> values) throws IOException {
@@ -93,7 +132,7 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
       }
     }
     meta.writeInt((int) count);
-    
+
     if (missing) {
       long start = data.getFilePointer();
       writeMissingBitset(values);
@@ -124,22 +163,22 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
       }
 
       switch(byteWidth) {
-      case 1:
-        data.writeByte((byte) v);
-        break;
-      case 2:
-        data.writeShort((short) v);
-        break;
-      case 4:
-        data.writeInt((int) v);
-        break;
-      case 8:
-        data.writeLong(v);
-        break;
+        case 1:
+          data.writeByte((byte) v);
+          break;
+        case 2:
+          data.writeShort((short) v);
+          break;
+        case 4:
+          data.writeInt((int) v);
+          break;
+        case 8:
+          data.writeLong(v);
+          break;
       }
     }
   }
-  
+
   @Override
   public void close() throws IOException {
     boolean success = false;
@@ -166,7 +205,47 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
   public void addBinaryField(FieldInfo field, final DocValuesProducer valuesProducer) throws IOException {
     meta.writeVInt(field.number);
     meta.writeByte(BYTES);
-    addBinaryFieldValues(field, LegacyDocValuesIterables.binaryIterable(field, valuesProducer, maxDoc));
+    addBinaryFieldValues(field, () -> {
+      final BinaryDocValues values;
+      try {
+        values = valuesProducer.getBinary(field);
+      } catch (IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
+
+      return new Iterator<BytesRef>() {
+        private int docIDUpto = -1;
+
+        @Override
+        public boolean hasNext() {
+          return docIDUpto + 1 < maxDoc;
+        }
+
+        @Override
+        public BytesRef next() {
+          docIDUpto++;
+          if (docIDUpto > values.docID()) {
+            try {
+              values.nextDoc();
+            } catch (IOException ioe) {
+              throw new RuntimeException(ioe);
+            }
+          }
+          BytesRef result;
+          if (docIDUpto == values.docID()) {
+            try {
+              result = values.binaryValue();
+            } catch (IOException e) {
+              throw new RuntimeException(e);
+            }
+          } else {
+            result = null;
+          }
+          return result;
+        }
+      };
+
+    });
   }
 
   private void addBinaryFieldValues(FieldInfo field, final Iterable<BytesRef> values) throws IOException {
@@ -199,7 +278,7 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
     } else {
       meta.writeLong(-1L);
     }
-    
+
     int addr = 0;
     for (BytesRef v : values) {
       data.writeInt(addr);
@@ -209,7 +288,7 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
     }
     data.writeInt(addr);
   }
-  
+
   // TODO: in some cases representing missing with minValue-1 wouldn't take up additional space and so on,
   // but this is very simple, and algorithms only check this for values of 0 anyway (doesnt slow down normal decode)
   void writeMissingBitset(Iterable<?> values) throws IOException {
@@ -237,16 +316,161 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
     meta.writeByte(SORTED);
 
     // write the ordinals as numerics
-    addNumericFieldValues(field, LegacyDocValuesIterables.sortedOrdIterable(valuesProducer, field, maxDoc));
+    addNumericFieldValues(field, () -> {
+      final SortedDocValues values;
+      try {
+        values = valuesProducer.getSorted(field);
+      } catch (IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
+
+      return new Iterator<Number>() {
+        private int nextDocID;
+
+        @Override
+        public boolean hasNext() {
+          return nextDocID < maxDoc;
+        }
+
+        @Override
+        public Number next() {
+          try {
+            if (nextDocID > values.docID()) {
+              values.nextDoc();
+            }
+            int result;
+            if (nextDocID == values.docID()) {
+              result = values.ordValue();
+            } else {
+              result = -1;
+            }
+            nextDocID++;
+            return result;
+          } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+          }
+        }
+      };
+    });
     // write the values as binary
-    addBinaryFieldValues(field, LegacyDocValuesIterables.valuesIterable(valuesProducer.getSorted(field)));
+    addBinaryFieldValues(field, () -> {
+      final SortedDocValues values;
+      try {
+        values = valuesProducer.getSorted(field);
+      } catch (IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
+
+      return new Iterator<BytesRef>() {
+        private int nextOrd;
+
+        @Override
+        public boolean hasNext() {
+          return nextOrd < values.getValueCount();
+        }
+
+        @Override
+        public BytesRef next() {
+          try {
+            return values.lookupOrd(nextOrd++);
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        }
+      };
+    });
   }
-  
+
   @Override
   public void addSortedNumericField(FieldInfo field, final DocValuesProducer valuesProducer) throws IOException {
+    final Iterable<Number> docToValueCount = () -> {
+      final SortedNumericDocValues values;
+      try {
+        values = valuesProducer.getSortedNumeric(field);
+      } catch (IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
+
+      return new Iterator<Number>() {
+        private int nextDocID;
+
+        @Override
+        public boolean hasNext() {
+          return nextDocID < maxDoc;
+        }
+
+        @Override
+        public Number next() {
+          try {
+            if (nextDocID > values.docID()) {
+              values.nextDoc();
+            }
+            int result;
+            if (nextDocID == values.docID()) {
+              result = values.docValueCount();
+            } else {
+              result = 0;
+            }
+            nextDocID++;
+            return result;
+          } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+          }
+        }
+      };
+    };
+    final Iterable<Number> values = () -> {
+      final SortedNumericDocValues values1;
+      try {
+        values1 = valuesProducer.getSortedNumeric(field);
+      } catch (IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
 
-    final Iterable<Number> docToValueCount = LegacyDocValuesIterables.sortedNumericToDocCount(valuesProducer, field, maxDoc);
-    final Iterable<Number> values = LegacyDocValuesIterables.sortedNumericToValues(valuesProducer, field);
+      return new Iterator<Number>() {
+        private boolean nextIsSet;
+        private int nextCount;
+        private int upto;
+        private long nextValue;
+
+        private void setNext() {
+          try {
+            if (!nextIsSet) {
+              if (upto == nextCount) {
+                values1.nextDoc();
+                if (values1.docID() == NO_MORE_DOCS) {
+                  nextCount = 0;
+                  nextIsSet = false;
+                  return;
+                } else {
+                  nextCount = values1.docValueCount();
+                }
+                upto = 0;
+              }
+              nextValue = values1.nextValue();
+              upto++;
+              nextIsSet = true;
+            }
+          } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+          }
+        }
+
+        @Override
+        public boolean hasNext() {
+          setNext();
+          return nextCount != 0;
+        }
+
+        @Override
+        public Number next() {
+          setNext();
+          assert nextCount != 0;
+          nextIsSet = false;
+          return nextValue;
+        }
+      };
+    };
 
     meta.writeVInt(field.number);
     if (isSingleValued(docToValueCount)) {
@@ -269,20 +493,133 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
   // note: this might not be the most efficient... but it's fairly simple
   @Override
   public void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer) throws IOException {
-    Iterable<BytesRef> values = LegacyDocValuesIterables.valuesIterable(valuesProducer.getSortedSet(field));
-    Iterable<Number> docToOrdCount = LegacyDocValuesIterables.sortedSetOrdCountIterable(valuesProducer, field, maxDoc);
-    Iterable<Number> ords = LegacyDocValuesIterables.sortedSetOrdsIterable(valuesProducer, field);
-    
+    Iterable<BytesRef> values = () -> {
+      final SortedSetDocValues values1;
+      try {
+        values1 = valuesProducer.getSortedSet(field);
+      } catch (IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
+
+      return new Iterator<BytesRef>() {
+        private long nextOrd;
+
+        @Override
+        public boolean hasNext() {
+          return nextOrd < values1.getValueCount();
+        }
+
+        @Override
+        public BytesRef next() {
+          try {
+            return values1.lookupOrd(nextOrd++);
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        }
+      };
+    };
+    Iterable<Number> docToOrdCount = () -> {
+      final SortedSetDocValues values12;
+      try {
+        values12 = valuesProducer.getSortedSet(field);
+      } catch (IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
+
+      return new Iterator<Number>() {
+        private int nextDocID;
+        private int ordCount;
+
+        @Override
+        public boolean hasNext() {
+          return nextDocID < maxDoc;
+        }
+
+        @Override
+        public Number next() {
+          try {
+            if (nextDocID > values12.docID()) {
+              if (values12.nextDoc() != NO_MORE_DOCS) {
+                ordCount = 0;
+                while (values12.nextOrd() != NO_MORE_ORDS) {
+                  ordCount++;
+                }
+              }
+            }
+            int result;
+            if (nextDocID == values12.docID()) {
+              result = ordCount;
+            } else {
+              result = 0;
+            }
+            nextDocID++;
+            return result;
+          } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+          }
+        }
+      };
+    };
+    Iterable<Number> ords = () -> {
+      final SortedSetDocValues values13;
+      try {
+        values13 = valuesProducer.getSortedSet(field);
+      } catch (IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
+
+      return new Iterator<Number>() {
+        private boolean nextIsSet;
+        private long nextOrd;
+
+        private void setNext() {
+          try {
+            if (!nextIsSet) {
+              if (values13.docID() == -1) {
+                values13.nextDoc();
+              }
+              while (true) {
+                if (values13.docID() == NO_MORE_DOCS) {
+                  nextOrd = -1;
+                  break;
+                }
+                nextOrd = values13.nextOrd();
+                if (nextOrd != -1) {
+                  break;
+                }
+                values13.nextDoc();
+              }
+              nextIsSet = true;
+            }
+          } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+          }
+        }
+
+        @Override
+        public boolean hasNext() {
+          setNext();
+          return nextOrd != -1;
+        }
+
+        @Override
+        public Number next() {
+          setNext();
+          assert nextOrd != -1;
+          nextIsSet = false;
+          return nextOrd;
+        }
+      };
+
+    };
     meta.writeVInt(field.number);
-    
+
     if (isSingleValued(docToOrdCount)) {
       meta.writeByte(SORTED_SET_SINGLETON);
       // Write ordinals for all docs, appended into one big
       // numerics:
       addNumericFieldValues(field, singletonView(docToOrdCount, ords, -1L));
-      
-      // write the values as binary
-      addBinaryFieldValues(field, values);
     } else {
       meta.writeByte(SORTED_SET);
 
@@ -294,37 +631,38 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
       // Write ordinals for all docs, appended into one big
       // numerics:
       addNumericFieldValues(field, ords);
-      
-      // write the values as binary
-      addBinaryFieldValues(field, values);
+
     }
+
+    // write the values as binary
+    addBinaryFieldValues(field, values);
   }
-  
-  /** 
+
+  /**
    * Just aggregates the count values so they become
    * "addresses", and adds one more value in the end
    * (the final sum)
-   */ 
+   */
   private Iterable<Number> countToAddressIterator(final Iterable<Number> counts) {
     return new Iterable<Number>() {
       @Override
       public Iterator<Number> iterator() {
         final Iterator<Number> iter = counts.iterator();
-        
+
         return new Iterator<Number>() {
-          
+
           long sum;
           boolean ended;
-          
+
           @Override
           public boolean hasNext() {
             return iter.hasNext() || !ended;
           }
-          
+
           @Override
           public Number next() {
             long toReturn = sum;
-            
+
             if (iter.hasNext()) {
               Number n = iter.next();
               if (n != null) {
@@ -335,10 +673,10 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
             } else {
               assert false;
             }
-            
+
             return toReturn;
           }
-          
+
           @Override
           public void remove() {
             throw new UnsupportedOperationException();
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
index baef4dbf90b..0d9cdd1bc09 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
@@ -51,7 +51,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
   private final Map<String,SortedSetEntry> sortedSets = new HashMap<>();
   private final Map<String,SortedNumericEntry> sortedNumerics = new HashMap<>();
   private final IndexInput data;
-  
+
   // ram instances we have already loaded
   private final Map<String,NumericRawValues> numericInstances = new HashMap<>();
   private final Map<String,BinaryRawValues> binaryInstances = new HashMap<>();
@@ -59,15 +59,15 @@ class DirectDocValuesProducer extends DocValuesProducer {
   private final Map<String,SortedSetRawValues> sortedSetInstances = new HashMap<>();
   private final Map<String,SortedNumericRawValues> sortedNumericInstances = new HashMap<>();
   private final Map<String,FixedBitSet> docsWithFieldInstances = new HashMap<>();
-  
+
   private final int numEntries;
-  
+
   private final int maxDoc;
   private final AtomicLong ramBytesUsed;
   private final int version;
-  
+
   private final boolean merging;
-  
+
   static final byte NUMBER = 0;
   static final byte BYTES = 1;
   static final byte SORTED = 2;
@@ -78,7 +78,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
 
   static final int VERSION_START = 3;
   static final int VERSION_CURRENT = VERSION_START;
-  
+
   // clone for merge: when merging we don't do any instances.put()s
   DirectDocValuesProducer(DirectDocValuesProducer original) {
     assert Thread.holdsLock(original);
@@ -88,21 +88,21 @@ class DirectDocValuesProducer extends DocValuesProducer {
     sortedSets.putAll(original.sortedSets);
     sortedNumerics.putAll(original.sortedNumerics);
     data = original.data.clone();
-    
+
     numericInstances.putAll(original.numericInstances);
     binaryInstances.putAll(original.binaryInstances);
     sortedInstances.putAll(original.sortedInstances);
     sortedSetInstances.putAll(original.sortedSetInstances);
     sortedNumericInstances.putAll(original.sortedNumericInstances);
     docsWithFieldInstances.putAll(original.docsWithFieldInstances);
-    
+
     numEntries = original.numEntries;
     maxDoc = original.maxDoc;
     ramBytesUsed = new AtomicLong(original.ramBytesUsed.get());
     version = original.version;
     merging = true;
   }
-    
+
   DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {
     maxDoc = state.segmentInfo.maxDoc();
     merging = false;
@@ -112,8 +112,8 @@ class DirectDocValuesProducer extends DocValuesProducer {
     ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));
     boolean success = false;
     try {
-      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, 
-                                                 state.segmentInfo.getId(), state.segmentSuffix);
+      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT,
+              state.segmentInfo.getId(), state.segmentSuffix);
       numEntries = readFields(in, state.fieldInfos);
 
       CodecUtil.checkFooter(in);
@@ -131,11 +131,11 @@ class DirectDocValuesProducer extends DocValuesProducer {
     success = false;
     try {
       final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,
-                                                              state.segmentInfo.getId(), state.segmentSuffix);
+              state.segmentInfo.getId(), state.segmentSuffix);
       if (version != version2) {
         throw new CorruptIndexException("Format versions mismatch: meta=" + version + ", data=" + version2, data);
       }
-      
+
       // NOTE: data file is too costly to verify checksum against all the bytes on open,
       // but for now we at least verify proper structure of the checksum footer: which looks
       // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption
@@ -196,7 +196,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
     entry.values = readBinaryEntry(meta);
     return entry;
   }
-  
+
   private SortedNumericEntry readSortedNumericEntry(IndexInput meta, boolean singleton) throws IOException {
     SortedNumericEntry entry = new SortedNumericEntry();
     if (singleton == false) {
@@ -243,12 +243,10 @@ class DirectDocValuesProducer extends DocValuesProducer {
     return numEntries;
   }
 
-  @Override
   public long ramBytesUsed() {
     return ramBytesUsed.get();
   }
-  
-  @Override
+
   public synchronized Collection<Accountable> getChildResources() {
     List<Accountable> resources = new ArrayList<>();
     resources.addAll(Accountables.namedAccountables("numeric field", numericInstances));
@@ -259,7 +257,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
     resources.addAll(Accountables.namedAccountables("missing bitset field", docsWithFieldInstances));
     return Collections.unmodifiableList(resources);
   }
-  
+
   @Override
   public String toString() {
     return getClass().getSimpleName() + "(entries=" + numEntries + ")";
@@ -270,6 +268,74 @@ class DirectDocValuesProducer extends DocValuesProducer {
     CodecUtil.checksumEntireFile(data.clone());
   }
 
+  private static class NumericDocValuesSub extends NumericDocValues {
+    private final Bits docsWithField;
+    private final NumericRawValues values;
+    private final int maxDoc;
+    private int docID = -1;
+    private long value;
+
+    public NumericDocValuesSub(Bits docsWithField, NumericRawValues values) {
+      this.docsWithField = docsWithField;
+      this.values = values;
+      this.maxDoc = docsWithField.length();
+    }
+
+    @Override
+    public int docID() {
+      return docID;
+    }
+
+    @Override
+    public int nextDoc() {
+      docID++;
+      while (docID < maxDoc) {
+        value = values.get(docID);
+        if (value != 0 || docsWithField.get(docID)) {
+          return docID;
+        }
+        docID++;
+      }
+      docID = NO_MORE_DOCS;
+      return NO_MORE_DOCS;
+    }
+
+    @Override
+    public int advance(int target) {
+      assert target >= docID: "target=" + target + " docID=" + docID;
+      if (target == NO_MORE_DOCS) {
+        this.docID = NO_MORE_DOCS;
+      } else {
+        this.docID = target-1;
+        nextDoc();
+      }
+      return docID;
+    }
+
+    @Override
+    public boolean advanceExact(int target) throws IOException {
+      docID = target;
+      value = values.get(docID);
+      return value != 0 || docsWithField.get(docID);
+    }
+
+    @Override
+    public long cost() {
+      // TODO
+      return 0;
+    }
+
+    @Override
+    public long longValue() {
+      return value;
+    }
+
+    @Override
+    public String toString() {
+      return "LegacyNumericDocValuesWrapper(" + values + ")";
+    }
+  }
+
   @Override
   public synchronized NumericDocValues getNumeric(FieldInfo field) throws IOException {
     NumericRawValues instance = numericInstances.get(field.name);
@@ -282,82 +348,81 @@ class DirectDocValuesProducer extends DocValuesProducer {
         ramBytesUsed.addAndGet(instance.ramBytesUsed());
       }
     }
-    return new LegacyNumericDocValuesWrapper(getMissingBits(field, ne.missingOffset, ne.missingBytes), instance.numerics);
+    return new NumericDocValuesSub(getMissingBits(field, ne.missingOffset, ne.missingBytes), instance);
   }
-  
+
   private NumericRawValues loadNumeric(NumericEntry entry) throws IOException {
-    NumericRawValues ret = new NumericRawValues();
     IndexInput data = this.data.clone();
     data.seek(entry.offset + entry.missingBytes);
     switch (entry.byteWidth) {
-    case 1:
+      case 1:
       {
         final byte[] values = new byte[entry.count];
         data.readBytes(values, 0, entry.count);
-        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
-        ret.numerics = new LegacyNumericDocValues() {
+        NumericRawValues ret = new NumericRawValues() {
           @Override
-          public long get(int idx) {
-            return values[idx];
+          public long get(int docID) {
+            return values[docID];
           }
         };
+        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
         return ret;
       }
 
-    case 2:
+      case 2:
       {
         final short[] values = new short[entry.count];
         for(int i=0;i<entry.count;i++) {
           values[i] = data.readShort();
         }
-        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
-        ret.numerics = new LegacyNumericDocValues() {
+        NumericRawValues ret = new NumericRawValues() {
           @Override
-          public long get(int idx) {
-            return values[idx];
+          public long get(int docID) {
+            return values[docID];
           }
         };
+        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
         return ret;
       }
 
-    case 4:
+      case 4:
       {
         final int[] values = new int[entry.count];
         for(int i=0;i<entry.count;i++) {
           values[i] = data.readInt();
         }
-        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
-        ret.numerics = new LegacyNumericDocValues() {
+        NumericRawValues ret = new NumericRawValues() {
           @Override
-          public long get(int idx) {
-            return values[idx];
+          public long get(int docID) {
+            return values[docID];
           }
         };
+        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
         return ret;
       }
 
-    case 8:
+      case 8:
       {
         final long[] values = new long[entry.count];
         for(int i=0;i<entry.count;i++) {
           values[i] = data.readLong();
         }
-        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
-        ret.numerics = new LegacyNumericDocValues() {
+        NumericRawValues ret = new NumericRawValues() {
           @Override
-          public long get(int idx) {
-            return values[idx];
+          public long get(int docID) {
+            return values[docID];
           }
         };
+        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
         return ret;
       }
-    
-    default:
-      throw new AssertionError();
+
+      default:
+        throw new AssertionError();
     }
   }
 
-  private synchronized LegacyBinaryDocValues getLegacyBinary(FieldInfo field) throws IOException {
+  private synchronized BinaryRawValues getBinaryRawValues(FieldInfo field) throws IOException {
     BinaryRawValues instance = binaryInstances.get(field.name);
     if (instance == null) {
       // Lazy load
@@ -367,28 +432,69 @@ class DirectDocValuesProducer extends DocValuesProducer {
         ramBytesUsed.addAndGet(instance.ramBytesUsed());
       }
     }
-    final byte[] bytes = instance.bytes;
-    final int[] address = instance.address;
-
-    return new LegacyBinaryDocValues() {
-      final BytesRef term = new BytesRef();
 
-      @Override
-      public BytesRef get(int docID) {
-        term.bytes = bytes;
-        term.offset = address[docID];
-        term.length = address[docID+1] - term.offset;
-        return term;
-      }
-    };
+    return new BinaryRawValues(instance.bytes, instance.address);
   }
-  
+
   @Override
   public synchronized BinaryDocValues getBinary(FieldInfo field) throws IOException {
     BinaryEntry be = binaries.get(field.name);
-    return new LegacyBinaryDocValuesWrapper(getMissingBits(field, be.missingOffset, be.missingBytes), getLegacyBinary(field));
+    Bits docsWithField = getMissingBits(field, be.missingOffset, be.missingBytes);
+    BinaryRawValues values = getBinaryRawValues(field);
+    int maxDoc = docsWithField.length();
+    return new BinaryDocValues() {
+      private int docID = -1;
+
+      @Override
+      public BytesRef binaryValue() throws IOException {
+        return values.get(docID);
+      }
+
+      @Override
+      public boolean advanceExact(int target) throws IOException {
+        docID = target;
+        return docsWithField.get(target);
+      }
+
+      @Override
+      public int docID() {
+        return docID;
+      }
+
+      @Override
+      public int nextDoc() throws IOException {
+        docID++;
+        while (docID < maxDoc) {
+          if (docsWithField.get(docID)) {
+            return docID;
+          }
+          docID++;
+        }
+        docID = NO_MORE_DOCS;
+        return NO_MORE_DOCS;
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+        if (target < docID) {
+          throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+        }
+        if (target == NO_MORE_DOCS) {
+          this.docID = NO_MORE_DOCS;
+        } else {
+          this.docID = target-1;
+          nextDoc();
+        }
+        return docID;
+      }
+
+      @Override
+      public long cost() {
+        return 0;
+      }
+    };
   }
-  
+
   private BinaryRawValues loadBinary(BinaryEntry entry) throws IOException {
     IndexInput data = this.data.clone();
     data.seek(entry.offset);
@@ -400,14 +506,87 @@ class DirectDocValuesProducer extends DocValuesProducer {
     for(int i=0;i<entry.count;i++) {
       address[i] = data.readInt();
     }
+
     address[entry.count] = data.readInt();
+    return new BinaryRawValues(bytes, address);
+  }
 
-    BinaryRawValues values = new BinaryRawValues();
-    values.bytes = bytes;
-    values.address = address;
-    return values;
+  private static class SortedDocValuesSub extends SortedDocValues {
+    private final NumericRawValues numericRawValues;
+    private final BinaryRawValues binaryRawValues;
+    private final int count;
+    private final int maxDoc;
+    private int docID = -1;
+    private int ord;
+
+    public SortedDocValuesSub(NumericRawValues numericRawValues, BinaryRawValues binaryRawValues, int count, int maxDoc) {
+      this.numericRawValues = numericRawValues;
+      this.binaryRawValues = binaryRawValues;
+      this.count = count;
+      this.maxDoc = maxDoc;
+    }
+
+    @Override
+    public int docID() {
+      return docID;
+    }
+
+    @Override
+    public int nextDoc() {
+      assert docID != NO_MORE_DOCS;
+      docID++;
+      while (docID < maxDoc) {
+        ord = (int) numericRawValues.get(docID);
+        if (ord != -1) {
+          return docID;
+        }
+        docID++;
+      }
+      docID = NO_MORE_DOCS;
+      return NO_MORE_DOCS;
+    }
+
+    @Override
+    public int advance(int target) {
+      if (target < docID) {
+        throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+      }
+      if (target >= maxDoc) {
+        this.docID = NO_MORE_DOCS;
+      } else {
+        this.docID = target-1;
+        nextDoc();
+      }
+      return docID;
+    }
+
+    @Override
+    public boolean advanceExact(int target) throws IOException {
+      docID = target;
+      ord = (int) numericRawValues.get(docID);
+      return ord != -1;
+    }
+
+    @Override
+    public long cost() {
+      return 0;
+    }
+
+    @Override
+    public int ordValue() {
+      return ord;
+    }
+
+    @Override
+    public BytesRef lookupOrd(int ord) {
+      return binaryRawValues.get(ord);
+    }
+
+    @Override
+    public int getValueCount() {
+      return count;
+    }
   }
-  
   @Override
   public SortedDocValues getSorted(FieldInfo field) throws IOException {
     final SortedEntry entry = sorteds.get(field.name);
@@ -423,31 +602,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
         }
       }
     }
-    return new LegacySortedDocValuesWrapper(newSortedInstance(instance.docToOrd.numerics, getLegacyBinary(field), entry.values.count), maxDoc);
-  }
-  
-  private LegacySortedDocValues newSortedInstance(final LegacyNumericDocValues docToOrd, final LegacyBinaryDocValues values, final int count) {
-    return new LegacySortedDocValues() {
-
-      @Override
-      public int getOrd(int docID) {
-        return (int) docToOrd.get(docID);
-      }
-
-      @Override
-      public BytesRef lookupOrd(int ord) {
-        return values.get(ord);
-      }
-
-      @Override
-      public int getValueCount() {
-        return count;
-      }
-
-      // Leave lookupTerm to super's binary search
-
-      // Leave termsEnum to super
-    };
+    return new SortedDocValuesSub(instance.docToOrd, getBinaryRawValues(field), entry.values.count, maxDoc);
   }
 
   private SortedRawValues loadSorted(FieldInfo field) throws IOException {
@@ -470,38 +625,88 @@ class DirectDocValuesProducer extends DocValuesProducer {
         ramBytesUsed.addAndGet(instance.ramBytesUsed());
       }
     }
-    
+
     if (entry.docToAddress == null) {
-      final LegacyNumericDocValues single = instance.values.numerics;
       final Bits docsWithField = getMissingBits(field, entry.values.missingOffset, entry.values.missingBytes);
-      return DocValues.singleton(new LegacyNumericDocValuesWrapper(docsWithField, single));
+      return DocValues.singleton(new NumericDocValuesSub(docsWithField, instance.values));
     } else {
-      final LegacyNumericDocValues docToAddress = instance.docToAddress.numerics;
-      final LegacyNumericDocValues values = instance.values.numerics;
-      
-      return new LegacySortedNumericDocValuesWrapper(new LegacySortedNumericDocValues() {
+      final NumericRawValues docToAddress = instance.docToAddress;
+      final NumericRawValues values = instance.values;
+
+      return new SortedNumericDocValues() {
+        private int docID = -1;
+        private int upto;
         int valueStart;
         int valueLimit;
-        
-        @Override
-        public void setDocument(int doc) {
+
+        private void setDocument(int doc) {
           valueStart = (int) docToAddress.get(doc);
           valueLimit = (int) docToAddress.get(doc+1);
         }
-        
+
         @Override
-        public long valueAt(int index) {
-          return values.get(valueStart + index);
+        public long nextValue() throws IOException {
+          return values.get(valueStart + upto++);
         }
-        
+
         @Override
-        public int count() {
+        public int docValueCount() {
           return valueLimit - valueStart;
         }
-        }, maxDoc);
+
+        @Override
+        public boolean advanceExact(int target) throws IOException {
+          docID = target;
+          setDocument(docID);
+          upto = 0;
+          return docValueCount() != 0;
+        }
+
+        @Override
+        public int docID() {
+          return docID;
+        }
+
+        @Override
+        public int nextDoc() throws IOException {
+          assert docID != NO_MORE_DOCS;
+          while (true) {
+            docID++;
+            if (docID == maxDoc) {
+              docID = NO_MORE_DOCS;
+              break;
+            }
+            setDocument(docID);
+            if (docValueCount() != 0) {
+              break;
+            }
+          }
+          upto = 0;
+          return docID;
+        }
+
+        @Override
+        public int advance(int target) throws IOException {
+          if (target < docID) {
+            throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+          }
+          if (target >= maxDoc) {
+            docID = NO_MORE_DOCS;
+          } else {
+            docID = target-1;
+            nextDoc();
+          }
+          return docID;
+        }
+
+        @Override
+        public long cost() {
+          return 0;
+        }
+      };
     }
   }
-  
+
   private SortedNumericRawValues loadSortedNumeric(SortedNumericEntry entry) throws IOException {
     SortedNumericRawValues instance = new SortedNumericRawValues();
     if (entry.docToAddress != null) {
@@ -525,51 +730,102 @@ class DirectDocValuesProducer extends DocValuesProducer {
     }
 
     if (instance.docToOrdAddress == null) {
-      LegacySortedDocValues sorted = newSortedInstance(instance.ords.numerics, getLegacyBinary(field), entry.values.count);
-      return DocValues.singleton(new LegacySortedDocValuesWrapper(sorted, maxDoc));
+      return DocValues.singleton(new SortedDocValuesSub(instance.ords, getBinaryRawValues(field), entry.values.count, maxDoc));
     } else {
-      final LegacyNumericDocValues docToOrdAddress = instance.docToOrdAddress.numerics;
-      final LegacyNumericDocValues ords = instance.ords.numerics;
-      final LegacyBinaryDocValues values = getLegacyBinary(field);
-      
-      // Must make a new instance since the iterator has state:
-      return new LegacySortedSetDocValuesWrapper(new LegacySortedSetDocValues() {
+      final NumericRawValues docToOrdAddress = instance.docToOrdAddress;
+      final NumericRawValues ords = instance.ords;
+      final BinaryRawValues values = getBinaryRawValues(field);
+
+      return new SortedSetDocValues() {
         int ordStart;
         int ordUpto;
         int ordLimit;
-        
-        @Override
-        public long nextOrd() {
+        private int docID = -1;
+        private long ord;
+
+        private long innerNextOrd() {
           if (ordUpto == ordLimit) {
             return NO_MORE_ORDS;
           } else {
             return ords.get(ordUpto++);
           }
         }
-        
-        @Override
-        public void setDocument(int docID) {
+
+        private void setDocument(int docID) {
           ordStart = ordUpto = (int) docToOrdAddress.get(docID);
           ordLimit = (int) docToOrdAddress.get(docID+1);
         }
-        
+
         @Override
-        public BytesRef lookupOrd(long ord) {
+        public long nextOrd() throws IOException {
+          long result = ord;
+          if (result != NO_MORE_ORDS) {
+            ord = innerNextOrd();
+          }
+          return result;
+        }
+
+        @Override
+        public BytesRef lookupOrd(long ord) throws IOException {
           return values.get((int) ord);
         }
-        
+
         @Override
         public long getValueCount() {
           return entry.values.count;
         }
-        
-        // Leave lookupTerm to super's binary search
-        
-        // Leave termsEnum to super
-        }, maxDoc);
+
+        @Override
+        public boolean advanceExact(int target) throws IOException {
+          docID = target;
+          setDocument(docID);
+          ord = innerNextOrd();
+          return ord != NO_MORE_ORDS;
+        }
+
+        @Override
+        public int docID() {
+          return docID;
+        }
+
+        @Override
+        public int nextDoc() throws IOException {
+          assert docID != NO_MORE_DOCS;
+          docID++;
+          while (docID < maxDoc) {
+            setDocument(docID);
+            ord = innerNextOrd();
+            if (ord != NO_MORE_ORDS) {
+              return docID;
+            }
+            docID++;
+          }
+          docID = NO_MORE_DOCS;
+          return NO_MORE_DOCS;
+        }
+
+        @Override
+        public int advance(int target) throws IOException {
+          if (target < docID) {
+            throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+          }
+          if (target >= maxDoc) {
+            this.docID = NO_MORE_DOCS;
+          } else {
+            this.docID = target-1;
+            nextDoc();
+          }
+          return docID;
+        }
+
+        @Override
+        public long cost() {
+          return 0;
+        }
+      };
     }
   }
-  
+
   private SortedSetRawValues loadSortedSet(SortedSetEntry entry) throws IOException {
     SortedSetRawValues instance = new SortedSetRawValues();
     if (entry.docToOrdAddress != null) {
@@ -604,7 +860,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       return instance;
     }
   }
-  
+
   @Override
   public synchronized DocValuesProducer getMergeInstance() {
     return new DirectDocValuesProducer(this);
@@ -618,7 +874,20 @@ class DirectDocValuesProducer extends DocValuesProducer {
   static class BinaryRawValues implements Accountable {
     byte[] bytes;
     int[] address;
-    
+    final BytesRef term = new BytesRef();
+
+    public BinaryRawValues(byte[] bytes, int[] address) {
+      this.bytes = bytes;
+      this.address = address;
+    }
+
+    public BytesRef get(int docID) {
+      term.bytes = bytes;
+      term.offset = address[docID];
+      term.length = address[docID+1] - term.offset;
+      return term;
+    }
+
     @Override
     public long ramBytesUsed() {
       long bytesUsed = RamUsageEstimator.sizeOf(bytes);
@@ -627,7 +896,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       }
       return bytesUsed;
     }
-    
+
     @Override
     public Collection<Accountable> getChildResources() {
       List<Accountable> resources = new ArrayList<>();
@@ -643,16 +912,17 @@ class DirectDocValuesProducer extends DocValuesProducer {
       return getClass().getSimpleName();
     }
   }
-  
-  static class NumericRawValues implements Accountable {
-    LegacyNumericDocValues numerics;
+
+  abstract static class NumericRawValues implements Accountable {
     long bytesUsed;
-    
+
+    public abstract long get(int docID);
+
     @Override
     public long ramBytesUsed() {
       return bytesUsed;
     }
-    
+
     @Override
     public String toString() {
       return getClass().getSimpleName();
@@ -671,17 +941,17 @@ class DirectDocValuesProducer extends DocValuesProducer {
     public Collection<Accountable> getChildResources() {
       return docToOrd.getChildResources();
     }
-    
+
     @Override
     public String toString() {
       return getClass().getSimpleName();
     }
   }
-  
+
   static class SortedNumericRawValues implements Accountable {
     NumericRawValues docToAddress;
     NumericRawValues values;
-    
+
     @Override
     public long ramBytesUsed() {
       long bytesUsed = values.ramBytesUsed();
@@ -690,7 +960,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       }
       return bytesUsed;
     }
-    
+
     @Override
     public Collection<Accountable> getChildResources() {
       List<Accountable> resources = new ArrayList<>();
@@ -700,7 +970,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       resources.add(Accountables.namedAccountable("values", values));
       return Collections.unmodifiableList(resources);
     }
-    
+
     @Override
     public String toString() {
       return getClass().getSimpleName();
@@ -729,7 +999,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       resources.add(Accountables.namedAccountable("ordinals", ords));
       return Collections.unmodifiableList(resources);
     }
-    
+
     @Override
     public String toString() {
       return getClass().getSimpleName();
@@ -756,7 +1026,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
     int packedIntsVersion;
     int blockSize;
   }
-  
+
   static class SortedEntry {
     NumericEntry docToOrd;
     BinaryEntry values;
@@ -767,12 +1037,12 @@ class DirectDocValuesProducer extends DocValuesProducer {
     NumericEntry ords;
     BinaryEntry values;
   }
-  
+
   static class SortedNumericEntry {
     NumericEntry docToAddress;
     NumericEntry values;
   }
-  
+
   static class FSTEntry {
     long offset;
     long numOrds;
