diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java
index 54ec424fdcb..e8474c14f1c 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java
@@ -18,17 +18,14 @@ package org.apache.lucene.codecs.memory;
 
 
 import java.io.IOException;
-import java.util.Iterator;
 
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.DocValuesConsumer;
 import org.apache.lucene.codecs.DocValuesProducer;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentWriteState;
+import org.apache.lucene.index.*;
+import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.*;
 
 import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.BYTES;
 import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.NUMBER;
@@ -38,6 +35,8 @@ import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.SORTED_NUM
 import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.SORTED_SET;
 import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.SORTED_SET_SINGLETON;
 import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.VERSION_CURRENT;
+import static org.apache.lucene.index.SortedSetDocValues.NO_MORE_ORDS;
+import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;
 
 /**
  * Writer for {@link DirectDocValuesFormat}
@@ -46,6 +45,7 @@ import static org.apache.lucene.codecs.memory.DirectDocValuesProducer.VERSION_CU
 class DirectDocValuesConsumer extends DocValuesConsumer {
   IndexOutput data, meta;
   final int maxDoc;
+  static final int MISSING_BITSET = Integer.MIN_VALUE;
 
   DirectDocValuesConsumer(SegmentWriteState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {
     maxDoc = state.segmentInfo.maxDoc();
@@ -69,34 +69,183 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
   public void addNumericField(FieldInfo field, DocValuesProducer valuesProducer) throws IOException {
     meta.writeVInt(field.number);
     meta.writeByte(NUMBER);
-    addNumericFieldValues(field, LegacyDocValuesIterables.numericIterable(field, valuesProducer, maxDoc));
+    addNumericFieldValues(field, new EmptyDocValuesProducer() {
+      @Override
+      public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {
+        return new SortedNumericDocValues() {
+          final NumericDocValues values = valuesProducer.getNumeric(field);
+          long[] ords = LongsRef.EMPTY_LONGS;
+          int docIDUpto, i, docValueCount;
+
+          @Override
+          public long nextValue() throws IOException {
+            return ords[i++];
+          }
+
+          @Override
+          public int docValueCount() {
+            return docValueCount;
+          }
+
+          @Override
+          public boolean advanceExact(int target) throws IOException {
+            throw new UnsupportedOperationException();
+          }
+
+          @Override
+          public int docID() {
+            throw new UnsupportedOperationException();
+          }
+
+          @Override
+          public int nextDoc() throws IOException {
+            if (docIDUpto == maxDoc) {
+              return NO_MORE_DOCS;
+            }
+            int docID = values.nextDoc();
+            if (docID == NO_MORE_DOCS) {
+              docID = MISSING_BITSET;
+            }
+            docValueCount = 0;
+            while (docIDUpto <= values.docID() && docIDUpto < maxDoc) {
+              ords = ArrayUtil.grow(ords, docValueCount + 1);
+              if (docIDUpto++ == values.docID()) {
+                ords[docValueCount++] = values.longValue();
+              } else {
+                ords[docValueCount++] = MISSING_BITSET;
+              }
+            }
+            i = 0;
+            return docID;
+          }
+
+          @Override
+          public int advance(int target) throws IOException {
+            throw new UnsupportedOperationException();
+          }
+
+          @Override
+          public long cost() {
+            throw new UnsupportedOperationException();
+          }
+        };
+      }
+    });
   }
 
-  private void addNumericFieldValues(FieldInfo field, Iterable<Number> values) throws IOException {
+  private void addNumericFieldValues(FieldInfo field, final DocValuesProducer valuesProducer) throws IOException {
     meta.writeLong(data.getFilePointer());
     long minValue = Long.MAX_VALUE;
     long maxValue = Long.MIN_VALUE;
     boolean missing = false;
 
     long count = 0;
-    for (Number nv : values) {
-      if (nv != null) {
-        long v = nv.longValue();
-        minValue = Math.min(minValue, v);
-        maxValue = Math.max(maxValue, v);
-      } else {
-        missing = true;
-      }
-      count++;
-      if (count >= DirectDocValuesFormat.MAX_SORTED_SET_ORDS) {
-        throw new IllegalArgumentException("DocValuesField \"" + field.name + "\" is too large, must be <= " + DirectDocValuesFormat.MAX_SORTED_SET_ORDS + " values/total ords");
+    SortedNumericDocValues values = valuesProducer.getSortedNumeric(field);
+    for (int docID = values.nextDoc(); docID != DocIdSetIterator.NO_MORE_DOCS; docID = values.nextDoc()) {
+      for (int i = 0, docValueCount = values.docValueCount(); i < docValueCount; ++i) {
+        long v = values.nextValue();
+        if (v != MISSING_BITSET) {
+          minValue = Math.min(minValue, v);
+          maxValue = Math.max(maxValue, v);
+        } else {
+          missing = true;
+        }
+        count++;
+        if (count >= DirectDocValuesFormat.MAX_SORTED_SET_ORDS) {
+          throw new IllegalArgumentException("DocValuesField \"" + field.name + "\" is too large, must be <= " + DirectDocValuesFormat.MAX_SORTED_SET_ORDS + " values/total ords");
+        }
       }
     }
+
     meta.writeInt((int) count);
-    
+
     if (missing) {
       long start = data.getFilePointer();
-      writeMissingBitset(values);
+      writeMissingBitset(new TermsEnum() {
+        final SortedNumericDocValues values = valuesProducer.getSortedNumeric(field);
+        int docID = values.nextDoc();
+        int i;
+        int docValueCount = values.docValueCount();
+
+        @Override
+        public AttributeSource attributes() {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean seekExact(BytesRef text) throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public SeekStatus seekCeil(BytesRef text) throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void seekExact(long ord) throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void seekExact(BytesRef term, TermState state) throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public BytesRef term() throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public long ord() throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int docFreq() throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public long totalTermFreq() throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public PostingsEnum postings(PostingsEnum reuse, int flags) throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public ImpactsEnum impacts(int flags) throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public TermState termState() throws IOException {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public BytesRef next() throws IOException {
+          if (i < docValueCount) {
+            i++;
+          } else {
+            docID = values.nextDoc();
+            if (docID == NO_MORE_DOCS) return null;
+            i = 1;
+            docValueCount = values.docValueCount();
+          }
+          long value = values.nextValue();
+          BytesRef result = new BytesRef();
+          if (value == MISSING_BITSET) {
+            result.bytes = null;
+          }
+          return result;
+        }
+      });
+
       meta.writeLong(start);
       meta.writeLong(data.getFilePointer() - start);
     } else {
@@ -115,31 +264,32 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
     }
     meta.writeByte(byteWidth);
 
-    for (Number nv : values) {
-      long v;
-      if (nv != null) {
-        v = nv.longValue();
-      } else {
-        v = 0;
-      }
+    values = valuesProducer.getSortedNumeric(field);
+    for (int doc = values.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = values.nextDoc()) {
+      for (int i = 0, docValueCount = values.docValueCount(); i < docValueCount; ++i) {
+        long v = values.nextValue();
+        if (v == MISSING_BITSET) {
+          v = 0;
+        }
 
-      switch(byteWidth) {
-      case 1:
-        data.writeByte((byte) v);
-        break;
-      case 2:
-        data.writeShort((short) v);
-        break;
-      case 4:
-        data.writeInt((int) v);
-        break;
-      case 8:
-        data.writeLong(v);
-        break;
+        switch (byteWidth) {
+          case 1:
+            data.writeByte((byte) v);
+            break;
+          case 2:
+            data.writeShort((short) v);
+            break;
+          case 4:
+            data.writeInt((int) v);
+            break;
+          case 8:
+            data.writeLong(v);
+            break;
+        }
       }
     }
   }
-  
+
   @Override
   public void close() throws IOException {
     boolean success = false;
@@ -166,19 +316,142 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
   public void addBinaryField(FieldInfo field, final DocValuesProducer valuesProducer) throws IOException {
     meta.writeVInt(field.number);
     meta.writeByte(BYTES);
-    addBinaryFieldValues(field, LegacyDocValuesIterables.binaryIterable(field, valuesProducer, maxDoc));
+    addBinaryFieldValues(field, new EmptyDocValuesProducer() {
+      @Override
+      public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {
+        return new SortedSetDocValues() {
+          final BinaryDocValues values = valuesProducer.getBinary(field);
+
+          @Override
+          public long nextOrd() throws IOException {
+            return 0;
+          }
+
+          @Override
+          public BytesRef lookupOrd(long ord) throws IOException {
+            if (ord > values.docID()) {
+              values.nextDoc();
+            }
+            BytesRef result;
+            if (ord == values.docID()) {
+              result = values.binaryValue();
+            } else {
+              result = new BytesRef();
+              result.bytes = null;
+            }
+            return result;
+          }
+
+          @Override
+          public long getValueCount() {
+            return maxDoc;
+          }
+
+          @Override
+          public boolean advanceExact(int target) throws IOException {
+            return false;
+          }
+
+          @Override
+          public int docID() {
+            return 0;
+          }
+
+          @Override
+          public int nextDoc() throws IOException {
+            return 0;
+          }
+
+          @Override
+          public int advance(int target) throws IOException {
+            return 0;
+          }
+
+          @Override
+          public long cost() {
+            return 0;
+          }
+        };
+      }
+    });
   }
 
-  private void addBinaryFieldValues(FieldInfo field, final Iterable<BytesRef> values) throws IOException {
+  private static class SortedSetDocValuesTermsEnum extends BaseTermsEnum {
+    private final SortedSetDocValues values;
+    private long currentOrd = -1;
+    private final BytesRefBuilder scratch;
+
+    private SortedSetDocValuesTermsEnum(SortedSetDocValues values) {
+      this.values = values;
+      scratch = new BytesRefBuilder();
+    }
+
+    @Override
+    public SeekStatus seekCeil(BytesRef text) throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void seekExact(long ord) throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public BytesRef term() throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public long ord() throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int docFreq() throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public long totalTermFreq() throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public PostingsEnum postings(PostingsEnum reuse, int flags) throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ImpactsEnum impacts(int flags) throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public BytesRef next() throws IOException {
+      currentOrd++;
+      if (currentOrd >= values.getValueCount()) {
+        return null;
+      }
+      BytesRef bytesRef = values.lookupOrd(currentOrd);
+      if (bytesRef.bytes == null) {
+        return bytesRef;
+      }
+      scratch.copyBytes(bytesRef);
+      return scratch.get();
+    }
+  }
+
+  private void addBinaryFieldValues(FieldInfo field, final DocValuesProducer valuesProducer) throws IOException {
     // write the byte[] data
     final long startFP = data.getFilePointer();
     boolean missing = false;
     long totalBytes = 0;
     int count = 0;
-    for(BytesRef v : values) {
-      if (v != null) {
-        data.writeBytes(v.bytes, v.offset, v.length);
-        totalBytes += v.length;
+    TermsEnum iterator = new SortedSetDocValuesTermsEnum(valuesProducer.getSortedSet(field));
+    for (BytesRef term = iterator.next(); term != null; term = iterator.next()) {
+      if (term.bytes != null) {
+        data.writeBytes(term.bytes, term.offset, term.length);
+        totalBytes += term.length;
         if (totalBytes > DirectDocValuesFormat.MAX_TOTAL_BYTES_LENGTH) {
           throw new IllegalArgumentException("DocValuesField \"" + field.name + "\" is too large, cannot have more than DirectDocValuesFormat.MAX_TOTAL_BYTES_LENGTH (" + DirectDocValuesFormat.MAX_TOTAL_BYTES_LENGTH + ") bytes");
         }
@@ -193,35 +466,37 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
     meta.writeInt(count);
     if (missing) {
       long start = data.getFilePointer();
-      writeMissingBitset(values);
+      iterator = new SortedSetDocValuesTermsEnum(valuesProducer.getSortedSet(field));
+      writeMissingBitset(iterator);
       meta.writeLong(start);
       meta.writeLong(data.getFilePointer() - start);
     } else {
       meta.writeLong(-1L);
     }
-    
+
     int addr = 0;
-    for (BytesRef v : values) {
+    iterator = new SortedSetDocValuesTermsEnum(valuesProducer.getSortedSet(field));
+    for (BytesRef term = iterator.next(); term != null; term = iterator.next()) {
       data.writeInt(addr);
-      if (v != null) {
-        addr += v.length;
+      if (term.bytes != null) {
+        addr += term.length;
       }
     }
     data.writeInt(addr);
   }
-  
+
   // TODO: in some cases representing missing with minValue-1 wouldn't take up additional space and so on,
   // but this is very simple, and algorithms only check this for values of 0 anyway (doesnt slow down normal decode)
-  void writeMissingBitset(Iterable<?> values) throws IOException {
+  void writeMissingBitset(TermsEnum termsEnum) throws IOException {
     long bits = 0;
     int count = 0;
-    for (Object v : values) {
+    for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
       if (count == 64) {
         data.writeLong(bits);
         count = 0;
         bits = 0;
       }
-      if (v != null) {
+      if (term.bytes != null) {
         bits |= 1L << (count & 0x3f);
       }
       count++;
@@ -237,114 +512,476 @@ class DirectDocValuesConsumer extends DocValuesConsumer {
     meta.writeByte(SORTED);
 
     // write the ordinals as numerics
-    addNumericFieldValues(field, LegacyDocValuesIterables.sortedOrdIterable(valuesProducer, field, maxDoc));
+    addNumericFieldValues(field, new EmptyDocValuesProducer() {
+      @Override
+      public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {
+        return new SortedNumericDocValues() {
+          final SortedDocValues values = valuesProducer.getSorted(field);
+          long[] ords = LongsRef.EMPTY_LONGS;
+          int docIDUpto, i, docValueCount;
+
+          @Override
+          public long nextValue() throws IOException {
+            return ords[i++];
+          }
+
+          @Override
+          public int docValueCount() {
+            return docValueCount;
+          }
+
+          @Override
+          public boolean advanceExact(int target) throws IOException {
+            throw new UnsupportedOperationException();
+          }
+
+          @Override
+          public int docID() {
+            return values.docID();
+          }
+
+          @Override
+          public int nextDoc() throws IOException {
+            if (docIDUpto == maxDoc) {
+              return NO_MORE_DOCS;
+            }
+            int docID = values.nextDoc();
+            if (docID == NO_MORE_DOCS) {
+              docID = MISSING_BITSET;
+            }
+            docValueCount = 0;
+            while (docIDUpto <= values.docID() && docIDUpto < maxDoc) {
+              ords = ArrayUtil.grow(ords, docValueCount + 1);
+              if (docIDUpto++ == values.docID()) {
+                ords[docValueCount++] = values.ordValue();
+              } else {
+                ords[docValueCount++] = -1L;
+              }
+            }
+            i = 0;
+            return docID;
+          }
+
+          @Override
+          public int advance(int target) throws IOException {
+            throw new UnsupportedOperationException();
+          }
+
+          @Override
+          public long cost() {
+            return values.cost();
+          }
+        };
+      }
+    });
+
     // write the values as binary
-    addBinaryFieldValues(field, LegacyDocValuesIterables.valuesIterable(valuesProducer.getSorted(field)));
+    addBinaryFieldValues(field, new EmptyDocValuesProducer() {
+      @Override
+      public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {
+        return DocValues.singleton(valuesProducer.getSorted(field));
+      }
+    });
   }
-  
+
   @Override
   public void addSortedNumericField(FieldInfo field, final DocValuesProducer valuesProducer) throws IOException {
-
-    final Iterable<Number> docToValueCount = LegacyDocValuesIterables.sortedNumericToDocCount(valuesProducer, field, maxDoc);
-    final Iterable<Number> values = LegacyDocValuesIterables.sortedNumericToValues(valuesProducer, field);
-
     meta.writeVInt(field.number);
-    if (isSingleValued(docToValueCount)) {
+    if (isSingleValued(valuesProducer.getSortedNumeric(field))) {
       meta.writeByte(SORTED_NUMERIC_SINGLETON);
-      addNumericFieldValues(field, singletonView(docToValueCount, values, null));
+      addNumericFieldValues(field, new EmptyDocValuesProducer() {
+        @Override
+        public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {
+          return new SortedNumericDocValues() {
+            final SortedNumericDocValues values = valuesProducer.getSortedNumeric(field);
+            long[] ords = LongsRef.EMPTY_LONGS;
+            int docIDUpto, i, docValueCount;
+
+            @Override
+            public long nextValue() throws IOException {
+              return ords[i++];
+            }
+
+            @Override
+            public int docValueCount() {
+              return docValueCount;
+            }
+
+            @Override
+            public boolean advanceExact(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int docID() {
+              return values.docID();
+            }
+
+            @Override
+            public int nextDoc() throws IOException {
+              if (docIDUpto == maxDoc) {
+                return NO_MORE_DOCS;
+              }
+              int docID = values.nextDoc();
+              if (docID == NO_MORE_DOCS) {
+                docID = MISSING_BITSET;
+              }
+              docValueCount = 0;
+              while (docIDUpto <= values.docID() && docIDUpto < maxDoc) {
+                ords = ArrayUtil.grow(ords, docValueCount + 1);
+                if (docIDUpto++ == values.docID()) {
+                  ords[docValueCount++] = values.nextValue();
+                } else {
+                  ords[docValueCount++] = MISSING_BITSET;
+                }
+              }
+              i = 0;
+              return docID;
+            }
+
+            @Override
+            public int advance(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public long cost() {
+              return values.cost();
+            }
+          };
+        }
+      });
     } else {
       meta.writeByte(SORTED_NUMERIC);
 
       // First write docToValueCounts, except we "aggregate" the
       // counts so they turn into addresses, and add a final
       // value = the total aggregate:
-      addNumericFieldValues(field, countToAddressIterator(docToValueCount));
+      addNumericFieldValues(field, new EmptyDocValuesProducer() {
+        @Override
+        public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {
+          return new SortedNumericDocValues() {
+            final SortedNumericDocValues values = valuesProducer.getSortedNumeric(field);
+            long[] ords = LongsRef.EMPTY_LONGS;
+            int docIDUpto, i, docValueCount;
+            boolean ended;
+            long sum;
+
+            @Override
+            public long nextValue() throws IOException {
+              return ords[i++];
+            }
+
+            @Override
+            public int docValueCount() {
+              return docValueCount;
+            }
+
+            @Override
+            public boolean advanceExact(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int docID() {
+              return values.docID();
+            }
+
+            @Override
+            public int nextDoc() throws IOException {
+              if (docIDUpto == maxDoc) {
+                if (!ended) {
+                  ords[0] = sum;
+                  docValueCount = 1;
+                  i = 0;
+                  ended = true;
+                  return -1;
+                } else {
+                  return NO_MORE_DOCS;
+                }
+              }
+              int docID = values.nextDoc();
+
+              docValueCount = 0;
+              while (docIDUpto <= docID && docIDUpto < maxDoc) {
+                ords = ArrayUtil.grow(ords, docValueCount + 1);
+                ords[docValueCount++] = sum;
+                if (docIDUpto++ == values.docID()) {
+                  sum += values.docValueCount();
+                }
+              }
+              i = 0;
+              if (docID == NO_MORE_DOCS) {
+                return -1;
+              }
+              return docID;
+            }
+
+            @Override
+            public int advance(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public long cost() {
+              return values.cost();
+            }
+          };
+        }
+      });
 
       // Write values for all docs, appended into one big
       // numerics:
-      addNumericFieldValues(field, values);
+      addNumericFieldValues(field, valuesProducer);
     }
   }
 
+  private boolean isSingleValued(SortedNumericDocValues values) throws IOException {
+    if (DocValues.unwrapSingleton(values) != null) {
+      return true;
+    }
+
+    for (int doc = values.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = values.nextDoc()) {
+      if (values.docValueCount() > 1) {
+        return false;
+      }
+    }
+    return true;
+  }
+
   // note: this might not be the most efficient... but it's fairly simple
   @Override
   public void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer) throws IOException {
-    Iterable<BytesRef> values = LegacyDocValuesIterables.valuesIterable(valuesProducer.getSortedSet(field));
-    Iterable<Number> docToOrdCount = LegacyDocValuesIterables.sortedSetOrdCountIterable(valuesProducer, field, maxDoc);
-    Iterable<Number> ords = LegacyDocValuesIterables.sortedSetOrdsIterable(valuesProducer, field);
-    
     meta.writeVInt(field.number);
-    
-    if (isSingleValued(docToOrdCount)) {
+
+    if (isSingleValued(valuesProducer.getSortedSet(field))) {
       meta.writeByte(SORTED_SET_SINGLETON);
       // Write ordinals for all docs, appended into one big
       // numerics:
-      addNumericFieldValues(field, singletonView(docToOrdCount, ords, -1L));
-      
-      // write the values as binary
-      addBinaryFieldValues(field, values);
+      addNumericFieldValues(field, new EmptyDocValuesProducer() {
+        @Override
+        public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {
+          return new SortedNumericDocValues() {
+            final SortedSetDocValues values = valuesProducer.getSortedSet(field);
+            long[] ords = LongsRef.EMPTY_LONGS;
+            int docIDUpto, i, docValueCount;
+
+            @Override
+            public long nextValue() throws IOException {
+              return ords[i++];
+            }
+
+            @Override
+            public int docValueCount() {
+              return docValueCount;
+            }
+
+            @Override
+            public boolean advanceExact(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int docID() {
+              return values.docID();
+            }
+
+            @Override
+            public int nextDoc() throws IOException {
+              if (docIDUpto == maxDoc) {
+                return NO_MORE_DOCS;
+              }
+              int docID = values.nextDoc();
+              if (docID == NO_MORE_DOCS) {
+                docID = -1;
+              }
+              docValueCount = 0;
+              while (docIDUpto <= values.docID() && docIDUpto < maxDoc) {
+                ords = ArrayUtil.grow(ords, docValueCount + 1);
+                if (docID == docIDUpto++) {
+                  ords[docValueCount++] = values.nextOrd();
+                } else {
+                  ords[docValueCount++] = -1L;
+                }
+              }
+              i = 0;
+              return docID;
+            }
+
+            @Override
+            public int advance(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public long cost() {
+              return values.cost();
+            }
+          };
+        }
+      });
     } else {
       meta.writeByte(SORTED_SET);
 
       // First write docToOrdCounts, except we "aggregate" the
       // counts so they turn into addresses, and add a final
       // value = the total aggregate:
-      addNumericFieldValues(field, countToAddressIterator(docToOrdCount));
+      addNumericFieldValues(field, new EmptyDocValuesProducer() {
+        @Override
+        public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {
+          return new SortedNumericDocValues() {
+            final SortedSetDocValues values = valuesProducer.getSortedSet(field);
+            long[] ords = LongsRef.EMPTY_LONGS;
+            int i, docValueCount, docIDUpto, ordCount;
+            boolean ended;
+            long sum;
+
+            @Override
+            public long nextValue() throws IOException {
+              return ords[i++];
+            }
+
+            @Override
+            public int docValueCount() {
+              return docValueCount;
+            }
+
+            @Override
+            public boolean advanceExact(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int docID() {
+              return values.docID();
+            }
+
+            @Override
+            public int nextDoc() throws IOException {
+              if (docIDUpto == maxDoc) {
+                if (!ended) {
+                  ords[0] = sum;
+                  docValueCount = 1;
+                  i = 0;
+                  ended = true;
+                  return -1;
+                } else {
+                  return NO_MORE_DOCS;
+                }
+              }
+              int docID = values.nextDoc();
+              if (docID != NO_MORE_DOCS) {
+                ordCount = 0;
+                while (values.nextOrd() != NO_MORE_ORDS) {
+                  ordCount++;
+                }
+              }
+
+              docValueCount = 0;
+              while (docIDUpto <= docID && docIDUpto < maxDoc) {
+                ords = ArrayUtil.grow(ords, docValueCount + 1);
+                ords[docValueCount++] = sum;
+                if (docIDUpto++ == docID) {
+                  sum += ordCount;
+                }
+              }
+              i = 0;
+              if (docID == NO_MORE_DOCS) {
+                return -1;
+              }
+              return docID;
+            }
+
+            @Override
+            public int advance(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public long cost() {
+              return values.cost();
+            }
+          };
+        }
+      });
 
       // Write ordinals for all docs, appended into one big
       // numerics:
-      addNumericFieldValues(field, ords);
-      
-      // write the values as binary
-      addBinaryFieldValues(field, values);
-    }
-  }
-  
-  /** 
-   * Just aggregates the count values so they become
-   * "addresses", and adds one more value in the end
-   * (the final sum)
-   */ 
-  private Iterable<Number> countToAddressIterator(final Iterable<Number> counts) {
-    return new Iterable<Number>() {
-      @Override
-      public Iterator<Number> iterator() {
-        final Iterator<Number> iter = counts.iterator();
-        
-        return new Iterator<Number>() {
-          
-          long sum;
-          boolean ended;
-          
-          @Override
-          public boolean hasNext() {
-            return iter.hasNext() || !ended;
-          }
-          
-          @Override
-          public Number next() {
-            long toReturn = sum;
-            
-            if (iter.hasNext()) {
-              Number n = iter.next();
-              if (n != null) {
-                sum += n.longValue();
+      addNumericFieldValues(field, new EmptyDocValuesProducer() {
+        @Override
+        public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {
+          return new SortedNumericDocValues() {
+            final SortedSetDocValues values = valuesProducer.getSortedSet(field);
+            long[] ords = LongsRef.EMPTY_LONGS;
+            int i, docValueCount;
+
+            @Override
+            public long nextValue() throws IOException {
+              return ords[i++];
+            }
+
+            @Override
+            public int docValueCount() {
+              return docValueCount;
+            }
+
+            @Override
+            public boolean advanceExact(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int docID() {
+              return values.docID();
+            }
+
+            @Override
+            public int nextDoc() throws IOException {
+              int docID = values.nextDoc();
+              if (docID != NO_MORE_DOCS) {
+                docValueCount = 0;
+                for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {
+                  ords = ArrayUtil.grow(ords, docValueCount + 1);
+                  ords[docValueCount++] = ord;
+                }
+                i = 0;
               }
-            } else if (!ended) {
-              ended = true;
-            } else {
-              assert false;
+              return docID;
             }
-            
-            return toReturn;
-          }
-          
-          @Override
-          public void remove() {
-            throw new UnsupportedOperationException();
-          }
-        };
+
+            @Override
+            public int advance(int target) throws IOException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public long cost() {
+              return values.cost();
+            }
+          };
+        }
+      });
+    }
+
+    // write the values as binary
+    addBinaryFieldValues(field, valuesProducer);
+  }
+
+  private boolean isSingleValued(SortedSetDocValues values) throws IOException {
+    if (DocValues.unwrapSingleton(values) != null) {
+      return true;
+    }
+
+    while (values.nextDoc() != NO_MORE_DOCS) {
+      int ordCount = 0;
+      while (values.nextOrd() != NO_MORE_ORDS) {
+        ordCount++;
+        if (ordCount > 1) {
+          return false;
+        }
       }
-    };
+    }
+
+    return true;
   }
 }
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
index baef4dbf90b..4969938230f 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
@@ -51,7 +51,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
   private final Map<String,SortedSetEntry> sortedSets = new HashMap<>();
   private final Map<String,SortedNumericEntry> sortedNumerics = new HashMap<>();
   private final IndexInput data;
-  
+
   // ram instances we have already loaded
   private final Map<String,NumericRawValues> numericInstances = new HashMap<>();
   private final Map<String,BinaryRawValues> binaryInstances = new HashMap<>();
@@ -59,15 +59,15 @@ class DirectDocValuesProducer extends DocValuesProducer {
   private final Map<String,SortedSetRawValues> sortedSetInstances = new HashMap<>();
   private final Map<String,SortedNumericRawValues> sortedNumericInstances = new HashMap<>();
   private final Map<String,FixedBitSet> docsWithFieldInstances = new HashMap<>();
-  
+
   private final int numEntries;
-  
+
   private final int maxDoc;
   private final AtomicLong ramBytesUsed;
   private final int version;
-  
+
   private final boolean merging;
-  
+
   static final byte NUMBER = 0;
   static final byte BYTES = 1;
   static final byte SORTED = 2;
@@ -78,7 +78,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
 
   static final int VERSION_START = 3;
   static final int VERSION_CURRENT = VERSION_START;
-  
+
   // clone for merge: when merging we don't do any instances.put()s
   DirectDocValuesProducer(DirectDocValuesProducer original) {
     assert Thread.holdsLock(original);
@@ -88,21 +88,21 @@ class DirectDocValuesProducer extends DocValuesProducer {
     sortedSets.putAll(original.sortedSets);
     sortedNumerics.putAll(original.sortedNumerics);
     data = original.data.clone();
-    
+
     numericInstances.putAll(original.numericInstances);
     binaryInstances.putAll(original.binaryInstances);
     sortedInstances.putAll(original.sortedInstances);
     sortedSetInstances.putAll(original.sortedSetInstances);
     sortedNumericInstances.putAll(original.sortedNumericInstances);
     docsWithFieldInstances.putAll(original.docsWithFieldInstances);
-    
+
     numEntries = original.numEntries;
     maxDoc = original.maxDoc;
     ramBytesUsed = new AtomicLong(original.ramBytesUsed.get());
     version = original.version;
     merging = true;
   }
-    
+
   DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {
     maxDoc = state.segmentInfo.maxDoc();
     merging = false;
@@ -112,8 +112,8 @@ class DirectDocValuesProducer extends DocValuesProducer {
     ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));
     boolean success = false;
     try {
-      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, 
-                                                 state.segmentInfo.getId(), state.segmentSuffix);
+      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT,
+              state.segmentInfo.getId(), state.segmentSuffix);
       numEntries = readFields(in, state.fieldInfos);
 
       CodecUtil.checkFooter(in);
@@ -131,11 +131,11 @@ class DirectDocValuesProducer extends DocValuesProducer {
     success = false;
     try {
       final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,
-                                                              state.segmentInfo.getId(), state.segmentSuffix);
+              state.segmentInfo.getId(), state.segmentSuffix);
       if (version != version2) {
         throw new CorruptIndexException("Format versions mismatch: meta=" + version + ", data=" + version2, data);
       }
-      
+
       // NOTE: data file is too costly to verify checksum against all the bytes on open,
       // but for now we at least verify proper structure of the checksum footer: which looks
       // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption
@@ -196,7 +196,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
     entry.values = readBinaryEntry(meta);
     return entry;
   }
-  
+
   private SortedNumericEntry readSortedNumericEntry(IndexInput meta, boolean singleton) throws IOException {
     SortedNumericEntry entry = new SortedNumericEntry();
     if (singleton == false) {
@@ -243,23 +243,6 @@ class DirectDocValuesProducer extends DocValuesProducer {
     return numEntries;
   }
 
-  @Override
-  public long ramBytesUsed() {
-    return ramBytesUsed.get();
-  }
-  
-  @Override
-  public synchronized Collection<Accountable> getChildResources() {
-    List<Accountable> resources = new ArrayList<>();
-    resources.addAll(Accountables.namedAccountables("numeric field", numericInstances));
-    resources.addAll(Accountables.namedAccountables("binary field", binaryInstances));
-    resources.addAll(Accountables.namedAccountables("sorted field", sortedInstances));
-    resources.addAll(Accountables.namedAccountables("sorted set field", sortedSetInstances));
-    resources.addAll(Accountables.namedAccountables("sorted numeric field", sortedNumericInstances));
-    resources.addAll(Accountables.namedAccountables("missing bitset field", docsWithFieldInstances));
-    return Collections.unmodifiableList(resources);
-  }
-  
   @Override
   public String toString() {
     return getClass().getSimpleName() + "(entries=" + numEntries + ")";
@@ -270,6 +253,74 @@ class DirectDocValuesProducer extends DocValuesProducer {
     CodecUtil.checksumEntireFile(data.clone());
   }
 
+  private static class NumericDocValuesSub extends NumericDocValues {
+    private final Bits docsWithField;
+    private final NumericRawValues values;
+    private final int maxDoc;
+    private int docID = -1;
+    private long value;
+
+    public NumericDocValuesSub(Bits docsWithField, NumericRawValues values) {
+      this.docsWithField = docsWithField;
+      this.values = values;
+      this.maxDoc = docsWithField.length();
+    }
+
+    @Override
+    public int docID() {
+      return docID;
+    }
+
+    @Override
+    public int nextDoc() {
+      docID++;
+      while (docID < maxDoc) {
+        value = values.get(docID);
+        if (value != 0 || docsWithField.get(docID)) {
+          return docID;
+        }
+        docID++;
+      }
+      docID = NO_MORE_DOCS;
+      return NO_MORE_DOCS;
+    }
+
+    @Override
+    public int advance(int target) {
+      assert target >= docID: "target=" + target + " docID=" + docID;
+      if (target == NO_MORE_DOCS) {
+        this.docID = NO_MORE_DOCS;
+      } else {
+        this.docID = target-1;
+        nextDoc();
+      }
+      return docID;
+    }
+
+    @Override
+    public boolean advanceExact(int target) throws IOException {
+      docID = target;
+      value = values.get(docID);
+      return value != 0 || docsWithField.get(docID);
+    }
+
+    @Override
+    public long cost() {
+      // TODO
+      return 0;
+    }
+
+    @Override
+    public long longValue() {
+      return value;
+    }
+
+    @Override
+    public String toString() {
+      return "NumericDocValuesSub(" + values + ")";
+    }
+  }
+
   @Override
   public synchronized NumericDocValues getNumeric(FieldInfo field) throws IOException {
     NumericRawValues instance = numericInstances.get(field.name);
@@ -282,82 +333,81 @@ class DirectDocValuesProducer extends DocValuesProducer {
         ramBytesUsed.addAndGet(instance.ramBytesUsed());
       }
     }
-    return new LegacyNumericDocValuesWrapper(getMissingBits(field, ne.missingOffset, ne.missingBytes), instance.numerics);
+    return new NumericDocValuesSub(getMissingBits(field, ne.missingOffset, ne.missingBytes), instance);
   }
-  
+
   private NumericRawValues loadNumeric(NumericEntry entry) throws IOException {
-    NumericRawValues ret = new NumericRawValues();
     IndexInput data = this.data.clone();
     data.seek(entry.offset + entry.missingBytes);
     switch (entry.byteWidth) {
-    case 1:
+      case 1:
       {
         final byte[] values = new byte[entry.count];
         data.readBytes(values, 0, entry.count);
-        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
-        ret.numerics = new LegacyNumericDocValues() {
+        NumericRawValues ret = new NumericRawValues() {
           @Override
-          public long get(int idx) {
-            return values[idx];
+          public long get(int docID) {
+            return values[docID];
           }
         };
+        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
         return ret;
       }
 
-    case 2:
+      case 2:
       {
         final short[] values = new short[entry.count];
         for(int i=0;i<entry.count;i++) {
           values[i] = data.readShort();
         }
-        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
-        ret.numerics = new LegacyNumericDocValues() {
+        NumericRawValues ret = new NumericRawValues() {
           @Override
-          public long get(int idx) {
-            return values[idx];
+          public long get(int docID) {
+            return values[docID];
           }
         };
+        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
         return ret;
       }
 
-    case 4:
+      case 4:
       {
         final int[] values = new int[entry.count];
         for(int i=0;i<entry.count;i++) {
           values[i] = data.readInt();
         }
-        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
-        ret.numerics = new LegacyNumericDocValues() {
+        NumericRawValues ret = new NumericRawValues() {
           @Override
-          public long get(int idx) {
-            return values[idx];
+          public long get(int docID) {
+            return values[docID];
           }
         };
+        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
         return ret;
       }
 
-    case 8:
+      case 8:
       {
         final long[] values = new long[entry.count];
         for(int i=0;i<entry.count;i++) {
           values[i] = data.readLong();
         }
-        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
-        ret.numerics = new LegacyNumericDocValues() {
+        NumericRawValues ret = new NumericRawValues() {
           @Override
-          public long get(int idx) {
-            return values[idx];
+          public long get(int docID) {
+            return values[docID];
           }
         };
+        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
         return ret;
       }
-    
-    default:
-      throw new AssertionError();
+
+      default:
+        throw new AssertionError();
     }
   }
 
-  private synchronized LegacyBinaryDocValues getLegacyBinary(FieldInfo field) throws IOException {
+  private synchronized BinaryRawValues getBinaryRawValues(FieldInfo field) throws IOException {
     BinaryRawValues instance = binaryInstances.get(field.name);
     if (instance == null) {
       // Lazy load
@@ -367,28 +417,69 @@ class DirectDocValuesProducer extends DocValuesProducer {
         ramBytesUsed.addAndGet(instance.ramBytesUsed());
       }
     }
-    final byte[] bytes = instance.bytes;
-    final int[] address = instance.address;
 
-    return new LegacyBinaryDocValues() {
-      final BytesRef term = new BytesRef();
-
-      @Override
-      public BytesRef get(int docID) {
-        term.bytes = bytes;
-        term.offset = address[docID];
-        term.length = address[docID+1] - term.offset;
-        return term;
-      }
-    };
+    return new BinaryRawValues(instance.bytes, instance.address);
   }
-  
+
   @Override
   public synchronized BinaryDocValues getBinary(FieldInfo field) throws IOException {
     BinaryEntry be = binaries.get(field.name);
-    return new LegacyBinaryDocValuesWrapper(getMissingBits(field, be.missingOffset, be.missingBytes), getLegacyBinary(field));
+    Bits docsWithField = getMissingBits(field, be.missingOffset, be.missingBytes);
+    BinaryRawValues values = getBinaryRawValues(field);
+    int maxDoc = docsWithField.length();
+    return new BinaryDocValues() {
+      private int docID = -1;
+
+      @Override
+      public BytesRef binaryValue() throws IOException {
+        return values.get(docID);
+      }
+
+      @Override
+      public boolean advanceExact(int target) throws IOException {
+        docID = target;
+        return docsWithField.get(target);
+      }
+
+      @Override
+      public int docID() {
+        return docID;
+      }
+
+      @Override
+      public int nextDoc() throws IOException {
+        docID++;
+        while (docID < maxDoc) {
+          if (docsWithField.get(docID)) {
+            return docID;
+          }
+          docID++;
+        }
+        docID = NO_MORE_DOCS;
+        return NO_MORE_DOCS;
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+        if (target < docID) {
+          throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+        }
+        if (target == NO_MORE_DOCS) {
+          this.docID = NO_MORE_DOCS;
+        } else {
+          this.docID = target-1;
+          nextDoc();
+        }
+        return docID;
+      }
+
+      @Override
+      public long cost() {
+        return 0;
+      }
+    };
   }
-  
+
   private BinaryRawValues loadBinary(BinaryEntry entry) throws IOException {
     IndexInput data = this.data.clone();
     data.seek(entry.offset);
@@ -400,14 +491,88 @@ class DirectDocValuesProducer extends DocValuesProducer {
     for(int i=0;i<entry.count;i++) {
       address[i] = data.readInt();
     }
+
     address[entry.count] = data.readInt();
+    return new BinaryRawValues(bytes, address);
+  }
 
-    BinaryRawValues values = new BinaryRawValues();
-    values.bytes = bytes;
-    values.address = address;
-    return values;
+  private static class SortedDocValuesSub extends SortedDocValues {
+    private final NumericRawValues numericRawValues;
+    private final BinaryRawValues binaryRawValues;
+    private final int count;
+    private final int maxDoc;
+    private int docID = -1;
+    private int ord;
+
+    public SortedDocValuesSub(NumericRawValues numericRawValues, BinaryRawValues binaryRawValues, int count, int maxDoc) {
+      this.numericRawValues = numericRawValues;
+      this.binaryRawValues = binaryRawValues;
+      this.count = count;
+      this.maxDoc = maxDoc;
+    }
+
+    @Override
+    public int docID() {
+      return docID;
+    }
+
+    @Override
+    public int nextDoc() {
+      assert docID != NO_MORE_DOCS;
+      docID++;
+      while (docID < maxDoc) {
+        ord = (int) numericRawValues.get(docID);
+        if (ord != -1) {
+          return docID;
+        }
+        docID++;
+      }
+      docID = NO_MORE_DOCS;
+      return NO_MORE_DOCS;
+    }
+
+    @Override
+    public int advance(int target) {
+      if (target < docID) {
+        throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+      }
+      if (target >= maxDoc) {
+        this.docID = NO_MORE_DOCS;
+      } else {
+        this.docID = target-1;
+        nextDoc();
+      }
+      return docID;
+    }
+
+    @Override
+    public boolean advanceExact(int target) throws IOException {
+      docID = target;
+      ord = (int) numericRawValues.get(docID);
+      return ord != -1;
+    }
+
+    @Override
+    public long cost() {
+      return 0;
+    }
+
+    @Override
+    public int ordValue() {
+      return ord;
+    }
+
+    @Override
+    public BytesRef lookupOrd(int ord) {
+      return binaryRawValues.get(ord);
+    }
+
+    @Override
+    public int getValueCount() {
+      return count;
+    }
   }
-  
+
   @Override
   public SortedDocValues getSorted(FieldInfo field) throws IOException {
     final SortedEntry entry = sorteds.get(field.name);
@@ -423,31 +588,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
         }
       }
     }
-    return new LegacySortedDocValuesWrapper(newSortedInstance(instance.docToOrd.numerics, getLegacyBinary(field), entry.values.count), maxDoc);
-  }
-  
-  private LegacySortedDocValues newSortedInstance(final LegacyNumericDocValues docToOrd, final LegacyBinaryDocValues values, final int count) {
-    return new LegacySortedDocValues() {
-
-      @Override
-      public int getOrd(int docID) {
-        return (int) docToOrd.get(docID);
-      }
-
-      @Override
-      public BytesRef lookupOrd(int ord) {
-        return values.get(ord);
-      }
-
-      @Override
-      public int getValueCount() {
-        return count;
-      }
-
-      // Leave lookupTerm to super's binary search
-
-      // Leave termsEnum to super
-    };
+    return new SortedDocValuesSub(instance.docToOrd, getBinaryRawValues(field), entry.values.count, maxDoc);
   }
 
   private SortedRawValues loadSorted(FieldInfo field) throws IOException {
@@ -470,38 +611,88 @@ class DirectDocValuesProducer extends DocValuesProducer {
         ramBytesUsed.addAndGet(instance.ramBytesUsed());
       }
     }
-    
+
     if (entry.docToAddress == null) {
-      final LegacyNumericDocValues single = instance.values.numerics;
       final Bits docsWithField = getMissingBits(field, entry.values.missingOffset, entry.values.missingBytes);
-      return DocValues.singleton(new LegacyNumericDocValuesWrapper(docsWithField, single));
+      return DocValues.singleton(new NumericDocValuesSub(docsWithField, instance.values));
     } else {
-      final LegacyNumericDocValues docToAddress = instance.docToAddress.numerics;
-      final LegacyNumericDocValues values = instance.values.numerics;
-      
-      return new LegacySortedNumericDocValuesWrapper(new LegacySortedNumericDocValues() {
+      final NumericRawValues docToAddress = instance.docToAddress;
+      final NumericRawValues values = instance.values;
+
+      return new SortedNumericDocValues() {
+        private int docID = -1;
+        private int upto;
         int valueStart;
         int valueLimit;
-        
-        @Override
-        public void setDocument(int doc) {
+
+        private void setDocument(int doc) {
           valueStart = (int) docToAddress.get(doc);
           valueLimit = (int) docToAddress.get(doc+1);
         }
-        
+
         @Override
-        public long valueAt(int index) {
-          return values.get(valueStart + index);
+        public long nextValue() throws IOException {
+          return values.get(valueStart + upto++);
         }
-        
+
         @Override
-        public int count() {
+        public int docValueCount() {
           return valueLimit - valueStart;
         }
-        }, maxDoc);
+
+        @Override
+        public boolean advanceExact(int target) throws IOException {
+          docID = target;
+          setDocument(docID);
+          upto = 0;
+          return docValueCount() != 0;
+        }
+
+        @Override
+        public int docID() {
+          return docID;
+        }
+
+        @Override
+        public int nextDoc() throws IOException {
+          assert docID != NO_MORE_DOCS;
+          while (true) {
+            docID++;
+            if (docID == maxDoc) {
+              docID = NO_MORE_DOCS;
+              break;
+            }
+            setDocument(docID);
+            if (docValueCount() != 0) {
+              break;
+            }
+          }
+          upto = 0;
+          return docID;
+        }
+
+        @Override
+        public int advance(int target) throws IOException {
+          if (target < docID) {
+            throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+          }
+          if (target >= maxDoc) {
+            docID = NO_MORE_DOCS;
+          } else {
+            docID = target-1;
+            nextDoc();
+          }
+          return docID;
+        }
+
+        @Override
+        public long cost() {
+          return 0;
+        }
+      };
     }
   }
-  
+
   private SortedNumericRawValues loadSortedNumeric(SortedNumericEntry entry) throws IOException {
     SortedNumericRawValues instance = new SortedNumericRawValues();
     if (entry.docToAddress != null) {
@@ -525,51 +716,102 @@ class DirectDocValuesProducer extends DocValuesProducer {
     }
 
     if (instance.docToOrdAddress == null) {
-      LegacySortedDocValues sorted = newSortedInstance(instance.ords.numerics, getLegacyBinary(field), entry.values.count);
-      return DocValues.singleton(new LegacySortedDocValuesWrapper(sorted, maxDoc));
+      return DocValues.singleton(new SortedDocValuesSub(instance.ords, getBinaryRawValues(field), entry.values.count, maxDoc));
     } else {
-      final LegacyNumericDocValues docToOrdAddress = instance.docToOrdAddress.numerics;
-      final LegacyNumericDocValues ords = instance.ords.numerics;
-      final LegacyBinaryDocValues values = getLegacyBinary(field);
-      
-      // Must make a new instance since the iterator has state:
-      return new LegacySortedSetDocValuesWrapper(new LegacySortedSetDocValues() {
+      final NumericRawValues docToOrdAddress = instance.docToOrdAddress;
+      final NumericRawValues ords = instance.ords;
+      final BinaryRawValues values = getBinaryRawValues(field);
+
+      return new SortedSetDocValues() {
         int ordStart;
         int ordUpto;
         int ordLimit;
-        
-        @Override
-        public long nextOrd() {
+        private int docID = -1;
+        private long ord;
+
+        private long innerNextOrd() {
           if (ordUpto == ordLimit) {
             return NO_MORE_ORDS;
           } else {
             return ords.get(ordUpto++);
           }
         }
-        
-        @Override
-        public void setDocument(int docID) {
+
+        private void setDocument(int docID) {
           ordStart = ordUpto = (int) docToOrdAddress.get(docID);
           ordLimit = (int) docToOrdAddress.get(docID+1);
         }
-        
+
         @Override
-        public BytesRef lookupOrd(long ord) {
+        public long nextOrd() throws IOException {
+          long result = ord;
+          if (result != NO_MORE_ORDS) {
+            ord = innerNextOrd();
+          }
+          return result;
+        }
+
+        @Override
+        public BytesRef lookupOrd(long ord) throws IOException {
           return values.get((int) ord);
         }
-        
+
         @Override
         public long getValueCount() {
           return entry.values.count;
         }
-        
-        // Leave lookupTerm to super's binary search
-        
-        // Leave termsEnum to super
-        }, maxDoc);
+
+        @Override
+        public boolean advanceExact(int target) throws IOException {
+          docID = target;
+          setDocument(docID);
+          ord = innerNextOrd();
+          return ord != NO_MORE_ORDS;
+        }
+
+        @Override
+        public int docID() {
+          return docID;
+        }
+
+        @Override
+        public int nextDoc() throws IOException {
+          assert docID != NO_MORE_DOCS;
+          docID++;
+          while (docID < maxDoc) {
+            setDocument(docID);
+            ord = innerNextOrd();
+            if (ord != NO_MORE_ORDS) {
+              return docID;
+            }
+            docID++;
+          }
+          docID = NO_MORE_DOCS;
+          return NO_MORE_DOCS;
+        }
+
+        @Override
+        public int advance(int target) throws IOException {
+          if (target < docID) {
+            throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+          }
+          if (target >= maxDoc) {
+            this.docID = NO_MORE_DOCS;
+          } else {
+            this.docID = target-1;
+            nextDoc();
+          }
+          return docID;
+        }
+
+        @Override
+        public long cost() {
+          return 0;
+        }
+      };
     }
   }
-  
+
   private SortedSetRawValues loadSortedSet(SortedSetEntry entry) throws IOException {
     SortedSetRawValues instance = new SortedSetRawValues();
     if (entry.docToOrdAddress != null) {
@@ -604,7 +846,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       return instance;
     }
   }
-  
+
   @Override
   public synchronized DocValuesProducer getMergeInstance() {
     return new DirectDocValuesProducer(this);
@@ -618,7 +860,20 @@ class DirectDocValuesProducer extends DocValuesProducer {
   static class BinaryRawValues implements Accountable {
     byte[] bytes;
     int[] address;
-    
+    final BytesRef term = new BytesRef();
+
+    public BinaryRawValues(byte[] bytes, int[] address) {
+      this.bytes = bytes;
+      this.address = address;
+    }
+
+    public BytesRef get(int docID) {
+      term.bytes = bytes;
+      term.offset = address[docID];
+      term.length = address[docID+1] - term.offset;
+      return term;
+    }
+
     @Override
     public long ramBytesUsed() {
       long bytesUsed = RamUsageEstimator.sizeOf(bytes);
@@ -627,7 +882,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       }
       return bytesUsed;
     }
-    
+
     @Override
     public Collection<Accountable> getChildResources() {
       List<Accountable> resources = new ArrayList<>();
@@ -643,16 +898,17 @@ class DirectDocValuesProducer extends DocValuesProducer {
       return getClass().getSimpleName();
     }
   }
-  
-  static class NumericRawValues implements Accountable {
-    LegacyNumericDocValues numerics;
+
+  abstract static class NumericRawValues implements Accountable {
     long bytesUsed;
-    
+
+    public abstract long get(int docID);
+
     @Override
     public long ramBytesUsed() {
       return bytesUsed;
     }
-    
+
     @Override
     public String toString() {
       return getClass().getSimpleName();
@@ -671,17 +927,17 @@ class DirectDocValuesProducer extends DocValuesProducer {
     public Collection<Accountable> getChildResources() {
       return docToOrd.getChildResources();
     }
-    
+
     @Override
     public String toString() {
       return getClass().getSimpleName();
     }
   }
-  
+
   static class SortedNumericRawValues implements Accountable {
     NumericRawValues docToAddress;
     NumericRawValues values;
-    
+
     @Override
     public long ramBytesUsed() {
       long bytesUsed = values.ramBytesUsed();
@@ -690,7 +946,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       }
       return bytesUsed;
     }
-    
+
     @Override
     public Collection<Accountable> getChildResources() {
       List<Accountable> resources = new ArrayList<>();
@@ -700,7 +956,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       resources.add(Accountables.namedAccountable("values", values));
       return Collections.unmodifiableList(resources);
     }
-    
+
     @Override
     public String toString() {
       return getClass().getSimpleName();
@@ -729,7 +985,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
       resources.add(Accountables.namedAccountable("ordinals", ords));
       return Collections.unmodifiableList(resources);
     }
-    
+
     @Override
     public String toString() {
       return getClass().getSimpleName();
@@ -756,7 +1012,7 @@ class DirectDocValuesProducer extends DocValuesProducer {
     int packedIntsVersion;
     int blockSize;
   }
-  
+
   static class SortedEntry {
     NumericEntry docToOrd;
     BinaryEntry values;
@@ -767,12 +1023,12 @@ class DirectDocValuesProducer extends DocValuesProducer {
     NumericEntry ords;
     BinaryEntry values;
   }
-  
+
   static class SortedNumericEntry {
     NumericEntry docToAddress;
     NumericEntry values;
   }
-  
+
   static class FSTEntry {
     long offset;
     long numOrds;
