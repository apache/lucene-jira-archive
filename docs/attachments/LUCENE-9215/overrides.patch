diff --git a/buildSrc/src/main/java/org/apache/lucene/gradle/MissingDoclet.java b/buildSrc/src/main/java/org/apache/lucene/gradle/MissingDoclet.java
index 413b9250b8e..83846dd612f 100644
--- a/buildSrc/src/main/java/org/apache/lucene/gradle/MissingDoclet.java
+++ b/buildSrc/src/main/java/org/apache/lucene/gradle/MissingDoclet.java
@@ -22,10 +22,16 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
+import java.util.stream.Stream;
 
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.ModuleElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
@@ -39,7 +45,7 @@ import jdk.javadoc.doclet.StandardDoclet;
 /**
  * Checks for missing javadocs, where missing also means "only whitespace" or "license header".
  * Has option --missing-level (package, class, method) so that we can improve over time.
- * Has option --missing-ignore to ignore individual elements (such as split packages). 
+ * Has option --missing-ignore to ignore individual elements (such as split packages).
  *   It isn't recursive, just ignores exactly the elements you tell it.
  *   This should be removed when packaging is fixed to no longer be split across JARs.
  * Has option --missing-method to apply "method" level to selected packages (fix one at a time).
@@ -56,7 +62,7 @@ public class MissingDoclet extends StandardDoclet {
   Elements elementUtils;
   Set<String> ignored = Collections.emptySet();
   Set<String> methodPackages = Collections.emptySet();
-  
+
   @Override
   public Set<Doclet.Option> getSupportedOptions() {
     Set<Doclet.Option> options = new HashSet<>();
@@ -188,7 +194,7 @@ public class MissingDoclet extends StandardDoclet {
 
     return super.run(docEnv);
   }
-  
+
   /**
    * Returns effective check level for this element
    */
@@ -200,8 +206,8 @@ public class MissingDoclet extends StandardDoclet {
       return level;
     }
   }
-  
-  /** 
+
+  /**
    * Check an individual element.
    * This checks packages and types from the doctrees.
    * It will recursively check methods/fields from encountered types when the level is "method"
@@ -226,9 +232,9 @@ public class MissingDoclet extends StandardDoclet {
           checkComment(element);
           for (var subElement : element.getEnclosedElements()) {
             // don't recurse into enclosed types, otherwise we'll double-check since they are already in the included docTree
-            if (subElement.getKind() == ElementKind.METHOD || 
-                subElement.getKind() == ElementKind.CONSTRUCTOR || 
-                subElement.getKind() == ElementKind.FIELD || 
+            if (subElement.getKind() == ElementKind.METHOD ||
+                subElement.getKind() == ElementKind.CONSTRUCTOR ||
+                subElement.getKind() == ElementKind.FIELD ||
                 subElement.getKind() == ElementKind.ENUM_CONSTANT) {
               check(subElement);
             }
@@ -248,9 +254,25 @@ public class MissingDoclet extends StandardDoclet {
         error(element, "I don't know how to analyze " + element.getKind() + " yet.");
     }
   }
-  
+
   /** Return true if the method is annotated with Override, if so, don't require javadocs (they'll be copied) */
   private boolean isOverridden(Element element) {
+    if (element instanceof ExecutableElement) {
+      ExecutableElement thisMethod = (ExecutableElement) element;
+      Iterable<Element> superTypes =
+          () -> superTypeForInheritDoc(thisMethod.getEnclosingElement()).iterator();
+
+      for (Element sup : superTypes) {
+        for (ExecutableElement supMethod : ElementFilter.methodsIn(sup.getEnclosedElements())) {
+          TypeElement clazz = (TypeElement) thisMethod.getEnclosingElement();
+          if (elementUtils.overrides(thisMethod, supMethod, clazz)) {
+            System.out.println(String.format(Locale.ROOT,
+                "Method %s overrides %s!", thisMethod, supMethod));
+          }
+        }
+      }
+    }
+
     for (var annotation : element.getAnnotationMirrors()) {
       if (annotation.getAnnotationType().toString().equals(Override.class.getName())) {
         return true;
@@ -258,8 +280,31 @@ public class MissingDoclet extends StandardDoclet {
     }
     return false;
   }
-  
-  /** 
+
+
+  /* Find types from which methods in type may inherit javadoc, in the proper order.*/
+  private Stream<Element> superTypeForInheritDoc(Element type) {
+    TypeElement clazz = (TypeElement) type;
+    Stream<Element> result = interfaces(clazz);
+    result = Stream.concat(result, interfaces(clazz).flatMap(el -> superTypeForInheritDoc(el)));
+
+    if (clazz.getSuperclass().getKind() == TypeKind.DECLARED) {
+      Element superClass = ((DeclaredType) clazz.getSuperclass()).asElement();
+      result = Stream.concat(result, Stream.of(superClass));
+      result = Stream.concat(result, superTypeForInheritDoc(superClass));
+    }
+
+    return result;
+  }
+
+  private Stream<Element> interfaces(TypeElement clazz) {
+    return clazz.getInterfaces()
+        .stream()
+        .filter(tm -> tm.getKind() == TypeKind.DECLARED)
+        .map(tm -> ((DeclaredType) tm).asElement());
+  }
+
+  /**
    * Return true if the method is synthetic enum method (values/valueOf).
    * According to the doctree documentation, the "included" set never includes synthetic elements.
    * UweSays: It should not happen but it happens!
@@ -272,7 +317,7 @@ public class MissingDoclet extends StandardDoclet {
     }
     return false;
   }
-  
+
   /**
    * Checks that an element doesn't have missing javadocs.
    * In addition to truly "missing", check that comments aren't solely whitespace (generated by some IDEs),
@@ -305,7 +350,7 @@ public class MissingDoclet extends StandardDoclet {
       }
     }
   }
-  
+
   /** logs a new error for the particular element */
   private void error(Element element, String message) {
     var fullMessage = new StringBuilder();
