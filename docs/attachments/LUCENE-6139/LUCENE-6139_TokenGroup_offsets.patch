Index: lucene/highlighter/src/java/org/apache/lucene/search/highlight/TokenGroup.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/highlight/TokenGroup.java	(revision 1648727)
+++ lucene/highlighter/src/java/org/apache/lucene/search/highlight/TokenGroup.java	(revision )
@@ -24,19 +24,21 @@
 
 /**
  * One, or several overlapping tokens, along with the score(s) and the scope of
- * the original text
+ * the original text.
  */
 public class TokenGroup {
 
   private static final int MAX_NUM_TOKENS_PER_GROUP = 50;
-  Token [] tokens=new Token[MAX_NUM_TOKENS_PER_GROUP];
-  float[] scores = new float[MAX_NUM_TOKENS_PER_GROUP];
-  int numTokens = 0;
-  int startOffset = 0;
-  int endOffset = 0;
-  float tot;
-  int matchStartOffset, matchEndOffset;
 
+  private Token[] tokens = new Token[MAX_NUM_TOKENS_PER_GROUP];
+  private float[] scores = new float[MAX_NUM_TOKENS_PER_GROUP];
+  private int numTokens = 0;
+  private int startOffset = 0;
+  private int endOffset = 0;
+  private float tot;
+  private int matchStartOffset;
+  private int matchEndOffset;
+
   private OffsetAttribute offsetAtt;
   private CharTermAttribute termAtt;
 
@@ -47,8 +49,8 @@
 
   void addToken(float score) {
     if (numTokens < MAX_NUM_TOKENS_PER_GROUP) {
-      int termStartOffset = offsetAtt.startOffset();
-      int termEndOffset = offsetAtt.endOffset();
+      final int termStartOffset = offsetAtt.startOffset();
+      final int termEndOffset = offsetAtt.endOffset();
       if (numTokens == 0) {
         startOffset = matchStartOffset = termStartOffset;
         endOffset = matchEndOffset = termEndOffset;
@@ -58,8 +60,8 @@
         endOffset = Math.max(endOffset, termEndOffset);
         if (score > 0) {
           if (tot == 0) {
-            matchStartOffset = offsetAtt.startOffset();
-            matchEndOffset = offsetAtt.endOffset();
+            matchStartOffset = termStartOffset;
+            matchEndOffset = termEndOffset;
           } else {
             matchStartOffset = Math.min(matchStartOffset, termStartOffset);
             matchEndOffset = Math.max(matchEndOffset, termEndOffset);
@@ -84,15 +86,14 @@
     numTokens = 0;
     tot = 0;
   }
-  
+
-  /* 
+  /**
-  * @param index a value between 0 and numTokens -1
-  * @return the "n"th token
-  */
+   * @param index a value between 0 and numTokens -1
+   * @return the "n"th token
+   */
- public Token getToken(int index)
- {
+  public Token getToken(int index) {
-     return tokens[index];
- }
+    return tokens[index];
+  }
 
   /**
    * 
@@ -104,10 +105,19 @@
   }
 
   /**
-   * @return the end position in the original text
+   * @return the earliest start offset in the original text of a matching token in this group (score &gt; 0), or
+   * if there are none then the earliest offset of any token in the group.
    */
+  public int getStartOffset() {
+    return matchStartOffset;
+  }
+
+  /**
+   * @return the latest end offset in the original text of a matching token in this group (score &gt; 0), or
+   * if there are none then {@link #getEndOffset()}.
+   */
   public int getEndOffset() {
-    return endOffset;
+    return matchEndOffset;
   }
 
   /**
@@ -118,16 +128,10 @@
   }
 
   /**
-   * @return the start position in the original text
-   */
-  public int getStartOffset() {
-    return startOffset;
-  }
-
-  /**
    * @return all tokens' scores summed up
    */
   public float getTotalScore() {
     return tot;
   }
+
 }
Index: lucene/highlighter/src/java/org/apache/lucene/search/highlight/Highlighter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/highlight/Highlighter.java	(revision 1648727)
+++ lucene/highlighter/src/java/org/apache/lucene/search/highlight/Highlighter.java	(revision )
@@ -225,12 +225,12 @@
           throw new InvalidTokenOffsetsException("Token "+ termAtt.toString()
               +" exceeds length of provided text sized "+text.length());
         }
-        if((tokenGroup.numTokens>0)&&(tokenGroup.isDistinct()))
+        if((tokenGroup.getNumTokens() >0)&&(tokenGroup.isDistinct()))
         {
           //the current token is distinct from previous tokens -
           // markup the cached token group info
-          startOffset = tokenGroup.matchStartOffset;
-          endOffset = tokenGroup.matchEndOffset;
+          startOffset = tokenGroup.getStartOffset();
+          endOffset = tokenGroup.getEndOffset();
           tokenText = text.substring(startOffset, endOffset);
           String markedUpText=formatter.highlightTerm(encoder.encodeText(tokenText), tokenGroup);
           //store any whitespace etc from between this and last group
@@ -261,11 +261,11 @@
       }
       currentFrag.setScore(fragmentScorer.getFragmentScore());
 
-      if(tokenGroup.numTokens>0)
+      if(tokenGroup.getNumTokens() >0)
       {
         //flush the accumulated text (same code as in above loop)
-        startOffset = tokenGroup.matchStartOffset;
-        endOffset = tokenGroup.matchEndOffset;
+        startOffset = tokenGroup.getStartOffset();
+        endOffset = tokenGroup.getEndOffset();
         tokenText = text.substring(startOffset, endOffset);
         String markedUpText=formatter.highlightTerm(encoder.encodeText(tokenText), tokenGroup);
         //store any whitespace etc from between this and last group
