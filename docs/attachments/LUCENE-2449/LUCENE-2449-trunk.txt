Index: lucene/src/java/org/apache/lucene/index/codecs/standard/StandardTermsDictReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/standard/StandardTermsDictReader.java	(revision 943137)
+++ lucene/src/java/org/apache/lucene/index/codecs/standard/StandardTermsDictReader.java	(working copy)
@@ -296,7 +296,7 @@
         fieldTerm.term = term;
         TermState cachedState;
         if (useCache) {
-          cachedState = termsCache.get(new FieldAndTerm(fieldTerm));
+          cachedState = termsCache.get(fieldTerm);
           if (cachedState != null) {
             state.copy(cachedState);
             seekPending = true;
Index: lucene/src/java/org/apache/lucene/util/DoubleBarrelLRUCache.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/DoubleBarrelLRUCache.java	(revision 943137)
+++ lucene/src/java/org/apache/lucene/util/DoubleBarrelLRUCache.java	(working copy)
@@ -28,8 +28,9 @@
  * <p>At any given time, one hash is primary and the other
  * is secondary.  {@link #get} first checks primary, and if
  * that's a miss, checks secondary.  If secondary has the
- * entry, it's promoted to primary.  Once primary is full,
- * the secondary is cleared and the two are swapped.</p>
+ * entry, it's promoted to primary (<b>NOTE</b>: the key is
+ * cloned at this point).  Once primary is full, the
+ * secondary is cleared and the two are swapped.</p>
  *
  * <p>This is not as space efficient as other possible
  * concurrent approaches (see LUCENE-2075): to achieve
@@ -41,7 +42,7 @@
  * @lucene.internal
  */
 
-final public class DoubleBarrelLRUCache<K,V> {
+final public class DoubleBarrelLRUCache<K extends DoubleBarrelLRUCache.CloneableKey,V> {
 
   public static abstract class CloneableKey {
     abstract public Object clone();
@@ -78,7 +79,7 @@
       result = secondary.get(key);
       if (result != null) {
         // Promote to primary
-        put(key, result);
+        put((K) key.clone(), result);
       }
     }
     return result;
