Index: src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest.java	(date 1523327887000)
+++ src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest.java	(revision )
@@ -17,11 +17,15 @@
 package org.apache.lucene.spatial3d.geom;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import com.carrotsearch.randomizedtesting.annotations.Repeat;
+import com.carrotsearch.randomizedtesting.generators.BiasedNumbers;
 import org.junit.Test;
 
+import static com.carrotsearch.randomizedtesting.RandomizedTest.randomDouble;
+
 /**
  * Random test for polygons.
  */
@@ -84,4 +88,140 @@
     GeoCompositePolygon polygon = (GeoCompositePolygon)GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE, points);
     assertTrue(polygon.size() == 3);
   }
+
+  /**
+   * Test comparing different polygon technologies using random
+   * biased doubles.
+   */
+  @Test
+  @Repeat(iterations = 10)
+  public void testComparePolygons() {
+    final PlanetModel planetModel = randomPlanetModel();
+    //Create polygon points using a reference point and a maximum distance to the point
+    final GeoPoint referencePoint = getBiasedPoint(planetModel);
+    final int n = random().nextInt(4) + 4;
+    final List<GeoPoint> points = new ArrayList<>(n);
+    final double maxDistance = random().nextDouble() *  Math.PI;
+    for (int i = 0; i < n; i++) {
+      while(true) {
+        final double distance = BiasedNumbers.randomDoubleBetween(random(), 0, maxDistance);// random().nextDouble() * maxDistance;
+        final double bearing = random().nextDouble() * 2 * Math.PI;
+        GeoPoint p = planetModel.surfacePointOnBearing(referencePoint, distance, bearing);
+        if (!contains(p, points)) {
+          if (points.size() > 1 && Plane.arePointsCoplanar(points.get(points.size() -1), points.get(points.size() - 2), p)) {
+            continue;
+          }
+          points.add(p);
+          break;
+        }
+      }
+    }
+    //order points so we don't get crossing edges
+    final List<GeoPoint> orderedPoints = orderPoints(points);
+    //Comment out below to get clock-wise polygons
+    if (random().nextBoolean() && random().nextBoolean()) {
+      Collections.reverse(orderedPoints);
+    }
+    GeoPolygonFactory.PolygonDescription polygonDescription = new GeoPolygonFactory.PolygonDescription(orderedPoints);
+    GeoPolygon polygon = null;
+    try {
+      polygon = GeoPolygonFactory.makeGeoPolygon(planetModel, polygonDescription);
+    } catch(Exception e) {
+      StringBuilder buffer = new StringBuilder("Polygon failed to build with an exception:\n");
+      buffer.append(points.toString()+ "\n");
+      buffer.append("WKT:" + getWKT(orderedPoints));
+      buffer.append(e.toString());
+      fail(buffer.toString());
+    }
+    if (polygon == null) {
+      StringBuilder buffer = new StringBuilder("Polygon failed to build:\n");
+      buffer.append(points.toString()+ "\n");
+      buffer.append("WKT:" + getWKT(orderedPoints));
+      fail(buffer.toString());
+    }
+    GeoPolygon largePolygon = null;
+    try {
+      largePolygon = GeoPolygonFactory.makeLargeGeoPolygon(planetModel, Collections.singletonList(polygonDescription));
+    } catch(Exception e) {
+      StringBuilder buffer = new StringBuilder("Large polygon failed to build with an exception:\n");
+      buffer.append(points.toString()+ "\n");
+      buffer.append("WKT:" + getWKT(orderedPoints));
+      buffer.append(e.toString());
+      fail(buffer.toString());
+    }
+    if (largePolygon == null) {
+      StringBuilder buffer = new StringBuilder("Large polygon failed to build:\n");
+      buffer.append(points.toString()+ "\n");
+      buffer.append("WKT:" + getWKT(orderedPoints));
+      fail(buffer.toString());
+    }
+
+    for(int i=0;i<100000;i++) {
+      GeoPoint point = getBiasedPoint(planetModel);
+      boolean withIn1 = polygon.isWithin(point);
+      boolean withIn2 = largePolygon.isWithin(point);
+      StringBuilder buffer = new StringBuilder();
+      if (withIn1 != withIn2) {
+        //NOTE: Sometimes we get errors when check point is near a polygon point.
+        // For the time being, we filter this errors.
+        double d1 = polygon.computeOutsideDistance(DistanceStyle.ARC, point);
+        double d2  = largePolygon.computeOutsideDistance(DistanceStyle.ARC, point);
+        if (d1 == 0 && d2 == 0) {
+          continue;
+        }
+        buffer = buffer.append("\nStandard polygon: " + polygon.toString() +"\n");
+        buffer = buffer.append("\nLarge polygon: " + largePolygon.toString() +"\n");
+        buffer = buffer.append("\nPoint: " + point.toString() +"\n");
+        buffer.append("\nWKT: " + getWKT(orderedPoints));
+        buffer.append("\nWKT: POINT(" + Math.toDegrees(point.getLongitude()) + " " + Math.toDegrees(point.getLatitude()) + ")\n");
+        buffer.append("normal polygon: " +withIn1 + "\n");
+        buffer.append("large polygon: " + withIn2 + "\n");
+      }
+      assertTrue(buffer.toString(), withIn1 == withIn2);
+    }
+    //Not yet tested
+//    for(int i=0;i<100;i++) {
+//      GeoShape shape = randomGeoShape(randomShapeType(), planetModel);
+//      int rel1 = polygon.getRelationship(shape);
+//      int rel2 = largePolygon.getRelationship(shape);
+//      StringBuilder buffer = new StringBuilder();
+//      if (rel1 != rel2) {
+//        buffer = buffer.append(polygon.toString() +"\n" + shape.toString() + "\n");
+//        buffer.append("WKT: " + getWKT(orderedPoints) + "\n");
+//        buffer.append("normal polygon: " + rel1 + "\n");
+//        buffer.append("large polygon: " + rel2 + "\n");
+//      }
+//      assertTrue(buffer.toString(), rel1 == rel2);
+//    }
+  }
+
+  private GeoPoint getBiasedPoint(PlanetModel planetModel) {
+    double lat = BiasedNumbers.randomDoubleBetween(random(), 0, Math.PI / 2);
+    if (random().nextBoolean()) {
+      lat = (-1) * lat;
+    }
+    double lon = BiasedNumbers.randomDoubleBetween(random(), 0, Math.PI);
+    if (random().nextBoolean()) {
+      lon = (-1) * lon;
+    }
+    return new GeoPoint(planetModel, lat, lon);
+  }
+
+  private String getWKT(List<GeoPoint> points) {
+    StringBuffer buffer = new StringBuffer("POLYGON((");
+    for (GeoPoint point : points) {
+      buffer.append(Math.toDegrees(point.getLongitude()) + " " + Math.toDegrees(point.getLatitude()) + ",");
+    }
+    buffer.append(Math.toDegrees(points.get(0).getLongitude()) + " " + Math.toDegrees(points.get(0).getLatitude()) + "))\n");
+    return buffer.toString();
+  }
+
+  private boolean contains(GeoPoint p, List<GeoPoint> points) {
+    for (GeoPoint point : points) {
+      if (point.isNumericallyIdentical(p)) {
+        return true;
+      }
+    }
+    return false;
+  }
 }
Index: src/test/org/apache/lucene/spatial3d/geom/RandomGeo3dShapeGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/org/apache/lucene/spatial3d/geom/RandomGeo3dShapeGenerator.java	(date 1523327887000)
+++ src/test/org/apache/lucene/spatial3d/geom/RandomGeo3dShapeGenerator.java	(revision )
@@ -897,7 +897,7 @@
    * @param points The points to order.
    * @return The list of ordered points anti-clockwise.
    */
-  private List<GeoPoint> orderPoints(List<GeoPoint> points) {
+  protected List<GeoPoint> orderPoints(List<GeoPoint> points) {
     double x = 0;
     double y = 0;
     double z = 0;
