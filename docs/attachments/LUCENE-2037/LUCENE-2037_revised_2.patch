Index: common-build.xml
===================================================================
--- common-build.xml	(revision 887375)
+++ common-build.xml	(working copy)
@@ -47,7 +47,7 @@
   <property name="year" value="2000-${current.year}"/>
   <property name="final.name" value="lucene-${name}-${version}"/>
 
-  <property name="junit.jar" value="junit-3.8.2.jar"/>
+  <property name="junit.jar" value="junit-4.7.jar"/>
   <property name="junit-location.jar" value="${common.dir}/lib/${junit.jar}"/>
   <path id="junit-path">
     <pathelement location="${junit-location.jar}"/>
Index: CHANGES.txt
===================================================================
--- CHANGES.txt	(revision 887375)
+++ CHANGES.txt	(working copy)
@@ -63,6 +63,8 @@
 
 Test Cases
 
+* LUCENE-2037 Allow Junit4 tests in our envrionment (Erick Erickson)
+
 * LUCENE-1844: Speed up the unit tests (Mark Miller, Erick Erickson,
   Mike McCandless)
 
Index: src/test/org/apache/lucene/search/TestSort.java
===================================================================
--- src/test/org/apache/lucene/search/TestSort.java	(revision 887375)
+++ src/test/org/apache/lucene/search/TestSort.java	(working copy)
@@ -747,7 +747,7 @@
     Sort[] sort = new Sort[] { new Sort(SortField.FIELD_DOC), new Sort() };
     for (int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
-      TopDocsCollector tdc = TopFieldCollector.create(sort[i], 10, false,
+      TopDocsCollector<FieldValueHitQueue.Entry> tdc = TopFieldCollector.create(sort[i], 10, false,
           false, false, true);
       
       full.search(q, tdc);
@@ -766,7 +766,7 @@
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
     for (int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
-      TopDocsCollector tdc = TopFieldCollector.create(sort[i], 10, true, false,
+      TopDocsCollector<FieldValueHitQueue.Entry> tdc = TopFieldCollector.create(sort[i], 10, true, false,
           false, true);
       
       full.search(q, tdc);
@@ -786,7 +786,7 @@
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
     for (int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
-      TopDocsCollector tdc = TopFieldCollector.create(sort[i], 10, true, true,
+      TopDocsCollector<FieldValueHitQueue.Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
           false, true);
       
       full.search(q, tdc);
@@ -806,7 +806,7 @@
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
     for (int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
-      TopDocsCollector tdc = TopFieldCollector.create(sort[i], 10, true, true,
+      TopDocsCollector<FieldValueHitQueue.Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
           true, true);
       
       full.search(q, tdc);
@@ -854,7 +854,7 @@
     bq.setMinimumNumberShouldMatch(1);
     for (int i = 0; i < sort.length; i++) {
       for (int j = 0; j < tfcOptions.length; j++) {
-        TopDocsCollector tdc = TopFieldCollector.create(sort[i], 10,
+        TopDocsCollector<FieldValueHitQueue.Entry> tdc = TopFieldCollector.create(sort[i], 10,
             tfcOptions[j][0], tfcOptions[j][1], tfcOptions[j][2], false);
 
         assertTrue(tdc.getClass().getName().endsWith("$"+actualTFCClasses[j]));
@@ -873,7 +873,7 @@
     // Two Sort criteria to instantiate the multi/single comparators.
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
     for (int i = 0; i < sort.length; i++) {
-      TopDocsCollector tdc = TopFieldCollector.create(sort[i], 10, true, true, true, true);
+      TopDocsCollector<FieldValueHitQueue.Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true, true, true);
       TopDocs td = tdc.topDocs();
       assertEquals(0, td.totalHits);
       assertTrue(Float.isNaN(td.getMaxScore()));
Index: src/test/org/apache/lucene/search/function/TestOrdValues.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestOrdValues.java	(revision 887375)
+++ src/test/org/apache/lucene/search/function/TestOrdValues.java	(working copy)
@@ -19,42 +19,42 @@
 
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.QueryUtils;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.search.*;
+import static org.junit.Assert.*;
+import org.junit.Test;
 
 /**
  * Test search based on OrdFieldSource and ReverseOrdFieldSource.
- * <p>
+ * <p/>
  * Tests here create an index with a few documents, each having
  * an indexed "id" field.
  * The ord values of this field are later used for scoring.
- * <p>
+ * <p/>
  * The order tests use Hits to verify that docs are ordered as expected.
- * <p>
- * The exact score tests use TopDocs top to verify the exact score.  
+ * <p/>
+ * The exact score tests use TopDocs top to verify the exact score.
  */
+@SuppressWarnings({"UseOfSystemOutOrSystemErr"})
 public class TestOrdValues extends FunctionTestSetup {
 
-  /* @override constructor */
-  public TestOrdValues(String name) {
-    super(name);
+  /**
+   * Test OrdFieldSource
+   */
+  @Test
+  public void testOrdFieldRank() throws CorruptIndexException, Exception {
+    doTestRank(ID_FIELD, true);
   }
 
-  /** Test OrdFieldSource */
-  public void testOrdFieldRank () throws CorruptIndexException, Exception {
-    doTestRank(ID_FIELD,true);
+  /**
+   * Test ReverseOrdFieldSource
+   */
+  @Test
+  public void testReverseOrdFieldRank() throws CorruptIndexException, Exception {
+    doTestRank(ID_FIELD, false);
   }
 
-  /** Test ReverseOrdFieldSource */
-  public void testReverseOrdFieldRank () throws CorruptIndexException, Exception {
-    doTestRank(ID_FIELD,false);
-  }
-
   // Test that queries based on reverse/ordFieldScore scores correctly
-  private void doTestRank (String field, boolean inOrder) throws CorruptIndexException, Exception {
+  private void doTestRank(String field, boolean inOrder) throws CorruptIndexException, Exception {
     IndexSearcher s = new IndexSearcher(dir, true);
     ValueSource vs;
     if (inOrder) {
@@ -62,42 +62,48 @@
     } else {
       vs = new ReverseOrdFieldSource(field);
     }
-        
+
     Query q = new ValueSourceQuery(vs);
-    log("test: "+q);
-    QueryUtils.check(q,s);
+    log("test: " + q);
+    QueryUtils.check(q, s);
     ScoreDoc[] h = s.search(q, null, 1000).scoreDocs;
-    assertEquals("All docs should be matched!",N_DOCS,h.length);
+    assertEquals("All docs should be matched!", N_DOCS, h.length);
     String prevID = inOrder
-      ? "IE"   // greater than all ids of docs in this test ("ID0001", etc.)
-      : "IC";  // smaller than all ids of docs in this test ("ID0001", etc.)
-          
-    for (int i=0; i<h.length; i++) {
+            ? "IE"   // greater than all ids of docs in this test ("ID0001", etc.)
+            : "IC";  // smaller than all ids of docs in this test ("ID0001", etc.)
+
+    for (int i = 0; i < h.length; i++) {
       String resID = s.doc(h[i].doc).get(ID_FIELD);
-      log(i+".   score="+h[i].score+"  -  "+resID);
-      log(s.explain(q,h[i].doc));
+      log(i + ".   score=" + h[i].score + "  -  " + resID);
+      log(s.explain(q, h[i].doc));
       if (inOrder) {
-        assertTrue("res id "+resID+" should be < prev res id "+prevID, resID.compareTo(prevID)<0);
+        assertTrue("res id " + resID + " should be < prev res id " + prevID, resID.compareTo(prevID) < 0);
       } else {
-        assertTrue("res id "+resID+" should be > prev res id "+prevID, resID.compareTo(prevID)>0);
+        assertTrue("res id " + resID + " should be > prev res id " + prevID, resID.compareTo(prevID) > 0);
       }
       prevID = resID;
     }
   }
 
-  /** Test exact score for OrdFieldSource */
-  public void testOrdFieldExactScore () throws CorruptIndexException, Exception {
-    doTestExactScore(ID_FIELD,true);
+  /**
+   * Test exact score for OrdFieldSource
+   */
+  @Test
+  public void testOrdFieldExactScore() throws CorruptIndexException, Exception {
+    doTestExactScore(ID_FIELD, true);
   }
 
-  /** Test exact score for ReverseOrdFieldSource */
-  public void testReverseOrdFieldExactScore () throws CorruptIndexException, Exception {
-    doTestExactScore(ID_FIELD,false);
+  /**
+   * Test exact score for ReverseOrdFieldSource
+   */
+  @Test
+  public void testReverseOrdFieldExactScore() throws CorruptIndexException, Exception {
+    doTestExactScore(ID_FIELD, false);
   }
 
-  
+
   // Test that queries based on reverse/ordFieldScore returns docs with expected score.
-  private void doTestExactScore (String field, boolean inOrder) throws CorruptIndexException, Exception {
+  private void doTestExactScore(String field, boolean inOrder) throws CorruptIndexException, Exception {
     IndexSearcher s = new IndexSearcher(dir, true);
     ValueSource vs;
     if (inOrder) {
@@ -106,41 +112,47 @@
       vs = new ReverseOrdFieldSource(field);
     }
     Query q = new ValueSourceQuery(vs);
-    TopDocs td = s.search(q,null,1000);
-    assertEquals("All docs should be matched!",N_DOCS,td.totalHits);
+    TopDocs td = s.search(q, null, 1000);
+    assertEquals("All docs should be matched!", N_DOCS, td.totalHits);
     ScoreDoc sd[] = td.scoreDocs;
-    for (int i=0; i<sd.length; i++) {
+    for (int i = 0; i < sd.length; i++) {
       float score = sd[i].score;
       String id = s.getIndexReader().document(sd[i].doc).get(ID_FIELD);
-      log("-------- "+i+". Explain doc "+id);
-      log(s.explain(q,sd[i].doc));
-      float expectedScore =  N_DOCS-i;
-      assertEquals("score of result "+i+" shuould be "+expectedScore+" != "+score, expectedScore, score, TEST_SCORE_TOLERANCE_DELTA);
-      String expectedId =  inOrder 
-        ? id2String(N_DOCS-i) // in-order ==> larger  values first 
-        : id2String(i+1);     // reverse  ==> smaller values first 
-      assertTrue("id of result "+i+" shuould be "+expectedId+" != "+score, expectedId.equals(id));
+      log("-------- " + i + ". Explain doc " + id);
+      log(s.explain(q, sd[i].doc));
+      float expectedScore = N_DOCS - i;
+      assertEquals("score of result " + i + " shuould be " + expectedScore + " != " + score, expectedScore, score, TEST_SCORE_TOLERANCE_DELTA);
+      String expectedId = inOrder
+              ? id2String(N_DOCS - i) // in-order ==> larger  values first
+              : id2String(i + 1);     // reverse  ==> smaller values first
+      assertTrue("id of result " + i + " shuould be " + expectedId + " != " + score, expectedId.equals(id));
     }
   }
-  
-  /** Test caching OrdFieldSource */
-  public void testCachingOrd () throws CorruptIndexException, Exception {
-    doTestCaching(ID_FIELD,true);
+
+  /**
+   * Test caching OrdFieldSource
+   */
+  @Test
+  public void testCachingOrd() throws CorruptIndexException, Exception {
+    doTestCaching(ID_FIELD, true);
   }
-  
-  /** Test caching for ReverseOrdFieldSource */
-  public void tesCachingReverseOrd () throws CorruptIndexException, Exception {
-    doTestCaching(ID_FIELD,false);
+
+  /**
+   * Test caching for ReverseOrdFieldSource
+   */
+  @Test
+  public void tesCachingReverseOrd() throws CorruptIndexException, Exception {
+    doTestCaching(ID_FIELD, false);
   }
 
   // Test that values loaded for FieldScoreQuery are cached properly and consumes the proper RAM resources.
-  private void doTestCaching (String field, boolean inOrder) throws CorruptIndexException, Exception {
+  private void doTestCaching(String field, boolean inOrder) throws CorruptIndexException, Exception {
     IndexSearcher s = new IndexSearcher(dir, true);
     Object innerArray = null;
 
     boolean warned = false; // print warning once
-    
-    for (int i=0; i<10; i++) {
+
+    for (int i = 0; i < 10; i++) {
       ValueSource vs;
       if (inOrder) {
         vs = new OrdFieldSource(field);
@@ -150,30 +162,29 @@
       ValueSourceQuery q = new ValueSourceQuery(vs);
       ScoreDoc[] h = s.search(q, null, 1000).scoreDocs;
       try {
-        assertEquals("All docs should be matched!",N_DOCS,h.length);
+        assertEquals("All docs should be matched!", N_DOCS, h.length);
         IndexReader[] readers = s.getIndexReader().getSequentialSubReaders();
 
-        for(int j = 0; j < readers.length; j++) {
-          IndexReader reader = readers[j];
-          if (i==0) {
+        for (IndexReader reader : readers) {
+          if (i == 0) {
             innerArray = q.valSrc.getValues(reader).getInnerArray();
           } else {
-            log(i+".  compare: "+innerArray+" to "+q.valSrc.getValues(reader).getInnerArray());
+            log(i + ".  compare: " + innerArray + " to " + q.valSrc.getValues(reader).getInnerArray());
             assertSame("field values should be cached and reused!", innerArray, q.valSrc.getValues(reader).getInnerArray());
           }
         }
       } catch (UnsupportedOperationException e) {
         if (!warned) {
-          System.err.println("WARNING: "+testName()+" cannot fully test values of "+q);
+          System.err.println("WARNING: " + testName() + " cannot fully test values of " + q);
           warned = true;
         }
       }
     }
-    
+
     ValueSource vs;
     ValueSourceQuery q;
     ScoreDoc[] h;
-    
+
     // verify that different values are loaded for a different field
     String field2 = INT_FIELD;
     assertFalse(field.equals(field2)); // otherwise this test is meaningless.
@@ -184,21 +195,20 @@
     }
     q = new ValueSourceQuery(vs);
     h = s.search(q, null, 1000).scoreDocs;
-    assertEquals("All docs should be matched!",N_DOCS,h.length);
+    assertEquals("All docs should be matched!", N_DOCS, h.length);
     IndexReader[] readers = s.getIndexReader().getSequentialSubReaders();
 
-    for (int j = 0; j < readers.length; j++) {
-      IndexReader reader = readers[j];
+    for (IndexReader reader : readers) {
       try {
         log("compare (should differ): " + innerArray + " to "
-            + q.valSrc.getValues(reader).getInnerArray());
+                + q.valSrc.getValues(reader).getInnerArray());
         assertNotSame(
-            "different values shuold be loaded for a different field!",
-            innerArray, q.valSrc.getValues(reader).getInnerArray());
+                "different values shuold be loaded for a different field!",
+                innerArray, q.valSrc.getValues(reader).getInnerArray());
       } catch (UnsupportedOperationException e) {
         if (!warned) {
           System.err.println("WARNING: " + testName()
-              + " cannot fully test values of " + q);
+                  + " cannot fully test values of " + q);
           warned = true;
         }
       }
@@ -213,21 +223,20 @@
     }
     q = new ValueSourceQuery(vs);
     h = s.search(q, null, 1000).scoreDocs;
-    assertEquals("All docs should be matched!",N_DOCS,h.length);
+    assertEquals("All docs should be matched!", N_DOCS, h.length);
     readers = s.getIndexReader().getSequentialSubReaders();
 
-    for (int j = 0; j < readers.length; j++) {
-      IndexReader reader = readers[j];
+    for (IndexReader reader : readers) {
       try {
         log("compare (should differ): " + innerArray + " to "
-            + q.valSrc.getValues(reader).getInnerArray());
+                + q.valSrc.getValues(reader).getInnerArray());
         assertNotSame(
-            "cached field values should not be reused if reader as changed!",
-            innerArray, q.valSrc.getValues(reader).getInnerArray());
+                "cached field values should not be reused if reader as changed!",
+                innerArray, q.valSrc.getValues(reader).getInnerArray());
       } catch (UnsupportedOperationException e) {
         if (!warned) {
           System.err.println("WARNING: " + testName()
-              + " cannot fully test values of " + q);
+                  + " cannot fully test values of " + q);
           warned = true;
         }
       }
@@ -235,7 +244,7 @@
   }
 
   private String testName() {
-    return getClass().getName()+"."+getName();
+    return getClass().getName() + "." + getName();
   }
 
 }
Index: src/test/org/apache/lucene/search/function/TestDocValues.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestDocValues.java	(revision 887375)
+++ src/test/org/apache/lucene/search/function/TestDocValues.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /**
  * DocValues TestCase  
@@ -41,7 +42,7 @@
     assertTrue("max is NaN - no values in inner array", Float.isNaN(docValues
         .getMinValue()));
   }
-
+  @Test
   public void testGetMaxValue() {
     float[] innerArray = new float[] { 1.0f, 2.0f, -1.0f, 10.0f };
     DocValuesTestImpl docValues = new DocValuesTestImpl(innerArray);
@@ -66,6 +67,7 @@
         .getMaxValue()));
   }
 
+  @Test
   public void testGetAverageValue() {
     float[] innerArray = new float[] { 1.0f, 1.0f, 1.0f, 1.0f };
     DocValuesTestImpl docValues = new DocValuesTestImpl(innerArray);
@@ -97,7 +99,6 @@
     /**
      * @see org.apache.lucene.search.function.DocValues#floatVal(int)
      */
-    /* @Override */
     @Override
     public float floatVal(int doc) {
       return innerArray[doc];
@@ -106,7 +107,6 @@
     /**
      * @see org.apache.lucene.search.function.DocValues#toString(int)
      */
-    /* @Override */
     @Override
     public String toString(int doc) {
       return Integer.toString(doc);
Index: src/test/org/apache/lucene/search/function/TestFieldScoreQuery.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestFieldScoreQuery.java	(revision 887375)
+++ src/test/org/apache/lucene/search/function/TestFieldScoreQuery.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.util.HashMap;
+import java.util.Map;
 
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.IndexReader;
@@ -26,6 +27,8 @@
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TopDocs;
+import org.junit.Test;
+import static org.junit.Assert.*;
 
 /**
  * Test FieldScoreQuery search.
@@ -38,32 +41,32 @@
  * <p>
  * The exact score tests use TopDocs top to verify the exact score.  
  */
+@SuppressWarnings({"UseOfSystemOutOrSystemErr"})
 public class TestFieldScoreQuery extends FunctionTestSetup {
 
-  /* @override constructor */
-  public TestFieldScoreQuery(String name) {
-    super(name);
-  }
-
   /** Test that FieldScoreQuery of Type.BYTE returns docs in expected order. */
-  public void testRankByte () throws CorruptIndexException, Exception {
+  @Test
+  public void testRankByte () throws Exception {
     // INT field values are small enough to be parsed as byte
     doTestRank(INT_FIELD,FieldScoreQuery.Type.BYTE);
   }
 
   /** Test that FieldScoreQuery of Type.SHORT returns docs in expected order. */
-  public void testRankShort () throws CorruptIndexException, Exception {
+  @Test
+  public void testRankShort () throws Exception {
     // INT field values are small enough to be parsed as short
     doTestRank(INT_FIELD,FieldScoreQuery.Type.SHORT);
   }
 
   /** Test that FieldScoreQuery of Type.INT returns docs in expected order. */
-  public void testRankInt () throws CorruptIndexException, Exception {
+  @Test
+  public void testRankInt () throws Exception {
     doTestRank(INT_FIELD,FieldScoreQuery.Type.INT);
   }
 
   /** Test that FieldScoreQuery of Type.FLOAT returns docs in expected order. */
-  public void testRankFloat () throws CorruptIndexException, Exception {
+  @Test
+  public void testRankFloat () throws Exception {
     // INT field can be parsed as float
     doTestRank(INT_FIELD,FieldScoreQuery.Type.FLOAT);
     // same values, but in flot format
@@ -71,7 +74,7 @@
   }
 
   // Test that FieldScoreQuery returns docs in expected order.
-  private void doTestRank (String field, FieldScoreQuery.Type tp) throws CorruptIndexException, Exception {
+  private void doTestRank (String field, FieldScoreQuery.Type tp) throws Exception {
     IndexSearcher s = new IndexSearcher(dir, true);
     Query q = new FieldScoreQuery(field,tp);
     log("test: "+q);
@@ -89,24 +92,28 @@
   }
 
   /** Test that FieldScoreQuery of Type.BYTE returns the expected scores. */
-  public void testExactScoreByte () throws CorruptIndexException, Exception {
+  @Test
+  public void testExactScoreByte () throws Exception {
     // INT field values are small enough to be parsed as byte
     doTestExactScore(INT_FIELD,FieldScoreQuery.Type.BYTE);
   }
 
   /** Test that FieldScoreQuery of Type.SHORT returns the expected scores. */
-  public void testExactScoreShort () throws CorruptIndexException, Exception {
+  @Test
+  public void testExactScoreShort () throws  Exception {
     // INT field values are small enough to be parsed as short
     doTestExactScore(INT_FIELD,FieldScoreQuery.Type.SHORT);
   }
 
   /** Test that FieldScoreQuery of Type.INT returns the expected scores. */
-  public void testExactScoreInt () throws CorruptIndexException, Exception {
+  @Test
+  public void testExactScoreInt () throws  Exception {
     doTestExactScore(INT_FIELD,FieldScoreQuery.Type.INT);
   }
 
   /** Test that FieldScoreQuery of Type.FLOAT returns the expected scores. */
-  public void testExactScoreFloat () throws CorruptIndexException, Exception {
+  @Test
+  public void testExactScoreFloat () throws  Exception {
     // INT field can be parsed as float
     doTestExactScore(INT_FIELD,FieldScoreQuery.Type.FLOAT);
     // same values, but in flot format
@@ -114,40 +121,44 @@
   }
 
   // Test that FieldScoreQuery returns docs with expected score.
-  private void doTestExactScore (String field, FieldScoreQuery.Type tp) throws CorruptIndexException, Exception {
+  private void doTestExactScore (String field, FieldScoreQuery.Type tp) throws Exception {
     IndexSearcher s = new IndexSearcher(dir, true);
     Query q = new FieldScoreQuery(field,tp);
     TopDocs td = s.search(q,null,1000);
     assertEquals("All docs should be matched!",N_DOCS,td.totalHits);
     ScoreDoc sd[] = td.scoreDocs;
-    for (int i=0; i<sd.length; i++) {
-      float score = sd[i].score;
-      log(s.explain(q,sd[i].doc));
-      String id = s.getIndexReader().document(sd[i].doc).get(ID_FIELD);
+    for (ScoreDoc aSd : sd) {
+      float score = aSd.score;
+      log(s.explain(q, aSd.doc));
+      String id = s.getIndexReader().document(aSd.doc).get(ID_FIELD);
       float expectedScore = expectedFieldScore(id); // "ID7" --> 7.0
-      assertEquals("score of "+id+" shuould be "+expectedScore+" != "+score, expectedScore, score, TEST_SCORE_TOLERANCE_DELTA);
+      assertEquals("score of " + id + " shuould be " + expectedScore + " != " + score, expectedScore, score, TEST_SCORE_TOLERANCE_DELTA);
     }
   }
 
   /** Test that FieldScoreQuery of Type.BYTE caches/reuses loaded values and consumes the proper RAM resources. */
-  public void testCachingByte () throws CorruptIndexException, Exception {
+  @Test
+  public void testCachingByte () throws  Exception {
     // INT field values are small enough to be parsed as byte
     doTestCaching(INT_FIELD,FieldScoreQuery.Type.BYTE);
   }
 
   /** Test that FieldScoreQuery of Type.SHORT caches/reuses loaded values and consumes the proper RAM resources. */
-  public void testCachingShort () throws CorruptIndexException, Exception {
+  @Test
+  public void testCachingShort () throws  Exception {
     // INT field values are small enough to be parsed as short
     doTestCaching(INT_FIELD,FieldScoreQuery.Type.SHORT);
   }
 
   /** Test that FieldScoreQuery of Type.INT caches/reuses loaded values and consumes the proper RAM resources. */
-  public void testCachingInt () throws CorruptIndexException, Exception {
+  @Test
+  public void testCachingInt () throws Exception {
     doTestCaching(INT_FIELD,FieldScoreQuery.Type.INT);
   }
 
   /** Test that FieldScoreQuery of Type.FLOAT caches/reuses loaded values and consumes the proper RAM resources. */
-  public void testCachingFloat () throws CorruptIndexException, Exception {
+  @Test
+  public void testCachingFloat () throws  Exception {
     // INT field values can be parsed as float
     doTestCaching(INT_FIELD,FieldScoreQuery.Type.FLOAT);
     // same values, but in flot format
@@ -223,7 +234,7 @@
   }
 
   private String testName() {
-    return getClass().getName()+"."+getName();
+    return getClass().getName()+"."+ getName();
   }
 
 }
Index: src/test/org/apache/lucene/search/function/FunctionTestSetup.java
===================================================================
--- src/test/org/apache/lucene/search/function/FunctionTestSetup.java	(revision 887375)
+++ src/test/org/apache/lucene/search/function/FunctionTestSetup.java	(working copy)
@@ -25,20 +25,23 @@
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.util.LuceneTestCaseJ4;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
 
-import org.apache.lucene.util.LuceneTestCase;
-
 /**
  * Setup for function tests
  */
-public abstract class FunctionTestSetup extends LuceneTestCase {
+@Ignore
+public class FunctionTestSetup extends LuceneTestCaseJ4 {
 
   /**
    * Actual score computation order is slightly different than assumptios
    * this allows for a small amount of variation
    */
-  public static float TEST_SCORE_TOLERANCE_DELTA = 0.001f;
-  
+  protected static float TEST_SCORE_TOLERANCE_DELTA = 0.001f;
+
   protected static final boolean DBG = false; // change to true for logging to print
 
   protected static final int N_DOCS = 17; // select a primary number > 2
@@ -47,62 +50,57 @@
   protected static final String TEXT_FIELD = "text";
   protected static final String INT_FIELD = "iii";
   protected static final String FLOAT_FIELD = "fff";
-  
+
   private static final String DOC_TEXT_LINES[] = {
-    "Well, this is just some plain text we use for creating the ",
-    "test documents. It used to be a text from an online collection ",
-    "devoted to first aid, but if there was there an (online) lawyers ",
-    "first aid collection with legal advices, \"it\" might have quite ",
-    "probably advised one not to include \"it\"'s text or the text of ",
-    "any other online collection in one's code, unless one has money ",
-    "that one don't need and one is happy to donate for lawyers ",
-    "charity. Anyhow at some point, rechecking the usage of this text, ",
-    "it became uncertain that this text is free to use, because ",
-    "the web site in the disclaimer of he eBook containing that text ",
-    "was not responding anymore, and at the same time, in projGut, ",
-    "searching for first aid no longer found that eBook as well. ",
-    "So here we are, with a perhaps much less interesting ",
-    "text for the test, but oh much much safer. ",
+          "Well, this is just some plain text we use for creating the ",
+          "test documents. It used to be a text from an online collection ",
+          "devoted to first aid, but if there was there an (online) lawyers ",
+          "first aid collection with legal advices, \"it\" might have quite ",
+          "probably advised one not to include \"it\"'s text or the text of ",
+          "any other online collection in one's code, unless one has money ",
+          "that one don't need and one is happy to donate for lawyers ",
+          "charity. Anyhow at some point, rechecking the usage of this text, ",
+          "it became uncertain that this text is free to use, because ",
+          "the web site in the disclaimer of he eBook containing that text ",
+          "was not responding anymore, and at the same time, in projGut, ",
+          "searching for first aid no longer found that eBook as well. ",
+          "So here we are, with a perhaps much less interesting ",
+          "text for the test, but oh much much safer. ",
   };
-  
-  protected Directory dir;
-  protected Analyzer anlzr;
-  
-  /* @override constructor */
-  public FunctionTestSetup(String name) {
-    super(name);
-  }
 
-  /* @override */
+  protected Directory dir = null;
+  protected Analyzer anlzr = null;
+
   @Override
-  protected void tearDown() throws Exception {
+  @After
+  public void tearDown() throws Exception {
     super.tearDown();
     dir = null;
     anlzr = null;
   }
 
-  /* @override */
   @Override
-  protected void setUp() throws Exception {
+  @Before
+  public void setUp() throws Exception {
     super.setUp();
     // prepare a small index with just a few documents.  
     super.setUp();
     dir = new RAMDirectory();
     anlzr = new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT);
     IndexWriter iw = new IndexWriter(dir, anlzr,
-                                     IndexWriter.MaxFieldLength.LIMITED);
+            IndexWriter.MaxFieldLength.LIMITED);
     // add docs not exactly in natural ID order, to verify we do check the order of docs by scores
     int remaining = N_DOCS;
     boolean done[] = new boolean[N_DOCS];
     int i = 0;
-    while (remaining>0) {
+    while (remaining > 0) {
       if (done[i]) {
-        throw new Exception("to set this test correctly N_DOCS="+N_DOCS+" must be primary and greater than 2!");
+        throw new Exception("to set this test correctly N_DOCS=" + N_DOCS + " must be primary and greater than 2!");
       }
-      addDoc(iw,i);
+      addDoc(iw, i);
       done[i] = true;
-      i = (i+4)%N_DOCS;
-      remaining --;
+      i = (i + 4) % N_DOCS;
+      remaining--;
     }
     iw.close();
   }
@@ -110,36 +108,36 @@
   private void addDoc(IndexWriter iw, int i) throws Exception {
     Document d = new Document();
     Fieldable f;
-    int scoreAndID = i+1;
-    
-    f = new Field(ID_FIELD,id2String(scoreAndID),Field.Store.YES,Field.Index.NOT_ANALYZED); // for debug purposes
+    int scoreAndID = i + 1;
+
+    f = new Field(ID_FIELD, id2String(scoreAndID), Field.Store.YES, Field.Index.NOT_ANALYZED); // for debug purposes
     f.setOmitNorms(true);
     d.add(f);
-    
-    f = new Field(TEXT_FIELD,"text of doc"+scoreAndID+textLine(i),Field.Store.NO,Field.Index.ANALYZED); // for regular search
+
+    f = new Field(TEXT_FIELD, "text of doc" + scoreAndID + textLine(i), Field.Store.NO, Field.Index.ANALYZED); // for regular search
     f.setOmitNorms(true);
     d.add(f);
-    
-    f = new Field(INT_FIELD,""+scoreAndID,Field.Store.NO,Field.Index.NOT_ANALYZED); // for function scoring
+
+    f = new Field(INT_FIELD, "" + scoreAndID, Field.Store.NO, Field.Index.NOT_ANALYZED); // for function scoring
     f.setOmitNorms(true);
     d.add(f);
-    
-    f = new Field(FLOAT_FIELD,scoreAndID+".000",Field.Store.NO,Field.Index.NOT_ANALYZED); // for function scoring
+
+    f = new Field(FLOAT_FIELD, scoreAndID + ".000", Field.Store.NO, Field.Index.NOT_ANALYZED); // for function scoring
     f.setOmitNorms(true);
     d.add(f);
 
     iw.addDocument(d);
-    log("added: "+d);
+    log("added: " + d);
   }
 
   // 17 --> ID00017
   protected String id2String(int scoreAndID) {
-    String s = "000000000"+scoreAndID;
-    int n = (""+N_DOCS).length() + 3;
-    int k = s.length() - n; 
-    return "ID"+s.substring(k);
+    String s = "000000000" + scoreAndID;
+    int n = ("" + N_DOCS).length() + 3;
+    int k = s.length() - n;
+    return "ID" + s.substring(k);
   }
-  
+
   // some text line for regular search
   private String textLine(int docNum) {
     return DOC_TEXT_LINES[docNum % DOC_TEXT_LINES.length];
@@ -147,11 +145,11 @@
 
   // extract expected doc score from its ID Field: "ID7" --> 7.0
   protected float expectedFieldScore(String docIDFieldVal) {
-    return Float.parseFloat(docIDFieldVal.substring(2)); 
+    return Float.parseFloat(docIDFieldVal.substring(2));
   }
-  
+
   // debug messages (change DBG to true for anything to print) 
-  protected void log (Object o) {
+  protected void log(Object o) {
     if (DBG) {
       System.out.println(o.toString());
     }
Index: src/test/org/apache/lucene/search/function/JustCompileSearchSpans.java
===================================================================
--- src/test/org/apache/lucene/search/function/JustCompileSearchSpans.java	(revision 887375)
+++ src/test/org/apache/lucene/search/function/JustCompileSearchSpans.java	(working copy)
@@ -17,11 +17,11 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.FieldCache;
 
+import java.io.IOException;
+
 /**
  * Holds all implementations of classes in the o.a.l.s.function package as a
  * back-compatibility test. It does not run any tests per-se, however if
@@ -34,7 +34,6 @@
   private static final String UNSUPPORTED_MSG = "unsupported: used for back-compat testing only !";
 
   static final class JustCompileDocValues extends DocValues {
-
     @Override
     public float floatVal(int doc) {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
@@ -44,7 +43,7 @@
     public String toString(int doc) {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
-    
+
   }
 
   static final class JustCompileFieldCacheSource extends FieldCacheSource {
@@ -65,14 +64,13 @@
 
     @Override
     public DocValues getCachedFieldValues(FieldCache cache, String field,
-        IndexReader reader) throws IOException {
+                                          IndexReader reader) throws IOException {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
-    
+
   }
 
   static final class JustCompileValueSource extends ValueSource {
-
     @Override
     public String description() {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
@@ -92,7 +90,7 @@
     public int hashCode() {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
-    
+
   }
-  
+
 }
Index: src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(revision 887375)
+++ src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(working copy)
@@ -28,24 +28,30 @@
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.util.Version;
+import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
 /**
  * Test CustomScoreQuery search.
  */
 public class TestCustomScoreQuery extends FunctionTestSetup {
 
   /* @override constructor */
-  public TestCustomScoreQuery(String name) {
-    super(name);
+  public TestCustomScoreQuery() {
+  
   }
 
   /** Test that CustomScoreQuery of Type.BYTE returns the expected scores. */
+  @Test
   public void testCustomScoreByte () throws CorruptIndexException, Exception {
     // INT field values are small enough to be parsed as byte
     doTestCustomScore(INT_FIELD,FieldScoreQuery.Type.BYTE,1.0);
     doTestCustomScore(INT_FIELD,FieldScoreQuery.Type.BYTE,2.0);
   }
 
+  @Test
   /** Test that CustomScoreQuery of Type.SHORT returns the expected scores. */
   public void testCustomScoreShort () throws CorruptIndexException, Exception {
     // INT field values are small enough to be parsed as short
@@ -53,12 +59,14 @@
     doTestCustomScore(INT_FIELD,FieldScoreQuery.Type.SHORT,3.0);
   }
 
+  @Test
   /** Test that CustomScoreQuery of Type.INT returns the expected scores. */
   public void testCustomScoreInt () throws CorruptIndexException, Exception {
     doTestCustomScore(INT_FIELD,FieldScoreQuery.Type.INT,1.0);
     doTestCustomScore(INT_FIELD,FieldScoreQuery.Type.INT,4.0);
   }
 
+  @Test
   /** Test that CustomScoreQuery of Type.FLOAT returns the expected scores. */
   public void testCustomScoreFloat () throws CorruptIndexException, Exception {
     // INT field can be parsed as float
@@ -119,7 +127,8 @@
         return subQueryScore + valSrcScores[0];
       }
       return (subQueryScore + valSrcScores[0]) * valSrcScores[1]; // we know there are two
-    } 
+    }
+
     /* (non-Javadoc)@see org.apache.lucene.search.function.CustomScoreQuery#customExplain(int, org.apache.lucene.search.Explanation, org.apache.lucene.search.Explanation)*/
     @Override
     public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
Index: src/test/org/apache/lucene/search/TestElevationComparator.java
===================================================================
--- src/test/org/apache/lucene/search/TestElevationComparator.java	(revision 887375)
+++ src/test/org/apache/lucene/search/TestElevationComparator.java	(working copy)
@@ -71,7 +71,7 @@
         new SortField(null, SortField.SCORE, reversed)
       );
 
-    TopDocsCollector topCollector = TopFieldCollector.create(sort, 50, false, true, true, true);
+    TopDocsCollector<FieldValueHitQueue.Entry> topCollector = TopFieldCollector.create(sort, 50, false, true, true, true);
     searcher.search(newq, null, topCollector);
 
     TopDocs topDocs = topCollector.topDocs(0, 10);
Index: src/test/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- src/test/org/apache/lucene/util/LuceneTestCase.java	(revision 887375)
+++ src/test/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -46,7 +46,11 @@
  * <code>super.tearDown()</code>
  * </p>
  * @see #assertSaneFieldCaches
+ *
+ * @deprecated Replaced by {@link #LuceneTestCaseJ4}
+ *
  */
+@Deprecated
 public abstract class LuceneTestCase extends TestCase {
 
   public LuceneTestCase() {
@@ -146,9 +150,9 @@
   }
 
   /**
-   * Convinience method for logging an iterator.
+   * Convenience method for logging an iterator.
    * @param label String logged before/after the items in the iterator
-   * @param iter Each next() is toString()ed and logged on it's own line. If iter is null this is logged differnetly then an empty iterator.
+   * @param iter Each next() is toString()ed and logged on it's own line. If iter is null this is logged differently then an empty iterator.
    * @param stream Stream to log messages to.
    */
   public static <T> void dumpIterator(String label, Iterator<T> iter, 
@@ -168,9 +172,9 @@
    * Convinience method for logging an array.  Wraps the array in an iterator and delegates
    * @see dumpIterator(String,Iterator,PrintStream)
    */
-  public static void dumpArray(String label, Object[] objs, 
+  public static <T> void dumpArray(String label, T[] objs, 
                                PrintStream stream) {
-    Iterator<Object> iter = (null == objs) ? null : Arrays.asList(objs).iterator();
+    Iterator<T> iter = (null == objs) ? null : Arrays.asList(objs).iterator();
     dumpIterator(label, iter, stream);
   }
   
