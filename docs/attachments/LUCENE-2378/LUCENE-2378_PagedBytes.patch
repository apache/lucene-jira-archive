Index: solr/src/java/org/apache/solr/request/UnInvertedField.java
===================================================================
--- solr/src/java/org/apache/solr/request/UnInvertedField.java	(revision 955646)
+++ solr/src/java/org/apache/solr/request/UnInvertedField.java	(working copy)
@@ -27,6 +27,7 @@
 import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.util.PagedBytes;
 import org.apache.noggit.CharArr;
 import org.apache.solr.common.params.FacetParams;
 import org.apache.solr.common.util.NamedList;
@@ -1097,6 +1098,7 @@
   NumberedTermsEnum getEnumerator(IndexReader reader) throws IOException {
     if (index==null) return new NumberedTermsEnum(reader,this, prefix==null?new BytesRef():prefix, 0) {
       ArrayList<BytesRef> lst;
+      PagedBytes bytes;
 
       protected BytesRef setTerm() throws IOException {
         BytesRef br = super.setTerm();
@@ -1104,8 +1106,11 @@
           sizeOfStrings += br.length;
           if (lst==null) {
             lst = new ArrayList<BytesRef>();
+            bytes = new PagedBytes(15);
           }
-          lst.add(new BytesRef(br));
+          BytesRef out = new BytesRef();
+          bytes.copy(br, out);
+          lst.add(out);
         }
         return br;
       }
Index: lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java	(revision 955646)
+++ lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java	(working copy)
@@ -866,7 +866,7 @@
       }
 
       // maybe an int-only impl?
-      return new DocTermsIndexImpl(bytes.freeze(), termOrdToBytesOffset.getMutable(), docToTermOrd.getMutable(), termOrd);
+      return new DocTermsIndexImpl(bytes.freeze(true), termOrdToBytesOffset.getMutable(), docToTermOrd.getMutable(), termOrd);
     }
   }
 
@@ -971,7 +971,7 @@
       }
 
       // maybe an int-only impl?
-      return new DocTermsImpl(bytes.freeze(), docToOffset.getMutable());
+      return new DocTermsImpl(bytes.freeze(true), docToOffset.getMutable());
     }
   }
   private volatile PrintStream infoStream;
Index: lucene/src/java/org/apache/lucene/index/codecs/standard/SimpleStandardTermsIndexReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/standard/SimpleStandardTermsIndexReader.java	(revision 955646)
+++ lucene/src/java/org/apache/lucene/index/codecs/standard/SimpleStandardTermsIndexReader.java	(working copy)
@@ -137,7 +137,7 @@
         if (success) {
           indexLoaded = true;
         }
-        termBytesReader = termBytes.freeze();
+        termBytesReader = termBytes.freeze(true);
       } else {
         this.in = in;
       }
@@ -413,7 +413,7 @@
 
       indexLoaded = true;
       in.close();
-      termBytesReader = termBytes.freeze();
+      termBytesReader = termBytes.freeze(true);
     }
   }
 
Index: lucene/src/java/org/apache/lucene/util/PagedBytes.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/PagedBytes.java	(revision 955646)
+++ lucene/src/java/org/apache/lucene/util/PagedBytes.java	(working copy)
@@ -203,8 +203,33 @@
     }
   }
 
-  /** Commits final byte[], trimming it if necessary. */
-  public Reader freeze() {
+  /** Copy BytesRef in, setting BytesRef out to the result.
+   * Do not use this if you will use freeze(true).
+   * This only supports bytes.length <= blockSize */
+  public void copy(BytesRef bytes, BytesRef out) throws IOException {
+    int left = blockSize - upto;
+    if (bytes.length > left) {
+      if (currentBlock != null) {
+        blocks.add(currentBlock);
+        blockEnd.add(upto);
+      }
+      currentBlock = new byte[blockSize];
+      upto = 0;
+      left = blockSize;
+      assert bytes.length <= blockSize;
+      // TODO: we could also support variable block sizes
+    }
+
+    out.bytes = currentBlock;
+    out.offset = upto;
+    out.length = bytes.length;
+
+    System.arraycopy(bytes.bytes, bytes.offset, currentBlock, upto, bytes.length);
+    upto += bytes.length;
+  }
+
+  /** Commits final byte[], trimming it if necessary and if trim=true */
+  public Reader freeze(boolean trim) {
     if (upto < blockSize) {
       final byte[] newBlock = new byte[upto];
       System.arraycopy(currentBlock, 0, newBlock, 0, upto);
