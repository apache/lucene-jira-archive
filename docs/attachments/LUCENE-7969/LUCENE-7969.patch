diff --git a/lucene/core/src/java/org/apache/lucene/util/SmallFloat.java b/lucene/core/src/java/org/apache/lucene/util/SmallFloat.java
index 317acab..b4763c1 100644
--- a/lucene/core/src/java/org/apache/lucene/util/SmallFloat.java
+++ b/lucene/core/src/java/org/apache/lucene/util/SmallFloat.java
@@ -25,78 +25,6 @@ public class SmallFloat {
   /** No instance */
   private SmallFloat() {}
 
-  /** Converts a 32 bit float to an 8 bit float.
-   * <br>Values less than zero are all mapped to zero.
-   * <br>Values are truncated (rounded down) to the nearest 8 bit value.
-   * <br>Values between zero and the smallest representable value
-   *  are rounded up.
-   *
-   * @param f the 32 bit float to be converted to an 8 bit float (byte)
-   * @param numMantissaBits the number of mantissa bits to use in the byte, with the remainder to be used in the exponent
-   * @param zeroExp the zero-point in the range of exponent values
-   * @return the 8 bit float representation
-   */
-  public static byte floatToByte(float f, int numMantissaBits, int zeroExp) {
-    // Adjustment from a float zero exponent to our zero exponent,
-    // shifted over to our exponent position.
-    int fzero = (63-zeroExp)<<numMantissaBits;
-    int bits = Float.floatToRawIntBits(f);
-    int smallfloat = bits >> (24-numMantissaBits);
-    if (smallfloat <= fzero) {
-      return (bits<=0) ?
-        (byte)0   // negative numbers and zero both map to 0 byte
-       :(byte)1;  // underflow is mapped to smallest non-zero number.
-    } else if (smallfloat >= fzero + 0x100) {
-      return -1;  // overflow maps to largest number
-    } else {
-      return (byte)(smallfloat - fzero);
-    }
-  }
-
-  /** Converts an 8 bit float to a 32 bit float. */
-  public static float byteToFloat(byte b, int numMantissaBits, int zeroExp) {
-    // on Java1.5 & 1.6 JVMs, prebuilding a decoding array and doing a lookup
-    // is only a little bit faster (anywhere from 0% to 7%)
-    if (b == 0) return 0.0f;
-    int bits = (b&0xff) << (24-numMantissaBits);
-    bits += (63-zeroExp) << 24;
-    return Float.intBitsToFloat(bits);
-  }
-
-
-  //
-  // Some specializations of the generic functions follow.
-  // The generic functions are just as fast with current (1.5)
-  // -server JVMs, but still slower with client JVMs.
-  //
-
-  /** floatToByte(b, mantissaBits=3, zeroExponent=15)
-   * <br>smallest non-zero value = 5.820766E-10
-   * <br>largest value = 7.5161928E9
-   * <br>epsilon = 0.125
-   */
-  public static byte floatToByte315(float f) {
-    int bits = Float.floatToRawIntBits(f);
-    int smallfloat = bits >> (24-3);
-    if (smallfloat <= ((63-15)<<3)) {
-      return (bits<=0) ? (byte)0 : (byte)1;
-    }
-    if (smallfloat >= ((63-15)<<3) + 0x100) {
-      return -1;
-    }
-    return (byte)(smallfloat - ((63-15)<<3));
- }
-
-  /** byteToFloat(b, mantissaBits=3, zeroExponent=15) */
-  public static float byte315ToFloat(byte b) {
-    // on Java1.5 & 1.6 JVMs, prebuilding a decoding array and doing a lookup
-    // is only a little bit faster (anywhere from 0% to 7%)
-    if (b == 0) return 0.0f;
-    int bits = (b&0xff) << (24-3);
-    bits += (63-15) << 24;
-    return Float.intBitsToFloat(bits);
-  }
-
   /** Float-like encoding for positive longs that preserves ordering and 4 significant bits. */
   public static int longToInt4(long i) {
     if (i < 0) {
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestSmallFloat.java b/lucene/core/src/test/org/apache/lucene/util/TestSmallFloat.java
index dca5f2d..a091960 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestSmallFloat.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestSmallFloat.java
@@ -20,108 +20,6 @@ import java.util.Arrays;
 
 public class TestSmallFloat extends LuceneTestCase {
 
-  // original lucene byteToFloat
-  static float orig_byteToFloat(byte b) {
-    if (b == 0)                                   // zero is a special case
-      return 0.0f;
-    int mantissa = b & 7;
-    int exponent = (b >> 3) & 31;
-    int bits = ((exponent+(63-15)) << 24) | (mantissa << 21);
-    return Float.intBitsToFloat(bits);
-  }
-
-  // original lucene floatToByte (since lucene 1.3)
-  static byte orig_floatToByte_v13(float f) {
-    if (f < 0.0f)                                 // round negatives up to zero
-      f = 0.0f;
-
-    if (f == 0.0f)                                // zero is a special case
-      return 0;
-
-    int bits = Float.floatToIntBits(f);           // parse float into parts
-    int mantissa = (bits & 0xffffff) >> 21;
-    int exponent = (((bits >> 24) & 0x7f) - 63) + 15;
-
-    if (exponent > 31) {                          // overflow: use max value
-      exponent = 31;
-      mantissa = 7;
-    }
-
-    if (exponent < 0) {                           // underflow: use min value
-      exponent = 0;
-      mantissa = 1;
-    }
-
-    return (byte)((exponent << 3) | mantissa);    // pack into a byte
-  }
-
-  // This is the original lucene floatToBytes (from v1.3)
-  // except with the underflow detection bug fixed for values like 5.8123817E-10f
-  static byte orig_floatToByte(float f) {
-    if (f < 0.0f)                                 // round negatives up to zero
-      f = 0.0f;
-
-    if (f == 0.0f)                                // zero is a special case
-      return 0;
-
-    int bits = Float.floatToIntBits(f);           // parse float into parts
-    int mantissa = (bits & 0xffffff) >> 21;
-    int exponent = (((bits >> 24) & 0x7f) - 63) + 15;
-
-    if (exponent > 31) {                          // overflow: use max value
-      exponent = 31;
-      mantissa = 7;
-    }
-
-    if (exponent < 0 || exponent == 0 && mantissa == 0) { // underflow: use min value
-      exponent = 0;
-      mantissa = 1;
-    }
-
-    return (byte)((exponent << 3) | mantissa);    // pack into a byte
-  }
-
-
-  public void testByteToFloat() {
-    for (int i=0; i<256; i++) {
-      float f1 = orig_byteToFloat((byte)i);
-      float f2 = SmallFloat.byteToFloat((byte)i, 3,15);
-      float f3 = SmallFloat.byte315ToFloat((byte)i);
-      assertEquals(f1,f2,0.0);
-      assertEquals(f2,f3,0.0);
-    }
-  }
-
-  public void testFloatToByte() {
-    assertEquals(0, orig_floatToByte_v13(5.8123817E-10f));       // verify the old bug (see LUCENE-2937)
-    assertEquals(1, orig_floatToByte(5.8123817E-10f));           // verify it's fixed in this test code
-    assertEquals(1, SmallFloat.floatToByte315(5.8123817E-10f));  // verify it's fixed
-
-    // test some constants
-    assertEquals(0, SmallFloat.floatToByte315(0));
-    assertEquals(1, SmallFloat.floatToByte315(Float.MIN_VALUE));             // underflow rounds up to smallest positive
-    assertEquals(255, SmallFloat.floatToByte315(Float.MAX_VALUE) & 0xff);    // overflow rounds down to largest positive
-    assertEquals(255, SmallFloat.floatToByte315(Float.POSITIVE_INFINITY) & 0xff);
-
-    // all negatives map to 0
-    assertEquals(0, SmallFloat.floatToByte315(-Float.MIN_VALUE));
-    assertEquals(0, SmallFloat.floatToByte315(-Float.MAX_VALUE));
-    assertEquals(0, SmallFloat.floatToByte315(Float.NEGATIVE_INFINITY));
-
-
-    // up iterations for more exhaustive test after changing something
-    int num = atLeast(100000);
-    for (int i = 0; i < num; i++) {
-      float f = Float.intBitsToFloat(random().nextInt());
-      if (Float.isNaN(f)) continue;    // skip NaN
-      byte b1 = orig_floatToByte(f);
-      byte b2 = SmallFloat.floatToByte(f,3,15);
-      byte b3 = SmallFloat.floatToByte315(f);
-      assertEquals(b1,b2);
-      assertEquals(b2,b3);
-    }
-  }
-
   public void testInt4() {
     for (int i = 0; i <= 16; ++i) {
       // all values in 0-16 are encoded accurately
@@ -166,23 +64,4 @@ public class TestSmallFloat extends LuceneTestCase {
       assertEquals((byte) idx, SmallFloat.intToByte4(i));
     }
   }
-
-  /***
-  // Do an exhaustive test of all possible floating point values
-  // for the 315 float against the original norm encoding in Similarity.
-  // Takes 75 seconds on my Pentium4 3GHz, with Java5 -server
-  public void testAllFloats() {
-    for(int i = Integer.MIN_VALUE;;i++) {
-      float f = Float.intBitsToFloat(i);
-      if (f==f) { // skip non-numbers
-        byte b1 = orig_floatToByte(f);
-        byte b2 = SmallFloat.floatToByte315(f);
-        if (b1!=b2 || b2==0 && f>0) {
-          fail("Failed floatToByte315 for float " + f + " source bits="+Integer.toHexString(i) + " float raw bits=" + Integer.toHexString(Float.floatToRawIntBits(i)));
-        }
-      }
-      if (i==Integer.MAX_VALUE) break;
-    }
-  }
-  ***/
 }
