Index: lucene/spatial/src/java/org/apache/lucene/spatial/bbox/AreaSimilarity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/bbox/AreaSimilarity.java	(revision 1603308)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/bbox/AreaSimilarity.java	(revision )
@@ -16,202 +16,199 @@
  */
 package org.apache.lucene.spatial.bbox;
 
+import com.spatial4j.core.shape.Rectangle;
 import org.apache.lucene.search.Explanation;
 
-import com.spatial4j.core.shape.Rectangle;
-
 /**
  * The algorithm is implemented as envelope on envelope overlays rather than
  * complex polygon on complex polygon overlays.
  * <p/>
  * <p/>
  * Spatial relevance scoring algorithm:
+ * <DL>
+ *   <DT>queryArea</DT> <DD>the area of the input query envelope</DD>
+ *   <DT>targetArea</DT> <DD>the area of the target envelope (per Lucene document)</DD>
+ *   <DT>intersectionArea</DT> <DD>the area of the intersection between the query and target envelopes</DD>
+ *   <DT>queryTargetProportion</DT> <DD>A 0-1 factor that divides the score proportion between query and target.
+ *   0.5 is evenly.</DD>
+ *
+ *   <DT>queryRatio</DT> <DD>intersectionArea / queryArea; (see note)</DD>
+ *   <DT>targetRatio</DT> <DD>intersectionArea / targetArea; (see note)</DD>
+ *   <DT>queryFactor</DT> <DD>queryRatio * queryTargetProportion;</DD>
+ *   <DT>targetFactor</DT> <DD>targetRatio * (1 - queryTargetProportion);</DD>
+ *   <DT>score</DT> <DD>queryFactor + targetFactor;</DD>
+ * </DL>
+ * Note: The actual computation of queryRatio and targetRatio is more complicated so that it considers
+ * points and lines. Lines have the ratio of overlap, and points are either 1.0 or 0.0 depending on wether
+ * it intersects or not.
- * <p/>
+ * <p />
- * <br/>  queryArea = the area of the input query envelope
- * <br/>  targetArea = the area of the target envelope (per Lucene document)
- * <br/>  intersectionArea = the area of the intersection for the query/target envelopes
- * <br/>  queryPower = the weighting power associated with the query envelope (default = 1.0)
- * <br/>  targetPower =  the weighting power associated with the target envelope (default = 1.0)
- * <p/>
- * <br/>  queryRatio  = intersectionArea / queryArea;
- * <br/>  targetRatio = intersectionArea / targetArea;
- * <br/>  queryFactor  = Math.pow(queryRatio,queryPower);
- * <br/>  targetFactor = Math.pow(targetRatio,targetPower);
- * <br/>  score = queryFactor * targetFactor;
- * <p/>
  * Based on Geoportal's
  * <a href="http://geoportal.svn.sourceforge.net/svnroot/geoportal/Geoportal/trunk/src/com/esri/gpt/catalog/lucene/SpatialRankingValueSource.java">
- *   SpatialRankingValueSource</a>.
+ *   SpatialRankingValueSource</a> but modified. GeoPortal's algorithm will yield a score of 0
+ * if either a line or point is compared, and it's doesn't output a 0-1 normalized score (it multiplies the factors).
  *
  * @lucene.experimental
  */
 public class AreaSimilarity implements BBoxSimilarity {
-  /**
-   * Properties associated with the query envelope
-   */
+
+  private final boolean isGeo;//-180/+180 degrees
   private final Rectangle queryExtent;
-  private final double queryArea;
+  private final double queryArea;//not part of identity
 
-  private final double targetPower;
-  private final double queryPower;
+  private final double queryTargetProportion;
 
-  public AreaSimilarity(Rectangle queryExtent, double queryPower, double targetPower) {
+  public AreaSimilarity(boolean isGeo, Rectangle queryExtent, double queryTargetProportion) {
+    this.isGeo = isGeo;
     this.queryExtent = queryExtent;
     this.queryArea = queryExtent.getArea(null);
-
-    this.queryPower = queryPower;
-    this.targetPower = targetPower;
-
-//  if (this.qryMinX > queryExtent.getMaxX()) {
-//    this.qryCrossedDateline = true;
-//    this.qryArea = Math.abs(qryMaxX + 360.0 - qryMinX) * Math.abs(qryMaxY - qryMinY);
-//  } else {
-//    this.qryArea = Math.abs(qryMaxX - qryMinX) * Math.abs(qryMaxY - qryMinY);
-//  }
+    assert queryArea >= 0;
+    this.queryTargetProportion = queryTargetProportion;
+    if (queryTargetProportion < 0 || queryTargetProportion > 1.0)
+      throw new IllegalArgumentException("queryTargetProportion must be >= 0 and <= 1");
   }
 
+  /** Construct with 75% weighting towards target (roughly GeoPortal's default), geo degrees assumed. */
   public AreaSimilarity(Rectangle queryExtent) {
-    this(queryExtent, 2.0, 0.5);
+    this(true, queryExtent, 0.25);
   }
 
-
-  public String getDelimiterQueryParameters() {
-    return queryExtent.toString() + ";" + queryPower + ";" + targetPower;
+  @Override
+  public String toString() {
+    return queryExtent.toString() + ";" + queryTargetProportion;
   }
 
   @Override
   public double score(Rectangle target, Explanation exp) {
-    if (target == null || queryArea <= 0) {
+    if (target == null) {
       return 0;
     }
-    double targetArea = target.getArea(null);
-    if (targetArea <= 0) {
-      return 0;
-    }
-    double score = 0;
 
+    // calculate "height": the intersection height between two boxes.
     double top = Math.min(queryExtent.getMaxY(), target.getMaxY());
     double bottom = Math.max(queryExtent.getMinY(), target.getMinY());
     double height = top - bottom;
-    double width = 0;
+    if (height < 0)
+      return 0;//no intersection
 
-    // queries that cross the date line
-    if (queryExtent.getCrossesDateLine()) {
-      // documents that cross the date line
-      if (target.getCrossesDateLine()) {
-        double left = Math.max(queryExtent.getMinX(), target.getMinX());
-        double right = Math.min(queryExtent.getMaxX(), target.getMaxX());
-        width = right + 360.0 - left;
+    // calculate "width": the intersection width between two boxes.
+    double width = 0;
+    {
+      Rectangle a = queryExtent;
+      Rectangle b = target;
+      if (a.getCrossesDateLine() == b.getCrossesDateLine()) {
+        //both either cross or don't
+        double left = Math.max(a.getMinX(), b.getMinX());
+        double right = Math.min(a.getMaxX(), b.getMaxX());
+        if (!a.getCrossesDateLine()) {//both don't
+          if (left <= right) {
+            width = right - left;
+          } else if (isGeo && (Math.abs(a.getMinX()) == 180 || Math.abs(a.getMaxX()) == 180)
+              && (Math.abs(b.getMinX()) == 180 || Math.abs(b.getMaxX()) == 180)) {
+            width = 0;//both adjacent to dateline
-      } else {
+          } else {
-        double qryWestLeft = Math.max(queryExtent.getMinX(), target.getMaxX());
-        double qryWestRight = Math.min(target.getMaxX(), 180.0);
-        double qryWestWidth = qryWestRight - qryWestLeft;
-        if (qryWestWidth > 0) {
-          width = qryWestWidth;
+            return 0;//no intersection
+          }
+        } else {//both cross
+          width = right - left + 360;
+        }
-        } else {
+      } else {
-          double qryEastLeft = Math.max(target.getMaxX(), -180.0);
-          double qryEastRight = Math.min(queryExtent.getMaxX(), target.getMaxX());
-          double qryEastWidth = qryEastRight - qryEastLeft;
-          if (qryEastWidth > 0) {
-            width = qryEastWidth;
+        if (!a.getCrossesDateLine()) {//then flip
+          a = target;
+          b = queryExtent;
-          }
+        }
+        //a crosses, b doesn't
+        double qryWestLeft = Math.max(a.getMinX(), b.getMinX());
+        double qryWestRight = b.getMaxX();
+        if (qryWestLeft < qryWestRight)
+          width += qryWestRight - qryWestLeft;
+
+        double qryEastLeft = b.getMinX();
+        double qryEastRight = Math.min(a.getMaxX(), b.getMaxX());
+        if (qryEastLeft < qryEastRight)
+          width += qryEastRight - qryEastLeft;
+
+        if (qryWestLeft > qryWestRight && qryEastLeft > qryEastRight)
+          return 0;//no intersection
-        }
-      }
+      }
+    }
-    } else { // queries that do not cross the date line
 
-      if (target.getCrossesDateLine()) {
-        double tgtWestLeft = Math.max(queryExtent.getMinX(), target.getMinX());
-        double tgtWestRight = Math.min(queryExtent.getMaxX(), 180.0);
-        double tgtWestWidth = tgtWestRight - tgtWestLeft;
-        if (tgtWestWidth > 0) {
-          width = tgtWestWidth;
+    // calculate queryRatio and targetRatio
+    double intersectionArea = width * height;
+    double queryRatio;
+    if (queryArea > 0) {
+      queryRatio = intersectionArea / queryArea;
+    } else if (queryExtent.getHeight() > 0) {//vert line
+      queryRatio = height / queryExtent.getHeight();
+    } else if (queryExtent.getWidth() > 0) {//horiz line
+      queryRatio = width / queryExtent.getWidth();
-        } else {
+    } else {
-          double tgtEastLeft = Math.max(queryExtent.getMinX(), -180.0);
-          double tgtEastRight = Math.min(queryExtent.getMaxX(), target.getMaxX());
-          double tgtEastWidth = tgtEastRight - tgtEastLeft;
-          if (tgtEastWidth > 0) {
-            width = tgtEastWidth;
+      queryRatio = queryExtent.relate(target).intersects() ? 1 : 0;//could be optimized
-          }
+    }
-        }
+
+    double targetArea = target.getArea(null);
+    assert targetArea >= 0;
+    double targetRatio;
+    if (targetArea > 0) {
+      targetRatio = intersectionArea / targetArea;
+    } else if (target.getHeight() > 0) {//vert line
+      targetRatio = height / target.getHeight();
+    } else if (target.getWidth() > 0) {//horiz line
+      targetRatio = width / target.getWidth();
-      } else {
+    } else {
-        double left = Math.max(queryExtent.getMinX(), target.getMinX());
-        double right = Math.min(queryExtent.getMaxX(), target.getMaxX());
-        width = right - left;
+      targetRatio = target.relate(queryExtent).intersects() ? 1 : 0;//could be optimized
-      }
+    }
-    }
+    assert queryRatio >= 0 && queryRatio <= 1 : queryRatio;
+    assert targetRatio >= 0 && targetRatio <= 1 : targetRatio;
 
+    // combine ratios into a score
 
-    // calculate the score
-    if ((width > 0) && (height > 0)) {
-      double intersectionArea = width * height;
-      double queryRatio = intersectionArea / queryArea;
-      double targetRatio = intersectionArea / targetArea;
-      double queryFactor = Math.pow(queryRatio, queryPower);
-      double targetFactor = Math.pow(targetRatio, targetPower);
-      score = queryFactor * targetFactor * 10000.0;
+    double queryFactor = queryRatio * queryTargetProportion;
+    double targetFactor = targetRatio * (1.0 - queryTargetProportion);
+    double score = queryFactor + targetFactor;
 
-      if (exp!=null) {
+    if (exp!=null) {
-//        StringBuilder sb = new StringBuilder();
-//        sb.append("\nscore=").append(score);
-//        sb.append("\n  query=").append();
-//        sb.append("\n  target=").append(target.toString());
-//        sb.append("\n  intersectionArea=").append(intersectionArea);
-//        
-//        sb.append(" queryArea=").append(queryArea).append(" targetArea=").append(targetArea);
-//        sb.append("\n  queryRatio=").append(queryRatio).append(" targetRatio=").append(targetRatio);
-//        sb.append("\n  queryFactor=").append(queryFactor).append(" targetFactor=").append(targetFactor);
-//        sb.append(" (queryPower=").append(queryPower).append(" targetPower=").append(targetPower).append(")");
-        
-        exp.setValue((float)score);
-        exp.setDescription(this.getClass().getSimpleName());
-        
+      exp.setValue((float)score);
+      exp.setDescription(this.getClass().getSimpleName());
+
-        Explanation e = null;
+      Explanation e;//tmp
-        
-        exp.addDetail( e = new Explanation((float)intersectionArea, "IntersectionArea") );
+
+      exp.addDetail( e = new Explanation((float)intersectionArea, "IntersectionArea") );
-        e.addDetail(new Explanation((float)width,  "width; Query: "+queryExtent.toString()));
-        e.addDetail(new Explanation((float)height, "height; Target: "+target.toString()));
+      e.addDetail(new Explanation((float)width,  "width; Query: "+queryExtent));
+      e.addDetail(new Explanation((float)height, "height; Target: "+target));
+      e.addDetail(new Explanation((float)height, "queryTargetProportion: "+ queryTargetProportion));
 
-        exp.addDetail( e = new Explanation((float)queryFactor, "Query") );
+      exp.addDetail( e = new Explanation((float)queryFactor, "Query") );
-        e.addDetail(new Explanation((float)queryArea, "area"));
+      e.addDetail(new Explanation((float)queryArea,  "area"));
-        e.addDetail(new Explanation((float)queryRatio, "ratio"));
+      e.addDetail(new Explanation((float)queryRatio, "ratio"));
-        e.addDetail(new Explanation((float)queryPower, "power"));
 
-        exp.addDetail( e = new Explanation((float)targetFactor, "Target") );
+      exp.addDetail( e = new Explanation((float)targetFactor, "Target") );
-        e.addDetail(new Explanation((float)targetArea, "area"));
+      e.addDetail(new Explanation((float)targetArea,  "area"));
-        e.addDetail(new Explanation((float)targetRatio, "ratio"));
+      e.addDetail(new Explanation((float)targetRatio, "ratio"));
-        e.addDetail(new Explanation((float)targetPower, "power"));
-      }
+    }
-    }
-    else if(exp !=null) {
-      exp.setValue(0);
-      exp.setDescription("Shape does not intersect");
-    }
+
     return score;
   }
 
-
-  /**
-   * Determines if this ValueSource is equal to another.
-   *
-   * @param o the ValueSource to compare
-   * @return <code>true</code> if the two objects are based upon the same query envelope
-   */
   @Override
   public boolean equals(Object o) {
-    if (o.getClass() != AreaSimilarity.class)
-      return false;
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
 
-    AreaSimilarity other = (AreaSimilarity) o;
-    return getDelimiterQueryParameters().equals(other.getDelimiterQueryParameters());
+    AreaSimilarity that = (AreaSimilarity) o;
+
+    if (Double.compare(that.queryTargetProportion, queryTargetProportion) != 0) return false;
+    if (!queryExtent.equals(that.queryExtent)) return false;
+
+    return true;
   }
 
-  /**
-   * Returns the ValueSource hash code.
-   *
-   * @return the hash code
-   */
   @Override
   public int hashCode() {
-    return getDelimiterQueryParameters().hashCode();
+    int result;
+    long temp;
+    result = queryExtent.hashCode();
+    temp = Double.doubleToLongBits(queryTargetProportion);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    return result;
   }
 }
Index: lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java	(revision 1603308)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java	(revision )
@@ -17,51 +17,202 @@
  * limitations under the License.
  */
 
+import com.carrotsearch.randomizedtesting.annotations.Repeat;
 import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.SpatialContextFactory;
+import com.spatial4j.core.distance.DistanceUtils;
+import com.spatial4j.core.shape.Rectangle;
 import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.impl.RectangleImpl;
 import org.apache.lucene.spatial.SpatialMatchConcern;
-import org.apache.lucene.spatial.StrategyTestCase;
-import org.junit.Before;
+import org.apache.lucene.spatial.prefix.RandomSpatialOpStrategyTestCase;
+import org.apache.lucene.spatial.query.SpatialOperation;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
 
-public class TestBBoxStrategy extends StrategyTestCase {
+public class TestBBoxStrategy extends RandomSpatialOpStrategyTestCase {
 
-  @Before
   @Override
-  public void setUp() throws Exception {
-    super.setUp();
+  protected Shape randomIndexedShape() {
+    Rectangle world = ctx.getWorldBounds();
+    if (random().nextInt(10) == 0) // increased chance of getting one of these
+      return world;
+
+    int worldWidth = (int) Math.round(world.getWidth());
+    int deltaLeft = nextIntInclusive(worldWidth);
+    int deltaRight = nextIntInclusive(worldWidth - deltaLeft);
+    int worldHeight = (int) Math.round(world.getHeight());
+    int deltaTop = nextIntInclusive(worldHeight);
+    int deltaBottom = nextIntInclusive(worldHeight - deltaTop);
+    if (ctx.isGeo() && (deltaLeft != 0 || deltaRight != 0)) {
+      //if geo & doesn't world-wrap, we shift randomly to potentially cross dateline
+      int shift = nextIntInclusive(360);
+      return ctx.makeRectangle(
+          DistanceUtils.normLonDEG(world.getMinX() + deltaLeft + shift),
+          DistanceUtils.normLonDEG(world.getMaxX() - deltaRight + shift),
+          world.getMinY() + deltaBottom, world.getMaxY() - deltaTop);
+    } else {
+      return ctx.makeRectangle(
+          world.getMinX() + deltaLeft, world.getMaxX() - deltaRight,
+          world.getMinY() + deltaBottom, world.getMaxY() - deltaTop);
+    }
+
+  }
+
+  /** next int, inclusive, rounds to multiple of 10 if given evenly divisible. */
+  private int nextIntInclusive(int toInc) {
+    final int DIVIS = 10;
+    if (toInc % DIVIS == 0) {
+      return random().nextInt(toInc/DIVIS + 1) * DIVIS;
+    } else {
+      return random().nextInt(toInc + 1);
+    }
+  }
+
+  @Override
+  protected Shape randomQueryShape() {
+    return randomIndexedShape();
+  }
+
+  @Test
+  @Repeat(iterations = 20)
+  public void testOperations() throws IOException {
+    //setup
+    if (random().nextInt(4) > 0) {//75% of the time choose geo (more interesting to test)
-    this.ctx = SpatialContext.GEO;
+      this.ctx = SpatialContext.GEO;
+    } else {
+      SpatialContextFactory factory = new SpatialContextFactory();
+      factory.geo = false;
+      factory.worldBounds = new RectangleImpl(-300, 300, -100, 100, null);
+      this.ctx = factory.newSpatialContext();
+    }
     this.strategy = new BBoxStrategy(ctx, "bbox");
+
+    for (SpatialOperation operation : SpatialOperation.values()) {
+      if (operation == SpatialOperation.Overlaps)
+        continue;//unsupported
+      testOperationRandomShapes(operation);
+
+      deleteAll();
+      commit();
-  }
+    }
+  }
 
-  /* Convert DATA_WORLD_CITIES_POINTS to bbox */
-  @Override
-  protected Shape convertShapeFromGetDocuments(Shape shape) {
-    return shape.getBoundingBox();
+  @Test
+  public void testIntersectsBugDatelineEdge() throws IOException {
+    setupGeo();
+    testOperation(
+        ctx.makeRectangle(160, 180, -10, 10),
+        SpatialOperation.Intersects,
+        ctx.makeRectangle(-180, -160, -10, 10), true);
   }
 
   @Test
+  public void testWithinBugDatelineEdge() throws IOException {
+    setupGeo();
+    testOperation(
+        ctx.makeRectangle(180, 180, -10, 10),
+        SpatialOperation.IsWithin,
+        ctx.makeRectangle(-180, -100, -10, 10), true);
+  }
+
+  @Test
+  public void testContainsBugDatelineEdge() throws IOException {
+    setupGeo();
+    testOperation(
+        ctx.makeRectangle(-180, -150, -10, 10),
+        SpatialOperation.Contains,
+        ctx.makeRectangle(180, 180, -10, 10), true);
+  }
+
+  @Test
+  public void testWorldContainsXDL() throws IOException {
+    setupGeo();
+    testOperation(
+        ctx.makeRectangle(-180, 180, -10, 10),
+        SpatialOperation.Contains,
+        ctx.makeRectangle(170, -170, -10, 10), true);
+  }
+
+  private void setupGeo() {
+    this.ctx = SpatialContext.GEO;
+    this.strategy = new BBoxStrategy(ctx, "bbox");
+  }
+
+  // OLD STATIC TESTS (worthless?)
+
+  @Test @Ignore("Overlaps not supported")
   public void testBasicOperaions() throws IOException {
+    setupGeo();
     getAddAndVerifyIndexedDocuments(DATA_SIMPLE_BBOX);
-    
+
     executeQueries(SpatialMatchConcern.EXACT, QTEST_Simple_Queries_BBox);
   }
-  
+
   @Test
   public void testStatesBBox() throws IOException {
+    setupGeo();
     getAddAndVerifyIndexedDocuments(DATA_STATES_BBOX);
-    
+
     executeQueries(SpatialMatchConcern.FILTER, QTEST_States_IsWithin_BBox);
     executeQueries(SpatialMatchConcern.FILTER, QTEST_States_Intersects_BBox);
   }
 
   @Test
   public void testCitiesIntersectsBBox() throws IOException {
+    setupGeo();
     getAddAndVerifyIndexedDocuments(DATA_WORLD_CITIES_POINTS);
-    
+
     executeQueries(SpatialMatchConcern.FILTER, QTEST_Cities_Intersects_BBox);
   }
-  
+
+  /* Convert DATA_WORLD_CITIES_POINTS to bbox */
+  @Override
+  protected Shape convertShapeFromGetDocuments(Shape shape) {
+    return shape.getBoundingBox();
+  }
+
+  public void testAreaOverlap() throws IOException {
+    setupGeo();
+    for (int SHIFT = 0; SHIFT < 360; SHIFT += 10) {
+      Rectangle queryBox = shiftedRect(0, 40, -20, 20, SHIFT);//40x40, 1600 area
+      AreaSimilarity sim = new AreaSimilarity(true, queryBox, 0.5);//even distribution
+      int nudge = SHIFT == 0 ? 0 : random().nextInt(3) * 10 - 10;//-10, 0, or 10.  Keep 0 on first round.
+
+      assertEquals("within", (200d/1600d * 0.5) + (0.5), sim.score(shiftedRect(10, 30, 0, 10, SHIFT + nudge), null), 0.0001);
+
+      assertEquals("in25%", 0.25, sim.score(shiftedRect(30, 70, -20, 20, SHIFT), null), 0.0001);
+
+      assertEquals("wrap", 0.2794117, sim.score(shiftedRect(30, 10, -20, 20, SHIFT + nudge), null), 0.0001);
+
+      assertEquals("no intersection H", 0.0, sim.score(shiftedRect(-10, -10, -20, 20, SHIFT), null), 0.0001);
+      assertEquals("no intersection V", 0.0, sim.score(shiftedRect(0, 20, -30, -30, SHIFT), null), 0.0001);
+
+      assertEquals("point", 0.5, sim.score(shiftedRect(0, 0, 0, 0, SHIFT), null), 0.0001);
+
+      assertEquals("line 25% intersection", 0.25/2, sim.score(shiftedRect(-30, 10, 0, 0, SHIFT), null), 0.0001);
+
+      assertEquals("null", 0.0, sim.score(null, null), 0.0001);
+
+      //test with point query
+      sim = new AreaSimilarity(true, shiftedRect(0, 0, 0, 0, SHIFT), 0.5);
+      assertEquals("same", 1.0, sim.score(shiftedRect(0, 0, 0, 0, SHIFT), null), 0.0001);
+      assertEquals("contains", 0.5, sim.score(shiftedRect(0, 30, 0, 10, SHIFT), null), 0.0001);
+
+      //test with line query (vertical this time)
+      sim = new AreaSimilarity(true, shiftedRect(0, 0, 20, 40, SHIFT), 0.5);
+      assertEquals("line 50%", 0.5, sim.score(shiftedRect(0, 0, 10, 30, SHIFT), null), 0.0001);
+      assertEquals("point", 0.5, sim.score(shiftedRect(0, 0, 30, 30, SHIFT), null), 0.0001);
+    }
+
+  }
+
+  private Rectangle shiftedRect(double minX, double maxX, double minY, double maxY, int xShift) {
+    return ctx.makeRectangle(
+        DistanceUtils.normLonDEG(minX + xShift),
+        DistanceUtils.normLonDEG(maxX + xShift),
+        minY, maxY);
+  }
 }
