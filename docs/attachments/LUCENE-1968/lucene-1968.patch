Index: src/test/org/apache/lucene/util/TestPriorityQueue.java
===================================================================
--- src/test/org/apache/lucene/util/TestPriorityQueue.java	(revision 823968)
+++ src/test/org/apache/lucene/util/TestPriorityQueue.java	(working copy)
@@ -47,7 +47,7 @@
         {
             int next = gen.nextInt();
             sum += next;
-            pq.put(next);
+            pq.add(next);
         }
 
         //      Date end = new Date();
@@ -75,9 +75,9 @@
 
     public void testClear() {
         PriorityQueue<Integer> pq = new IntegerQueue(3);
-        pq.put(2);
-        pq.put(3);
-        pq.put(1);
+        pq.add(2);
+        pq.add(3);
+        pq.add(1);
         assertEquals(3, pq.size());
         pq.clear();
         assertEquals(0, pq.size());
@@ -85,12 +85,12 @@
     
     public void testFixedSize() {
         PriorityQueue<Integer> pq = new IntegerQueue(3);
-        pq.insert(2);
-        pq.insert(3);
-        pq.insert(1);
-        pq.insert(5);
-        pq.insert(7);
-        pq.insert(1);
+        pq.insertWithOverflow(2);
+        pq.insertWithOverflow(3);
+        pq.insertWithOverflow(1);
+        pq.insertWithOverflow(5);
+        pq.insertWithOverflow(7);
+        pq.insertWithOverflow(1);
         assertEquals(3, pq.size());
         assertEquals((Integer) 3, pq.top());
     }
Index: src/java/org/apache/lucene/search/FieldDocSortedHitQueue.java
===================================================================
--- src/java/org/apache/lucene/search/FieldDocSortedHitQueue.java	(revision 823968)
+++ src/java/org/apache/lucene/search/FieldDocSortedHitQueue.java	(working copy)
@@ -31,7 +31,7 @@
  * @since   lucene 1.4
  */
 class FieldDocSortedHitQueue
-extends PriorityQueue {
+extends PriorityQueue<FieldDoc> {
 
 	// this cannot contain AUTO fields - any AUTO fields should
 	// have been resolved by the time this class is used.
@@ -99,9 +99,7 @@
 	 * @param b ScoreDoc
 	 * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
 	 */
-	protected final boolean lessThan (final Object a, final Object b) {
-		final FieldDoc docA = (FieldDoc) a;
-		final FieldDoc docB = (FieldDoc) b;
+	protected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {
 		final int n = fields.length;
 		int c = 0;
 		for (int i=0; i<n && c==0; ++i) {
Index: src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
===================================================================
--- src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(revision 823968)
+++ src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(working copy)
@@ -51,14 +51,12 @@
   private boolean more = true;                    // true iff not done
   private boolean firstTime = true;               // true before first next()
 
-  private class CellQueue extends PriorityQueue {
+  private class CellQueue extends PriorityQueue<SpansCell> {
     public CellQueue(int size) {
       initialize(size);
     }
     
-    protected final boolean lessThan(Object o1, Object o2) {
-      SpansCell spans1 = (SpansCell)o1;
-      SpansCell spans2 = (SpansCell)o2;
+    protected final boolean lessThan(SpansCell spans1, SpansCell spans2) {
       if (spans1.doc() == spans2.doc()) {
         return NearSpansOrdered.docSpansOrdered(spans1, spans2);
       } else {
@@ -147,7 +145,7 @@
       firstTime = false;
     } else if (more) {
       if (min().next()) { // trigger further scanning
-        queue.adjustTop(); // maintain queue
+        queue.updateTop(); // maintain queue
       } else {
         more = false;
       }
@@ -185,7 +183,7 @@
       
       more = min().next();
       if (more) {
-        queue.adjustTop();                      // maintain queue
+        queue.updateTop();                      // maintain queue
       }
     }
     return false;                                 // no more matches
@@ -204,7 +202,7 @@
     } else {                                      // normal case
       while (more && min().doc() < target) {      // skip as needed
         if (min().skipTo(target)) {
-          queue.adjustTop();
+          queue.updateTop();
         } else {
           more = false;
         }
@@ -290,7 +288,7 @@
   private void listToQueue() {
     queue.clear(); // rebuild queue
     for (SpansCell cell = first; cell != null; cell = cell.next) {
-      queue.put(cell);                      // add to queue from list
+      queue.add(cell);                      // add to queue from list
     }
   }
 
Index: src/java/org/apache/lucene/search/spans/SpanOrQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(revision 823968)
+++ src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(working copy)
@@ -181,7 +181,7 @@
             Spans spans = ((SpanQuery)i.next()).getSpans(reader);
             if (   ((target == -1) && spans.next())
                 || ((target != -1) && spans.skipTo(target))) {
-              queue.put(spans);
+              queue.add(spans);
             }
           }
           return queue.size() != 0;
@@ -197,7 +197,7 @@
           }
 
           if (top().next()) { // move to next
-            queue.adjustTop();
+            queue.updateTop();
             return true;
           }
 
@@ -215,7 +215,7 @@
           boolean skipCalled = false;
           while (queue.size() != 0 && top().doc() < target) {
             if (top().skipTo(target)) {
-              queue.adjustTop();
+              queue.updateTop();
             } else {
               queue.pop();
             }
@@ -232,7 +232,6 @@
         public int start() { return top().start(); }
         public int end() { return top().end(); }
 
-      // TODO: Remove warning after API has been finalized
       public Collection/*<byte[]>*/ getPayload() throws IOException {
         ArrayList result = null;
         Spans theTop = top();
@@ -242,7 +241,6 @@
         return result;
       }
 
-      // TODO: Remove warning after API has been finalized
      public boolean isPayloadAvailable() {
         Spans top = top();
         return top != null && top.isPayloadAvailable();
Index: src/java/org/apache/lucene/search/SloppyPhraseScorer.java
===================================================================
--- src/java/org/apache/lucene/search/SloppyPhraseScorer.java	(revision 823968)
+++ src/java/org/apache/lucene/search/SloppyPhraseScorer.java	(working copy)
@@ -83,7 +83,7 @@
 
             if (pp.position > end)
                 end = pp.position;
-            pq.put(pp);               // restore pq
+            pq.add(pp);               // restore pq
         }
 
         return freq;
@@ -101,10 +101,10 @@
       }
       //insert back all but pp2
       for (n--; n>=0; n--) {
-        pq.insert(tmpPos[n]);
+        pq.insertWithOverflow(tmpPos[n]);
       }
       //insert pp back
-      pq.put(pp);
+      pq.add(pp);
       return pp2;
     }
 
@@ -133,7 +133,7 @@
                 pp.firstPosition();
                 if (pp.position > end)
                     end = pp.position;
-                pq.put(pp);         // build pq from list
+                pq.add(pp);         // build pq from list
             }
             return end;
         }
@@ -182,7 +182,7 @@
         for (PhrasePositions pp = first; pp != null; pp = pp.next) {
             if (pp.position > end)
                 end = pp.position;
-            pq.put(pp);         // build pq from list
+            pq.add(pp);         // build pq from list
         }
 
         if (repeats!=null) {
Index: src/java/org/apache/lucene/search/FieldSortedHitQueue.java
===================================================================
--- src/java/org/apache/lucene/search/FieldSortedHitQueue.java	(revision 823968)
+++ src/java/org/apache/lucene/search/FieldSortedHitQueue.java	(working copy)
@@ -89,21 +89,6 @@
     maxscore = Math.max(maxscore, fdoc.score);
   }
   
-  // The signature of this method takes a FieldDoc in order to avoid
-  // the unneeded cast to retrieve the score.
-  // inherit javadoc
-  public boolean insert(FieldDoc fdoc) {
-    updateMaxScore(fdoc);
-    return super.insert(fdoc);
-  }
-
-  // This overrides PriorityQueue.insert() so that insert(FieldDoc) that
-  // keeps track of the score isn't accidentally bypassed.  
-  // inherit javadoc
-  public boolean insert(Object fdoc) {
-    return insert((FieldDoc)fdoc);
-  }
-
   // This overrides PriorityQueue.insertWithOverflow() so that
   // updateMaxScore(FieldDoc) that keeps track of the score isn't accidentally
   // bypassed.
Index: src/java/org/apache/lucene/search/MultiSearcher.java
===================================================================
--- src/java/org/apache/lucene/search/MultiSearcher.java	(revision 823968)
+++ src/java/org/apache/lucene/search/MultiSearcher.java	(working copy)
@@ -191,7 +191,7 @@
       for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq
         ScoreDoc scoreDoc = scoreDocs[j];
         scoreDoc.doc += starts[i];                // convert doc
-        if(!hq.insert(scoreDoc))
+        if(scoreDoc == hq.insertWithOverflow(scoreDoc))
           break;                                // no more scores > minScore
       }
     }
@@ -234,7 +234,7 @@
       for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq
         ScoreDoc scoreDoc = scoreDocs[j];
         scoreDoc.doc += starts[i];                // convert doc
-        if (!hq.insert (scoreDoc))
+        if (scoreDoc == hq.insertWithOverflow((FieldDoc) scoreDoc))
           break;                                  // no more scores > minScore
       }
     }
Index: src/java/org/apache/lucene/search/ParallelMultiSearcher.java
===================================================================
--- src/java/org/apache/lucene/search/ParallelMultiSearcher.java	(revision 823968)
+++ src/java/org/apache/lucene/search/ParallelMultiSearcher.java	(working copy)
@@ -269,7 +269,7 @@
         scoreDoc.doc += starts[i]; // convert doc 
         //it would be so nice if we had a thread-safe insert 
         synchronized (hq) {
-          if (!hq.insert(scoreDoc))
+          if (scoreDoc == hq.insertWithOverflow(scoreDoc))
             break;
         } // no more scores > minScore
       }
Index: src/java/org/apache/lucene/search/ExactPhraseScorer.java
===================================================================
--- src/java/org/apache/lucene/search/ExactPhraseScorer.java	(revision 823968)
+++ src/java/org/apache/lucene/search/ExactPhraseScorer.java	(working copy)
@@ -32,7 +32,7 @@
     pq.clear();
     for (PhrasePositions pp = first; pp != null; pp = pp.next) {
       pp.firstPosition();
-      pq.put(pp);				  // build pq from list
+      pq.add(pp);				  // build pq from list
     }
     pqToList();					  // rebuild list from pq
 
Index: src/java/org/apache/lucene/search/PhraseQueue.java
===================================================================
--- src/java/org/apache/lucene/search/PhraseQueue.java	(revision 823968)
+++ src/java/org/apache/lucene/search/PhraseQueue.java	(working copy)
@@ -19,14 +19,12 @@
 
 import org.apache.lucene.util.PriorityQueue;
 
-final class PhraseQueue extends PriorityQueue {
+final class PhraseQueue extends PriorityQueue<PhrasePositions> {
   PhraseQueue(int size) {
     initialize(size);
   }
 
-  protected final boolean lessThan(Object o1, Object o2) {
-    PhrasePositions pp1 = (PhrasePositions)o1;
-    PhrasePositions pp2 = (PhrasePositions)o2;
+  protected final boolean lessThan(PhrasePositions pp1, PhrasePositions pp2) {
     if (pp1.doc == pp2.doc) 
       if (pp1.position == pp2.position)
         // same doc and pp.position, so decide by actual term positions. 
Index: src/java/org/apache/lucene/search/HitQueue.java
===================================================================
--- src/java/org/apache/lucene/search/HitQueue.java	(revision 823968)
+++ src/java/org/apache/lucene/search/HitQueue.java	(working copy)
@@ -19,7 +19,7 @@
 
 import org.apache.lucene.util.PriorityQueue;
 
-final class HitQueue extends PriorityQueue {
+final class HitQueue extends PriorityQueue<ScoreDoc> {
 
   private boolean prePopulate;
 
@@ -68,16 +68,14 @@
   }
 
   // Returns null if prePopulate is false.
-  protected Object getSentinelObject() {
+  protected ScoreDoc getSentinelObject() {
     // Always set the doc Id to MAX_VALUE so that it won't be favored by
     // lessThan. This generally should not happen since if score is not NEG_INF,
     // TopScoreDocCollector will always add the object to the queue.
     return !prePopulate ? null : new ScoreDoc(Integer.MAX_VALUE, Float.NEGATIVE_INFINITY);
   }
   
-  protected final boolean lessThan(Object a, Object b) {
-    ScoreDoc hitA = (ScoreDoc)a;
-    ScoreDoc hitB = (ScoreDoc)b;
+  protected final boolean lessThan(ScoreDoc hitA, ScoreDoc hitB) {
     if (hitA.score == hitB.score)
       return hitA.doc > hitB.doc; 
     else
Index: src/java/org/apache/lucene/index/DirectoryReader.java
===================================================================
--- src/java/org/apache/lucene/index/DirectoryReader.java	(revision 823968)
+++ src/java/org/apache/lucene/index/DirectoryReader.java	(working copy)
@@ -980,7 +980,7 @@
         SegmentMergeInfo smi = new SegmentMergeInfo(starts[i], termEnum, reader);
         smi.ord = i;
         if (t == null ? smi.next() : termEnum.term() != null)
-          queue.put(smi);          // initialize queue
+          queue.add(smi);          // initialize queue
         else
           smi.close();
       }
@@ -995,7 +995,7 @@
         SegmentMergeInfo smi = matchingSegments[i];
         if (smi==null) break;
         if (smi.next())
-          queue.put(smi);
+          queue.add(smi);
         else
           smi.close(); // done with segment
       }
Index: src/java/org/apache/lucene/index/MultipleTermPositions.java
===================================================================
--- src/java/org/apache/lucene/index/MultipleTermPositions.java	(revision 823968)
+++ src/java/org/apache/lucene/index/MultipleTermPositions.java	(working copy)
@@ -32,7 +32,7 @@
  */
 public class MultipleTermPositions implements TermPositions {
 
-  private static final class TermPositionsQueue extends PriorityQueue {
+  private static final class TermPositionsQueue extends PriorityQueue<TermPositions> {
     TermPositionsQueue(List termPositions) throws IOException {
       initialize(termPositions.size());
 
@@ -40,7 +40,7 @@
       while (i.hasNext()) {
         TermPositions tp = (TermPositions) i.next();
         if (tp.next())
-          put(tp);
+          add(tp);
       }
     }
 
@@ -48,8 +48,8 @@
       return (TermPositions) top();
     }
 
-    public final boolean lessThan(Object a, Object b) {
-      return ((TermPositions) a).doc() < ((TermPositions) b).doc();
+    public final boolean lessThan(TermPositions a, TermPositions b) {
+      return a.doc() < b.doc();
     }
   }
 
@@ -126,7 +126,7 @@
         _posList.add(tp.nextPosition());
 
       if (tp.next())
-        _termPositionsQueue.adjustTop();
+        _termPositionsQueue.updateTop();
       else {
         _termPositionsQueue.pop();
         tp.close();
@@ -147,7 +147,7 @@
     while (_termPositionsQueue.peek() != null && target > _termPositionsQueue.peek().doc()) {
       TermPositions tp = (TermPositions) _termPositionsQueue.pop();
       if (tp.skipTo(target))
-        _termPositionsQueue.put(tp);
+        _termPositionsQueue.add(tp);
       else
         tp.close();
     }
Index: src/java/org/apache/lucene/index/SegmentMergeQueue.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentMergeQueue.java	(revision 823968)
+++ src/java/org/apache/lucene/index/SegmentMergeQueue.java	(working copy)
@@ -20,14 +20,12 @@
 import java.io.IOException;
 import org.apache.lucene.util.PriorityQueue;
 
-final class SegmentMergeQueue extends PriorityQueue {
+final class SegmentMergeQueue extends PriorityQueue<SegmentMergeInfo> {
   SegmentMergeQueue(int size) {
     initialize(size);
   }
 
-  protected final boolean lessThan(Object a, Object b) {
-    SegmentMergeInfo stiA = (SegmentMergeInfo)a;
-    SegmentMergeInfo stiB = (SegmentMergeInfo)b;
+  protected final boolean lessThan(SegmentMergeInfo stiA, SegmentMergeInfo stiB) {
     int comparison = stiA.term.compareTo(stiB.term);
     if (comparison == 0)
       return stiA.base < stiB.base; 
Index: src/java/org/apache/lucene/util/PriorityQueue.java
===================================================================
--- src/java/org/apache/lucene/util/PriorityQueue.java	(revision 823968)
+++ src/java/org/apache/lucene/util/PriorityQueue.java	(working copy)
@@ -103,20 +103,6 @@
 
   /**
    * Adds an Object to a PriorityQueue in log(size) time. If one tries to add
-   * more objects than maxSize from initialize a RuntimeException
-   * (ArrayIndexOutOfBound) is thrown.
-   * 
-   * @deprecated use {@link #add(T)} which returns the new top object,
-   *             saving an additional call to {@link #top()}.
-   */
-  public final void put(T element) {
-    size++;
-    heap[size] = element;
-    upHeap();
-  }
-
-  /**
-   * Adds an Object to a PriorityQueue in log(size) time. If one tries to add
    * more objects than maxSize from initialize an
    * {@link ArrayIndexOutOfBoundsException} is thrown.
    * 
@@ -130,19 +116,6 @@
   }
 
   /**
-   * Adds element to the PriorityQueue in log(size) time if either the
-   * PriorityQueue is not full, or not lessThan(element, top()).
-   * 
-   * @param element
-   * @return true if element is added, false otherwise.
-   * @deprecated use {@link #insertWithOverflow(T)} instead, which
-   *             encourages objects reuse.
-   */
-  public boolean insert(T element) {
-    return insertWithOverflow(element) != element;
-  }
-
-  /**
    * insertWithOverflow() is the same as insert() except its
    * return value: it returns the object (if any) that was
    * dropped off the heap because it was full. This can be
@@ -154,12 +127,12 @@
    */
   public T insertWithOverflow(T element) {
     if (size < maxSize) {
-      put(element);
+      add(element);
       return null;
     } else if (size > 0 && !lessThan(element, heap[1])) {
       T ret = heap[1];
       heap[1] = element;
-      adjustTop();
+      updateTop();
       return ret;
     } else {
       return element;
@@ -187,30 +160,6 @@
     } else
       return null;
   }
-
-  /**
-   * Should be called when the Object at top changes values. Still log(n) worst
-   * case, but it's at least twice as fast to
-   * 
-   * <pre>
-   * pq.top().change();
-   * pq.adjustTop();
-   * </pre>
-   * 
-   * instead of
-   * 
-   * <pre>
-   * o = pq.pop();
-   * o.change();
-   * pq.push(o);
-   * </pre>
-   * 
-   * @deprecated use {@link #updateTop()} which returns the new top element and
-   *             saves an additional call to {@link #top()}.
-   */
-  public final void adjustTop() {
-    downHeap();
-  }
   
   /**
    * Should be called when the Object at top changes values. Still log(n) worst
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/QualityQueriesFinder.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/QualityQueriesFinder.java	(revision 823968)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/QualityQueriesFinder.java	(working copy)
@@ -84,7 +84,7 @@
   }
   
   private String [] bestTerms(String field,int numTerms) throws IOException {
-    PriorityQueue pq = new TermsDfQueue(numTerms);
+    PriorityQueue<TermDf> pq = new TermsDfQueue(numTerms);
     IndexReader ir = IndexReader.open(dir, true);
     try {
       int threshold = ir.maxDoc() / 10; // ignore words too common.
@@ -96,7 +96,7 @@
         int df = terms.docFreq();
         if (df<threshold) {
           String ttxt = terms.term().text();
-          pq.insert(new TermDf(ttxt,df));
+          pq.insertWithOverflow(new TermDf(ttxt,df));
         }
       }
     } finally {
@@ -121,13 +121,11 @@
     }
   }
   
-  private static class TermsDfQueue extends PriorityQueue {
+  private static class TermsDfQueue extends PriorityQueue<TermDf> {
     TermsDfQueue (int maxSize) {
       initialize(maxSize);
     }
-    protected boolean lessThan(Object a, Object b) {
-      TermDf tf1 = (TermDf) a;
-      TermDf tf2 = (TermDf) b;
+    protected boolean lessThan(TermDf tf1, TermDf tf2) {
       return tf1.df < tf2.df;
     }
   }
Index: contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms.java
===================================================================
--- contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms.java	(revision 823968)
+++ contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms.java	(working copy)
@@ -55,13 +55,13 @@
     if (field != null) { 
       while (terms.next()) {
         if (terms.term().field().equals(field)) {
-          tiq.insert(new TermInfo(terms.term(), terms.docFreq()));
+          tiq.insertWithOverflow(new TermInfo(terms.term(), terms.docFreq()));
         }
       }
     }
     else {
       while (terms.next()) {
-        tiq.insert(new TermInfo(terms.term(), terms.docFreq()));
+        tiq.insertWithOverflow(new TermInfo(terms.term(), terms.docFreq()));
       }
     }
     while (tiq.size() != 0) {
@@ -88,13 +88,11 @@
   Term term;
 }
 
-final class TermInfoQueue extends PriorityQueue {
+final class TermInfoQueue extends PriorityQueue<TermInfo> {
   TermInfoQueue(int size) {
     initialize(size);
   }
-  protected final boolean lessThan(Object a, Object b) {
-    TermInfo termInfoA = (TermInfo) a;
-    TermInfo termInfoB = (TermInfo) b;
+  protected final boolean lessThan(TermInfo termInfoA, TermInfo termInfoB) {
     return termInfoA.docFreq < termInfoB.docFreq;
   }
 }
Index: contrib/spellchecker/src/java/org/apache/lucene/search/spell/SuggestWordQueue.java
===================================================================
--- contrib/spellchecker/src/java/org/apache/lucene/search/spell/SuggestWordQueue.java	(revision 823968)
+++ contrib/spellchecker/src/java/org/apache/lucene/search/spell/SuggestWordQueue.java	(working copy)
@@ -25,15 +25,13 @@
  * Sorts SuggestWord instances
  *
  */
-final class SuggestWordQueue extends PriorityQueue {
+final class SuggestWordQueue extends PriorityQueue<SuggestWord> {
 
   SuggestWordQueue (int size) {
     initialize(size);
   }
 
-  protected final boolean lessThan (Object a, Object b) {
-    SuggestWord wa = (SuggestWord) a;
-    SuggestWord wb = (SuggestWord) b;
+  protected final boolean lessThan (SuggestWord wa, SuggestWord wb) {
     int val = wa.compareTo(wb);
     return val < 0;
   }
Index: contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker.java
===================================================================
--- contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker.java	(revision 823968)
+++ contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker.java	(working copy)
@@ -246,7 +246,7 @@
           continue;
         }
       }
-      sugQueue.insert(sugWord);
+      sugQueue.insertWithOverflow(sugWord);
       if (sugQueue.size() == numSug) {
         // if queue full, maintain the minScore score
         min = ((SuggestWord) sugQueue.top()).score;
Index: contrib/queries/src/java/org/apache/lucene/search/similar/MoreLikeThis.java
===================================================================
--- contrib/queries/src/java/org/apache/lucene/search/similar/MoreLikeThis.java	(revision 823968)
+++ contrib/queries/src/java/org/apache/lucene/search/similar/MoreLikeThis.java	(working copy)
@@ -668,7 +668,7 @@
             float score = tf * idf;
 
             // only really need 1st 3 entries, other ones are for troubleshooting
-            res.insert(new Object[]{word,                   // the word
+            res.insertWithOverflow(new Object[]{word,                   // the word
                                     topField,               // the top field
                                     Float.valueOf(score),       // overall score
                                     Float.valueOf(idf),         // idf
@@ -953,14 +953,12 @@
     /**
      * PriorityQueue that orders words by score.
      */
-    private static class FreqQ extends PriorityQueue {
+    private static class FreqQ extends PriorityQueue<Object[]> {
         FreqQ (int s) {
             initialize(s);
         }
 
-        protected boolean lessThan(Object a, Object b) {
-            Object[] aa = (Object[]) a;
-            Object[] bb = (Object[]) b;
+        protected boolean lessThan(Object[] aa, Object[] bb) {
             Float fa = (Float) aa[2];
             Float fb = (Float) bb[2];
             return fa.floatValue() > fb.floatValue();
Index: contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery.java
===================================================================
--- contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery.java	(revision 823968)
+++ contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery.java	(working copy)
@@ -215,7 +215,7 @@
     	                float score=fe.difference();
     	                if(variantsQ.size() < MAX_VARIANTS_PER_TERM || score > minScore){
     	                    ScoreTerm st=new ScoreTerm(possibleMatch,score,startTerm);                    
-    	                    variantsQ.insert(st);
+    	                    variantsQ.insertWithOverflow(st);
     	                    minScore = ((ScoreTerm)variantsQ.top()).score; // maintain minScore
     	                }
                     }
@@ -237,7 +237,7 @@
 	                {
 	                  ScoreTerm st = (ScoreTerm) variantsQ.pop();
 	                  st.score=(st.score*st.score)*sim.idf(df,corpusNumDocs);
-	                  q.insert(st);
+	                  q.insertWithOverflow(st);
 	                }                            
                 }
         	}
@@ -326,7 +326,7 @@
         }
       }
       
-      private static class ScoreTermQueue extends PriorityQueue {        
+      private static class ScoreTermQueue extends PriorityQueue<ScoreTerm> {        
         public ScoreTermQueue(int size){
           initialize(size);
         }
@@ -334,9 +334,7 @@
         /* (non-Javadoc)
          * @see org.apache.lucene.util.PriorityQueue#lessThan(java.lang.Object, java.lang.Object)
          */
-        protected boolean lessThan(Object a, Object b) {
-          ScoreTerm termA = (ScoreTerm)a;
-          ScoreTerm termB = (ScoreTerm)b;
+        protected boolean lessThan(ScoreTerm termA, ScoreTerm termB) {
           if (termA.score== termB.score)
             return termA.term.compareTo(termB.term) > 0;
           else
