diff --git a/lucene/core/src/java/org/apache/lucene/search/BitsDocIdSet.java b/lucene/core/src/java/org/apache/lucene/search/BitsDocIdSet.java
new file mode 100644
index 0000000..1406a55
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/BitsDocIdSet.java
@@ -0,0 +1,81 @@
+package org.apache.lucene.search;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.util.Bits;
+
+/**
+ *  This class implements the {@link org.apache.lucene.search.DocIdSet} api from a
+ *  {@link org.apache.lucene.util.Bits}
+ *
+ * @see DocIdSet
+ *
+ */
+public class BitsDocIdSet extends DocIdSet {
+
+  private final Bits bits;
+  private final int length;
+  
+  public BitsDocIdSet(Bits bits, int length) {
+    assert !(bits instanceof DocIdSet);
+    this.bits = bits;
+    this.length = length;
+  }
+
+  @Override
+  public Bits bits() throws IOException {
+    return bits;
+  }
+
+  @Override
+  public DocIdSetIterator iterator() throws IOException {
+    return new DocIdSetIterator() {
+      int docid = -1;
+
+      @Override
+      public int nextDoc() throws IOException {
+
+        while(++docid < length) {
+          if (bits.get(docid)) {
+            return docid;
+          }
+        }
+        return NO_MORE_DOCS;
+      }
+
+      @Override
+      public int docID() {
+        return docid;
+      }
+
+      @Override
+      public long cost() {
+        return length;
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+        assert docid < target;
+        docid = target - 1;
+        return nextDoc();
+      }
+    };
+  }
+
+}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
index 0dc324b..5ba2419 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
@@ -49,12 +49,14 @@ import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.queries.BooleanFilter;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
 import org.apache.lucene.queries.function.valuesource.DoubleFieldSource;
 import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
 import org.apache.lucene.queries.function.valuesource.LongFieldSource;
+import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.CachingWrapperFilter;
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
@@ -64,6 +66,7 @@ import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.NumericRangeFilter;
 import org.apache.lucene.search.NumericRangeQuery;
 import org.apache.lucene.search.QueryWrapperFilter;
+import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.IOUtils;
@@ -72,6 +75,70 @@ import org.apache.lucene.util.TestUtil;
 
 public class TestRangeFacetCounts extends FacetTestCase {
 
+  //Fixes bug in BooleanFilter. See LUCENE-5495
+  public void testBooleanFilterWithRange() throws Exception {
+    Directory d = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), d);
+    Document doc = new Document();
+    NumericDocValuesField field = new NumericDocValuesField("field", 0L);
+    doc.add(field);
+    for(long l=0;l<100;l++) {
+      field.setLongValue(l);
+      w.addDocument(doc);
+    }
+
+    // Also add Long.MAX_VALUE
+    field.setLongValue(Long.MAX_VALUE);
+    w.addDocument(doc);
+
+    IndexReader r = w.getReader();
+    w.close();
+
+    LongRange range1 = new LongRange("r1",  10, true, 20, false);
+    LongRange range2 = new LongRange("r2", 15, true, 30, false);
+    LongRange range3 = new LongRange("r3", 5, true, 17, false);
+
+    ValueSource valueSource = new LongFieldSource("field");
+    Filter f1 = range1.getFilter(valueSource);
+    Filter f2 = range2.getFilter(valueSource);
+    Filter f3 = range3.getFilter(valueSource);
+
+    BooleanFilter filter = new BooleanFilter();
+    filter.add(f1, Occur.MUST);
+    filter.add(f2, Occur.MUST);
+    
+    IndexSearcher searcher = new IndexSearcher(r);
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), filter, 10);
+
+    assertEquals(5, td.totalHits);
+    
+    filter = new BooleanFilter();
+    filter.add(f1, Occur.MUST);
+    filter.add(f2, Occur.MUST);
+    filter.add(f3, Occur.SHOULD);
+    
+    searcher = new IndexSearcher(r);
+
+    td = searcher.search(new MatchAllDocsQuery(), filter, 10);
+
+    assertEquals(2, td.totalHits);
+    
+    filter = new BooleanFilter();
+    filter.add(f1, Occur.MUST);
+    filter.add(f2, Occur.MUST_NOT);
+    filter.add(f3, Occur.SHOULD);
+    
+    searcher = new IndexSearcher(r);
+
+    td = searcher.search(new MatchAllDocsQuery(), filter, 10);
+
+    assertEquals(5, td.totalHits);
+
+    r.close();
+    d.close();
+  }
+
   public void testBasicLong() throws Exception {
     Directory d = newDirectory();
     RandomIndexWriter w = new RandomIndexWriter(random(), d);
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter.java b/lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter.java
index d050e0f..e2f16c0 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter.java
@@ -26,6 +26,7 @@ import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.search.BitsFilteredDocIdSet;
 import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.search.BitsDocIdSet;
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.Filter;
@@ -52,12 +53,21 @@ public class BooleanFilter extends Filter implements Iterable<FilterClause> {
   @Override
   public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {
     FixedBitSet res = null;
+    final List<Bits> shouldBitsList = new ArrayList<Bits>();
+    final List<Bits> mustBitsList = new ArrayList<Bits>();
+    final List<Bits> mustNotBitsList = new ArrayList<Bits>();
     final AtomicReader reader = context.reader();
-    
     boolean hasShouldClauses = false;
     for (final FilterClause fc : clauses) {
       if (fc.getOccur() == Occur.SHOULD) {
         hasShouldClauses = true;
+        Filter filter = fc.getFilter();
+       // pick out filter with bits
+        final Bits bits = getBits(filter, context);
+        if (bits != null) {
+          shouldBitsList.add(bits);
+          continue;
+        }
         final DocIdSetIterator disi = getDISI(fc.getFilter(), context);
         if (disi == null) continue;
         if (res == null) {
@@ -65,18 +75,36 @@ public class BooleanFilter extends Filter implements Iterable<FilterClause> {
         }
         res.or(disi);
       }
+    }    
+    
+    if (!shouldBitsList.isEmpty()) {
+      if (res == null) {
+        res = new FixedBitSet(reader.maxDoc()); 
+      }
+      for (int i = 0; i < reader.maxDoc(); ++i) {
+        for (Bits shouldBits : shouldBitsList) {
+          if (shouldBits.get(i)) {
+            res.set(i);
+            break;
+          }
+        }
+      }
     }
-    if (hasShouldClauses && res == null)
-      return null;
     
     for (final FilterClause fc : clauses) {
       if (fc.getOccur() == Occur.MUST_NOT) {
+        Filter filter = fc.getFilter();
+        // pick out filter with bits
+        final Bits bits = getBits(filter, context);
+        if (bits != null) {
+          mustNotBitsList.add(bits);
+          continue;
+        }
         if (res == null) {
-          assert !hasShouldClauses;
           res = new FixedBitSet(reader.maxDoc());
           res.set(0, reader.maxDoc()); // NOTE: may set bits on deleted docs
         }
-        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);
+        final DocIdSetIterator disi = getDISI(filter, context);
         if (disi != null) {
           res.andNot(disi);
         }
@@ -85,7 +113,14 @@ public class BooleanFilter extends Filter implements Iterable<FilterClause> {
     
     for (final FilterClause fc : clauses) {
       if (fc.getOccur() == Occur.MUST) {
-        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);
+        Filter filter = fc.getFilter();
+        // pick out filter with bits
+        final Bits bits = getBits(filter, context);
+        if (bits != null) {
+          mustBitsList.add(bits);
+          continue;
+        }
+        final DocIdSetIterator disi = getDISI(filter, context);
         if (disi == null) {
           return null; // no documents can match
         }
@@ -96,9 +131,59 @@ public class BooleanFilter extends Filter implements Iterable<FilterClause> {
           res.and(disi);
         }
       }
+    }  
+    
+    if (hasShouldClauses && res == null) {
+      return null;
+    }
+
+    if (res == null) {
+      if (mustBitsList.isEmpty() && mustNotBitsList.isEmpty()) {
+        return null;
+      }
+      Bits compositeBits = getCompositeBits(mustBitsList, mustNotBitsList, reader.maxDoc());
+      return new BitsDocIdSet(compositeBits, reader.maxDoc());
+    } else {
+      // we have deleted docs, so let's add acceptedDocs as a MUST
+      if (mustBitsList.isEmpty() && mustNotBitsList.isEmpty()) {
+        return BitsFilteredDocIdSet.wrap(res, acceptDocs);  
+      }
+      if (acceptDocs != null) {
+        mustBitsList.add(acceptDocs);
+      }
+      // wrap the bits along with compositeBits
+      Bits compositeBits = getCompositeBits(mustBitsList, mustNotBitsList, reader.maxDoc());
+      return BitsFilteredDocIdSet.wrap(res, compositeBits);
     }
+  }  
 
-    return BitsFilteredDocIdSet.wrap(res, acceptDocs);
+  /**
+   * builds a composite Bits implementation that returns true if and only if
+   * the index is in all of mustBits and none of mustNotBits
+   */
+  private static Bits getCompositeBits(final List<Bits> mustBitsList, final List<Bits> mustNotBitsList, final int len) {
+    return new Bits() {
+      
+      @Override
+      public boolean get(int index) {
+        for (Bits mustNotBits : mustNotBitsList) {
+          if (mustNotBits.get(index)) {
+            return false;
+          }
+        }
+        for (Bits mustBits : mustBitsList) {
+          if (!mustBits.get(index)) {
+            return false;
+          }
+        }
+        return true;
+      }
+      
+      @Override
+      public int length() {
+        return len;
+      }
+    };
   }
 
   private static DocIdSetIterator getDISI(Filter filter, AtomicReaderContext context)
@@ -108,6 +193,12 @@ public class BooleanFilter extends Filter implements Iterable<FilterClause> {
     return set == null ? null : set.iterator();
   }
 
+  static Bits getBits(Filter filter, AtomicReaderContext context)
+      throws IOException {
+    final DocIdSet set = filter.getDocIdSet(context, null);
+    return set == null ? null : set.bits();
+  }
+
   /**
   * Adds a new FilterClause to the Boolean Filter container
   * @param filterClause A FilterClause object containing a Filter and an Occur parameter
