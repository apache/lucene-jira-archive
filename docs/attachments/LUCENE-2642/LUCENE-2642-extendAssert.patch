Index: lucene/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java	(revision 996509)
+++ lucene/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java	(working copy)
@@ -46,7 +46,7 @@
   static Directory small;
   static IndexReader reader;
 
-  void assertEquals(String m, float e, float a) {
+  static public void assertEquals(String m, float e, float a) {
     Assert.assertEquals(m, e, a, SCORE_COMP_THRESH);
   }
 
Index: lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4.java	(revision 996509)
+++ lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4.java	(working copy)
@@ -54,6 +54,8 @@
 import org.junit.runner.RunWith;
 import org.junit.runner.manipulation.Filter;
 import org.junit.runner.manipulation.NoTestsRemainException;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunListener;
 import org.junit.runner.notification.RunNotifier;
 import org.junit.runners.BlockJUnit4ClassRunner;
 import org.junit.runners.model.FrameworkMethod;
@@ -78,9 +80,6 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
 /**
  * Base class for all Lucene unit tests, Junit4 variant.
  * Replaces LuceneTestCase.
@@ -117,7 +116,7 @@
 // get from that override is provided by InterceptTestCaseEvents
 //@RunWith(RunBareWrapper.class)
 @RunWith(LuceneTestCaseJ4.LuceneTestCaseRunner.class)
-public abstract class LuceneTestCaseJ4 {
+public abstract class LuceneTestCaseJ4 extends Assert {
 
   /**
    * true iff tests are run in verbose mode. Note: if it is false, tests are not
@@ -337,6 +336,7 @@
       // set current method name for logging
       LuceneTestCaseJ4.this.name = method.getName();
       // check if the current test's class annotated all test* methods with @Test
+      /*
       final Class<? extends LuceneTestCaseJ4> clazz = LuceneTestCaseJ4.this.getClass();
       if (!checkedClasses.containsKey(clazz)) {
         checkedClasses.put(clazz, PLACEHOLDER);
@@ -346,6 +346,7 @@
           }
         }
       }
+      */
       super.starting(method);
     }
     
@@ -433,7 +434,29 @@
     
     Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);
   }
+  
+  // These deprecated methods should be removed soon, when all tests using no Epsilon are fixed:
+  
+	@Deprecated
+	static public void assertEquals(double expected, double actual) {
+		assertEquals(null, expected, actual);
+	}
 
+	@Deprecated
+	static public void assertEquals(String message, double expected, double actual) {
+		assertEquals(message, Double.valueOf(expected), Double.valueOf(actual));
+	}
+
+	@Deprecated
+	static public void assertEquals(float expected, float actual) {
+		assertEquals(null, expected, actual);
+	}
+
+	@Deprecated
+	static public void assertEquals(String message, float expected, float actual) {
+		assertEquals(message, Float.valueOf(expected), Float.valueOf(actual));
+	}
+
   /**
    * Asserts that FieldCacheSanityChecker does not detect any
    * problems with FieldCache.DEFAULT.
@@ -777,8 +800,23 @@
   
   /** optionally filters the tests to be run by TEST_METHOD */
   public static class LuceneTestCaseRunner extends BlockJUnit4ClassRunner {
+    private List<FrameworkMethod> testMethods;
 
     @Override
+    protected List<FrameworkMethod> computeTestMethods() {
+      if (testMethods != null)
+        return testMethods;
+      testMethods = getTestClass().getAnnotatedMethods(Test.class);
+      for (Method m : getTestClass().getJavaClass().getMethods())
+        if (m.getName().startsWith("test") &&
+            m.getAnnotation(Test.class) == null &&
+            m.getParameterTypes().length == 0 &&
+            m.getGenericReturnType() == Void.TYPE)
+          testMethods.add(new FrameworkMethod(m));
+      return testMethods;
+    }
+
+    @Override
     protected void runChild(FrameworkMethod arg0, RunNotifier arg1) {
       for (int i = 0; i < TEST_ITER; i++)
         super.runChild(arg0, arg1);
@@ -804,4 +842,103 @@
       }
     }
   }
+  
+  /**
+   * Test runner for Lucene test classes that test Locale-sensitive behavior.
+   * <p>
+   * This class will run tests under the default Locale, but then will also run
+   * tests under all available JVM locales. This is helpful to ensure tests will
+   * not fail under a different environment.
+   * </p>
+   */
+  public static class LocalizedTestCaseRunner extends LuceneTestCaseRunner {
+    /**
+     * Before changing the default Locale, save the default Locale here so
+     * that it can be restored.
+     */
+    private final Locale defaultLocale = Locale.getDefault();
+    
+    /**
+     * The locale being used as the system default Locale
+     */
+    private Locale locale;
+    
+    private final RunListener listener = new RunListener() {
+      @Override
+      public void testFailure(Failure failure) throws Exception {
+        super.testFailure(failure);
+        String methodName = failure.getDescription().getMethodName();
+        if (locale.equals(defaultLocale))
+          System.out.println("Test failure of '" + methodName
+            + "' occurred with the default Locale " + locale);
+        else
+          System.out.println("Test failure of '" + methodName
+            + "' occurred under a different Locale " + locale);
+      }
+    };
+    
+    public LocalizedTestCaseRunner(Class<?> clazz) throws InitializationError {
+      super(clazz);
+    }
+    
+    @Override
+    protected void runChild(FrameworkMethod arg0, RunNotifier arg1) {
+      arg1.addListener(listener);
+      locale = defaultLocale;
+      super.runChild(arg0, arg1);
+      
+      for (Locale other : Locale.getAvailableLocales()) {
+        locale = other;
+        Locale.setDefault(locale);
+        super.runChild(arg0, arg1);
+      }
+      
+      Locale.setDefault(defaultLocale);
+    }
+  }
+  
+  /**
+   * Test runner for Lucene test classes that run across all core codecs.
+   */
+  public static class MultiCodecTestCaseRunner extends LuceneTestCaseRunner {
+    /**
+     * Before changing the default Codec, save the default Codec here so
+     * that it can be restored.
+     */
+    private final String defaultCodec = CodecProvider.getDefaultCodec();
+    
+    /**
+     * The Codec being used as the system default
+     */
+    private String codec;
+    
+    private final RunListener listener = new RunListener() {
+      @Override
+      public void testFailure(Failure failure) throws Exception {
+        super.testFailure(failure);
+        String methodName = failure.getDescription().getMethodName();
+        System.out.println("Test failure of '" + methodName
+          + "' occurred with codec " + codec);
+      }
+    };
+    
+    public MultiCodecTestCaseRunner(Class<?> clazz) throws InitializationError {
+      super(clazz);
+    }
+    
+    @Override
+    protected void runChild(FrameworkMethod arg0, RunNotifier arg1) {
+      arg1.addListener(listener);
+      
+      for (String other : CodecProvider.CORE_CODECS) {
+        if (other.equals("PreFlex")) continue; // nocommit: impersonation problem!
+        codec = other;
+        CodecProvider.setDefaultCodec(codec);
+        super.runChild(arg0, arg1);
+      }
+      
+      CodecProvider.setDefaultCodec(defaultCodec);
+    }
+
+  }
 }
