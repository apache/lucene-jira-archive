Index: lucene/sandbox/src/java/org/apache/lucene/geo/Line2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/geo/Line2D.java	(revision d381b739993e92a2e3865fa7b691724661612f8d)
+++ lucene/sandbox/src/java/org/apache/lucene/geo/Line2D.java	(date 1551512644000)
@@ -16,7 +16,7 @@
  */
 package org.apache.lucene.geo;
 
-import org.apache.lucene.index.PointValues;
+import org.apache.lucene.index.PointValues.Relation;
 
 /**
  * 2D line implementation represented as a balanced interval tree of edges.
@@ -41,15 +41,24 @@
   }
 
   @Override
-  protected PointValues.Relation componentRelate(double minLat, double maxLat, double minLon, double maxLon) {
+  protected Relation componentRelate(double minLat, double maxLat, double minLon, double maxLon) {
     if (tree.crosses(minLat, maxLat, minLon, maxLon)) {
-      return PointValues.Relation.CELL_CROSSES_QUERY;
+      return Relation.CELL_CROSSES_QUERY;
     }
-    return PointValues.Relation.CELL_OUTSIDE_QUERY;
+
+    return Relation.CELL_OUTSIDE_QUERY;
   }
 
   @Override
-  protected PointValues.Relation componentRelateTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
+  protected Relation componentRelateTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
+    Relation rel =  tree.relateTriangle(ax, ay, bx, by, cx, cy);
+    if (rel != Relation.CELL_OUTSIDE_QUERY) {
+      return rel;
+    }
+    //check if line is inside triangle
+    if (pointInTriangle(tree.lon1, tree.lat1, ax, ay, bx, by, cx, cy)) {
+      return Relation.CELL_CROSSES_QUERY;
+    }
     return tree.relateTriangle(ax, ay, bx, by, cx, cy);
   }
 }
\ No newline at end of file
Index: lucene/sandbox/src/test/org/apache/lucene/document/BaseLatLonShapeTestCase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/document/BaseLatLonShapeTestCase.java	(revision d381b739993e92a2e3865fa7b691724661612f8d)
+++ lucene/sandbox/src/test/org/apache/lucene/document/BaseLatLonShapeTestCase.java	(date 1551512620000)
@@ -110,7 +110,7 @@
   }
 
   /** use {@link GeoTestUtil#nextPolygon()} to create a random line; TODO: move to GeoTestUtil */
-  public Line nextLine() {
+  public static Line nextLine() {
     Polygon poly = GeoTestUtil.nextPolygon();
     double[] lats = new double[poly.numPoints() - 1];
     double[] lons = new double[lats.length];
Index: lucene/sandbox/src/test/org/apache/lucene/geo/TestLine2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/geo/TestLine2D.java	(date 1551512620000)
+++ lucene/sandbox/src/test/org/apache/lucene/geo/TestLine2D.java	(date 1551512620000)
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.geo;
+
+import org.apache.lucene.document.TestLatLonLineShapeQueries;
+import org.apache.lucene.index.PointValues.Relation;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestLine2D extends LuceneTestCase {
+
+  public void testTriangleDisjoint() {
+    Line line = new Line(new double[] {0, 1, 2, 3}, new double[] {0, 0, 2, 2});
+    Line2D line2D = Line2D.create(line);
+    int ax = GeoEncodingUtils.encodeLongitude(4);
+    int ay = GeoEncodingUtils.encodeLatitude(4);
+    int bx = GeoEncodingUtils.encodeLongitude(5);
+    int by = GeoEncodingUtils.encodeLatitude(5);
+    int cx = GeoEncodingUtils.encodeLongitude(5);
+    int cy = GeoEncodingUtils.encodeLatitude(4);
+    assertEquals(Relation.CELL_OUTSIDE_QUERY, line2D.componentRelateTriangle(ax, ay, bx, by , cx, cy));;
+  }
+
+  public void testTriangleIntersects() {
+    Line line = new Line(new double[] {0.5, 0, 1, 2, 3}, new double[] {0.5, 0, 0, 2, 2});
+    Line2D line2D = Line2D.create(line);
+    int ax = GeoEncodingUtils.encodeLongitude(0.0);
+    int ay = GeoEncodingUtils.encodeLatitude(0.0);
+    int bx = GeoEncodingUtils.encodeLongitude(1);
+    int by = GeoEncodingUtils.encodeLatitude(0);
+    int cx = GeoEncodingUtils.encodeLongitude(0);
+    int cy = GeoEncodingUtils.encodeLatitude(1);
+    assertEquals(Relation.CELL_CROSSES_QUERY, line2D.componentRelateTriangle(ax, ay, bx, by , cx, cy));
+  }
+
+  public void testTriangleContains() {
+    Line line = new Line(new double[] {0.5, 0, 1, 2, 3}, new double[] {0.5, 0, 0, 2, 2});
+    Line2D line2D = Line2D.create(line);
+    int ax = GeoEncodingUtils.encodeLongitude(-10);
+    int ay = GeoEncodingUtils.encodeLatitude(-10);
+    int bx = GeoEncodingUtils.encodeLongitude(4);
+    int by = GeoEncodingUtils.encodeLatitude(-10);
+    int cx = GeoEncodingUtils.encodeLongitude(4);
+    int cy = GeoEncodingUtils.encodeLatitude(30);
+    assertEquals(Relation.CELL_CROSSES_QUERY, line2D.componentRelateTriangle(ax, ay, bx, by , cx, cy));
+  }
+
+  public void testRandomTriangles() {
+    Line line = TestLatLonLineShapeQueries.nextLine();
+    Line2D line2D = Line2D.create(line);
+
+    for (int i =0; i < 100; i++) {
+      double ax = GeoTestUtil.nextLongitude();
+      double ay = GeoTestUtil.nextLatitude();
+      double bx = GeoTestUtil.nextLongitude();
+      double by = GeoTestUtil.nextLatitude();
+      double cx = GeoTestUtil.nextLongitude();
+      double cy = GeoTestUtil.nextLatitude();
+
+      double tMinX = StrictMath.min(StrictMath.min(ax, bx), cx);
+      double tMaxX = StrictMath.max(StrictMath.max(ax, bx), cx);
+      double tMinY = StrictMath.min(StrictMath.min(ay, by), cy);
+      double tMaxY = StrictMath.max(StrictMath.max(ay, by), cy);
+
+      Relation r = line2D.relate(tMinY, tMaxY, tMinX, tMaxX);
+      if (r == Relation.CELL_OUTSIDE_QUERY) {
+        assertEquals(Relation.CELL_OUTSIDE_QUERY, line2D.componentRelateTriangle(ax, ay, bx, by, cx, cy));
+      }
+    }
+  }
+}
