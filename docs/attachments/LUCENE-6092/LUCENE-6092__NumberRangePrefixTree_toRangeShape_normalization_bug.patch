Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java	(revision 1643057)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java	(revision )
@@ -56,7 +56,7 @@
   /** A value implemented as a stack of numbers. Spatially speaking, it's
    * analogous to a Point but 1D yet has some precision width.
    * @lucene.internal */
-  protected static interface LevelledValue extends Shape {
+  public static interface LevelledValue extends Shape {
     int getLevel();//0 means the world (universe).
     int getValAtLevel(int level);//level >= 0 && <= getLevel()
     LevelledValue getLVAtLevel(int level);
@@ -189,8 +189,8 @@
     }
   }// class NRShapeImpl
 
-  /** Converts the value to a shape (usually not a range). If it's a JDK object (e.g. Number, Calendar)
-   * that could be parsed from a String, this class won't do it; you must parse it. */
+  /** Converts the value to a shape (usually not a range). Doesn't parse strings; see {@link #parseShape(String)} for
+   * that. */
   public abstract Shape toShape(Object value);
 
   /** Detects a range pattern and parses it, otherwise it's parsed as one shape via
@@ -222,31 +222,46 @@
     }
   }
 
-  /** Parse a String to a LevelledValue. "*" should be the full-range. */
+  /** Parse a String to a LevelledValue Shape. "*" should be the full-range. */
   protected abstract LevelledValue parseShapeLV(String str) throws ParseException;
 
   /** Returns a shape that represents the continuous range between {@code start} and {@code end}. It will
-   * be optimized.
+   * be normalized, and so sometimes a {@link LevelledValue} will be returned.
+   * Both parameters are assumed to be {@link LevelledValue}, not range shapes.
    * @throws IllegalArgumentException if the arguments are in the wrong order, or if either contains the other.
    */
   public Shape toRangeShape(Shape start, Shape end) {
     if (!(start instanceof LevelledValue && end instanceof LevelledValue))
       throw new IllegalArgumentException("Must pass "+LevelledValue.class+" but got "+start.getClass());
-    LevelledValue minLV = (LevelledValue) start;
-    LevelledValue maxLV = (LevelledValue) end;
-    if (minLV.equals(maxLV))
-      return minLV;
-    //Optimize precision of the range, e.g. April 1st to April 30th is April.
-    minLV = minLV.getLVAtLevel(truncateStartVals(minLV, 0));
-    maxLV = maxLV.getLVAtLevel(truncateEndVals(maxLV, 0));
-    int cmp = comparePrefixLV(minLV, maxLV);
+    LevelledValue startLV = (LevelledValue) start;
+    LevelledValue endLV = (LevelledValue) end;
+    //note: this normalization/optimization process is actually REQUIRED based on assumptions elsewhere.
+    //Normalize start & end
+    startLV = startLV.getLVAtLevel(truncateStartVals(startLV, 0)); // chops off trailing min-vals (zeroes)
+    endLV = endLV.getLVAtLevel(truncateEndVals(endLV, 0)); // chops off trailing max-vals
+    //Optimize to just start or end if it's equivalent, e.g. April to April 1st is April 1st.
+    int cmp = comparePrefixLV(startLV, endLV);
     if (cmp > 0) {
       throw new IllegalArgumentException("Wrong order: "+start+" TO "+end);
     }
-    if (cmp == 0 && minLV.getLevel() == maxLV.getLevel())
-      return minLV;
-    return new NRShape(minLV, maxLV);
+    if (cmp == 0) {//one is a prefix of the other
+      if (startLV.getLevel() == endLV.getLevel()) {
+        //same
+        return startLV;
+      } else if (endLV.getLevel() > startLV.getLevel()) {
+        // e.g. April to April 1st
+        if (truncateStartVals(endLV, startLV.getLevel()) == startLV.getLevel()) {
+          return endLV;
-  }
+        }
+      } else {//minLV level > maxLV level
+        // e.g. April 30 to April
+        if (truncateEndVals(startLV, endLV.getLevel()) == endLV.getLevel()) {
+          return startLV;
+        }
+      }
+    }
+    return new NRShape(startLV, endLV);
+  }
 
   /** From lv.getLevel on up, it returns the first Level seen with val != 0. It doesn't check past endLevel. */
   private int truncateStartVals(LevelledValue lv, int endLevel) {
@@ -388,7 +403,7 @@
    * of Cells at adjacent levels, that all have a reference back to the cell array to traverse. They also share a common
    * BytesRef for the term.
    * @lucene.internal */
-  protected class NRCell extends CellIterator implements Cell, LevelledValue {
+  public class NRCell extends CellIterator implements Cell, LevelledValue {
 
     //Shared: (TODO put this in a new class)
     final NRCell[] cellsByLevel;
Index: lucene/spatial/src/test/org/apache/lucene/spatial/prefix/DateNRStrategyTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/prefix/DateNRStrategyTest.java	(revision 1643057)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/prefix/DateNRStrategyTest.java	(revision )
@@ -27,6 +27,7 @@
 import org.junit.Test;
 
 import java.io.IOException;
+import java.text.ParseException;
 import java.util.Calendar;
 
 public class DateNRStrategyTest extends RandomSpatialOpStrategyTestCase {
@@ -63,12 +64,6 @@
   @Repeat(iterations = ITERATIONS)
   public void testContains() throws IOException {
     testOperationRandomShapes(SpatialOperation.Contains);
-  }
-
-  @Test @Ignore("see LUCENE-5692")
-  @Repeat(iterations = ITERATIONS)
-  public void testDisjoint() throws IOException {
-    testOperationRandomShapes(SpatialOperation.IsDisjointTo);
   }
 
   @Test
Index: lucene/spatial/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest.java	(revision 1643057)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest.java	(revision )
@@ -157,7 +157,9 @@
 
     assertEquals("2014", tree.parseShape("[2014-01-01 TO 2014-12-31]").toString());
 
-    assertEquals("2014", tree.parseShape("[2014-01 TO 2014]").toString());
+    assertEquals("2014",    tree.parseShape("[2014-01 TO 2014]").toString());
+    assertEquals("2014-01", tree.parseShape("[2014 TO 2014-01]").toString());
+    assertEquals("2014-12", tree.parseShape("[2014-12 TO 2014]").toString());
 
     assertEquals("[2014 TO 2014-04-06]", tree.parseShape("[2014-01 TO 2014-04-06]").toString());
 
\ No newline at end of file
