Index: lucene/codecs/src/java/org/apache/lucene/codecs/intblock/FixedIntBlockIndexInput.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/intblock/FixedIntBlockIndexInput.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/intblock/FixedIntBlockIndexInput.java	(working copy)
@@ -1,171 +0,0 @@
-package org.apache.lucene.codecs.intblock;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** Naive int block API that writes vInts.  This is
- *  expected to give poor performance; it's really only for
- *  testing the pluggability.  One should typically use pfor instead. */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.sep.IntIndexInput;
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.store.IndexInput;
-
-/** Abstract base class that reads fixed-size blocks of ints
- *  from an IndexInput.  While this is a simple approach, a
- *  more performant approach would directly create an impl
- *  of IntIndexInput inside Directory.  Wrapping a generic
- *  IndexInput will likely cost performance.
- *
- * @lucene.experimental
- */
-public abstract class FixedIntBlockIndexInput extends IntIndexInput {
-
-  private final IndexInput in;
-  protected final int blockSize;
-  
-  public FixedIntBlockIndexInput(final IndexInput in) throws IOException {
-    this.in = in;
-    blockSize = in.readVInt();
-  }
-
-  @Override
-  public IntIndexInput.Reader reader() throws IOException {
-    final int[] buffer = new int[blockSize];
-    final IndexInput clone = in.clone();
-    // TODO: can this be simplified?
-    return new Reader(clone, buffer, this.getBlockReader(clone, buffer));
-  }
-
-  @Override
-  public void close() throws IOException {
-    in.close();
-  }
-
-  @Override
-  public IntIndexInput.Index index() {
-    return new Index();
-  }
-
-  protected abstract BlockReader getBlockReader(IndexInput in, int[] buffer) throws IOException;
-
-  /**
-   * Interface for fixed-size block decoders.
-   * <p>
-   * Implementations should decode into the buffer in {@link #readBlock}.
-   */
-  public interface BlockReader {
-    public void readBlock() throws IOException;
-  }
-
-  private static class Reader extends IntIndexInput.Reader {
-    private final IndexInput in;
-    private final BlockReader blockReader;
-    private final int blockSize;
-    private final int[] pending;
-
-    private int upto;
-    private boolean seekPending;
-    private long pendingFP;
-    private long lastBlockFP = -1;
-
-    public Reader(final IndexInput in, final int[] pending, final BlockReader blockReader) {
-      this.in = in;
-      this.pending = pending;
-      this.blockSize = pending.length;
-      this.blockReader = blockReader;
-      upto = blockSize;
-    }
-
-    void seek(final long fp, final int upto) {
-      assert upto < blockSize;
-      if (seekPending || fp != lastBlockFP) {
-        pendingFP = fp;
-        seekPending = true;
-      }
-      this.upto = upto;
-    }
-
-    @Override
-    public int next() throws IOException {
-      if (seekPending) {
-        // Seek & load new block
-        in.seek(pendingFP);
-        lastBlockFP = pendingFP;
-        blockReader.readBlock();
-        seekPending = false;
-      } else if (upto == blockSize) {
-        // Load new block
-        lastBlockFP = in.getFilePointer();
-        blockReader.readBlock();
-        upto = 0;
-      }
-      return pending[upto++];
-    }
-  }
-
-  private class Index extends IntIndexInput.Index {
-    private long fp;
-    private int upto;
-
-    @Override
-    public void read(final DataInput indexIn, final boolean absolute) throws IOException {
-      if (absolute) {
-        upto = indexIn.readVInt();
-        fp = indexIn.readVLong();
-      } else {
-        final int uptoDelta = indexIn.readVInt();
-        if ((uptoDelta & 1) == 1) {
-          // same block
-          upto += uptoDelta >>> 1;
-        } else {
-          // new block
-          upto = uptoDelta >>> 1;
-          fp += indexIn.readVLong();
-        }
-      }
-      assert upto < blockSize;
-    }
-
-    @Override
-    public void seek(final IntIndexInput.Reader other) throws IOException {
-      ((Reader) other).seek(fp, upto);
-    }
-
-    @Override
-    public void copyFrom(final IntIndexInput.Index other) {
-      final Index idx = (Index) other;
-      fp = idx.fp;
-      upto = idx.upto;
-    }
-
-    @Override
-    public Index clone() {
-      Index other = new Index();
-      other.fp = fp;
-      other.upto = upto;
-      return other;
-    }
-    
-    @Override
-    public String toString() {
-      return "fp=" + fp + " upto=" + upto;
-    }
-  }
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/intblock/FixedIntBlockIndexOutput.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/intblock/FixedIntBlockIndexOutput.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/intblock/FixedIntBlockIndexOutput.java	(working copy)
@@ -1,128 +0,0 @@
-package org.apache.lucene.codecs.intblock;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** Naive int block API that writes vInts.  This is
- *  expected to give poor performance; it's really only for
- *  testing the pluggability.  One should typically use pfor instead. */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.sep.IntIndexOutput;
-import org.apache.lucene.store.DataOutput;
-import org.apache.lucene.store.IndexOutput;
-
-/** Abstract base class that writes fixed-size blocks of ints
- *  to an IndexOutput.  While this is a simple approach, a
- *  more performant approach would directly create an impl
- *  of IntIndexOutput inside Directory.  Wrapping a generic
- *  IndexInput will likely cost performance.
- *
- * @lucene.experimental
- */
-public abstract class FixedIntBlockIndexOutput extends IntIndexOutput {
-
-  protected final IndexOutput out;
-  private final int blockSize;
-  protected final int[] buffer;
-  private int upto;
-
-  protected FixedIntBlockIndexOutput(IndexOutput out, int fixedBlockSize) throws IOException {
-    blockSize = fixedBlockSize;
-    this.out = out;
-    out.writeVInt(blockSize);
-    buffer = new int[blockSize];
-  }
-
-  protected abstract void flushBlock() throws IOException;
-
-  @Override
-  public IntIndexOutput.Index index() {
-    return new Index();
-  }
-
-  private class Index extends IntIndexOutput.Index {
-    long fp;
-    int upto;
-    long lastFP;
-    int lastUpto;
-
-    @Override
-    public void mark() throws IOException {
-      fp = out.getFilePointer();
-      upto = FixedIntBlockIndexOutput.this.upto;
-    }
-
-    @Override
-    public void copyFrom(IntIndexOutput.Index other, boolean copyLast) throws IOException {
-      Index idx = (Index) other;
-      fp = idx.fp;
-      upto = idx.upto;
-      if (copyLast) {
-        lastFP = fp;
-        lastUpto = upto;
-      }
-    }
-
-    @Override
-    public void write(DataOutput indexOut, boolean absolute) throws IOException {
-      if (absolute) {
-        indexOut.writeVInt(upto);
-        indexOut.writeVLong(fp);
-      } else if (fp == lastFP) {
-        // same block
-        assert upto >= lastUpto;
-        int uptoDelta = upto - lastUpto;
-        indexOut.writeVInt(uptoDelta << 1 | 1);
-      } else {      
-        // new block
-        indexOut.writeVInt(upto << 1);
-        indexOut.writeVLong(fp - lastFP);
-      }
-      lastUpto = upto;
-      lastFP = fp;
-    }
-
-    @Override
-    public String toString() {
-      return "fp=" + fp + " upto=" + upto;
-    }
-  }
-
-  @Override
-  public void write(int v) throws IOException {
-    buffer[upto++] = v;
-    if (upto == blockSize) {
-      flushBlock();
-      upto = 0;
-    }
-  }
-
-  @Override
-  public void close() throws IOException {
-    try {
-      if (upto > 0) {
-        // NOTE: entries in the block after current upto are
-        // invalid
-        flushBlock();
-      }
-    } finally {
-      out.close();
-    }
-  }
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/intblock/VariableIntBlockIndexInput.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/intblock/VariableIntBlockIndexInput.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/intblock/VariableIntBlockIndexInput.java	(working copy)
@@ -1,198 +0,0 @@
-package org.apache.lucene.codecs.intblock;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** Naive int block API that writes vInts.  This is
- *  expected to give poor performance; it's really only for
- *  testing the pluggability.  One should typically use pfor instead. */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.sep.IntIndexInput;
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.store.IndexInput;
-
-// TODO: much of this can be shared code w/ the fixed case
-
-/** Abstract base class that reads variable-size blocks of ints
- *  from an IndexInput.  While this is a simple approach, a
- *  more performant approach would directly create an impl
- *  of IntIndexInput inside Directory.  Wrapping a generic
- *  IndexInput will likely cost performance.
- *
- * @lucene.experimental
- */
-public abstract class VariableIntBlockIndexInput extends IntIndexInput {
-
-  protected final IndexInput in;
-  protected final int maxBlockSize;
-
-  protected VariableIntBlockIndexInput(final IndexInput in) throws IOException {
-    this.in = in;
-    maxBlockSize = in.readInt();
-  }
-
-  @Override
-  public IntIndexInput.Reader reader() throws IOException {
-    final int[] buffer = new int[maxBlockSize];
-    final IndexInput clone = in.clone();
-    // TODO: can this be simplified?
-    return new Reader(clone, buffer, this.getBlockReader(clone, buffer));
-  }
-
-  @Override
-  public void close() throws IOException {
-    in.close();
-  }
-
-  @Override
-  public IntIndexInput.Index index() {
-    return new Index();
-  }
-
-  protected abstract BlockReader getBlockReader(IndexInput in, int[] buffer) throws IOException;
-
-  /**
-   * Interface for variable-size block decoders.
-   * <p>
-   * Implementations should decode into the buffer in {@link #readBlock}.
-   */
-  public interface BlockReader {
-    public int readBlock() throws IOException;
-    public void seek(long pos) throws IOException;
-  }
-
-  private static class Reader extends IntIndexInput.Reader {
-    private final IndexInput in;
-
-    public final int[] pending;
-    int upto;
-
-    private boolean seekPending;
-    private long pendingFP;
-    private int pendingUpto;
-    private long lastBlockFP;
-    private int blockSize;
-    private final BlockReader blockReader;
-
-    public Reader(final IndexInput in, final int[] pending, final BlockReader blockReader) {
-      this.in = in;
-      this.pending = pending;
-      this.blockReader = blockReader;
-    }
-
-    void seek(final long fp, final int upto) {
-      // TODO: should we do this in real-time, not lazy?
-      pendingFP = fp;
-      pendingUpto = upto;
-      assert pendingUpto >= 0: "pendingUpto=" + pendingUpto;
-      seekPending = true;
-    }
-
-    private final void maybeSeek() throws IOException {
-      if (seekPending) {
-        if (pendingFP != lastBlockFP) {
-          // need new block
-          in.seek(pendingFP);
-          blockReader.seek(pendingFP);
-          lastBlockFP = pendingFP;
-          blockSize = blockReader.readBlock();
-        }
-        upto = pendingUpto;
-
-        // TODO: if we were more clever when writing the
-        // index, such that a seek point wouldn't be written
-        // until the int encoder "committed", we could avoid
-        // this (likely minor) inefficiency:
-
-        // This is necessary for int encoders that are
-        // non-causal, ie must see future int values to
-        // encode the current ones.
-        while(upto >= blockSize) {
-          upto -= blockSize;
-          lastBlockFP = in.getFilePointer();
-          blockSize = blockReader.readBlock();
-        }
-        seekPending = false;
-      }
-    }
-
-    @Override
-    public int next() throws IOException {
-      this.maybeSeek();
-      if (upto == blockSize) {
-        lastBlockFP = in.getFilePointer();
-        blockSize = blockReader.readBlock();
-        upto = 0;
-      }
-
-      return pending[upto++];
-    }
-  }
-
-  private class Index extends IntIndexInput.Index {
-    private long fp;
-    private int upto;
-
-    @Override
-    public void read(final DataInput indexIn, final boolean absolute) throws IOException {
-      if (absolute) {
-        upto = indexIn.readVInt();
-        fp = indexIn.readVLong();
-      } else {
-        final int uptoDelta = indexIn.readVInt();
-        if ((uptoDelta & 1) == 1) {
-          // same block
-          upto += uptoDelta >>> 1;
-        } else {
-          // new block
-          upto = uptoDelta >>> 1;
-          fp += indexIn.readVLong();
-        }
-      }
-      // TODO: we can't do this assert because non-causal
-      // int encoders can have upto over the buffer size
-      //assert upto < maxBlockSize: "upto=" + upto + " max=" + maxBlockSize;
-    }
-
-    @Override
-    public String toString() {
-      return "VarIntBlock.Index fp=" + fp + " upto=" + upto + " maxBlock=" + maxBlockSize;
-    }
-
-    @Override
-    public void seek(final IntIndexInput.Reader other) throws IOException {
-      ((Reader) other).seek(fp, upto);
-    }
-
-    @Override
-    public void copyFrom(final IntIndexInput.Index other) {
-      final Index idx = (Index) other;
-      fp = idx.fp;
-      upto = idx.upto;
-    }
-
-    @Override
-    public Index clone() {
-      Index other = new Index();
-      other.fp = fp;
-      other.upto = upto;
-      return other;
-    }
-  }
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/intblock/VariableIntBlockIndexOutput.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/intblock/VariableIntBlockIndexOutput.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/intblock/VariableIntBlockIndexOutput.java	(working copy)
@@ -1,136 +0,0 @@
-package org.apache.lucene.codecs.intblock;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** Naive int block API that writes vInts.  This is
- *  expected to give poor performance; it's really only for
- *  testing the pluggability.  One should typically use pfor instead. */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.sep.IntIndexOutput;
-import org.apache.lucene.store.DataOutput;
-import org.apache.lucene.store.IndexOutput;
-
-// TODO: much of this can be shared code w/ the fixed case
-
-/** Abstract base class that writes variable-size blocks of ints
- *  to an IndexOutput.  While this is a simple approach, a
- *  more performant approach would directly create an impl
- *  of IntIndexOutput inside Directory.  Wrapping a generic
- *  IndexInput will likely cost performance.
- *
- * @lucene.experimental
- */
-public abstract class VariableIntBlockIndexOutput extends IntIndexOutput {
-
-  protected final IndexOutput out;
-
-  private int upto;
-  private boolean hitExcDuringWrite;
-
-  // TODO what Var-Var codecs exist in practice... and what are there blocksizes like?
-  // if its less than 128 we should set that as max and use byte?
-
-  /** NOTE: maxBlockSize must be the maximum block size 
-   *  plus the max non-causal lookahead of your codec.  EG Simple9
-   *  requires lookahead=1 because on seeing the Nth value
-   *  it knows it must now encode the N-1 values before it. */
-  protected VariableIntBlockIndexOutput(IndexOutput out, int maxBlockSize) throws IOException {
-    this.out = out;
-    out.writeInt(maxBlockSize);
-  }
-
-  /** Called one value at a time.  Return the number of
-   *  buffered input values that have been written to out. */
-  protected abstract int add(int value) throws IOException;
-
-  @Override
-  public IntIndexOutput.Index index() {
-    return new Index();
-  }
-
-  private class Index extends IntIndexOutput.Index {
-    long fp;
-    int upto;
-    long lastFP;
-    int lastUpto;
-
-    @Override
-    public void mark() throws IOException {
-      fp = out.getFilePointer();
-      upto = VariableIntBlockIndexOutput.this.upto;
-    }
-
-    @Override
-    public void copyFrom(IntIndexOutput.Index other, boolean copyLast) throws IOException {
-      Index idx = (Index) other;
-      fp = idx.fp;
-      upto = idx.upto;
-      if (copyLast) {
-        lastFP = fp;
-        lastUpto = upto;
-      }
-    }
-
-    @Override
-    public void write(DataOutput indexOut, boolean absolute) throws IOException {
-      assert upto >= 0;
-      if (absolute) {
-        indexOut.writeVInt(upto);
-        indexOut.writeVLong(fp);
-      } else if (fp == lastFP) {
-        // same block
-        assert upto >= lastUpto;
-        int uptoDelta = upto - lastUpto;
-        indexOut.writeVInt(uptoDelta << 1 | 1);
-      } else {      
-        // new block
-        indexOut.writeVInt(upto << 1);
-        indexOut.writeVLong(fp - lastFP);
-      }
-      lastUpto = upto;
-      lastFP = fp;
-    }
-  }
-
-  @Override
-  public void write(int v) throws IOException {
-    hitExcDuringWrite = true;
-    upto -= add(v)-1;
-    hitExcDuringWrite = false;
-    assert upto >= 0;
-  }
-
-  @Override
-  public void close() throws IOException {
-    try {
-      if (!hitExcDuringWrite) {
-        // stuff 0s in until the "real" data is flushed:
-        int stuffed = 0;
-        while(upto > stuffed) {
-          upto -= add(0)-1;
-          assert upto >= 0;
-          stuffed += 1;
-        }
-      }
-    } finally {
-      out.close();
-    }
-  }
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/intblock/package.html
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/intblock/package.html	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/intblock/package.html	(working copy)
@@ -1,25 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-Intblock: base support for fixed or variable length block integer encoders
-</body>
-</html>
Index: lucene/codecs/src/java/org/apache/lucene/codecs/sep/IntIndexInput.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/sep/IntIndexInput.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/sep/IntIndexInput.java	(working copy)
@@ -1,59 +0,0 @@
-package org.apache.lucene.codecs.sep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.Closeable;
-import java.io.IOException;
-
-import org.apache.lucene.store.DataInput;
-
-/** Defines basic API for writing ints to an IndexOutput.
- *  IntBlockCodec interacts with this API. @see
- *  IntBlockReader
- *
- * @lucene.experimental */
-public abstract class IntIndexInput implements Closeable {
-
-  public abstract Reader reader() throws IOException;
-
-  @Override
-  public abstract void close() throws IOException;
-
-  public abstract Index index() throws IOException;
-  
-  /** Records a single skip-point in the {@link IntIndexInput.Reader}. */
-  public abstract static class Index {
-
-    public abstract void read(DataInput indexIn, boolean absolute) throws IOException;
-
-    /** Seeks primary stream to the last read offset */
-    public abstract void seek(IntIndexInput.Reader stream) throws IOException;
-
-    public abstract void copyFrom(Index other);
-    
-    @Override
-    public abstract Index clone();
-  }
-
-  /** Reads int values. */
-  public abstract static class Reader {
-
-    /** Reads next single int */
-    public abstract int next() throws IOException;
-  }
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/sep/IntIndexOutput.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/sep/IntIndexOutput.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/sep/IntIndexOutput.java	(working copy)
@@ -1,61 +0,0 @@
-package org.apache.lucene.codecs.sep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// TODO: we may want tighter integration w/ IndexOutput --
-// may give better perf:
-
-import org.apache.lucene.store.DataOutput;
-
-import java.io.IOException;
-import java.io.Closeable;
-
-/** Defines basic API for writing ints to an IndexOutput.
- *  IntBlockCodec interacts with this API. @see
- *  IntBlockReader.
- *
- * <p>NOTE: block sizes could be variable
- *
- * @lucene.experimental */
-public abstract class IntIndexOutput implements Closeable {
-
-  /** Write an int to the primary file.  The value must be
-   * >= 0.  */
-  public abstract void write(int v) throws IOException;
-
-  /** Records a single skip-point in the IndexOutput. */
-  public abstract static class Index {
-
-    /** Internally records the current location */
-    public abstract void mark() throws IOException;
-
-    /** Copies index from other */
-    public abstract void copyFrom(Index other, boolean copyLast) throws IOException;
-
-    /** Writes "location" of current output pointer of primary
-     *  output to different output (out) */
-    public abstract void write(DataOutput indexOut, boolean absolute) throws IOException;
-  }
-
-  /** If you are indexing the primary output file, call
-   *  this and interact with the returned IndexWriter. */
-  public abstract Index index();
-
-  @Override
-  public abstract void close() throws IOException;
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/sep/IntStreamFactory.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/sep/IntStreamFactory.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/sep/IntStreamFactory.java	(working copy)
@@ -1,36 +0,0 @@
-package org.apache.lucene.codecs.sep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-
-import java.io.IOException;
-
-/** Provides int reader and writer to specified files.
- *
- * @lucene.experimental */
-public abstract class IntStreamFactory {
-  /** Create an {@link IntIndexInput} on the provided
-   *  fileName. */
-  public abstract IntIndexInput openInput(Directory dir, String fileName, IOContext context) throws IOException;
-
-  /** Create an {@link IntIndexOutput} on the provided
-   *  fileName. */
-  public abstract IntIndexOutput createOutput(Directory dir, String fileName, IOContext context) throws IOException;
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepPostingsReader.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepPostingsReader.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepPostingsReader.java	(working copy)
@@ -1,714 +0,0 @@
-package org.apache.lucene.codecs.sep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.BlockTermState;
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.PostingsReaderBase;
-import org.apache.lucene.index.DocsAndPositionsEnum;
-import org.apache.lucene.index.DocsEnum;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.TermState;
-import org.apache.lucene.store.ByteArrayDataInput;
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IOUtils;
-
-/** Concrete class that reads the current doc/freq/skip
- *  postings format.    
- *
- * @lucene.experimental
- */
-
-// TODO: -- should we switch "hasProx" higher up?  and
-// create two separate docs readers, one that also reads
-// prox and one that doesn't?
-
-public class SepPostingsReader extends PostingsReaderBase {
-
-  final IntIndexInput freqIn;
-  final IntIndexInput docIn;
-  final IntIndexInput posIn;
-  final IndexInput payloadIn;
-  final IndexInput skipIn;
-
-  int skipInterval;
-  int maxSkipLevels;
-  int skipMinimum;
-
-  public SepPostingsReader(Directory dir, FieldInfos fieldInfos, SegmentInfo segmentInfo, IOContext context, IntStreamFactory intFactory, String segmentSuffix) throws IOException {
-    boolean success = false;
-    try {
-
-      final String docFileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, SepPostingsWriter.DOC_EXTENSION);
-      docIn = intFactory.openInput(dir, docFileName, context);
-
-      skipIn = dir.openInput(IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, SepPostingsWriter.SKIP_EXTENSION), context);
-
-      if (fieldInfos.hasFreq()) {
-        freqIn = intFactory.openInput(dir, IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, SepPostingsWriter.FREQ_EXTENSION), context);        
-      } else {
-        freqIn = null;
-      }
-      if (fieldInfos.hasProx()) {
-        posIn = intFactory.openInput(dir, IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, SepPostingsWriter.POS_EXTENSION), context);
-        payloadIn = dir.openInput(IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, SepPostingsWriter.PAYLOAD_EXTENSION), context);
-      } else {
-        posIn = null;
-        payloadIn = null;
-      }
-      success = true;
-    } finally {
-      if (!success) {
-        close();
-      }
-    }
-  }
-
-  @Override
-  public void init(IndexInput termsIn) throws IOException {
-    // Make sure we are talking to the matching past writer
-    CodecUtil.checkHeader(termsIn, SepPostingsWriter.CODEC,
-      SepPostingsWriter.VERSION_START, SepPostingsWriter.VERSION_START);
-    skipInterval = termsIn.readInt();
-    maxSkipLevels = termsIn.readInt();
-    skipMinimum = termsIn.readInt();
-  }
-
-  @Override
-  public void close() throws IOException {
-    IOUtils.close(freqIn, docIn, skipIn, posIn, payloadIn);
-  }
-
-  private static final class SepTermState extends BlockTermState {
-    // We store only the seek point to the docs file because
-    // the rest of the info (freqIndex, posIndex, etc.) is
-    // stored in the docs file:
-    IntIndexInput.Index docIndex;
-    IntIndexInput.Index posIndex;
-    IntIndexInput.Index freqIndex;
-    long payloadFP;
-    long skipFP;
-
-    @Override
-    public SepTermState clone() {
-      SepTermState other = new SepTermState();
-      other.copyFrom(this);
-      return other;
-    }
-
-    @Override
-    public void copyFrom(TermState _other) {
-      super.copyFrom(_other);
-      SepTermState other = (SepTermState) _other;
-      if (docIndex == null) {
-        docIndex = other.docIndex.clone();
-      } else {
-        docIndex.copyFrom(other.docIndex);
-      }
-      if (other.freqIndex != null) {
-        if (freqIndex == null) {
-          freqIndex = other.freqIndex.clone();
-        } else {
-          freqIndex.copyFrom(other.freqIndex);
-        }
-      } else {
-        freqIndex = null;
-      }
-      if (other.posIndex != null) {
-        if (posIndex == null) {
-          posIndex = other.posIndex.clone();
-        } else {
-          posIndex.copyFrom(other.posIndex);
-        }
-      } else {
-        posIndex = null;
-      }
-      payloadFP = other.payloadFP;
-      skipFP = other.skipFP;
-    }
-
-    @Override
-    public String toString() {
-      return super.toString() + " docIndex=" + docIndex + " freqIndex=" + freqIndex + " posIndex=" + posIndex + " payloadFP=" + payloadFP + " skipFP=" + skipFP;
-    }
-  }
-
-  @Override
-  public BlockTermState newTermState() throws IOException {
-    final SepTermState state = new SepTermState();
-    state.docIndex = docIn.index();
-    if (freqIn != null) {
-      state.freqIndex = freqIn.index();
-    }
-    if (posIn != null) {
-      state.posIndex = posIn.index();
-    }
-    return state;
-  }
-
-  @Override
-  public void decodeTerm(long[] empty, DataInput in, FieldInfo fieldInfo, BlockTermState _termState, boolean absolute) 
-    throws IOException {
-    final SepTermState termState = (SepTermState) _termState;
-    termState.docIndex.read(in, absolute);
-    if (fieldInfo.getIndexOptions() != IndexOptions.DOCS_ONLY) {
-      termState.freqIndex.read(in, absolute);
-      if (fieldInfo.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {
-        //System.out.println("  freqIndex=" + termState.freqIndex);
-        termState.posIndex.read(in, absolute);
-        //System.out.println("  posIndex=" + termState.posIndex);
-        if (fieldInfo.hasPayloads()) {
-          if (absolute) {
-            termState.payloadFP = in.readVLong();
-          } else {
-            termState.payloadFP += in.readVLong();
-          }
-          //System.out.println("  payloadFP=" + termState.payloadFP);
-        }
-      }
-    }
-
-    if (termState.docFreq >= skipMinimum) {
-      //System.out.println("   readSkip @ " + in.getPosition());
-      if (absolute) {
-        termState.skipFP = in.readVLong();
-      } else {
-        termState.skipFP += in.readVLong();
-      }
-      //System.out.println("  skipFP=" + termState.skipFP);
-    } else if (absolute) {
-      termState.skipFP = 0;
-    }
-  }
-
-  @Override
-  public DocsEnum docs(FieldInfo fieldInfo, BlockTermState _termState, Bits liveDocs, DocsEnum reuse, int flags) throws IOException {
-    final SepTermState termState = (SepTermState) _termState;
-    SepDocsEnum docsEnum;
-    if (reuse == null || !(reuse instanceof SepDocsEnum)) {
-      docsEnum = new SepDocsEnum();
-    } else {
-      docsEnum = (SepDocsEnum) reuse;
-      if (docsEnum.startDocIn != docIn) {
-        // If you are using ParellelReader, and pass in a
-        // reused DocsAndPositionsEnum, it could have come
-        // from another reader also using sep codec
-        docsEnum = new SepDocsEnum();        
-      }
-    }
-
-    return docsEnum.init(fieldInfo, termState, liveDocs);
-  }
-
-  @Override
-  public DocsAndPositionsEnum docsAndPositions(FieldInfo fieldInfo, BlockTermState _termState, Bits liveDocs,
-                                               DocsAndPositionsEnum reuse, int flags)
-    throws IOException {
-
-    assert fieldInfo.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
-    final SepTermState termState = (SepTermState) _termState;
-    SepDocsAndPositionsEnum postingsEnum;
-    if (reuse == null || !(reuse instanceof SepDocsAndPositionsEnum)) {
-      postingsEnum = new SepDocsAndPositionsEnum();
-    } else {
-      postingsEnum = (SepDocsAndPositionsEnum) reuse;
-      if (postingsEnum.startDocIn != docIn) {
-        // If you are using ParellelReader, and pass in a
-        // reused DocsAndPositionsEnum, it could have come
-        // from another reader also using sep codec
-        postingsEnum = new SepDocsAndPositionsEnum();        
-      }
-    }
-
-    return postingsEnum.init(fieldInfo, termState, liveDocs);
-  }
-
-  class SepDocsEnum extends DocsEnum {
-    int docFreq;
-    int doc = -1;
-    int accum;
-    int count;
-    int freq;
-    long freqStart;
-
-    // TODO: -- should we do omitTF with 2 different enum classes?
-    private boolean omitTF;
-    private IndexOptions indexOptions;
-    private boolean storePayloads;
-    private Bits liveDocs;
-    private final IntIndexInput.Reader docReader;
-    private final IntIndexInput.Reader freqReader;
-    private long skipFP;
-
-    private final IntIndexInput.Index docIndex;
-    private final IntIndexInput.Index freqIndex;
-    private final IntIndexInput.Index posIndex;
-    private final IntIndexInput startDocIn;
-
-    // TODO: -- should we do hasProx with 2 different enum classes?
-
-    boolean skipped;
-    SepSkipListReader skipper;
-
-    SepDocsEnum() throws IOException {
-      startDocIn = docIn;
-      docReader = docIn.reader();
-      docIndex = docIn.index();
-      if (freqIn != null) {
-        freqReader = freqIn.reader();
-        freqIndex = freqIn.index();
-      } else {
-        freqReader = null;
-        freqIndex = null;
-      }
-      if (posIn != null) {
-        posIndex = posIn.index();                 // only init this so skipper can read it
-      } else {
-        posIndex = null;
-      }
-    }
-
-    SepDocsEnum init(FieldInfo fieldInfo, SepTermState termState, Bits liveDocs) throws IOException {
-      this.liveDocs = liveDocs;
-      this.indexOptions = fieldInfo.getIndexOptions();
-      omitTF = indexOptions == IndexOptions.DOCS_ONLY;
-      storePayloads = fieldInfo.hasPayloads();
-
-      // TODO: can't we only do this if consumer
-      // skipped consuming the previous docs?
-      docIndex.copyFrom(termState.docIndex);
-      docIndex.seek(docReader);
-
-      if (!omitTF) {
-        freqIndex.copyFrom(termState.freqIndex);
-        freqIndex.seek(freqReader);
-      }
-
-      docFreq = termState.docFreq;
-      // NOTE: unused if docFreq < skipMinimum:
-      skipFP = termState.skipFP;
-      count = 0;
-      doc = -1;
-      accum = 0;
-      freq = 1;
-      skipped = false;
-
-      return this;
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-
-      while(true) {
-        if (count == docFreq) {
-          return doc = NO_MORE_DOCS;
-        }
-
-        count++;
-
-        // Decode next doc
-        //System.out.println("decode docDelta:");
-        accum += docReader.next();
-          
-        if (!omitTF) {
-          //System.out.println("decode freq:");
-          freq = freqReader.next();
-        }
-
-        if (liveDocs == null || liveDocs.get(accum)) {
-          break;
-        }
-      }
-      return (doc = accum);
-    }
-
-    @Override
-    public int freq() throws IOException {
-      return freq;
-    }
-
-    @Override
-    public int docID() {
-      return doc;
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-
-      if ((target - skipInterval) >= doc && docFreq >= skipMinimum) {
-
-        // There are enough docs in the posting to have
-        // skip data, and its not too close
-
-        if (skipper == null) {
-          // This DocsEnum has never done any skipping
-          skipper = new SepSkipListReader(skipIn.clone(),
-                                          freqIn,
-                                          docIn,
-                                          posIn,
-                                          maxSkipLevels, skipInterval);
-
-        }
-
-        if (!skipped) {
-          // We haven't yet skipped for this posting
-          skipper.init(skipFP,
-                       docIndex,
-                       freqIndex,
-                       posIndex,
-                       0,
-                       docFreq,
-                       storePayloads);
-          skipper.setIndexOptions(indexOptions);
-
-          skipped = true;
-        }
-
-        final int newCount = skipper.skipTo(target); 
-
-        if (newCount > count) {
-
-          // Skipper did move
-          if (!omitTF) {
-            skipper.getFreqIndex().seek(freqReader);
-          }
-          skipper.getDocIndex().seek(docReader);
-          count = newCount;
-          doc = accum = skipper.getDoc();
-        }
-      }
-        
-      // Now, linear scan for the rest:
-      do {
-        if (nextDoc() == NO_MORE_DOCS) {
-          return NO_MORE_DOCS;
-        }
-      } while (target > doc);
-
-      return doc;
-    }
-    
-    @Override
-    public long cost() {
-      return docFreq;
-    }
-  }
-
-  class SepDocsAndPositionsEnum extends DocsAndPositionsEnum {
-    int docFreq;
-    int doc = -1;
-    int accum;
-    int count;
-    int freq;
-    long freqStart;
-
-    private boolean storePayloads;
-    private Bits liveDocs;
-    private final IntIndexInput.Reader docReader;
-    private final IntIndexInput.Reader freqReader;
-    private final IntIndexInput.Reader posReader;
-    private final IndexInput payloadIn;
-    private long skipFP;
-
-    private final IntIndexInput.Index docIndex;
-    private final IntIndexInput.Index freqIndex;
-    private final IntIndexInput.Index posIndex;
-    private final IntIndexInput startDocIn;
-
-    private long payloadFP;
-
-    private int pendingPosCount;
-    private int position;
-    private int payloadLength;
-    private long pendingPayloadBytes;
-
-    private boolean skipped;
-    private SepSkipListReader skipper;
-    private boolean payloadPending;
-    private boolean posSeekPending;
-
-    SepDocsAndPositionsEnum() throws IOException {
-      startDocIn = docIn;
-      docReader = docIn.reader();
-      docIndex = docIn.index();
-      freqReader = freqIn.reader();
-      freqIndex = freqIn.index();
-      posReader = posIn.reader();
-      posIndex = posIn.index();
-      payloadIn = SepPostingsReader.this.payloadIn.clone();
-    }
-
-    SepDocsAndPositionsEnum init(FieldInfo fieldInfo, SepTermState termState, Bits liveDocs) throws IOException {
-      this.liveDocs = liveDocs;
-      storePayloads = fieldInfo.hasPayloads();
-      //System.out.println("Sep D&P init");
-
-      // TODO: can't we only do this if consumer
-      // skipped consuming the previous docs?
-      docIndex.copyFrom(termState.docIndex);
-      docIndex.seek(docReader);
-      //System.out.println("  docIndex=" + docIndex);
-
-      freqIndex.copyFrom(termState.freqIndex);
-      freqIndex.seek(freqReader);
-      //System.out.println("  freqIndex=" + freqIndex);
-
-      posIndex.copyFrom(termState.posIndex);
-      //System.out.println("  posIndex=" + posIndex);
-      posSeekPending = true;
-      payloadPending = false;
-
-      payloadFP = termState.payloadFP;
-      skipFP = termState.skipFP;
-      //System.out.println("  skipFP=" + skipFP);
-
-      docFreq = termState.docFreq;
-      count = 0;
-      doc = -1;
-      accum = 0;
-      pendingPosCount = 0;
-      pendingPayloadBytes = 0;
-      skipped = false;
-
-      return this;
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-
-      while(true) {
-        if (count == docFreq) {
-          return doc = NO_MORE_DOCS;
-        }
-
-        count++;
-
-        // TODO: maybe we should do the 1-bit trick for encoding
-        // freq=1 case?
-
-        // Decode next doc
-        //System.out.println("  sep d&p read doc");
-        accum += docReader.next();
-
-        //System.out.println("  sep d&p read freq");
-        freq = freqReader.next();
-
-        pendingPosCount += freq;
-
-        if (liveDocs == null || liveDocs.get(accum)) {
-          break;
-        }
-      }
-
-      position = 0;
-      return (doc = accum);
-    }
-
-    @Override
-    public int freq() throws IOException {
-      return freq;
-    }
-
-    @Override
-    public int docID() {
-      return doc;
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      //System.out.println("SepD&P advance target=" + target + " vs current=" + doc + " this=" + this);
-
-      if ((target - skipInterval) >= doc && docFreq >= skipMinimum) {
-
-        // There are enough docs in the posting to have
-        // skip data, and its not too close
-
-        if (skipper == null) {
-          //System.out.println("  create skipper");
-          // This DocsEnum has never done any skipping
-          skipper = new SepSkipListReader(skipIn.clone(),
-                                          freqIn,
-                                          docIn,
-                                          posIn,
-                                          maxSkipLevels, skipInterval);
-        }
-
-        if (!skipped) {
-          //System.out.println("  init skip data skipFP=" + skipFP);
-          // We haven't yet skipped for this posting
-          skipper.init(skipFP,
-                       docIndex,
-                       freqIndex,
-                       posIndex,
-                       payloadFP,
-                       docFreq,
-                       storePayloads);
-          skipper.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
-          skipped = true;
-        }
-        final int newCount = skipper.skipTo(target); 
-        //System.out.println("  skip newCount=" + newCount + " vs " + count);
-
-        if (newCount > count) {
-
-          // Skipper did move
-          skipper.getFreqIndex().seek(freqReader);
-          skipper.getDocIndex().seek(docReader);
-          //System.out.println("  doc seek'd to " + skipper.getDocIndex());
-          // NOTE: don't seek pos here; do it lazily
-          // instead.  Eg a PhraseQuery may skip to many
-          // docs before finally asking for positions...
-          posIndex.copyFrom(skipper.getPosIndex());
-          posSeekPending = true;
-          count = newCount;
-          doc = accum = skipper.getDoc();
-          //System.out.println("    moved to doc=" + doc);
-          //payloadIn.seek(skipper.getPayloadPointer());
-          payloadFP = skipper.getPayloadPointer();
-          pendingPosCount = 0;
-          pendingPayloadBytes = 0;
-          payloadPending = false;
-          payloadLength = skipper.getPayloadLength();
-          //System.out.println("    move payloadLen=" + payloadLength);
-        }
-      }
-        
-      // Now, linear scan for the rest:
-      do {
-        if (nextDoc() == NO_MORE_DOCS) {
-          //System.out.println("  advance nextDoc=END");
-          return NO_MORE_DOCS;
-        }
-        //System.out.println("  advance nextDoc=" + doc);
-      } while (target > doc);
-
-      //System.out.println("  return doc=" + doc);
-      return doc;
-    }
-
-    @Override
-    public int nextPosition() throws IOException {
-      if (posSeekPending) {
-        posIndex.seek(posReader);
-        payloadIn.seek(payloadFP);
-        posSeekPending = false;
-      }
-
-      // scan over any docs that were iterated without their
-      // positions
-      while (pendingPosCount > freq) {
-        final int code = posReader.next();
-        if (storePayloads && (code & 1) != 0) {
-          // Payload length has changed
-          payloadLength = posReader.next();
-          assert payloadLength >= 0;
-        }
-        pendingPosCount--;
-        position = 0;
-        pendingPayloadBytes += payloadLength;
-      }
-
-      final int code = posReader.next();
-
-      if (storePayloads) {
-        if ((code & 1) != 0) {
-          // Payload length has changed
-          payloadLength = posReader.next();
-          assert payloadLength >= 0;
-        }
-        position += code >>> 1;
-        pendingPayloadBytes += payloadLength;
-        payloadPending = payloadLength > 0;
-      } else {
-        position += code;
-      }
-    
-      pendingPosCount--;
-      assert pendingPosCount >= 0;
-      return position;
-    }
-
-    @Override
-    public int startOffset() {
-      return -1;
-    }
-
-    @Override
-    public int endOffset() {
-      return -1;
-    }
-
-    private BytesRef payload;
-
-    @Override
-    public BytesRef getPayload() throws IOException {
-      if (!payloadPending) {
-        return null;
-      }
-      
-      if (pendingPayloadBytes == 0) {
-        return payload;
-      }
-
-      assert pendingPayloadBytes >= payloadLength;
-
-      if (pendingPayloadBytes > payloadLength) {
-        payloadIn.seek(payloadIn.getFilePointer() + (pendingPayloadBytes - payloadLength));
-      }
-
-      if (payload == null) {
-        payload = new BytesRef();
-        payload.bytes = new byte[payloadLength];
-      } else if (payload.bytes.length < payloadLength) {
-        payload.grow(payloadLength);
-      }
-
-      payloadIn.readBytes(payload.bytes, 0, payloadLength);
-      payload.length = payloadLength;
-      pendingPayloadBytes = 0;
-      return payload;
-    }
-    
-    @Override
-    public long cost() {
-      return docFreq;
-    }
-  }
-
-  @Override
-  public long ramBytesUsed() {
-    return 0;
-  }
-
-  @Override
-  public void checkIntegrity() throws IOException {
-    // TODO: remove sep layout, its fallen behind on features...
-  }
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepPostingsWriter.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepPostingsWriter.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepPostingsWriter.java	(working copy)
@@ -1,366 +0,0 @@
-package org.apache.lucene.codecs.sep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.BlockTermState;
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.PushPostingsWriterBase;
-import org.apache.lucene.index.CorruptIndexException;
-import org.apache.lucene.index.DocsEnum;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.store.DataOutput;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IOUtils;
-
-/** Writes frq to .frq, docs to .doc, pos to .pos, payloads
- *  to .pyl, skip data to .skp
- *
- * @lucene.experimental */
-public final class SepPostingsWriter extends PushPostingsWriterBase {
-  final static String CODEC = "SepPostingsWriter";
-
-  final static String DOC_EXTENSION = "doc";
-  final static String SKIP_EXTENSION = "skp";
-  final static String FREQ_EXTENSION = "frq";
-  final static String POS_EXTENSION = "pos";
-  final static String PAYLOAD_EXTENSION = "pyl";
-
-  // Increment version to change it:
-  final static int VERSION_START = 0;
-  final static int VERSION_CURRENT = VERSION_START;
-
-  IntIndexOutput freqOut;
-  IntIndexOutput.Index freqIndex;
-
-  IntIndexOutput posOut;
-  IntIndexOutput.Index posIndex;
-
-  IntIndexOutput docOut;
-  IntIndexOutput.Index docIndex;
-
-  IndexOutput payloadOut;
-
-  IndexOutput skipOut;
-
-  final SepSkipListWriter skipListWriter;
-  /** Expert: The fraction of TermDocs entries stored in skip tables,
-   * used to accelerate {@link DocsEnum#advance(int)}.  Larger values result in
-   * smaller indexes, greater acceleration, but fewer accelerable cases, while
-   * smaller values result in bigger indexes, less acceleration and more
-   * accelerable cases. More detailed experiments would be useful here. */
-  final int skipInterval;
-  static final int DEFAULT_SKIP_INTERVAL = 16;
-  
-  /**
-   * Expert: minimum docFreq to write any skip data at all
-   */
-  final int skipMinimum;
-
-  /** Expert: The maximum number of skip levels. Smaller values result in 
-   * slightly smaller indexes, but slower skipping in big posting lists.
-   */
-  final int maxSkipLevels = 10;
-
-  final int totalNumDocs;
-
-  IndexOptions indexOptions;
-
-  int lastPayloadLength;
-  int lastPosition;
-  long payloadStart;
-  int lastDocID;
-  int df;
-
-  SepTermState lastState;
-  long lastPayloadFP;
-  long lastSkipFP;
-
-  public SepPostingsWriter(SegmentWriteState state, IntStreamFactory factory) throws IOException {
-    this(state, factory, DEFAULT_SKIP_INTERVAL);
-  }
-
-  public SepPostingsWriter(SegmentWriteState state, IntStreamFactory factory, int skipInterval) throws IOException {
-    freqOut = null;
-    freqIndex = null;
-    posOut = null;
-    posIndex = null;
-    payloadOut = null;
-    boolean success = false;
-    try {
-      this.skipInterval = skipInterval;
-      this.skipMinimum = skipInterval; /* set to the same for now */
-      final String docFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, DOC_EXTENSION);
-
-      docOut = factory.createOutput(state.directory, docFileName, state.context);
-      docIndex = docOut.index();
-
-      if (state.fieldInfos.hasFreq()) {
-        final String frqFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, FREQ_EXTENSION);
-        freqOut = factory.createOutput(state.directory, frqFileName, state.context);
-        freqIndex = freqOut.index();
-      }
-
-      if (state.fieldInfos.hasProx()) {      
-        final String posFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, POS_EXTENSION);
-        posOut = factory.createOutput(state.directory, posFileName, state.context);
-        posIndex = posOut.index();
-        
-        // TODO: -- only if at least one field stores payloads?
-        final String payloadFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, PAYLOAD_EXTENSION);
-        payloadOut = state.directory.createOutput(payloadFileName, state.context);
-      }
-
-      final String skipFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, SKIP_EXTENSION);
-      skipOut = state.directory.createOutput(skipFileName, state.context);
-      
-      totalNumDocs = state.segmentInfo.getDocCount();
-      
-      skipListWriter = new SepSkipListWriter(skipInterval,
-          maxSkipLevels,
-          totalNumDocs,
-          freqOut, docOut,
-          posOut, payloadOut);
-      
-      success = true;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(docOut, skipOut, freqOut, posOut, payloadOut);
-      }
-    }
-  }
-
-  @Override
-  public void init(IndexOutput termsOut) throws IOException {
-    CodecUtil.writeHeader(termsOut, CODEC, VERSION_CURRENT);
-    // TODO: -- just ask skipper to "start" here
-    termsOut.writeInt(skipInterval);                // write skipInterval
-    termsOut.writeInt(maxSkipLevels);               // write maxSkipLevels
-    termsOut.writeInt(skipMinimum);                 // write skipMinimum
-  }
-
-  @Override
-  public BlockTermState newTermState() {
-    return new SepTermState();
-  }
-
-  @Override
-  public void startTerm() throws IOException {
-    docIndex.mark();
-    //System.out.println("SEPW: startTerm docIndex=" + docIndex);
-
-    if (indexOptions != IndexOptions.DOCS_ONLY) {
-      freqIndex.mark();
-    }
-    
-    if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {
-      posIndex.mark();
-      payloadStart = payloadOut.getFilePointer();
-      lastPayloadLength = -1;
-    }
-
-    skipListWriter.resetSkip(docIndex, freqIndex, posIndex);
-  }
-
-  // Currently, this instance is re-used across fields, so
-  // our parent calls setField whenever the field changes
-  @Override
-  public int setField(FieldInfo fieldInfo) {
-    super.setField(fieldInfo);
-    this.indexOptions = fieldInfo.getIndexOptions();
-    if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0) {
-      throw new UnsupportedOperationException("this codec cannot index offsets");
-    }
-    skipListWriter.setIndexOptions(indexOptions);
-    lastPayloadFP = 0;
-    lastSkipFP = 0;
-    lastState = setEmptyState();
-    return 0;
-  }
-
-  private SepTermState setEmptyState() {
-    SepTermState emptyState = new SepTermState();
-    emptyState.docIndex = docOut.index();
-    if (indexOptions != IndexOptions.DOCS_ONLY) {
-      emptyState.freqIndex = freqOut.index();
-      if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {
-        emptyState.posIndex = posOut.index();
-      }
-    }
-    emptyState.payloadFP = 0;
-    emptyState.skipFP = 0;
-    return emptyState;
-  }
-
-  /** Adds a new doc in this term.  If this returns null
-   *  then we just skip consuming positions/payloads. */
-  @Override
-  public void startDoc(int docID, int termDocFreq) throws IOException {
-
-    final int delta = docID - lastDocID;
-    //System.out.println("SEPW: startDoc: write doc=" + docID + " delta=" + delta + " out.fp=" + docOut);
-
-    if (docID < 0 || (df > 0 && delta <= 0)) {
-      throw new CorruptIndexException("docs out of order (" + docID + " <= " + lastDocID + " ) (docOut: " + docOut + ")");
-    }
-
-    if ((++df % skipInterval) == 0) {
-      // TODO: -- awkward we have to make these two
-      // separate calls to skipper
-      //System.out.println("    buffer skip lastDocID=" + lastDocID);
-      skipListWriter.setSkipData(lastDocID, writePayloads, lastPayloadLength);
-      skipListWriter.bufferSkip(df);
-    }
-
-    lastDocID = docID;
-    docOut.write(delta);
-    if (indexOptions != IndexOptions.DOCS_ONLY) {
-      //System.out.println("    sepw startDoc: write freq=" + termDocFreq);
-      freqOut.write(termDocFreq);
-    }
-  }
-
-  /** Add a new position & payload */
-  @Override
-  public void addPosition(int position, BytesRef payload, int startOffset, int endOffset) throws IOException {
-    assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
-
-    final int delta = position - lastPosition;
-    assert delta >= 0: "position=" + position + " lastPosition=" + lastPosition;            // not quite right (if pos=0 is repeated twice we don't catch it)
-    lastPosition = position;
-
-    if (writePayloads) {
-      final int payloadLength = payload == null ? 0 : payload.length;
-      if (payloadLength != lastPayloadLength) {
-        lastPayloadLength = payloadLength;
-        // TODO: explore whether we get better compression
-        // by not storing payloadLength into prox stream?
-        posOut.write((delta<<1)|1);
-        posOut.write(payloadLength);
-      } else {
-        posOut.write(delta << 1);
-      }
-
-      if (payloadLength > 0) {
-        payloadOut.writeBytes(payload.bytes, payload.offset, payloadLength);
-      }
-    } else {
-      posOut.write(delta);
-    }
-
-    lastPosition = position;
-  }
-
-  /** Called when we are done adding positions & payloads */
-  @Override
-  public void finishDoc() {       
-    lastPosition = 0;
-  }
-
-  private static class SepTermState extends BlockTermState {
-    public IntIndexOutput.Index docIndex;
-    public IntIndexOutput.Index freqIndex;
-    public IntIndexOutput.Index posIndex;
-    public long payloadFP;
-    public long skipFP;
-  }
-
-  /** Called when we are done adding docs to this term */
-  @Override
-  public void finishTerm(BlockTermState _state) throws IOException {
-    SepTermState state = (SepTermState)_state;
-    // TODO: -- wasteful we are counting this in two places?
-    assert state.docFreq > 0;
-    assert state.docFreq == df;
-
-    state.docIndex = docOut.index();
-    state.docIndex.copyFrom(docIndex, false);
-    if (indexOptions != IndexOptions.DOCS_ONLY) {
-      state.freqIndex = freqOut.index();
-      state.freqIndex.copyFrom(freqIndex, false);
-      if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {
-        state.posIndex = posOut.index();
-        state.posIndex.copyFrom(posIndex, false);
-      } else {
-        state.posIndex = null;
-      }
-    } else {
-      state.freqIndex = null;
-      state.posIndex = null;
-    }
-
-    if (df >= skipMinimum) {
-      state.skipFP = skipOut.getFilePointer();
-      //System.out.println("  skipFP=" + skipFP);
-      skipListWriter.writeSkip(skipOut);
-      //System.out.println("    numBytes=" + (skipOut.getFilePointer()-skipFP));
-    } else {
-      state.skipFP = -1;
-    }
-    state.payloadFP = payloadStart;
-
-    lastDocID = 0;
-    df = 0;
-  }
-
-  @Override
-  public void encodeTerm(long[] longs, DataOutput out, FieldInfo fieldInfo, BlockTermState _state, boolean absolute) throws IOException {
-    SepTermState state = (SepTermState)_state;
-    if (absolute) {
-      lastSkipFP = 0;
-      lastPayloadFP = 0;
-      lastState = state;
-    }
-    lastState.docIndex.copyFrom(state.docIndex, false);
-    lastState.docIndex.write(out, absolute);
-    if (indexOptions != IndexOptions.DOCS_ONLY) {
-      lastState.freqIndex.copyFrom(state.freqIndex, false);
-      lastState.freqIndex.write(out, absolute);
-      if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {
-        lastState.posIndex.copyFrom(state.posIndex, false);
-        lastState.posIndex.write(out, absolute);
-        if (writePayloads) {
-          if (absolute) {
-            out.writeVLong(state.payloadFP);
-          } else {
-            out.writeVLong(state.payloadFP - lastPayloadFP);
-          }
-          lastPayloadFP = state.payloadFP;
-        }
-      }
-    }
-    if (state.skipFP != -1) {
-      if (absolute) {
-        out.writeVLong(state.skipFP);
-      } else {
-        out.writeVLong(state.skipFP - lastSkipFP);
-      }
-      lastSkipFP = state.skipFP;
-    }
-  }
-
-  @Override
-  public void close() throws IOException {
-    IOUtils.close(docOut, skipOut, freqOut, posOut, payloadOut);
-  }
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepSkipListReader.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepSkipListReader.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepSkipListReader.java	(working copy)
@@ -1,209 +0,0 @@
-package org.apache.lucene.codecs.sep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.codecs.MultiLevelSkipListReader;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-
-/**
- * Implements the skip list reader for the default posting list format
- * that stores positions and payloads.
- *
- * @lucene.experimental
- */
-
-// TODO: rewrite this as recursive classes?
-class SepSkipListReader extends MultiLevelSkipListReader {
-  private boolean currentFieldStoresPayloads;
-  private IntIndexInput.Index freqIndex[];
-  private IntIndexInput.Index docIndex[];
-  private IntIndexInput.Index posIndex[];
-  private long payloadPointer[];
-  private int payloadLength[];
-
-  private final IntIndexInput.Index lastFreqIndex;
-  private final IntIndexInput.Index lastDocIndex;
-  // TODO: -- make private again
-  final IntIndexInput.Index lastPosIndex;
-  
-  private long lastPayloadPointer;
-  private int lastPayloadLength;
-                           
-  SepSkipListReader(IndexInput skipStream,
-                    IntIndexInput freqIn,
-                    IntIndexInput docIn,
-                    IntIndexInput posIn,
-                    int maxSkipLevels,
-                    int skipInterval)
-    throws IOException {
-    super(skipStream, maxSkipLevels, skipInterval);
-    if (freqIn != null) {
-      freqIndex = new IntIndexInput.Index[maxSkipLevels];
-    }
-    docIndex = new IntIndexInput.Index[maxSkipLevels];
-    if (posIn != null) {
-      posIndex = new IntIndexInput.Index[maxNumberOfSkipLevels];
-    }
-    for(int i=0;i<maxSkipLevels;i++) {
-      if (freqIn != null) {
-        freqIndex[i] = freqIn.index();
-      }
-      docIndex[i] = docIn.index();
-      if (posIn != null) {
-        posIndex[i] = posIn.index();
-      }
-    }
-    payloadPointer = new long[maxSkipLevels];
-    payloadLength = new int[maxSkipLevels];
-
-    if (freqIn != null) {
-      lastFreqIndex = freqIn.index();
-    } else {
-      lastFreqIndex = null;
-    }
-    lastDocIndex = docIn.index();
-    if (posIn != null) {
-      lastPosIndex = posIn.index();
-    } else {
-      lastPosIndex = null;
-    }
-  }
-  
-  IndexOptions indexOptions;
-
-  void setIndexOptions(IndexOptions v) {
-    indexOptions = v;
-  }
-
-  void init(long skipPointer,
-            IntIndexInput.Index docBaseIndex,
-            IntIndexInput.Index freqBaseIndex,
-            IntIndexInput.Index posBaseIndex,
-            long payloadBasePointer,
-            int df,
-            boolean storesPayloads) {
-
-    super.init(skipPointer, df);
-    this.currentFieldStoresPayloads = storesPayloads;
-
-    lastPayloadPointer = payloadBasePointer;
-
-    for(int i=0;i<maxNumberOfSkipLevels;i++) {
-      docIndex[i].copyFrom(docBaseIndex);
-      if (freqIndex != null) {
-        freqIndex[i].copyFrom(freqBaseIndex);
-      }
-      if (posBaseIndex != null) {
-        posIndex[i].copyFrom(posBaseIndex);
-      }
-    }
-    Arrays.fill(payloadPointer, payloadBasePointer);
-    Arrays.fill(payloadLength, 0);
-  }
-
-  long getPayloadPointer() {
-    return lastPayloadPointer;
-  }
-  
-  /** Returns the payload length of the payload stored just before 
-   * the doc to which the last call of {@link MultiLevelSkipListReader#skipTo(int)} 
-   * has skipped.  */
-  int getPayloadLength() {
-    return lastPayloadLength;
-  }
-  
-  @Override
-  protected void seekChild(int level) throws IOException {
-    super.seekChild(level);
-    payloadPointer[level] = lastPayloadPointer;
-    payloadLength[level] = lastPayloadLength;
-  }
-  
-  @Override
-  protected void setLastSkipData(int level) {
-    super.setLastSkipData(level);
-
-    lastPayloadPointer = payloadPointer[level];
-    lastPayloadLength = payloadLength[level];
-    if (freqIndex != null) {
-      lastFreqIndex.copyFrom(freqIndex[level]);
-    }
-    lastDocIndex.copyFrom(docIndex[level]);
-    if (lastPosIndex != null) {
-      lastPosIndex.copyFrom(posIndex[level]);
-    }
-
-    if (level > 0) {
-      if (freqIndex != null) {
-        freqIndex[level-1].copyFrom(freqIndex[level]);
-      }
-      docIndex[level-1].copyFrom(docIndex[level]);
-      if (posIndex != null) {
-        posIndex[level-1].copyFrom(posIndex[level]);
-      }
-    }
-  }
-
-  IntIndexInput.Index getFreqIndex() {
-    return lastFreqIndex;
-  }
-
-  IntIndexInput.Index getPosIndex() {
-    return lastPosIndex;
-  }
-
-  IntIndexInput.Index getDocIndex() {
-    return lastDocIndex;
-  }
-
-  @Override
-  protected int readSkipData(int level, IndexInput skipStream) throws IOException {
-    int delta;
-    assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS || !currentFieldStoresPayloads;
-    if (currentFieldStoresPayloads) {
-      // the current field stores payloads.
-      // if the doc delta is odd then we have
-      // to read the current payload length
-      // because it differs from the length of the
-      // previous payload
-      delta = skipStream.readVInt();
-      if ((delta & 1) != 0) {
-        payloadLength[level] = skipStream.readVInt();
-      }
-      delta >>>= 1;
-    } else {
-      delta = skipStream.readVInt();
-    }
-    if (indexOptions != IndexOptions.DOCS_ONLY) {
-      freqIndex[level].read(skipStream, false);
-    }
-    docIndex[level].read(skipStream, false);
-    if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {
-      posIndex[level].read(skipStream, false);
-      if (currentFieldStoresPayloads) {
-        payloadPointer[level] += skipStream.readVInt();
-      }
-    }
-    
-    return delta;
-  }
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepSkipListWriter.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepSkipListWriter.java	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/sep/SepSkipListWriter.java	(working copy)
@@ -1,200 +0,0 @@
-package org.apache.lucene.codecs.sep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.codecs.MultiLevelSkipListWriter;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-
-// TODO: -- skip data should somehow be more local to the
-// particular stream (doc, freq, pos, payload)
-
-/**
- * Implements the skip list writer for the default posting list format
- * that stores positions and payloads.
- *
- * @lucene.experimental
- */
-class SepSkipListWriter extends MultiLevelSkipListWriter {
-  private int[] lastSkipDoc;
-  private int[] lastSkipPayloadLength;
-  private long[] lastSkipPayloadPointer;
-
-  private IntIndexOutput.Index[] docIndex;
-  private IntIndexOutput.Index[] freqIndex;
-  private IntIndexOutput.Index[] posIndex;
-  
-  private IntIndexOutput freqOutput;
-  // TODO: -- private again
-  IntIndexOutput posOutput;
-  // TODO: -- private again
-  IndexOutput payloadOutput;
-
-  private int curDoc;
-  private boolean curStorePayloads;
-  private int curPayloadLength;
-  private long curPayloadPointer;
-  
-  SepSkipListWriter(int skipInterval, int numberOfSkipLevels, int docCount,
-                    IntIndexOutput freqOutput,
-                    IntIndexOutput docOutput,
-                    IntIndexOutput posOutput,
-                    IndexOutput payloadOutput)
-    throws IOException {
-    super(skipInterval, numberOfSkipLevels, docCount);
-
-    this.freqOutput = freqOutput;
-    this.posOutput = posOutput;
-    this.payloadOutput = payloadOutput;
-    
-    lastSkipDoc = new int[numberOfSkipLevels];
-    lastSkipPayloadLength = new int[numberOfSkipLevels];
-    // TODO: -- also cutover normal IndexOutput to use getIndex()?
-    lastSkipPayloadPointer = new long[numberOfSkipLevels];
-
-    freqIndex = new IntIndexOutput.Index[numberOfSkipLevels];
-    docIndex = new IntIndexOutput.Index[numberOfSkipLevels];
-    posIndex = new IntIndexOutput.Index[numberOfSkipLevels];
-
-    for(int i=0;i<numberOfSkipLevels;i++) {
-      if (freqOutput != null) {
-        freqIndex[i] = freqOutput.index();
-      }
-      docIndex[i] = docOutput.index();
-      if (posOutput != null) {
-        posIndex[i] = posOutput.index();
-      }
-    }
-  }
-
-  IndexOptions indexOptions;
-
-  void setIndexOptions(IndexOptions v) {
-    indexOptions = v;
-  }
-
-  void setPosOutput(IntIndexOutput posOutput) throws IOException {
-    this.posOutput = posOutput;
-    for(int i=0;i<numberOfSkipLevels;i++) {
-      posIndex[i] = posOutput.index();
-    }
-  }
-
-  void setPayloadOutput(IndexOutput payloadOutput) {
-    this.payloadOutput = payloadOutput;
-  }
-
-  /**
-   * Sets the values for the current skip data. 
-   */
-  // Called @ every index interval (every 128th (by default)
-  // doc)
-  void setSkipData(int doc, boolean storePayloads, int payloadLength) {
-    this.curDoc = doc;
-    this.curStorePayloads = storePayloads;
-    this.curPayloadLength = payloadLength;
-    if (payloadOutput != null) {
-      this.curPayloadPointer = payloadOutput.getFilePointer();
-    }
-  }
-
-  // Called @ start of new term
-  protected void resetSkip(IntIndexOutput.Index topDocIndex, IntIndexOutput.Index topFreqIndex, IntIndexOutput.Index topPosIndex)
-    throws IOException {
-    super.resetSkip();
-
-    Arrays.fill(lastSkipDoc, 0);
-    Arrays.fill(lastSkipPayloadLength, -1);  // we don't have to write the first length in the skip list
-    for(int i=0;i<numberOfSkipLevels;i++) {
-      docIndex[i].copyFrom(topDocIndex, true);
-      if (freqOutput != null) {
-        freqIndex[i].copyFrom(topFreqIndex, true);
-      }
-      if (posOutput != null) {
-        posIndex[i].copyFrom(topPosIndex, true);
-      }
-    }
-    if (payloadOutput != null) {
-      Arrays.fill(lastSkipPayloadPointer, payloadOutput.getFilePointer());
-    }
-  }
-  
-  @Override
-  protected void writeSkipData(int level, IndexOutput skipBuffer) throws IOException {
-    // To efficiently store payloads in the posting lists we do not store the length of
-    // every payload. Instead we omit the length for a payload if the previous payload had
-    // the same length.
-    // However, in order to support skipping the payload length at every skip point must be known.
-    // So we use the same length encoding that we use for the posting lists for the skip data as well:
-    // Case 1: current field does not store payloads
-    //           SkipDatum                 --> DocSkip, FreqSkip, ProxSkip
-    //           DocSkip,FreqSkip,ProxSkip --> VInt
-    //           DocSkip records the document number before every SkipInterval th  document in TermFreqs. 
-    //           Document numbers are represented as differences from the previous value in the sequence.
-    // Case 2: current field stores payloads
-    //           SkipDatum                 --> DocSkip, PayloadLength?, FreqSkip,ProxSkip
-    //           DocSkip,FreqSkip,ProxSkip --> VInt
-    //           PayloadLength             --> VInt    
-    //         In this case DocSkip/2 is the difference between
-    //         the current and the previous value. If DocSkip
-    //         is odd, then a PayloadLength encoded as VInt follows,
-    //         if DocSkip is even, then it is assumed that the
-    //         current payload length equals the length at the previous
-    //         skip point
-
-    assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS || !curStorePayloads;
-
-    if (curStorePayloads) {
-      int delta = curDoc - lastSkipDoc[level];
-      if (curPayloadLength == lastSkipPayloadLength[level]) {
-        // the current payload length equals the length at the previous skip point,
-        // so we don't store the length again
-        skipBuffer.writeVInt(delta << 1);
-      } else {
-        // the payload length is different from the previous one. We shift the DocSkip, 
-        // set the lowest bit and store the current payload length as VInt.
-        skipBuffer.writeVInt(delta << 1 | 1);
-        skipBuffer.writeVInt(curPayloadLength);
-        lastSkipPayloadLength[level] = curPayloadLength;
-      }
-    } else {
-      // current field does not store payloads
-      skipBuffer.writeVInt(curDoc - lastSkipDoc[level]);
-    }
-
-    if (indexOptions != IndexOptions.DOCS_ONLY) {
-      freqIndex[level].mark();
-      freqIndex[level].write(skipBuffer, false);
-    }
-    docIndex[level].mark();
-    docIndex[level].write(skipBuffer, false);
-    if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {
-      posIndex[level].mark();
-      posIndex[level].write(skipBuffer, false);
-      if (curStorePayloads) {
-        skipBuffer.writeVInt((int) (curPayloadPointer - lastSkipPayloadPointer[level]));
-      }
-    }
-
-    lastSkipDoc[level] = curDoc;
-    lastSkipPayloadPointer[level] = curPayloadPointer;
-  }
-}
Index: lucene/codecs/src/java/org/apache/lucene/codecs/sep/package.html
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/sep/package.html	(revision 1584122)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/sep/package.html	(working copy)
@@ -1,25 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-Sep: base support for separate files (doc,frq,pos,skp,pyl)
-</body>
-</html>
Index: lucene/codecs/src/test/org/apache/lucene/codecs/intblock/TestFixedIntBlockPostingsFormat.java
===================================================================
--- lucene/codecs/src/test/org/apache/lucene/codecs/intblock/TestFixedIntBlockPostingsFormat.java	(revision 1584122)
+++ lucene/codecs/src/test/org/apache/lucene/codecs/intblock/TestFixedIntBlockPostingsFormat.java	(working copy)
@@ -1,36 +0,0 @@
-package org.apache.lucene.codecs.intblock;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.mockintblock.MockFixedIntBlockPostingsFormat;
-import org.apache.lucene.index.BasePostingsFormatTestCase;
-import org.apache.lucene.util.TestUtil;
-
-/**
- * Basic tests for FixedIntBlock
- */
-public class TestFixedIntBlockPostingsFormat extends BasePostingsFormatTestCase {
-  // TODO: randomize blocksize
-  private final Codec codec = TestUtil.alwaysPostingsFormat(new MockFixedIntBlockPostingsFormat());
-
-  @Override
-  protected Codec getCodec() {
-    return codec;
-  }
-}
Index: lucene/codecs/src/test/org/apache/lucene/codecs/intblock/TestIntBlockCodec.java
===================================================================
--- lucene/codecs/src/test/org/apache/lucene/codecs/intblock/TestIntBlockCodec.java	(revision 1584122)
+++ lucene/codecs/src/test/org/apache/lucene/codecs/intblock/TestIntBlockCodec.java	(working copy)
@@ -1,64 +0,0 @@
-package org.apache.lucene.codecs.intblock;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.store.*;
-import org.apache.lucene.codecs.mockintblock.*;
-import org.apache.lucene.codecs.sep.*;
-
-public class TestIntBlockCodec extends LuceneTestCase {
-
-  public void testSimpleIntBlocks() throws Exception {
-    Directory dir = newDirectory();
-
-    IntStreamFactory f = new MockFixedIntBlockPostingsFormat(128).getIntFactory();
-
-    IntIndexOutput out = f.createOutput(dir, "test", newIOContext(random()));
-    for(int i=0;i<11777;i++) {
-      out.write(i);
-    }
-    out.close();
-
-    IntIndexInput in = f.openInput(dir, "test", newIOContext(random()));
-    IntIndexInput.Reader r = in.reader();
-
-    for(int i=0;i<11777;i++) {
-      assertEquals(i, r.next());
-    }
-    in.close();
-    
-    dir.close();
-  }
-
-  public void testEmptySimpleIntBlocks() throws Exception {
-    Directory dir = newDirectory();
-
-    IntStreamFactory f = new MockFixedIntBlockPostingsFormat(128).getIntFactory();
-    IntIndexOutput out = f.createOutput(dir, "test", newIOContext(random()));
-
-    // write no ints
-    out.close();
-
-    IntIndexInput in = f.openInput(dir, "test", newIOContext(random()));
-    in.reader();
-    // read no ints
-    in.close();
-    dir.close();
-  }
-}
Index: lucene/codecs/src/test/org/apache/lucene/codecs/intblock/TestVariableIntBlockPostingsFormat.java
===================================================================
--- lucene/codecs/src/test/org/apache/lucene/codecs/intblock/TestVariableIntBlockPostingsFormat.java	(revision 1584122)
+++ lucene/codecs/src/test/org/apache/lucene/codecs/intblock/TestVariableIntBlockPostingsFormat.java	(working copy)
@@ -1,37 +0,0 @@
-package org.apache.lucene.codecs.intblock;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.mockintblock.MockVariableIntBlockPostingsFormat;
-import org.apache.lucene.index.BasePostingsFormatTestCase;
-import org.apache.lucene.util.TestUtil;
-import org.apache.lucene.util.TestUtil;
-
-/**
- * Basic tests for VariableIntBlock
- */
-public class TestVariableIntBlockPostingsFormat extends BasePostingsFormatTestCase {
-  // TODO: randomize blocksize
-  private final Codec codec = TestUtil.alwaysPostingsFormat(new MockVariableIntBlockPostingsFormat());
-
-  @Override
-  protected Codec getCodec() {
-    return codec;
-  }
-}
Index: lucene/codecs/src/test/org/apache/lucene/codecs/sep/TestSepPostingsFormat.java
===================================================================
--- lucene/codecs/src/test/org/apache/lucene/codecs/sep/TestSepPostingsFormat.java	(revision 1584122)
+++ lucene/codecs/src/test/org/apache/lucene/codecs/sep/TestSepPostingsFormat.java	(working copy)
@@ -1,36 +0,0 @@
-package org.apache.lucene.codecs.sep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.mocksep.MockSepPostingsFormat;
-import org.apache.lucene.index.BasePostingsFormatTestCase;
-import org.apache.lucene.util.TestUtil;
-
-/**
- * Tests sep layout
- */
-public class TestSepPostingsFormat extends BasePostingsFormatTestCase {
-  // TODO: randomize cutoff
-  private final Codec codec = TestUtil.alwaysPostingsFormat(new MockSepPostingsFormat());
-
-  @Override
-  protected Codec getCodec() {
-    return codec;
-  }
-}
Index: lucene/core/src/test/org/apache/lucene/codecs/perfield/TestPerFieldPostingsFormat2.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/perfield/TestPerFieldPostingsFormat2.java	(revision 1584122)
+++ lucene/core/src/test/org/apache/lucene/codecs/perfield/TestPerFieldPostingsFormat2.java	(working copy)
@@ -23,7 +23,7 @@
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.lucene41.Lucene41PostingsFormat;
 import org.apache.lucene.codecs.lucene46.Lucene46Codec;
-import org.apache.lucene.codecs.mocksep.MockSepPostingsFormat;
+import org.apache.lucene.codecs.memory.MemoryPostingsFormat;
 import org.apache.lucene.codecs.pulsing.Pulsing41PostingsFormat;
 import org.apache.lucene.codecs.simpletext.SimpleTextPostingsFormat;
 import org.apache.lucene.document.Document;
@@ -44,7 +44,6 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
-import org.apache.lucene.util.TestUtil;
 import org.junit.Test;
 
 /**
@@ -204,7 +203,7 @@
   public static class MockCodec extends Lucene46Codec {
     final PostingsFormat lucene40 = new Lucene41PostingsFormat();
     final PostingsFormat simpleText = new SimpleTextPostingsFormat();
-    final PostingsFormat mockSep = new MockSepPostingsFormat();
+    final PostingsFormat memory = new MemoryPostingsFormat();
     
     @Override
     public PostingsFormat getPostingsFormatForField(String field) {
@@ -211,7 +210,7 @@
       if (field.equals("id")) {
         return simpleText;
       } else if (field.equals("content")) {
-        return mockSep;
+        return memory;
       } else {
         return lucene40;
       }
Index: lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java	(revision 1584122)
+++ lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java	(working copy)
@@ -1064,7 +1064,7 @@
   private static final class CustomPerFieldCodec extends Lucene46Codec {
     private final PostingsFormat simpleTextFormat = PostingsFormat.forName("SimpleText");
     private final PostingsFormat defaultFormat = PostingsFormat.forName("Lucene41");
-    private final PostingsFormat mockSepFormat = PostingsFormat.forName("MockSep");
+    private final PostingsFormat memoryFormat = PostingsFormat.forName("Memory");
 
     @Override
     public PostingsFormat getPostingsFormatForField(String field) {
@@ -1071,7 +1071,7 @@
       if (field.equals("id")) {
         return simpleTextFormat;
       } else if (field.equals("content")) {
-        return mockSepFormat;
+        return memoryFormat;
       } else {
         return defaultFormat;
       }
Index: lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java	(revision 1584122)
+++ lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java	(working copy)
@@ -77,7 +77,7 @@
 // we won't even be running the actual code, only the impostor
 // @SuppressCodecs("Lucene4x")
 // Sep codec cannot yet handle the offsets in our 4.x index!
-@SuppressCodecs({"MockFixedIntBlock", "MockVariableIntBlock", "MockSep", "MockRandom", "Lucene40", "Lucene41", "Lucene42", "Lucene45"})
+@SuppressCodecs({"Lucene40", "Lucene41", "Lucene42", "Lucene45"})
 public class TestBackwardsCompatibility extends LuceneTestCase {
 
   // Uncomment these cases & run them on an older Lucene version,
Index: lucene/core/src/test/org/apache/lucene/index/TestBagOfPositions.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestBagOfPositions.java	(revision 1584122)
+++ lucene/core/src/test/org/apache/lucene/index/TestBagOfPositions.java	(working copy)
@@ -87,7 +87,7 @@
     if (options == 0) {
       fieldType.setIndexOptions(IndexOptions.DOCS_AND_FREQS); // we dont actually need positions
       fieldType.setStoreTermVectors(true); // but enforce term vectors when we do this so we check SOMETHING
-    } else if (options == 1 && !doesntSupportOffsets.contains(TestUtil.getPostingsFormat("field"))) {
+    } else if (options == 1) {
       fieldType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
     }
     // else just positions
Index: lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestCodecs.java	(revision 1584122)
+++ lucene/core/src/test/org/apache/lucene/index/TestCodecs.java	(working copy)
@@ -29,7 +29,6 @@
 import org.apache.lucene.codecs.lucene40.Lucene40RWCodec;
 import org.apache.lucene.codecs.lucene41.Lucene41RWCodec;
 import org.apache.lucene.codecs.lucene42.Lucene42RWCodec;
-import org.apache.lucene.codecs.mocksep.MockSepPostingsFormat;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field.Store;
 import org.apache.lucene.document.FieldType;
@@ -336,54 +335,6 @@
     dir.close();
   }
 
-  public void testSepPositionAfterMerge() throws IOException {
-    final Directory dir = newDirectory();
-    final IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,
-      new MockAnalyzer(random()));
-    config.setMergePolicy(newLogMergePolicy());
-    config.setCodec(TestUtil.alwaysPostingsFormat(new MockSepPostingsFormat()));
-    final IndexWriter writer = new IndexWriter(dir, config);
-
-    try {
-      final PhraseQuery pq = new PhraseQuery();
-      pq.add(new Term("content", "bbb"));
-      pq.add(new Term("content", "ccc"));
-
-      final Document doc = new Document();
-      FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);
-      customType.setOmitNorms(true);
-      doc.add(newField("content", "aaa bbb ccc ddd", customType));
-
-      // add document and force commit for creating a first segment
-      writer.addDocument(doc);
-      writer.commit();
-
-      ScoreDoc[] results = this.search(writer, pq, 5);
-      assertEquals(1, results.length);
-      assertEquals(0, results[0].doc);
-
-      // add document and force commit for creating a second segment
-      writer.addDocument(doc);
-      writer.commit();
-
-      // at this point, there should be at least two segments
-      results = this.search(writer, pq, 5);
-      assertEquals(2, results.length);
-      assertEquals(0, results[0].doc);
-
-      writer.forceMerge(1);
-
-      // optimise to merge the segments.
-      results = this.search(writer, pq, 5);
-      assertEquals(2, results.length);
-      assertEquals(0, results[0].doc);
-    }
-    finally {
-      writer.close();
-      dir.close();
-    }
-  }
-
   private ScoreDoc[] search(final IndexWriter writer, final Query q, final int n) throws IOException {
     final IndexReader reader = writer.getReader();
     final IndexSearcher searcher = newSearcher(reader);
Index: lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets.java	(revision 1584122)
+++ lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets.java	(working copy)
@@ -43,13 +43,11 @@
 import org.apache.lucene.util.English;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.TestUtil;
 
 // TODO: we really need to test indexingoffsets, but then getting only docs / docs + freqs.
 // not all codecs store prx separate...
 // TODO: fix sep codec to index offsets so we can greatly reduce this list!
-@SuppressCodecs({"MockFixedIntBlock", "MockVariableIntBlock", "MockSep", "MockRandom"})
 public class TestPostingsOffsets extends LuceneTestCase {
   IndexWriterConfig iwc;
   
Index: lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java
===================================================================
--- lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java	(revision 1584122)
+++ lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java	(working copy)
@@ -51,13 +51,11 @@
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 
 /** 
  * Some tests that override {@link PostingsHighlighter#getIndexAnalyzer} to
  * highlight wilcard, fuzzy, etc queries.
  */
-@SuppressCodecs({"MockFixedIntBlock", "MockVariableIntBlock", "MockSep", "MockRandom"})
 public class TestMultiTermHighlighting extends LuceneTestCase {
   
   public void testWildcards() throws Exception {
Index: lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestPostingsHighlighter.java
===================================================================
--- lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestPostingsHighlighter.java	(revision 1584122)
+++ lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestPostingsHighlighter.java	(working copy)
@@ -49,10 +49,8 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 
-@SuppressCodecs({"MockFixedIntBlock", "MockVariableIntBlock", "MockSep", "MockRandom"})
 public class TestPostingsHighlighter extends LuceneTestCase {
   
   public void testBasics() throws Exception {
Index: lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestPostingsHighlighterRanking.java
===================================================================
--- lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestPostingsHighlighterRanking.java	(revision 1584122)
+++ lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestPostingsHighlighterRanking.java	(working copy)
@@ -43,10 +43,8 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.TestUtil;
 
-@SuppressCodecs({"MockFixedIntBlock", "MockVariableIntBlock", "MockSep", "MockRandom"})
 public class TestPostingsHighlighterRanking extends LuceneTestCase {
   /** 
    * indexes a bunch of gibberish, and then highlights top(n).
Index: lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase.java
===================================================================
--- lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase.java	(revision 1584122)
+++ lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase.java	(working copy)
@@ -172,12 +172,7 @@
     doc.add(new StringField(ID_FIELD, Integer.toString(id), Store.YES));
     doc.add(new StringField(DOCS_ENUM_FIELD, DOCS_ENUM_TERM, Store.NO));
     positions.setId(id);
-    if (doesntSupportOffsets.contains(TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {
-      // codec doesnt support offsets: just index positions for the field
-      doc.add(new Field(DOC_POSITIONS_FIELD, positions, TextField.TYPE_NOT_STORED));
-    } else {
-      doc.add(new Field(DOC_POSITIONS_FIELD, positions, POSITIONS_TYPE));
-    }
+    doc.add(new Field(DOC_POSITIONS_FIELD, positions, POSITIONS_TYPE));
     doc.add(new NumericDocValuesField(NUMERIC_DV_FIELD, id));
     TextField norms = new TextField(NORMS_FIELD, Integer.toString(id), Store.NO);
     norms.setBoost(Float.intBitsToFloat(id));
@@ -264,10 +259,8 @@
       assertEquals("incorrect freq for doc=" + doc, sortedValues[doc].intValue() / 10 + 1, freq);
       for (int i = 0; i < freq; i++) {
         assertEquals("incorrect position for doc=" + doc, i, sortedPositions.nextPosition());
-        if (!doesntSupportOffsets.contains(TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {
-          assertEquals("incorrect startOffset for doc=" + doc, i, sortedPositions.startOffset());
-          assertEquals("incorrect endOffset for doc=" + doc, i, sortedPositions.endOffset());
-        }
+        assertEquals("incorrect startOffset for doc=" + doc, i, sortedPositions.startOffset());
+        assertEquals("incorrect endOffset for doc=" + doc, i, sortedPositions.endOffset());
         assertEquals("incorrect payload for doc=" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));
       }
     }
@@ -284,10 +277,8 @@
       assertEquals("incorrect freq for doc=" + doc, sortedValues[doc].intValue() / 10 + 1, freq);
       for (int i = 0; i < freq; i++) {
         assertEquals("incorrect position for doc=" + doc, i, sortedPositions.nextPosition());
-        if (!doesntSupportOffsets.contains(TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {
-          assertEquals("incorrect startOffset for doc=" + doc, i, sortedPositions.startOffset());
-          assertEquals("incorrect endOffset for doc=" + doc, i, sortedPositions.endOffset());
-        }
+        assertEquals("incorrect startOffset for doc=" + doc, i, sortedPositions.startOffset());
+        assertEquals("incorrect endOffset for doc=" + doc, i, sortedPositions.endOffset());
         assertEquals("incorrect payload for doc=" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));
       }
     }
Index: lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest.java
===================================================================
--- lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest.java	(revision 1584122)
+++ lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest.java	(working copy)
@@ -39,12 +39,9 @@
 import org.apache.lucene.search.suggest.InputArrayIterator;
 import org.apache.lucene.search.suggest.Lookup.LookupResult;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 
-// Test requires postings offsets:
-@SuppressCodecs({"Lucene3x","MockFixedIntBlock","MockVariableIntBlock","MockSep","MockRandom"})
 public class AnalyzingInfixSuggesterTest extends LuceneTestCase {
 
   public void testBasic() throws Exception {
Index: lucene/test-framework/src/java/org/apache/lucene/analysis/BaseTokenStreamTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/analysis/BaseTokenStreamTestCase.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/analysis/BaseTokenStreamTestCase.java	(working copy)
@@ -563,14 +563,12 @@
       if (random.nextBoolean()) {
         ft.setOmitNorms(true);
       }
-      String pf = TestUtil.getPostingsFormat("dummy");
-      boolean supportsOffsets = !doesntSupportOffsets.contains(pf);
       switch(random.nextInt(4)) {
         case 0: ft.setIndexOptions(IndexOptions.DOCS_ONLY); break;
         case 1: ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS); break;
         case 2: ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS); break;
         default:
-                if (supportsOffsets && offsetsAreCorrect) {
+                if (offsetsAreCorrect) {
                   ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
                 } else {
                   ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
Index: lucene/test-framework/src/java/org/apache/lucene/codecs/mockintblock/MockFixedIntBlockPostingsFormat.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/mockintblock/MockFixedIntBlockPostingsFormat.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/mockintblock/MockFixedIntBlockPostingsFormat.java	(working copy)
@@ -1,202 +0,0 @@
-package org.apache.lucene.codecs.mockintblock;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.FieldsConsumer;
-import org.apache.lucene.codecs.FieldsProducer;
-import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.PostingsReaderBase;
-import org.apache.lucene.codecs.PostingsWriterBase;
-import org.apache.lucene.codecs.blockterms.BlockTermsReader;
-import org.apache.lucene.codecs.blockterms.BlockTermsWriter;
-import org.apache.lucene.codecs.blockterms.FixedGapTermsIndexReader;
-import org.apache.lucene.codecs.blockterms.FixedGapTermsIndexWriter;
-import org.apache.lucene.codecs.blockterms.TermsIndexReaderBase;
-import org.apache.lucene.codecs.blockterms.TermsIndexWriterBase;
-import org.apache.lucene.codecs.intblock.FixedIntBlockIndexInput;
-import org.apache.lucene.codecs.intblock.FixedIntBlockIndexOutput;
-import org.apache.lucene.codecs.sep.IntIndexInput;
-import org.apache.lucene.codecs.sep.IntIndexOutput;
-import org.apache.lucene.codecs.sep.IntStreamFactory;
-import org.apache.lucene.codecs.sep.SepPostingsReader;
-import org.apache.lucene.codecs.sep.SepPostingsWriter;
-import org.apache.lucene.index.SegmentReadState;
-import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.store.*;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IOUtils;
-
-/**
- * A silly test codec to verify core support for fixed
- * sized int block encoders is working.  The int encoder
- * used here just writes each block as a series of vInt.
- */
-
-public final class MockFixedIntBlockPostingsFormat extends PostingsFormat {
-
-  private final int blockSize;
-
-  public MockFixedIntBlockPostingsFormat() {
-    this(1);
-  }
-
-  public MockFixedIntBlockPostingsFormat(int blockSize) {
-    super("MockFixedIntBlock");
-    this.blockSize = blockSize;
-  }
-
-  @Override
-  public String toString() {
-    return getName() + "(blockSize=" + blockSize + ")";
-  }
-
-  // only for testing
-  public IntStreamFactory getIntFactory() {
-    return new MockIntFactory(blockSize);
-  }
-
-  /**
-   * Encodes blocks as vInts of a fixed block size.
-   */
-  public static class MockIntFactory extends IntStreamFactory {
-    private final int blockSize;
-
-    public MockIntFactory(int blockSize) {
-      this.blockSize = blockSize;
-    }
-
-    @Override
-    public IntIndexInput openInput(Directory dir, String fileName, IOContext context) throws IOException {
-      return new FixedIntBlockIndexInput(dir.openInput(fileName, context)) {
-
-        @Override
-        protected BlockReader getBlockReader(final IndexInput in, final int[] buffer) {
-          return new BlockReader() {
-            public void seek(long pos) {}
-            @Override
-            public void readBlock() throws IOException {
-              for(int i=0;i<buffer.length;i++) {
-                buffer[i] = in.readVInt();
-              }
-            }
-          };
-        }
-      };
-    }
-
-    @Override
-    public IntIndexOutput createOutput(Directory dir, String fileName, IOContext context) throws IOException {
-      IndexOutput out = dir.createOutput(fileName, context);
-      boolean success = false;
-      try {
-        FixedIntBlockIndexOutput ret = new FixedIntBlockIndexOutput(out, blockSize) {
-          @Override
-          protected void flushBlock() throws IOException {
-            for(int i=0;i<buffer.length;i++) {
-              out.writeVInt(buffer[i]);
-            }
-          }
-        };
-        success = true;
-        return ret;
-      } finally {
-        if (!success) {
-          IOUtils.closeWhileHandlingException(out);
-        }
-      }
-    }
-  }
-
-  @Override
-  public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
-    PostingsWriterBase postingsWriter = new SepPostingsWriter(state, new MockIntFactory(blockSize));
-
-    boolean success = false;
-    TermsIndexWriterBase indexWriter;
-    try {
-      indexWriter = new FixedGapTermsIndexWriter(state);
-      success = true;
-    } finally {
-      if (!success) {
-        postingsWriter.close();
-      }
-    }
-
-    success = false;
-    try {
-      FieldsConsumer ret = new BlockTermsWriter(indexWriter, state, postingsWriter);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        try {
-          postingsWriter.close();
-        } finally {
-          indexWriter.close();
-        }
-      }
-    }
-  }
-
-  @Override
-  public FieldsProducer fieldsProducer(SegmentReadState state) throws IOException {
-    PostingsReaderBase postingsReader = new SepPostingsReader(state.directory,
-                                                              state.fieldInfos,
-                                                              state.segmentInfo,
-                                                              state.context,
-                                                              new MockIntFactory(blockSize), state.segmentSuffix);
-
-    TermsIndexReaderBase indexReader;
-    boolean success = false;
-    try {
-      indexReader = new FixedGapTermsIndexReader(state.directory,
-                                                       state.fieldInfos,
-                                                       state.segmentInfo.name,
-                                                       BytesRef.getUTF8SortedAsUnicodeComparator(), state.segmentSuffix,
-                                                       IOContext.DEFAULT);
-      success = true;
-    } finally {
-      if (!success) {
-        postingsReader.close();
-      }
-    }
-
-    success = false;
-    try {
-      FieldsProducer ret = new BlockTermsReader(indexReader,
-                                                state.directory,
-                                                state.fieldInfos,
-                                                state.segmentInfo,
-                                                postingsReader,
-                                                state.context,
-                                                state.segmentSuffix);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        try {
-          postingsReader.close();
-        } finally {
-          indexReader.close();
-        }
-      }
-    }
-  }
-}
Index: lucene/test-framework/src/java/org/apache/lucene/codecs/mockintblock/MockVariableIntBlockPostingsFormat.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/mockintblock/MockVariableIntBlockPostingsFormat.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/mockintblock/MockVariableIntBlockPostingsFormat.java	(working copy)
@@ -1,227 +0,0 @@
-package org.apache.lucene.codecs.mockintblock;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.FieldsConsumer;
-import org.apache.lucene.codecs.FieldsProducer;
-import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.PostingsReaderBase;
-import org.apache.lucene.codecs.PostingsWriterBase;
-import org.apache.lucene.codecs.blockterms.BlockTermsReader;
-import org.apache.lucene.codecs.blockterms.BlockTermsWriter;
-import org.apache.lucene.codecs.blockterms.FixedGapTermsIndexReader;
-import org.apache.lucene.codecs.blockterms.FixedGapTermsIndexWriter;
-import org.apache.lucene.codecs.blockterms.TermsIndexReaderBase;
-import org.apache.lucene.codecs.blockterms.TermsIndexWriterBase;
-import org.apache.lucene.codecs.intblock.VariableIntBlockIndexInput;
-import org.apache.lucene.codecs.intblock.VariableIntBlockIndexOutput;
-import org.apache.lucene.codecs.sep.IntIndexInput;
-import org.apache.lucene.codecs.sep.IntIndexOutput;
-import org.apache.lucene.codecs.sep.IntStreamFactory;
-import org.apache.lucene.codecs.sep.SepPostingsReader;
-import org.apache.lucene.codecs.sep.SepPostingsWriter;
-import org.apache.lucene.index.SegmentReadState;
-import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IOUtils;
-
-/**
- * A silly test codec to verify core support for variable
- * sized int block encoders is working.  The int encoder
- * used here writes baseBlockSize ints at once, if the first
- * int is <= 3, else 2*baseBlockSize.
- */
-
-public final class MockVariableIntBlockPostingsFormat extends PostingsFormat {
-  private final int baseBlockSize;
-  
-  public MockVariableIntBlockPostingsFormat() {
-    this(1);
-  }
-
-  public MockVariableIntBlockPostingsFormat(int baseBlockSize) {
-    super("MockVariableIntBlock");
-    this.baseBlockSize = baseBlockSize;
-  }
-
-  @Override
-  public String toString() {
-    return getName() + "(baseBlockSize="+ baseBlockSize + ")";
-  }
-
-  /**
-   * If the first value is <= 3, writes baseBlockSize vInts at once,
-   * otherwise writes 2*baseBlockSize vInts.
-   */
-  public static class MockIntFactory extends IntStreamFactory {
-
-    private final int baseBlockSize;
-
-    public MockIntFactory(int baseBlockSize) {
-      this.baseBlockSize = baseBlockSize;
-    }
-
-    @Override
-    public IntIndexInput openInput(Directory dir, String fileName, IOContext context) throws IOException {
-      final IndexInput in = dir.openInput(fileName, context);
-      final int baseBlockSize = in.readInt();
-      return new VariableIntBlockIndexInput(in) {
-
-        @Override
-        protected BlockReader getBlockReader(final IndexInput in, final int[] buffer) {
-          return new BlockReader() {
-            @Override
-            public void seek(long pos) {}
-            @Override
-            public int readBlock() throws IOException {
-              buffer[0] = in.readVInt();
-              final int count = buffer[0] <= 3 ? baseBlockSize-1 : 2*baseBlockSize-1;
-              assert buffer.length >= count: "buffer.length=" + buffer.length + " count=" + count;
-              for(int i=0;i<count;i++) {
-                buffer[i+1] = in.readVInt();
-              }
-              return 1+count;
-            }
-          };
-        }
-      };
-    }
-
-    @Override
-    public IntIndexOutput createOutput(Directory dir, String fileName, IOContext context) throws IOException {
-      final IndexOutput out = dir.createOutput(fileName, context);
-      boolean success = false;
-      try {
-        out.writeInt(baseBlockSize);
-        VariableIntBlockIndexOutput ret = new VariableIntBlockIndexOutput(out, 2*baseBlockSize) {
-          int pendingCount;
-          final int[] buffer = new int[2+2*baseBlockSize];
-          
-          @Override
-          protected int add(int value) throws IOException {
-            buffer[pendingCount++] = value;
-            // silly variable block length int encoder: if
-            // first value <= 3, we write N vints at once;
-            // else, 2*N
-            final int flushAt = buffer[0] <= 3 ? baseBlockSize : 2*baseBlockSize;
-            
-            // intentionally be non-causal here:
-            if (pendingCount == flushAt+1) {
-              for(int i=0;i<flushAt;i++) {
-                out.writeVInt(buffer[i]);
-              }
-              buffer[0] = buffer[flushAt];
-              pendingCount = 1;
-              return flushAt;
-            } else {
-              return 0;
-            }
-          }
-        };
-        success = true;
-        return ret;
-      } finally {
-        if (!success) {
-          IOUtils.closeWhileHandlingException(out);
-        }
-      }
-    }
-  }
-
-  @Override
-  public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
-    PostingsWriterBase postingsWriter = new SepPostingsWriter(state, new MockIntFactory(baseBlockSize));
-
-    boolean success = false;
-    TermsIndexWriterBase indexWriter;
-    try {
-      indexWriter = new FixedGapTermsIndexWriter(state);
-      success = true;
-    } finally {
-      if (!success) {
-        postingsWriter.close();
-      }
-    }
-
-    success = false;
-    try {
-      FieldsConsumer ret = new BlockTermsWriter(indexWriter, state, postingsWriter);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        try {
-          postingsWriter.close();
-        } finally {
-          indexWriter.close();
-        }
-      }
-    }
-  }
-
-  @Override
-  public FieldsProducer fieldsProducer(SegmentReadState state) throws IOException {
-    PostingsReaderBase postingsReader = new SepPostingsReader(state.directory,
-                                                              state.fieldInfos,
-                                                              state.segmentInfo,
-                                                              state.context,
-                                                              new MockIntFactory(baseBlockSize), state.segmentSuffix);
-
-    TermsIndexReaderBase indexReader;
-    boolean success = false;
-    try {
-      indexReader = new FixedGapTermsIndexReader(state.directory,
-                                                       state.fieldInfos,
-                                                       state.segmentInfo.name,
-                                                       BytesRef.getUTF8SortedAsUnicodeComparator(),
-                                                       state.segmentSuffix, state.context);
-      success = true;
-    } finally {
-      if (!success) {
-        postingsReader.close();
-      }
-    }
-
-    success = false;
-    try {
-      FieldsProducer ret = new BlockTermsReader(indexReader,
-                                                state.directory,
-                                                state.fieldInfos,
-                                                state.segmentInfo,
-                                                postingsReader,
-                                                state.context,
-                                                state.segmentSuffix);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        try {
-          postingsReader.close();
-        } finally {
-          indexReader.close();
-        }
-      }
-    }
-  }
-}
Index: lucene/test-framework/src/java/org/apache/lucene/codecs/mockintblock/package.html
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/mockintblock/package.html	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/mockintblock/package.html	(working copy)
@@ -1,25 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-Integer encoder implementations for testing.
-</body>
-</html>
Index: lucene/test-framework/src/java/org/apache/lucene/codecs/mockrandom/MockRandomPostingsFormat.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/mockrandom/MockRandomPostingsFormat.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/mockrandom/MockRandomPostingsFormat.java	(working copy)
@@ -18,8 +18,6 @@
  */
 
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Random;
 
 import org.apache.lucene.codecs.BlockTreeTermsReader;
@@ -44,22 +42,12 @@
 import org.apache.lucene.codecs.memory.FSTOrdTermsWriter;
 import org.apache.lucene.codecs.memory.FSTTermsReader;
 import org.apache.lucene.codecs.memory.FSTTermsWriter;
-import org.apache.lucene.codecs.mockintblock.MockFixedIntBlockPostingsFormat;
-import org.apache.lucene.codecs.mockintblock.MockVariableIntBlockPostingsFormat;
-import org.apache.lucene.codecs.mocksep.MockSingleIntFactory;
 import org.apache.lucene.codecs.pulsing.PulsingPostingsReader;
 import org.apache.lucene.codecs.pulsing.PulsingPostingsWriter;
-import org.apache.lucene.codecs.sep.IntIndexInput;
-import org.apache.lucene.codecs.sep.IntIndexOutput;
-import org.apache.lucene.codecs.sep.IntStreamFactory;
-import org.apache.lucene.codecs.sep.SepPostingsReader;
-import org.apache.lucene.codecs.sep.SepPostingsWriter;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentReadState;
 import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.BytesRef;
@@ -93,48 +81,6 @@
     }
   }
 
-  // Chooses random IntStreamFactory depending on file's extension
-  private static class MockIntStreamFactory extends IntStreamFactory {
-    private final int salt;
-    private final List<IntStreamFactory> delegates = new ArrayList<>();
-
-    public MockIntStreamFactory(Random random) {
-      salt = random.nextInt();
-      delegates.add(new MockSingleIntFactory());
-      final int blockSize = TestUtil.nextInt(random, 1, 2000);
-      delegates.add(new MockFixedIntBlockPostingsFormat.MockIntFactory(blockSize));
-      final int baseBlockSize = TestUtil.nextInt(random, 1, 127);
-      delegates.add(new MockVariableIntBlockPostingsFormat.MockIntFactory(baseBlockSize));
-      // TODO: others
-    }
-
-    private static String getExtension(String fileName) {
-      final int idx = fileName.indexOf('.');
-      assert idx != -1;
-      return fileName.substring(idx);
-    }
-
-    @Override
-    public IntIndexInput openInput(Directory dir, String fileName, IOContext context) throws IOException {
-      // Must only use extension, because IW.addIndexes can
-      // rename segment!
-      final IntStreamFactory f = delegates.get((Math.abs(salt ^ getExtension(fileName).hashCode())) % delegates.size());
-      if (LuceneTestCase.VERBOSE) {
-        System.out.println("MockRandomCodec: read using int factory " + f + " from fileName=" + fileName);
-      }
-      return f.openInput(dir, fileName, context);
-    }
-
-    @Override
-    public IntIndexOutput createOutput(Directory dir, String fileName, IOContext context) throws IOException {
-      final IntStreamFactory f = delegates.get((Math.abs(salt ^ getExtension(fileName).hashCode())) % delegates.size());
-      if (LuceneTestCase.VERBOSE) {
-        System.out.println("MockRandomCodec: write using int factory " + f + " to fileName=" + fileName);
-      }
-      return f.createOutput(dir, fileName, context);
-    }
-  }
-
   @Override
   public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
     int minSkipInterval;
@@ -171,16 +117,7 @@
     
     random.nextInt(); // consume a random for buffersize
 
-    PostingsWriterBase postingsWriter;
-    if (random.nextBoolean()) {
-      postingsWriter = new SepPostingsWriter(state, new MockIntStreamFactory(random), skipInterval);
-    } else {
-      if (LuceneTestCase.VERBOSE) {
-        System.out.println("MockRandomCodec: writing Standard postings");
-      }
-      // TODO: randomize variables like acceptibleOverHead?!
-      postingsWriter = new Lucene41PostingsWriter(state, skipInterval);
-    }
+    PostingsWriterBase postingsWriter = new Lucene41PostingsWriter(state, skipInterval);
 
     if (random.nextBoolean()) {
       final int totTFCutoff = TestUtil.nextInt(random, 1, 20);
@@ -327,22 +264,9 @@
       System.out.println("MockRandomCodec: readBufferSize=" + readBufferSize);
     }
 
-    PostingsReaderBase postingsReader;
+    PostingsReaderBase postingsReader = new Lucene41PostingsReader(state.directory, state.fieldInfos, state.segmentInfo, state.context, state.segmentSuffix);
 
     if (random.nextBoolean()) {
-      if (LuceneTestCase.VERBOSE) {
-        System.out.println("MockRandomCodec: reading Sep postings");
-      }
-      postingsReader = new SepPostingsReader(state.directory, state.fieldInfos, state.segmentInfo,
-                                             state.context, new MockIntStreamFactory(random), state.segmentSuffix);
-    } else {
-      if (LuceneTestCase.VERBOSE) {
-        System.out.println("MockRandomCodec: reading Standard postings");
-      }
-      postingsReader = new Lucene41PostingsReader(state.directory, state.fieldInfos, state.segmentInfo, state.context, state.segmentSuffix);
-    }
-
-    if (random.nextBoolean()) {
       final int totTFCutoff = TestUtil.nextInt(random, 1, 20);
       if (LuceneTestCase.VERBOSE) {
         System.out.println("MockRandomCodec: reading pulsing postings with totTFCutoff=" + totTFCutoff);
Index: lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSepPostingsFormat.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSepPostingsFormat.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSepPostingsFormat.java	(working copy)
@@ -1,125 +0,0 @@
-package org.apache.lucene.codecs.mocksep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.FieldsConsumer;
-import org.apache.lucene.codecs.FieldsProducer;
-import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.PostingsReaderBase;
-import org.apache.lucene.codecs.PostingsWriterBase;
-import org.apache.lucene.codecs.blockterms.BlockTermsReader;
-import org.apache.lucene.codecs.blockterms.BlockTermsWriter;
-import org.apache.lucene.codecs.blockterms.FixedGapTermsIndexReader;
-import org.apache.lucene.codecs.blockterms.FixedGapTermsIndexWriter;
-import org.apache.lucene.codecs.blockterms.TermsIndexReaderBase;
-import org.apache.lucene.codecs.blockterms.TermsIndexWriterBase;
-import org.apache.lucene.codecs.sep.SepPostingsReader;
-import org.apache.lucene.codecs.sep.SepPostingsWriter;
-import org.apache.lucene.index.SegmentReadState;
-import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.util.BytesRef;
-
-/**
- * A silly codec that simply writes each file separately as
- * single vInts.  Don't use this (performance will be poor)!
- * This is here just to test the core sep codec
- * classes.
- */
-public final class MockSepPostingsFormat extends PostingsFormat {
-
-  public MockSepPostingsFormat() {
-    super("MockSep");
-  }
-
-  @Override
-  public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
-
-    PostingsWriterBase postingsWriter = new SepPostingsWriter(state, new MockSingleIntFactory());
-
-    boolean success = false;
-    TermsIndexWriterBase indexWriter;
-    try {
-      indexWriter = new FixedGapTermsIndexWriter(state);
-      success = true;
-    } finally {
-      if (!success) {
-        postingsWriter.close();
-      }
-    }
-
-    success = false;
-    try {
-      FieldsConsumer ret = new BlockTermsWriter(indexWriter, state, postingsWriter);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        try {
-          postingsWriter.close();
-        } finally {
-          indexWriter.close();
-        }
-      }
-    }
-  }
-
-  @Override
-  public FieldsProducer fieldsProducer(SegmentReadState state) throws IOException {
-
-    PostingsReaderBase postingsReader = new SepPostingsReader(state.directory, state.fieldInfos, state.segmentInfo,
-        state.context, new MockSingleIntFactory(), state.segmentSuffix);
-
-    TermsIndexReaderBase indexReader;
-    boolean success = false;
-    try {
-      indexReader = new FixedGapTermsIndexReader(state.directory,
-                                                       state.fieldInfos,
-                                                       state.segmentInfo.name,
-                                                       BytesRef.getUTF8SortedAsUnicodeComparator(),
-                                                       state.segmentSuffix, state.context);
-      success = true;
-    } finally {
-      if (!success) {
-        postingsReader.close();
-      }
-    }
-
-    success = false;
-    try {
-      FieldsProducer ret = new BlockTermsReader(indexReader,
-                                                state.directory,
-                                                state.fieldInfos,
-                                                state.segmentInfo,
-                                                postingsReader,
-                                                state.context,
-                                                state.segmentSuffix);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        try {
-          postingsReader.close();
-        } finally {
-          indexReader.close();
-        }
-      }
-    }
-  }
-}
Index: lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntFactory.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntFactory.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntFactory.java	(working copy)
@@ -1,41 +0,0 @@
-package org.apache.lucene.codecs.mocksep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.codecs.sep.IntIndexInput;
-import org.apache.lucene.codecs.sep.IntIndexOutput;
-import org.apache.lucene.codecs.sep.IntStreamFactory;
-
-import java.io.IOException;
-
-/** 
- * Encodes ints directly as vInts with {@link MockSingleIntIndexOutput}
- * @lucene.experimental 
- */
-public class MockSingleIntFactory extends IntStreamFactory {
-  @Override
-  public IntIndexInput openInput(Directory dir, String fileName, IOContext context) throws IOException {
-    return new MockSingleIntIndexInput(dir, fileName, context);
-  }
-  @Override
-  public IntIndexOutput createOutput(Directory dir, String fileName, IOContext context) throws IOException {
-    return new MockSingleIntIndexOutput(dir, fileName, context);
-  }
-}
Index: lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexInput.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexInput.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexInput.java	(working copy)
@@ -1,117 +0,0 @@
-package org.apache.lucene.codecs.mocksep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.sep.IntIndexInput;
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-
-/** Reads IndexInputs written with {@link
- *  MockSingleIntIndexOutput}.  NOTE: this class is just for
- *  demonstration purposes (it is a very slow way to read a
- *  block of ints).
- *
- * @lucene.experimental
- */
-public class MockSingleIntIndexInput extends IntIndexInput {
-  private final IndexInput in;
-
-  public MockSingleIntIndexInput(Directory dir, String fileName, IOContext context)
-    throws IOException {
-    in = dir.openInput(fileName, context);
-    CodecUtil.checkHeader(in, MockSingleIntIndexOutput.CODEC,
-                          MockSingleIntIndexOutput.VERSION_START,
-                          MockSingleIntIndexOutput.VERSION_START);
-  }
-
-  @Override
-  public Reader reader() throws IOException {
-    return new Reader(in.clone());
-  }
-
-  @Override
-  public void close() throws IOException {
-    in.close();
-  }
-
-  /**
-   * Just reads a vInt directly from the file.
-   */
-  public static class Reader extends IntIndexInput.Reader {
-    // clone:
-    private final IndexInput in;
-
-    public Reader(IndexInput in) {
-      this.in = in;
-    }
-
-    /** Reads next single int */
-    @Override
-    public int next() throws IOException {
-      //System.out.println("msii.next() fp=" + in.getFilePointer() + " vs " + in.length());
-      return in.readVInt();
-    }
-  }
-  
-  class MockSingleIntIndexInputIndex extends IntIndexInput.Index {
-    private long fp;
-
-    @Override
-    public void read(DataInput indexIn, boolean absolute)
-      throws IOException {
-      if (absolute) {
-        fp = indexIn.readVLong();
-      } else {
-        fp += indexIn.readVLong();
-      }
-    }
-
-    @Override
-    public void copyFrom(IntIndexInput.Index other) {
-      fp = ((MockSingleIntIndexInputIndex) other).fp;
-    }
-
-    @Override
-    public void seek(IntIndexInput.Reader other) throws IOException {
-      ((Reader) other).in.seek(fp);
-    }
-
-    @Override
-    public String toString() {
-      return Long.toString(fp);
-    }
-
-    @Override
-    public Index clone() {
-      MockSingleIntIndexInputIndex other = new MockSingleIntIndexInputIndex();
-      other.fp = fp;
-      return other;
-    }
-  }
-
-  @Override
-  public Index index() {
-    return new MockSingleIntIndexInputIndex();
-  }
-}
-
Index: lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexOutput.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexOutput.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexOutput.java	(working copy)
@@ -1,105 +0,0 @@
-package org.apache.lucene.codecs.mocksep;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.DataOutput;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.sep.IntIndexOutput;
-
-import java.io.IOException;
-
-/** Writes ints directly to the file (not in blocks) as
- *  vInt.
- * 
- * @lucene.experimental
-*/
-public class MockSingleIntIndexOutput extends IntIndexOutput {
-  private final IndexOutput out;
-  final static String CODEC = "SINGLE_INTS";
-  final static int VERSION_START = 0;
-  final static int VERSION_CURRENT = VERSION_START;
-
-  public MockSingleIntIndexOutput(Directory dir, String fileName, IOContext context) throws IOException {
-    out = dir.createOutput(fileName, context);
-    boolean success = false;
-    try {
-      CodecUtil.writeHeader(out, CODEC, VERSION_CURRENT);
-      success = true;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(out);
-      }
-    }
-  }
-
-  /** Write an int to the primary file */
-  @Override
-  public void write(int v) throws IOException {
-    out.writeVInt(v);
-  }
-
-  @Override
-  public Index index() {
-    return new MockSingleIntIndexOutputIndex();
-  }
-
-  @Override
-  public void close() throws IOException {
-    out.close();
-  }
-
-  @Override
-  public String toString() {
-    return "MockSingleIntIndexOutput fp=" + out.getFilePointer();
-  }
-
-  private class MockSingleIntIndexOutputIndex extends IntIndexOutput.Index {
-    long fp;
-    long lastFP;
-    @Override
-    public void mark() {
-      fp = out.getFilePointer();
-    }
-    @Override
-    public void copyFrom(IntIndexOutput.Index other, boolean copyLast) {
-      fp = ((MockSingleIntIndexOutputIndex) other).fp;
-      if (copyLast) {
-        lastFP = ((MockSingleIntIndexOutputIndex) other).fp;
-      }
-    }
-    @Override
-    public void write(DataOutput indexOut, boolean absolute)
-      throws IOException {
-      if (absolute) {
-        indexOut.writeVLong(fp);
-      } else {
-        indexOut.writeVLong(fp - lastFP);
-      }
-      lastFP = fp;
-    }
-      
-    @Override
-    public String toString() {
-      return Long.toString(fp);
-    }
-  }
-}
Index: lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/package.html
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/package.html	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/package.html	(working copy)
@@ -1,25 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-Very simple implementations of {@link org.apache.lucene.codecs.sep} for testing.
-</body>
-</html>
Index: lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java	(working copy)
@@ -667,18 +667,10 @@
     FieldInfo[] newFieldInfoArray = new FieldInfo[fields.size()];
     for(int fieldUpto=0;fieldUpto<fields.size();fieldUpto++) {
       FieldInfo oldFieldInfo = fieldInfos.fieldInfo(fieldUpto);
-
-      String pf = TestUtil.getPostingsFormat(codec, oldFieldInfo.name);
-      int fieldMaxIndexOption;
-      if (doesntSupportOffsets.contains(pf)) {
-        fieldMaxIndexOption = Math.min(maxIndexOptionNoOffsets, maxIndexOption);
-      } else {
-        fieldMaxIndexOption = maxIndexOption;
-      }
     
       // Randomly picked the IndexOptions to index this
       // field with:
-      IndexOptions indexOptions = IndexOptions.values()[alwaysTestMax ? fieldMaxIndexOption : random().nextInt(1+fieldMaxIndexOption)];
+      IndexOptions indexOptions = IndexOptions.values()[alwaysTestMax ? maxIndexOption : random().nextInt(1+maxIndexOption)];
       boolean doPayloads = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 && allowPayloads;
 
       newFieldInfoArray[fieldUpto] = new FieldInfo(oldFieldInfo.name,
Index: lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec.java	(working copy)
@@ -46,10 +46,7 @@
 import org.apache.lucene.codecs.memory.FSTPulsing41PostingsFormat;
 import org.apache.lucene.codecs.memory.MemoryDocValuesFormat;
 import org.apache.lucene.codecs.memory.MemoryPostingsFormat;
-import org.apache.lucene.codecs.mockintblock.MockFixedIntBlockPostingsFormat;
-import org.apache.lucene.codecs.mockintblock.MockVariableIntBlockPostingsFormat;
 import org.apache.lucene.codecs.mockrandom.MockRandomPostingsFormat;
-import org.apache.lucene.codecs.mocksep.MockSepPostingsFormat;
 import org.apache.lucene.codecs.nestedpulsing.NestedPulsingPostingsFormat;
 import org.apache.lucene.codecs.pulsing.Pulsing41PostingsFormat;
 import org.apache.lucene.codecs.simpletext.SimpleTextDocValuesFormat;
@@ -142,9 +139,6 @@
         //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing 
         //with such "wrapper" classes?
         new TestBloomFilteredLucene41Postings(),                
-        new MockSepPostingsFormat(),
-        new MockFixedIntBlockPostingsFormat(TestUtil.nextInt(random, 1, 2000)),
-        new MockVariableIntBlockPostingsFormat( TestUtil.nextInt(random, 1, 127)),
         new MockRandomPostingsFormat(random),
         new NestedPulsingPostingsFormat(),
         new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),
Index: lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(revision 1584122)
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -324,14 +324,6 @@
     CORE_DIRECTORIES.add("RAMDirectory");
   };
   
-  protected static final Set<String> doesntSupportOffsets = new HashSet<>(Arrays.asList(
-    "Lucene3x",
-    "MockFixedIntBlock",
-    "MockVariableIntBlock",
-    "MockSep",
-    "MockRandom"
-  ));
-  
   // -----------------------------------------------------------------
   // Fields initialized in class or instance rules.
   // -----------------------------------------------------------------
Index: lucene/test-framework/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat
===================================================================
--- lucene/test-framework/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat	(revision 1584122)
+++ lucene/test-framework/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat	(working copy)
@@ -13,10 +13,7 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
-org.apache.lucene.codecs.mockintblock.MockFixedIntBlockPostingsFormat
-org.apache.lucene.codecs.mockintblock.MockVariableIntBlockPostingsFormat
 org.apache.lucene.codecs.mockrandom.MockRandomPostingsFormat
-org.apache.lucene.codecs.mocksep.MockSepPostingsFormat
 org.apache.lucene.codecs.nestedpulsing.NestedPulsingPostingsFormat
 org.apache.lucene.codecs.ramonly.RAMOnlyPostingsFormat
 org.apache.lucene.codecs.lucene41ords.Lucene41WithOrds
Index: solr/core/src/test/org/apache/solr/highlight/TestPostingsSolrHighlighter.java
===================================================================
--- solr/core/src/test/org/apache/solr/highlight/TestPostingsSolrHighlighter.java	(revision 1584122)
+++ solr/core/src/test/org/apache/solr/highlight/TestPostingsSolrHighlighter.java	(working copy)
@@ -24,7 +24,6 @@
 import org.junit.BeforeClass;
 
 /** simple tests for PostingsSolrHighlighter */
-@SuppressCodecs({"MockFixedIntBlock", "MockVariableIntBlock", "MockSep", "MockRandom"})
 public class TestPostingsSolrHighlighter extends SolrTestCaseJ4 {
   
   @BeforeClass
