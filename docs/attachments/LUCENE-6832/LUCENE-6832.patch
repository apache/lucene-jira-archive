Index: lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter.java
===================================================================
--- lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter.java	(revision 1707330)
+++ lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter.java	(working copy)
@@ -194,6 +194,52 @@
     analyzer.close();
   }
 
+  public void testIgnoreCase() throws Exception{
+    b = new SynonymMap.Builder(true);
+    add("Mars", "Red", true);
+    add("stormy", "dusty", true);
+
+    tokensIn = new MockTokenizer(MockTokenizer.WHITESPACE,
+                                 true);
+    tokensIn.setReader(new StringReader("a"));
+    tokensIn.reset();
+    assertTrue(tokensIn.incrementToken());
+    assertFalse(tokensIn.incrementToken());
+    tokensIn.end();
+    tokensIn.close();
+
+    tokensOut = new SynonymFilter(tokensIn,
+                                     b.build(),
+                                     true);
+    termAtt = tokensOut.addAttribute(CharTermAttribute.class);
+    posIncrAtt = tokensOut.addAttribute(PositionIncrementAttribute.class);
+    posLenAtt = tokensOut.addAttribute(PositionLengthAttribute.class);
+    offsetAtt = tokensOut.addAttribute(OffsetAttribute.class);
+
+    verify("Mars", "Mars/Red");
+    verify("mars", "mars/Red");
+    verify("Venus", "Venus");
+    verify("venus", "venus");
+    verify("stormy", "stormy/dusty");
+    verify("Stormy", "Stormy/dusty");
+
+    tokensOut = new SynonymFilter(tokensIn,
+                                     b.build(),
+                                     false);
+    termAtt = tokensOut.addAttribute(CharTermAttribute.class);
+    posIncrAtt = tokensOut.addAttribute(PositionIncrementAttribute.class);
+    posLenAtt = tokensOut.addAttribute(PositionLengthAttribute.class);
+    offsetAtt = tokensOut.addAttribute(OffsetAttribute.class);
+
+    verify("Mars", "Mars/Red");
+    verify("mars", "mars");
+    verify("Venus", "Venus");
+    verify("venus", "venus");
+    verify("stormy", "stormy/dusty");
+    verify("Stormy", "Stormy");
+
+  }
+
   public void testBasic() throws Exception {
     b = new SynonymMap.Builder(true);
     add("a", "foo", true);
@@ -365,7 +411,7 @@
         sb.append(inputTokens[inputIDX]);
         posHasOutput = true;
       }
-      
+
       if (outputs[inputIDX] != null) {
         if (posHasOutput) {
           sb.append('/');
@@ -383,7 +429,7 @@
   }
 
   public void testRandom() throws Exception {
-    
+
     final int alphabetSize = TestUtil.nextInt(random(), 2, 7);
 
     final int docLen = atLeast(3000);
@@ -493,7 +539,7 @@
       }
       final SynonymMap map = b.build();
       final boolean ignoreCase = random().nextBoolean();
-      
+
       final Analyzer analyzer = new Analyzer() {
         @Override
         protected TokenStreamComponents createComponents(String fieldName) {
@@ -523,7 +569,7 @@
       }
       final SynonymMap map = b.build();
       final boolean ignoreCase = random.nextBoolean();
-      
+
       final Analyzer analyzer = new Analyzer() {
         @Override
         protected TokenStreamComponents createComponents(String fieldName) {
@@ -550,7 +596,7 @@
       }
       final SynonymMap map = b.build();
       final boolean ignoreCase = random.nextBoolean();
-      
+
       final Analyzer analyzer = new Analyzer() {
         @Override
         protected TokenStreamComponents createComponents(String fieldName) {
@@ -565,7 +611,7 @@
       analyzer.close();
     }
   }
-  
+
   public void testEmptyTerm() throws IOException {
     Random random = random();
     final int numIters = atLeast(10);
@@ -577,7 +623,7 @@
       }
       final SynonymMap map = b.build();
       final boolean ignoreCase = random.nextBoolean();
-      
+
       final Analyzer analyzer = new Analyzer() {
         @Override
         protected TokenStreamComponents createComponents(String fieldName) {
@@ -590,7 +636,7 @@
       analyzer.close();
     }
   }
-  
+
   /** simple random test like testRandom2, but for larger docs
    */
   public void testRandomHuge() throws Exception {
@@ -607,7 +653,7 @@
       }
       final SynonymMap map = b.build();
       final boolean ignoreCase = random.nextBoolean();
-      
+
       final Analyzer analyzer = new Analyzer() {
         @Override
         protected TokenStreamComponents createComponents(String fieldName) {
@@ -620,11 +666,11 @@
       analyzer.close();
     }
   }
-  
+
   // LUCENE-3375
   public void testVanishingTerms() throws Exception {
-    String testFile = 
-      "aaa => aaaa1 aaaa2 aaaa3\n" + 
+    String testFile =
+      "aaa => aaaa1 aaaa2 aaaa3\n" +
       "bbb => bbbb1 bbbb2\n";
     Analyzer synAnalyzer = new MockAnalyzer(random());
     SolrSynonymParser parser = new SolrSynonymParser(true, true, synAnalyzer);
@@ -631,7 +677,7 @@
     parser.parse(new StringReader(testFile));
     final SynonymMap map = parser.build();
     synAnalyzer.close();
-      
+
     Analyzer analyzer = new Analyzer() {
       @Override
       protected TokenStreamComponents createComponents(String fieldName) {
@@ -639,11 +685,11 @@
         return new TokenStreamComponents(tokenizer, new SynonymFilter(tokenizer, map, true));
       }
     };
-    
+
     // where did my pot go?!
     assertAnalyzesTo(analyzer, "xyzzy bbb pot of gold",
                      new String[] { "xyzzy", "bbbb1", "pot", "bbbb2", "of", "gold" });
-    
+
     // this one nukes 'pot' and 'of'
     // xyzzy aaa pot of gold -> xyzzy aaaa1 aaaa2 aaaa3 gold
     assertAnalyzesTo(analyzer, "xyzzy aaa pot of gold",
@@ -681,7 +727,7 @@
       verify("xyzzy aaa pot of gold", "xyzzy aaaa1 pot/aaaa2 of/aaaa3 gold");
     }
   }
-  
+
   public void testMatching() throws Exception {
     b = new SynonymMap.Builder(true);
     final boolean keepOrig = false;
@@ -703,29 +749,29 @@
     checkOneTerm(a, "$", "$");
     checkOneTerm(a, "a", "aa");
     checkOneTerm(a, "b", "bb");
-    
+
     assertAnalyzesTo(a, "a $",
        new String[] { "aa", "$" },
        new int[] { 1, 1 });
-    
+
     assertAnalyzesTo(a, "$ a",
         new String[] { "$", "aa" },
         new int[] { 1, 1 });
-    
+
     assertAnalyzesTo(a, "a a",
         new String[] { "aa", "aa" },
         new int[] { 1, 1 });
-    
+
     assertAnalyzesTo(a, "z x c v",
         new String[] { "zxcv" },
         new int[] { 1 });
-    
+
     assertAnalyzesTo(a, "z x c $",
         new String[] { "z", "xc", "$" },
         new int[] { 1, 1, 1 });
     a.close();
   }
-  
+
   public void testRepeatsOff() throws Exception {
     b = new SynonymMap.Builder(true);
     final boolean keepOrig = false;
@@ -746,7 +792,7 @@
         new int[] { 1 });
     a.close();
   }
-  
+
   public void testRepeatsOn() throws Exception {
     b = new SynonymMap.Builder(false);
     final boolean keepOrig = false;
@@ -767,7 +813,7 @@
         new int[] { 1, 0, 0 });
     a.close();
   }
-  
+
   public void testRecursion() throws Exception {
     b = new SynonymMap.Builder(true);
     final boolean keepOrig = false;
@@ -780,13 +826,13 @@
         return new TokenStreamComponents(tokenizer, new SynonymFilter(tokenizer, map, true));
       }
     };
-    
+
     assertAnalyzesTo(a, "zoo zoo $ zoo",
         new String[] { "zoo", "zoo", "$", "zoo" },
         new int[] { 1, 1, 1, 1 });
     a.close();
   }
- 
+
   public void testRecursion2() throws Exception {
     b = new SynonymMap.Builder(true);
     final boolean keepOrig = false;
@@ -832,7 +878,7 @@
     // Make sure endOffset inherits from previous input token:
     verify("a", "a b:1");
   }
-  
+
   public void testIncludeOrig() throws Exception {
     b = new SynonymMap.Builder(true);
     final boolean keepOrig = true;
@@ -850,29 +896,29 @@
         return new TokenStreamComponents(tokenizer, new SynonymFilter(tokenizer, map, true));
       }
     };
-    
-    assertAnalyzesTo(a, "$", 
+
+    assertAnalyzesTo(a, "$",
         new String[] { "$" },
         new int[] { 1 });
-    assertAnalyzesTo(a, "a", 
+    assertAnalyzesTo(a, "a",
         new String[] { "a", "aa" },
         new int[] { 1, 0 });
-    assertAnalyzesTo(a, "a", 
+    assertAnalyzesTo(a, "a",
         new String[] { "a", "aa" },
         new int[] { 1, 0 });
-    assertAnalyzesTo(a, "$ a", 
+    assertAnalyzesTo(a, "$ a",
         new String[] { "$", "a", "aa" },
         new int[] { 1, 1, 0 });
-    assertAnalyzesTo(a, "a $", 
+    assertAnalyzesTo(a, "a $",
         new String[] { "a", "aa", "$" },
         new int[] { 1, 0, 1 });
-    assertAnalyzesTo(a, "$ a !", 
+    assertAnalyzesTo(a, "$ a !",
         new String[] { "$", "a", "aa", "!" },
         new int[] { 1, 1, 0, 1 });
-    assertAnalyzesTo(a, "a a", 
+    assertAnalyzesTo(a, "a a",
         new String[] { "a", "aa", "a", "aa" },
         new int[] { 1, 0, 1, 0 });
-    assertAnalyzesTo(a, "b", 
+    assertAnalyzesTo(a, "b",
         new String[] { "b", "bb" },
         new int[] { 1, 0 });
     assertAnalyzesTo(a, "z x c v",
@@ -883,7 +929,7 @@
         new int[] { 1, 1, 0, 1, 1 });
     a.close();
   }
-  
+
   public void testRecursion3() throws Exception {
     b = new SynonymMap.Builder(true);
     final boolean keepOrig = true;
@@ -896,13 +942,13 @@
         return new TokenStreamComponents(tokenizer, new SynonymFilter(tokenizer, map, true));
       }
     };
-    
+
     assertAnalyzesTo(a, "zoo zoo $ zoo",
         new String[] { "zoo", "zoo", "zoo", "$", "zoo" },
         new int[] { 1, 0, 1, 1, 1 });
     a.close();
   }
-  
+
   public void testRecursion4() throws Exception {
     b = new SynonymMap.Builder(true);
     final boolean keepOrig = true;
@@ -916,13 +962,13 @@
         return new TokenStreamComponents(tokenizer, new SynonymFilter(tokenizer, map, true));
       }
     };
-    
+
     assertAnalyzesTo(a, "zoo zoo $ zoo",
         new String[] { "zoo", "zoo", "zoo", "$", "zoo", "zoo", "zoo" },
         new int[] { 1, 0, 1, 1, 1, 0, 1 });
     a.close();
   }
-  
+
   public void testMultiwordOffsets() throws Exception {
     b = new SynonymMap.Builder(true);
     final boolean keepOrig = true;
@@ -935,7 +981,7 @@
         return new TokenStreamComponents(tokenizer, new SynonymFilter(tokenizer, map, true));
       }
     };
-    
+
     assertAnalyzesTo(a, "national hockey league",
         new String[] { "national", "nhl", "hockey", "league" },
         new int[] { 0, 0, 9, 16 },
