Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties	(revision 0)
@@ -0,0 +1,45 @@
+# This resource bundle contains Flexible Query Parser messages.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+#  <REPLACEMENT arg="{0}" value="detailed_message"/>
+INVALID_SYNTAX = Syntax Error: {0}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+#  <REPLACEMENT arg="{0}" value="invalid_query"/>
+#  <REPLACEMENT arg="{1}" value="detailed_message"/>
+INVALID_SYNTAX_CANNOT_PARSE = Syntax Error, cannot parse {0}: {1} 
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_FUZZY_LIMITS = The similarity value for a fuzzy search must be between 0.0 and 1.0.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION = Truncated unicode escape sequence.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_ESCAPE_CHARACTER = Term can not end with escape character.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE = None-hex character in unicode escape sequence: {0}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+NODE_ACTION_NOT_SUPPORTED = This node does not support this action.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+PARAMETER_VALUE_NOT_SUPPORTED = Parameter {1} with value {0} not supported.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+#  <REPLACEMENT arg="{0}" value="query"/>
+#  <REPLACEMENT arg="{1}" value="error/class"/>
+LUCENE_QUERY_CONVERSION_ERROR = Cannot convert query to lucene syntax: {0} error: {1}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+EMPTY_MESSAGE = 
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+WILDCARD_NOT_SUPPORTED = Wildcard is not supported for query: {0} 
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+TOO_MANY_BOOLEAN_CLAUSES = Too many boolean clauses, the maximum supported is {0}: {1}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+LEADING_WILDCARD_NOT_ALLOWED = Leading wildcard is not allowed: {0}\ No newline at end of file
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java	(working copy)
@@ -75,11 +75,11 @@
 
   }
 
-  CharSequence getTermEscaped(EscapeQuerySyntax escaper) {
+  protected CharSequence getTermEscaped(EscapeQuerySyntax escaper) {
     return escaper.escape(this.text, Locale.getDefault(), Type.NORMAL);
   }
 
-  CharSequence getTermEscapeQuoted(EscapeQuerySyntax escaper) {
+  protected CharSequence getTermEscapeQuoted(EscapeQuerySyntax escaper) {
     return escaper.escape(this.text, Locale.getDefault(), Type.STRING);
   }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/WildcardQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/WildcardQueryNode.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/WildcardQueryNode.java	(working copy)
@@ -1,76 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.search.MultiTermQuery;
-
-/**
- * A {@link WildcardQueryNode} represents wildcard query This does not apply to
- * phrases. Examples: a*b*c Fl?w? m?ke*g
- */
-public class WildcardQueryNode extends FieldQueryNode {
-  private static final long serialVersionUID = 0L;
-  private MultiTermQuery.RewriteMethod multiTermRewriteMethod;
-
-  /**
-   * @param field
-   *          - field name
-   * @param text
-   *          - value that contains one or more wild card characters (? or *)
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public WildcardQueryNode(CharSequence field, CharSequence text, int begin,
-      int end) {
-    super(field, text, begin, end);
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
-    if (isDefaultField(this.field)) {
-      return getTermEscaped(escaper);
-    } else {
-      return this.field + ":" + getTermEscaped(escaper);
-    }
-  }
-
-  public String toString() {
-    return "<wildcard field='" + this.field + "' term='" + this.text + "'/>";
-  }
-
-  public WildcardQueryNode cloneTree() throws CloneNotSupportedException {
-    WildcardQueryNode clone = (WildcardQueryNode) super.cloneTree();
-
-    // nothing to do here
-
-    return clone;
-  }
-
-  /**
-   * @return the rewrite method
-   */
-  public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
-    return multiTermRewriteMethod;
-  }
-
-  public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method) {
-    multiTermRewriteMethod = method;
-  }
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PrefixWildcardQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PrefixWildcardQueryNode.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PrefixWildcardQueryNode.java	(working copy)
@@ -1,57 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * A {@link PrefixWildcardQueryNode} represents wildcardquery that matches abc*
- * or *. This does not apply to phrases, this is a special case on the original
- * lucene parser. TODO: refactor the code to remove this special case from the
- * parser. and probably do it on a Processor
- */
-public class PrefixWildcardQueryNode extends WildcardQueryNode {
-
-  private static final long serialVersionUID = 6851557641826407515L;
-
-  /**
-   * @param field
-   *          - field name
-   * @param text
-   *          - value including the wildcard
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public PrefixWildcardQueryNode(CharSequence field, CharSequence text,
-      int begin, int end) {
-    super(field, text, begin, end);
-  }
-
-  public String toString() {
-    return "<prefixWildcard field='" + this.field + "' term='" + this.text
-        + "'/>";
-  }
-
-  public PrefixWildcardQueryNode cloneTree() throws CloneNotSupportedException {
-    PrefixWildcardQueryNode clone = (PrefixWildcardQueryNode) super.cloneTree();
-
-    // nothing to do here
-
-    return clone;
-  }
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java	(working copy)
@@ -27,14 +27,14 @@
 import org.apache.lucene.queryParser.core.nodes.MatchAllDocsQueryNode;
 import org.apache.lucene.queryParser.core.nodes.MatchNoDocsQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
 import org.apache.lucene.search.Query;
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java	(working copy)
@@ -19,8 +19,8 @@
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.search.PrefixQuery;
 
 /**
@@ -36,8 +36,8 @@
   public PrefixQuery build(QueryNode queryNode) throws QueryNodeException {
     PrefixWildcardQueryNode wildcardNode = (PrefixWildcardQueryNode) queryNode;
 
-    PrefixQuery q = new PrefixQuery(new Term(wildcardNode.getFieldAsString(),
-                                             wildcardNode.getTextAsString()));
+    String text = wildcardNode.getText().subSequence(0, wildcardNode.getText().length() - 1).toString();
+    PrefixQuery q = new PrefixQuery(new Term(wildcardNode.getFieldAsString(), text));
     q.setRewriteMethod(wildcardNode.getMultiTermRewriteMethod());
     return q;
   }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java	(working copy)
@@ -20,7 +20,7 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.WildcardQuery;
 
 /**
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java	(working copy)
@@ -20,10 +20,11 @@
 import java.util.List;
 
 import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryParser.core.nodes.MatchAllDocsQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.MatchAllDocsQuery;
 
 /**
@@ -41,11 +42,11 @@
 
   protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
 
-    if (node instanceof WildcardQueryNode) {
-      WildcardQueryNode wildcardNode = (WildcardQueryNode) node;
+    if (node instanceof FieldQueryNode) {
+      FieldQueryNode fqn = (FieldQueryNode) node;
 
-      if (wildcardNode.getField().toString().equals("*")
-          && wildcardNode.getText().toString().equals("*")) {
+      if (fqn.getField().toString().equals("*")
+          && fqn.getText().toString().equals("*")) {
 
         return new MatchAllDocsQueryNode();
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java	(working copy)
@@ -48,13 +48,13 @@
   public StandardQueryNodeProcessorPipeline(QueryConfigHandler queryConfig) {
     super(queryConfig);
 
+    addProcessor(new WildcardQueryNodeProcessor());
     addProcessor(new MultiFieldQueryNodeProcessor());
     addProcessor(new FuzzyQueryNodeProcessor());
     addProcessor(new MatchAllDocsQueryNodeProcessor());
     addProcessor(new LowercaseExpandedTermsQueryNodeProcessor());
     addProcessor(new ParametricRangeQueryNodeProcessor());
-    addProcessor(new AllowLeadingWildcardProcessor());
-    addProcessor(new PrefixWildcardQueryNodeProcessor());
+    addProcessor(new AllowLeadingWildcardProcessor());    
     addProcessor(new AnalyzerQueryNodeProcessor());
     addProcessor(new PhraseSlopQueryNodeProcessor());
     addProcessor(new GroupQueryNodeProcessor());
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java	(working copy)
@@ -38,12 +38,12 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.TextableQueryNode;
 import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.standard.config.AnalyzerAttribute;
 import org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute;
 import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 
 /**
  * This processor verifies if the attribute {@link AnalyzerQueryNodeProcessor}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java	(working copy)
@@ -25,9 +25,9 @@
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 
 /**
  * This processor verifies if the attribute
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PrefixWildcardQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PrefixWildcardQueryNodeProcessor.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PrefixWildcardQueryNodeProcessor.java	(working copy)
@@ -1,72 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
-import org.apache.lucene.search.PrefixQuery;
-
-/**
- * The {@link StandardSyntaxParser} creates {@link PrefixWildcardQueryNode} nodes which
- * have values containing the prefixed wildcard. However, Lucene
- * {@link PrefixQuery} cannot contain the prefixed wildcard. So, this processor
- * basically removed the prefixed wildcard from the
- * {@link PrefixWildcardQueryNode} value. <br/>
- * 
- * @see PrefixQuery
- * @see PrefixWildcardQueryNode
- */
-public class PrefixWildcardQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  public PrefixWildcardQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof PrefixWildcardQueryNode) {
-      PrefixWildcardQueryNode prefixWildcardNode = (PrefixWildcardQueryNode) node;
-      CharSequence text = prefixWildcardNode.getText();
-
-      prefixWildcardNode.setText(text.subSequence(0, text.length() - 1));
-
-    }
-
-    return node;
-
-  }
-
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java	(working copy)
@@ -24,9 +24,9 @@
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
 import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
 
 /**
@@ -66,14 +66,16 @@
     if (node instanceof WildcardQueryNode) {
       WildcardQueryNode wildcardNode = (WildcardQueryNode) node;
 
-      switch (wildcardNode.getText().charAt(0)) {
-
-      case '*':
-      case '?':
-        throw new QueryNodeException(new MessageImpl(
-            QueryParserMessages.LEADING_WILDCARD_NOT_ALLOWED, node
-                .toQueryString(new EscapeQuerySyntaxImpl())));
-
+      if (wildcardNode.getText().length() > 0) {
+        switch (wildcardNode.getText().charAt(0)) {
+    
+        case '*':
+        case '?':
+          throw new QueryNodeException(new MessageImpl(
+              QueryParserMessages.LEADING_WILDCARD_NOT_ALLOWED, node
+                  .toQueryString(new EscapeQuerySyntaxImpl())));
+    
+        }
       }
 
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java	(working copy)
@@ -20,9 +20,14 @@
 import java.util.List;
 
 import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
 import org.apache.lucene.search.PrefixQuery;
 
@@ -36,20 +41,48 @@
  * @see PrefixQuery
  * @see PrefixWildcardQueryNode
  */
-public class PrefixWildcardQueryNodeProcessor extends QueryNodeProcessorImpl {
+public class WildcardQueryNodeProcessor extends QueryNodeProcessorImpl {
 
-  public PrefixWildcardQueryNodeProcessor() {
+  public WildcardQueryNodeProcessor() {
     // empty constructor
   }
 
   protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
 
-    if (node instanceof PrefixWildcardQueryNode) {
-      PrefixWildcardQueryNode prefixWildcardNode = (PrefixWildcardQueryNode) node;
-      CharSequence text = prefixWildcardNode.getText();
-
-      prefixWildcardNode.setText(text.subSequence(0, text.length() - 1));
-
+    // the old Lucene Parser ignores FuzzyQueryNode that are also PrefixWildcardQueryNode or WildcardQueryNode
+    // we do the same here, also ignore empty terms
+    if (node instanceof FieldQueryNode || node instanceof FuzzyQueryNode) {      
+      FieldQueryNode fqn = (FieldQueryNode) node;      
+      CharSequence text = fqn.getText(); 
+      
+      // do not process wildcards for ParametricQueryNode and 
+      // QuotedFieldQueryNode to reproduce the old parser behavior
+      if (fqn instanceof ParametricQueryNode 
+          || fqn instanceof QuotedFieldQueryNode 
+          || text.length() <= 0){
+        // Ignore empty terms
+        return node;
+      }
+      
+      // Code below simulates the old lucene parser behavior for wildcards
+      
+      // If single wildcard return WildcardQueryNode 
+      if (text.toString().equals("*")) {
+        WildcardQueryNode wildcardQN = new WildcardQueryNode(fqn);
+        return wildcardQN;
+      } else 
+        // only make a prefix if there is only one single star at the end and no ? characters
+        if (!text.subSequence(0, text.length() - 1).toString().contains("*") 
+            && !text.subSequence(0, text.length() - 1).toString().contains("?")
+                 && text.charAt(text.length()-1) == '*') {        
+        PrefixWildcardQueryNode prefixWildcardQN = new PrefixWildcardQueryNode(fqn);
+        // remove the last character as expected by lucene classes
+        // prefixWildcardQN.setText(text.subSequence(0, text.length() - 1));
+        return prefixWildcardQN;
+      } else if (text.toString().contains("*") || text.toString().contains("?")){
+        WildcardQueryNode wildcardQN = new WildcardQueryNode(fqn);
+        return wildcardQN;
+      }      
     }
 
     return node;

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteDefaultProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteDefaultProcessor.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteDefaultProcessor.java	(working copy)
@@ -20,9 +20,8 @@
 import java.util.List;
 
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.MultiTermQuery;
 
 /**
@@ -36,8 +35,6 @@
   protected QueryNode postProcessNode(QueryNode node) {
     if (node instanceof WildcardQueryNode) {
       ((WildcardQueryNode) node).setMultiTermRewriteMethod(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
-    } else if (node instanceof PrefixWildcardQueryNode) {
-      ((PrefixWildcardQueryNode) node).setMultiTermRewriteMethod(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
     }
 
     return node;
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java	(working copy)
@@ -1,4 +1,6 @@
-package org.apache.lucene.queryParser.core.nodes;
+package org.apache.lucene.queryParser.standard.nodes;
+
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
 
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -42,6 +44,10 @@
     super(field, text, begin, end);
   }
 
+  public PrefixWildcardQueryNode(FieldQueryNode fqn) {
+    this(fqn.getField(), fqn.getText(), fqn.getBegin(), fqn.getEnd());
+  }
+
   public String toString() {
     return "<prefixWildcard field='" + this.field + "' term='" + this.text
         + "'/>";

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java	(working copy)
@@ -1,4 +1,4 @@
-package org.apache.lucene.queryParser.core.nodes;
+package org.apache.lucene.queryParser.standard.nodes;
 
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
 import org.apache.lucene.search.MultiTermQuery;
 
@@ -43,6 +44,10 @@
     super(field, text, begin, end);
   }
 
+  public WildcardQueryNode(FieldQueryNode fqn) {
+    this(fqn.getField(), fqn.getText(), fqn.getBegin(), fqn.getEnd());
+  }
+
   public CharSequence toQueryString(EscapeQuerySyntax escaper) {
     if (isDefaultField(this.field)) {
       return getTermEscaped(escaper);

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj	(working copy)
@@ -52,13 +52,11 @@
 import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
 import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 @SuppressWarnings("all")
@@ -110,7 +108,7 @@
 // every character that follows a backslash is considered as an escaped character
 | <#_ESCAPED_CHAR: "\\" ~[] >
 | <#_TERM_START_CHAR: ( ~[ " ", "\t", "\n", "\r", "\u3000", "+", "-", "!", "(", ")", ":", "^",
-                           "[", "]", "\"", "{", "}", "~", "*", "?", "\\" ]
+                           "[", "]", "\"", "{", "}", "~", "\\" ]
                        | <_ESCAPED_CHAR> ) >
 | <#_TERM_CHAR: ( <_TERM_START_CHAR> | <_ESCAPED_CHAR> | "-" | "+" ) >
 | <#_WHITESPACE: ( " " | "\t" | "\n" | "\r" | "\u3000") >
@@ -130,13 +128,10 @@
 | <LPAREN:    "(" >
 | <RPAREN:    ")" >
 | <COLON:     ":" >
-| <STAR:      "*" >
 | <CARAT:     "^" > : Boost
 | <QUOTED:     "\"" (<_QUOTED_CHAR>)* "\"">
 | <TERM:      <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
 | <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
-| <PREFIXTERM:  ("*") | ( <_TERM_START_CHAR> (<_TERM_CHAR>)* "*" ) >
-| <WILDTERM:  (<_TERM_START_CHAR> | [ "*", "?" ]) (<_TERM_CHAR> | ( [ "*", "?" ] ))* >
 | <RANGEIN_START: "[" > : RangeIn
 | <RANGEEX_START: "{" > : RangeEx
 }
@@ -346,8 +341,7 @@
   [
     LOOKAHEAD(2)
     (
-    fieldToken=<TERM> <COLON> {field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);}
-    | <STAR> <COLON> {field="*";}
+    fieldToken=<TERM> <COLON> {field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);}    
     )
   ]
 
@@ -379,8 +373,6 @@
 
 QueryNode Term(CharSequence field) : {
   Token term, boost=null, fuzzySlop=null, goop1, goop2;
-  boolean prefix = false;
-  boolean wildcard = false;
   boolean fuzzy = false;
   QueryNode q =null; 
   ParametricQueryNode qLower, qUpper;
@@ -390,15 +382,12 @@
   (
      (
  	   term=<TERM> { q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
-	   | term=<STAR> { wildcard=true; q = new WildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
-	   | term=<PREFIXTERM> { prefix=true; q = new PrefixWildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
-	   | term=<WILDTERM> { wildcard=true; q = new WildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
        | term=<NUMBER>
      )
      [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ]
      [ <CARAT> boost=<NUMBER> [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ] ]
      {
-       if (!wildcard && !prefix && fuzzy) {
+       if (fuzzy) {
        	  float fms = defaultMinSimilarity;
        	  try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java	(working copy)
@@ -128,4 +128,4 @@
   }
 
 }
-/* JavaCC - StandardChecksum=f9eb36a076cde62bf39ccbf828bc2117 (do not edit this line) */
+/* JavaCC - OriginalChecksum=75998e81abbed08b0922a65bec11680d (do not edit this line) */
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java	(working copy)
@@ -144,4 +144,4 @@
     this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
   }
 }
-/* JavaCC - StandardChecksum=91ba9c9f5e0e552a815530d639ce15ed (do not edit this line) */
+/* JavaCC - OriginalChecksum=9672a6de7ecf4f5789a473d7dd40f6fb (do not edit this line) */
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java	(working copy)
@@ -614,4 +614,4 @@
   }
 
 }
-/* JavaCC - StandardChecksum=065d79d49fcd02f542903038e37bd9d9 (do not edit this line) */
+/* JavaCC - OriginalChecksum=d665eff1df49d9f82f07f7dc863fcd22 (do not edit this line) */
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java	(working copy)
@@ -39,41 +39,35 @@
   /** RegularExpression Id. */
   int COLON = 15;
   /** RegularExpression Id. */
-  int STAR = 16;
-  /** RegularExpression Id. */
-  int CARAT = 17;
+  int CARAT = 16;
   /** RegularExpression Id. */
-  int QUOTED = 18;
+  int QUOTED = 17;
   /** RegularExpression Id. */
-  int TERM = 19;
+  int TERM = 18;
   /** RegularExpression Id. */
-  int FUZZY_SLOP = 20;
+  int FUZZY_SLOP = 19;
   /** RegularExpression Id. */
-  int PREFIXTERM = 21;
+  int RANGEIN_START = 20;
   /** RegularExpression Id. */
-  int WILDTERM = 22;
+  int RANGEEX_START = 21;
   /** RegularExpression Id. */
-  int RANGEIN_START = 23;
+  int NUMBER = 22;
   /** RegularExpression Id. */
-  int RANGEEX_START = 24;
+  int RANGEIN_TO = 23;
   /** RegularExpression Id. */
-  int NUMBER = 25;
+  int RANGEIN_END = 24;
   /** RegularExpression Id. */
-  int RANGEIN_TO = 26;
+  int RANGEIN_QUOTED = 25;
   /** RegularExpression Id. */
-  int RANGEIN_END = 27;
+  int RANGEIN_GOOP = 26;
   /** RegularExpression Id. */
-  int RANGEIN_QUOTED = 28;
+  int RANGEEX_TO = 27;
   /** RegularExpression Id. */
-  int RANGEIN_GOOP = 29;
+  int RANGEEX_END = 28;
   /** RegularExpression Id. */
-  int RANGEEX_TO = 30;
+  int RANGEEX_QUOTED = 29;
   /** RegularExpression Id. */
-  int RANGEEX_END = 31;
-  /** RegularExpression Id. */
-  int RANGEEX_QUOTED = 32;
-  /** RegularExpression Id. */
-  int RANGEEX_GOOP = 33;
+  int RANGEEX_GOOP = 30;
 
   /** Lexical state. */
   int Boost = 0;
@@ -102,13 +96,10 @@
     "\"(\"",
     "\")\"",
     "\":\"",
-    "\"*\"",
     "\"^\"",
     "<QUOTED>",
     "<TERM>",
     "<FUZZY_SLOP>",
-    "<PREFIXTERM>",
-    "<WILDTERM>",
     "\"[\"",
     "\"{\"",
     "<NUMBER>",
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java	(working copy)
@@ -40,13 +40,11 @@
 import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
 import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 @SuppressWarnings("all")
@@ -178,11 +176,8 @@
       case PLUS:
       case MINUS:
       case LPAREN:
-      case STAR:
       case QUOTED:
       case TERM:
-      case PREFIXTERM:
-      case WILDTERM:
       case RANGEIN_START:
       case RANGEEX_START:
       case NUMBER:
@@ -322,31 +317,15 @@
   Token fieldToken=null, boost=null;
   boolean group = false;
     if (jj_2_1(2)) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case TERM:
-        fieldToken = jj_consume_token(TERM);
-        jj_consume_token(COLON);
+      fieldToken = jj_consume_token(TERM);
+      jj_consume_token(COLON);
                                field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
-        break;
-      case STAR:
-        jj_consume_token(STAR);
-        jj_consume_token(COLON);
-                      field="*";
-        break;
-      default:
-        jj_la1[7] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
     } else {
       ;
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case STAR:
     case QUOTED:
     case TERM:
-    case PREFIXTERM:
-    case WILDTERM:
     case RANGEIN_START:
     case RANGEEX_START:
     case NUMBER:
@@ -362,13 +341,13 @@
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[8] = jj_gen;
+        jj_la1[7] = jj_gen;
         ;
       }
                                                                  group=true;
       break;
     default:
-      jj_la1[9] = jj_gen;
+      jj_la1[8] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -393,40 +372,23 @@
 
   final public QueryNode Term(CharSequence field) throws ParseException {
   Token term, boost=null, fuzzySlop=null, goop1, goop2;
-  boolean prefix = false;
-  boolean wildcard = false;
   boolean fuzzy = false;
   QueryNode q =null;
   ParametricQueryNode qLower, qUpper;
   float defaultMinSimilarity = 0.5f;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case STAR:
     case TERM:
-    case PREFIXTERM:
-    case WILDTERM:
     case NUMBER:
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case TERM:
         term = jj_consume_token(TERM);
                          q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
         break;
-      case STAR:
-        term = jj_consume_token(STAR);
-                           wildcard=true; q = new WildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-        break;
-      case PREFIXTERM:
-        term = jj_consume_token(PREFIXTERM);
-                                 prefix=true; q = new PrefixWildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-        break;
-      case WILDTERM:
-        term = jj_consume_token(WILDTERM);
-                               wildcard=true; q = new WildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-        break;
       case NUMBER:
         term = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[10] = jj_gen;
+        jj_la1[9] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -436,7 +398,7 @@
                                 fuzzy=true;
         break;
       default:
-        jj_la1[11] = jj_gen;
+        jj_la1[10] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -449,15 +411,15 @@
                                                          fuzzy=true;
           break;
         default:
-          jj_la1[12] = jj_gen;
+          jj_la1[11] = jj_gen;
           ;
         }
         break;
       default:
-        jj_la1[13] = jj_gen;
+        jj_la1[12] = jj_gen;
         ;
       }
-       if (!wildcard && !prefix && fuzzy) {
+       if (fuzzy) {
           float fms = defaultMinSimilarity;
           try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
@@ -478,7 +440,7 @@
         goop1 = jj_consume_token(RANGEIN_QUOTED);
         break;
       default:
-        jj_la1[14] = jj_gen;
+        jj_la1[13] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -487,7 +449,7 @@
         jj_consume_token(RANGEIN_TO);
         break;
       default:
-        jj_la1[15] = jj_gen;
+        jj_la1[14] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -498,7 +460,7 @@
         goop2 = jj_consume_token(RANGEIN_QUOTED);
         break;
       default:
-        jj_la1[16] = jj_gen;
+        jj_la1[15] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -509,7 +471,7 @@
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[17] = jj_gen;
+        jj_la1[16] = jj_gen;
         ;
       }
           if (goop1.kind == RANGEIN_QUOTED) {
@@ -535,7 +497,7 @@
         goop1 = jj_consume_token(RANGEEX_QUOTED);
         break;
       default:
-        jj_la1[18] = jj_gen;
+        jj_la1[17] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -544,7 +506,7 @@
         jj_consume_token(RANGEEX_TO);
         break;
       default:
-        jj_la1[19] = jj_gen;
+        jj_la1[18] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -555,7 +517,7 @@
         goop2 = jj_consume_token(RANGEEX_QUOTED);
         break;
       default:
-        jj_la1[20] = jj_gen;
+        jj_la1[19] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -566,7 +528,7 @@
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[21] = jj_gen;
+        jj_la1[20] = jj_gen;
         ;
       }
           if (goop1.kind == RANGEEX_QUOTED) {
@@ -589,7 +551,7 @@
         fuzzySlop = jj_consume_token(FUZZY_SLOP);
         break;
       default:
-        jj_la1[22] = jj_gen;
+        jj_la1[21] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -598,7 +560,7 @@
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[23] = jj_gen;
+        jj_la1[22] = jj_gen;
         ;
       }
          int phraseSlop = 0;
@@ -616,7 +578,7 @@
          }
       break;
     default:
-      jj_la1[24] = jj_gen;
+      jj_la1[23] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -645,28 +607,12 @@
     finally { jj_save(0, xla); }
   }
 
-  private boolean jj_3R_5() {
-    if (jj_scan_token(STAR)) return true;
-    if (jj_scan_token(COLON)) return true;
-    return false;
-  }
-
-  private boolean jj_3R_4() {
+  private boolean jj_3_1() {
     if (jj_scan_token(TERM)) return true;
     if (jj_scan_token(COLON)) return true;
     return false;
   }
 
-  private boolean jj_3_1() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_4()) {
-    jj_scanpos = xsp;
-    if (jj_3R_5()) return true;
-    }
-    return false;
-  }
-
   /** Generated Token Manager. */
   public StandardSyntaxParserTokenManager token_source;
   JavaCharStream jj_input_stream;
@@ -678,18 +624,13 @@
   private Token jj_scanpos, jj_lastpos;
   private int jj_la;
   private int jj_gen;
-  final private int[] jj_la1 = new int[25];
+  final private int[] jj_la1 = new int[24];
   static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
   static {
       jj_la1_init_0();
-      jj_la1_init_1();
    }
    private static void jj_la1_init_0() {
-      jj_la1_0 = new int[] {0x300,0x300,0x1c00,0x1c00,0x3ed3c00,0x200,0x100,0x90000,0x20000,0x3ed2000,0x2690000,0x100000,0x100000,0x20000,0x30000000,0x4000000,0x30000000,0x20000,0x0,0x40000000,0x0,0x20000,0x100000,0x20000,0x3ed0000,};
-   }
-   private static void jj_la1_init_1() {
-      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x3,0x0,0x0,0x0,0x0,};
+      jj_la1_0 = new int[] {0x300,0x300,0x1c00,0x1c00,0x763c00,0x200,0x100,0x10000,0x762000,0x440000,0x80000,0x80000,0x10000,0x6000000,0x800000,0x6000000,0x10000,0x60000000,0x8000000,0x60000000,0x10000,0x80000,0x10000,0x760000,};
    }
   final private JJCalls[] jj_2_rtns = new JJCalls[1];
   private boolean jj_rescan = false;
@@ -706,7 +647,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -721,7 +662,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -732,7 +673,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -743,7 +684,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -753,7 +694,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -763,7 +704,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -875,24 +816,21 @@
   /** Generate ParseException. */
   public ParseException generateParseException() {
     jj_expentries.clear();
-    boolean[] la1tokens = new boolean[34];
+    boolean[] la1tokens = new boolean[31];
     if (jj_kind >= 0) {
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
-    for (int i = 0; i < 25; i++) {
+    for (int i = 0; i < 24; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
             la1tokens[j] = true;
           }
-          if ((jj_la1_1[i] & (1<<j)) != 0) {
-            la1tokens[32+j] = true;
-          }
         }
       }
     }
-    for (int i = 0; i < 34; i++) {
+    for (int i = 0; i < 31; i++) {
       if (la1tokens[i]) {
         jj_expentry = new int[1];
         jj_expentry[0] = i;
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java	(revision 804409)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java	(working copy)
@@ -38,13 +38,11 @@
 import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
 import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 /** Token Manager. */
@@ -81,8 +79,6 @@
          return jjStopAtPos(0, 13);
       case 41:
          return jjStopAtPos(0, 14);
-      case 42:
-         return jjStartNfaWithStates_3(0, 16, 36);
       case 43:
          return jjStopAtPos(0, 11);
       case 45:
@@ -90,23 +86,15 @@
       case 58:
          return jjStopAtPos(0, 15);
       case 91:
-         return jjStopAtPos(0, 23);
+         return jjStopAtPos(0, 20);
       case 94:
-         return jjStopAtPos(0, 17);
+         return jjStopAtPos(0, 16);
       case 123:
-         return jjStopAtPos(0, 24);
+         return jjStopAtPos(0, 21);
       default :
          return jjMoveNfa_3(0, 0);
    }
 }
-private int jjStartNfaWithStates_3(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_3(state, pos + 1);
-}
 static final long[] jjbitVec0 = {
    0x1L, 0x0L, 0x0L, 0x0L
 };
@@ -122,7 +110,7 @@
 private int jjMoveNfa_3(int startState, int curPos)
 {
    int startsAt = 0;
-   jjnewStateCnt = 36;
+   jjnewStateCnt = 28;
    int i = 1;
    jjstateSet[0] = startState;
    int kind = 0x7fffffff;
@@ -137,20 +125,12 @@
          {
             switch(jjstateSet[--i])
             {
-               case 36:
-               case 25:
-                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
                case 0:
                   if ((0xfbffd4f8ffffd9ffL & l) != 0L)
                   {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddTwoStates(25, 26);
+                     if (kind > 18)
+                        kind = 18;
+                     jjCheckNAddTwoStates(20, 21);
                   }
                   else if ((0x100002600L & l) != 0L)
                   {
@@ -164,17 +144,6 @@
                      if (kind > 10)
                         kind = 10;
                   }
-                  if ((0x7bffd0f8ffffd9ffL & l) != 0L)
-                  {
-                     if (kind > 19)
-                        kind = 19;
-                     jjCheckNAddStates(3, 7);
-                  }
-                  else if (curChar == 42)
-                  {
-                     if (kind > 21)
-                        kind = 21;
-                  }
                   if (curChar == 38)
                      jjstateSet[jjnewStateCnt++] = 4;
                   break;
@@ -202,68 +171,45 @@
                   jjCheckNAddStates(0, 2);
                   break;
                case 18:
-                  if (curChar == 34 && kind > 18)
+                  if (curChar == 34 && kind > 17)
+                     kind = 17;
+                  break;
+               case 19:
+                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 18)
                      kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
                case 20:
-                  if ((0x3ff000000000000L & l) == 0L)
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
                      break;
-                  if (kind > 20)
-                     kind = 20;
-                  jjAddStates(8, 9);
-                  break;
-               case 21:
-                  if (curChar == 46)
-                     jjCheckNAdd(22);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
                case 22:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 20)
-                     kind = 20;
-                  jjCheckNAdd(22);
-                  break;
-               case 23:
-                  if (curChar == 42 && kind > 21)
-                     kind = 21;
-                  break;
-               case 24:
-                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 27:
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
-               case 28:
-                  if ((0x7bffd0f8ffffd9ffL & l) == 0L)
+               case 25:
+                  if ((0x3ff000000000000L & l) == 0L)
                      break;
                   if (kind > 19)
                      kind = 19;
-                  jjCheckNAddStates(3, 7);
+                  jjAddStates(3, 4);
                   break;
-               case 29:
-                  if ((0x7bfff8f8ffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
+               case 26:
+                  if (curChar == 46)
+                     jjCheckNAdd(27);
                   break;
-               case 31:
+               case 27:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
                   if (kind > 19)
                      kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
-                  break;
-               case 32:
-                  if ((0x7bfff8f8ffffd9ffL & l) != 0L)
-                     jjCheckNAddStates(10, 12);
-                  break;
-               case 34:
-                  jjCheckNAddStates(10, 12);
+                  jjCheckNAdd(27);
                   break;
                default : break;
             }
@@ -276,37 +222,21 @@
          {
             switch(jjstateSet[--i])
             {
-               case 36:
+               case 0:
                   if ((0x97ffffff87ffffffL & l) != 0L)
                   {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddTwoStates(25, 26);
+                     if (kind > 18)
+                        kind = 18;
+                     jjCheckNAddTwoStates(20, 21);
                   }
-                  else if (curChar == 92)
-                     jjCheckNAddTwoStates(27, 27);
-                  break;
-               case 0:
-                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  else if (curChar == 126)
                   {
                      if (kind > 19)
                         kind = 19;
-                     jjCheckNAddStates(3, 7);
+                     jjstateSet[jjnewStateCnt++] = 25;
                   }
                   else if (curChar == 92)
-                     jjCheckNAddStates(13, 15);
-                  else if (curChar == 126)
-                  {
-                     if (kind > 20)
-                        kind = 20;
-                     jjstateSet[jjnewStateCnt++] = 20;
-                  }
-                  if ((0x97ffffff87ffffffL & l) != 0L)
-                  {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddTwoStates(25, 26);
-                  }
+                     jjCheckNAdd(22);
                   if (curChar == 78)
                      jjstateSet[jjnewStateCnt++] = 11;
                   else if (curChar == 124)
@@ -368,72 +298,32 @@
                   jjCheckNAddStates(0, 2);
                   break;
                case 19:
-                  if (curChar != 126)
-                     break;
-                  if (kind > 20)
-                     kind = 20;
-                  jjstateSet[jjnewStateCnt++] = 20;
-                  break;
-               case 24:
-                  if ((0x97ffffff87ffffffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 25:
+               case 20:
                   if ((0x97ffffff87ffffffL & l) == 0L)
                      break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
-               case 26:
+               case 21:
                   if (curChar == 92)
-                     jjCheckNAddTwoStates(27, 27);
+                     jjCheckNAddTwoStates(22, 22);
                   break;
-               case 27:
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 28:
-                  if ((0x97ffffff87ffffffL & l) == 0L)
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddStates(3, 7);
-                  break;
-               case 29:
-                  if ((0x97ffffff87ffffffL & l) == 0L)
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
+               case 22:
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
-               case 30:
+               case 23:
                   if (curChar == 92)
-                     jjCheckNAddTwoStates(31, 31);
+                     jjCheckNAdd(22);
                   break;
-               case 31:
+               case 24:
+                  if (curChar != 126)
+                     break;
                   if (kind > 19)
                      kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
-                  break;
-               case 32:
-                  if ((0x97ffffff87ffffffL & l) != 0L)
-                     jjCheckNAddStates(10, 12);
-                  break;
-               case 33:
-                  if (curChar == 92)
-                     jjCheckNAddTwoStates(34, 34);
-                  break;
-               case 34:
-                  jjCheckNAddStates(10, 12);
-                  break;
-               case 35:
-                  if (curChar == 92)
-                     jjCheckNAddStates(13, 15);
+                  jjstateSet[jjnewStateCnt++] = 25;
                   break;
                default : break;
             }
@@ -450,14 +340,6 @@
          {
             switch(jjstateSet[--i])
             {
-               case 36:
-               case 25:
-                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
                case 0:
                   if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                   {
@@ -466,15 +348,9 @@
                   }
                   if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                   {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddTwoStates(25, 26);
-                  }
-                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 19)
-                        kind = 19;
-                     jjCheckNAddStates(3, 7);
+                     if (kind > 18)
+                        kind = 18;
+                     jjCheckNAddTwoStates(20, 21);
                   }
                   break;
                case 15:
@@ -482,48 +358,20 @@
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                      jjCheckNAddStates(0, 2);
                   break;
-               case 24:
-                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 27:
-                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 28:
-                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddStates(3, 7);
-                  break;
-               case 29:
+               case 19:
+               case 20:
                   if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
-               case 31:
+               case 22:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
-                  break;
-               case 32:
-                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
-                     jjCheckNAddStates(10, 12);
-                  break;
-               case 34:
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjCheckNAddStates(10, 12);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
                default : break;
             }
@@ -536,7 +384,7 @@
          kind = 0x7fffffff;
       }
       ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
+      if ((i = jjnewStateCnt) == (startsAt = 28 - (jjnewStateCnt = startsAt)))
          return curPos;
       try { curChar = input_stream.readChar(); }
       catch(java.io.IOException e) { return curPos; }
@@ -547,9 +395,9 @@
    switch (pos)
    {
       case 0:
-         if ((active0 & 0x40000000L) != 0L)
+         if ((active0 & 0x8000000L) != 0L)
          {
-            jjmatchedKind = 33;
+            jjmatchedKind = 30;
             return 6;
          }
          return -1;
@@ -566,9 +414,9 @@
    switch(curChar)
    {
       case 84:
-         return jjMoveStringLiteralDfa1_1(0x40000000L);
+         return jjMoveStringLiteralDfa1_1(0x8000000L);
       case 125:
-         return jjStopAtPos(0, 31);
+         return jjStopAtPos(0, 28);
       default :
          return jjMoveNfa_1(0, 0);
    }
@@ -583,8 +431,8 @@
    switch(curChar)
    {
       case 79:
-         if ((active0 & 0x40000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 30, 6);
+         if ((active0 & 0x8000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 27, 6);
          break;
       default :
          break;
@@ -620,8 +468,8 @@
                case 0:
                   if ((0xfffffffeffffffffL & l) != 0L)
                   {
-                     if (kind > 33)
-                        kind = 33;
+                     if (kind > 30)
+                        kind = 30;
                      jjCheckNAdd(6);
                   }
                   if ((0x100002600L & l) != 0L)
@@ -638,21 +486,21 @@
                   break;
                case 2:
                   if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(5, 7);
                   break;
                case 3:
                   if (curChar == 34)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(5, 7);
                   break;
                case 5:
-                  if (curChar == 34 && kind > 32)
-                     kind = 32;
+                  if (curChar == 34 && kind > 29)
+                     kind = 29;
                   break;
                case 6:
                   if ((0xfffffffeffffffffL & l) == 0L)
                      break;
-                  if (kind > 33)
-                     kind = 33;
+                  if (kind > 30)
+                     kind = 30;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -670,12 +518,12 @@
                case 6:
                   if ((0xdfffffffffffffffL & l) == 0L)
                      break;
-                  if (kind > 33)
-                     kind = 33;
+                  if (kind > 30)
+                     kind = 30;
                   jjCheckNAdd(6);
                   break;
                case 2:
-                  jjAddStates(16, 18);
+                  jjAddStates(5, 7);
                   break;
                case 4:
                   if (curChar == 92)
@@ -704,20 +552,20 @@
                   }
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                   {
-                     if (kind > 33)
-                        kind = 33;
+                     if (kind > 30)
+                        kind = 30;
                      jjCheckNAdd(6);
                   }
                   break;
                case 2:
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjAddStates(16, 18);
+                     jjAddStates(5, 7);
                   break;
                case 6:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 33)
-                     kind = 33;
+                  if (kind > 30)
+                     kind = 30;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -762,9 +610,9 @@
                case 0:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 25)
-                     kind = 25;
-                  jjAddStates(19, 20);
+                  if (kind > 22)
+                     kind = 22;
+                  jjAddStates(8, 9);
                   break;
                case 1:
                   if (curChar == 46)
@@ -773,8 +621,8 @@
                case 2:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 25)
-                     kind = 25;
+                  if (kind > 22)
+                     kind = 22;
                   jjCheckNAdd(2);
                   break;
                default : break;
@@ -825,9 +673,9 @@
    switch (pos)
    {
       case 0:
-         if ((active0 & 0x4000000L) != 0L)
+         if ((active0 & 0x800000L) != 0L)
          {
-            jjmatchedKind = 29;
+            jjmatchedKind = 26;
             return 6;
          }
          return -1;
@@ -844,9 +692,9 @@
    switch(curChar)
    {
       case 84:
-         return jjMoveStringLiteralDfa1_2(0x4000000L);
+         return jjMoveStringLiteralDfa1_2(0x800000L);
       case 93:
-         return jjStopAtPos(0, 27);
+         return jjStopAtPos(0, 24);
       default :
          return jjMoveNfa_2(0, 0);
    }
@@ -861,8 +709,8 @@
    switch(curChar)
    {
       case 79:
-         if ((active0 & 0x4000000L) != 0L)
-            return jjStartNfaWithStates_2(1, 26, 6);
+         if ((active0 & 0x800000L) != 0L)
+            return jjStartNfaWithStates_2(1, 23, 6);
          break;
       default :
          break;
@@ -898,8 +746,8 @@
                case 0:
                   if ((0xfffffffeffffffffL & l) != 0L)
                   {
-                     if (kind > 29)
-                        kind = 29;
+                     if (kind > 26)
+                        kind = 26;
                      jjCheckNAdd(6);
                   }
                   if ((0x100002600L & l) != 0L)
@@ -916,21 +764,21 @@
                   break;
                case 2:
                   if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(5, 7);
                   break;
                case 3:
                   if (curChar == 34)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(5, 7);
                   break;
                case 5:
-                  if (curChar == 34 && kind > 28)
-                     kind = 28;
+                  if (curChar == 34 && kind > 25)
+                     kind = 25;
                   break;
                case 6:
                   if ((0xfffffffeffffffffL & l) == 0L)
                      break;
-                  if (kind > 29)
-                     kind = 29;
+                  if (kind > 26)
+                     kind = 26;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -948,12 +796,12 @@
                case 6:
                   if ((0xffffffffdfffffffL & l) == 0L)
                      break;
-                  if (kind > 29)
-                     kind = 29;
+                  if (kind > 26)
+                     kind = 26;
                   jjCheckNAdd(6);
                   break;
                case 2:
-                  jjAddStates(16, 18);
+                  jjAddStates(5, 7);
                   break;
                case 4:
                   if (curChar == 92)
@@ -982,20 +830,20 @@
                   }
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                   {
-                     if (kind > 29)
-                        kind = 29;
+                     if (kind > 26)
+                        kind = 26;
                      jjCheckNAdd(6);
                   }
                   break;
                case 2:
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjAddStates(16, 18);
+                     jjAddStates(5, 7);
                   break;
                case 6:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 29)
-                     kind = 29;
+                  if (kind > 26)
+                     kind = 26;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -1016,8 +864,7 @@
    }
 }
 static final int[] jjnextStates = {
-   15, 16, 18, 29, 32, 23, 33, 30, 20, 21, 32, 23, 33, 31, 34, 27, 
-   2, 4, 5, 0, 1, 
+   15, 16, 18, 25, 26, 2, 4, 5, 0, 1, 
 };
 private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
 {
@@ -1059,8 +906,8 @@
 /** Token literal values. */
 public static final String[] jjstrLiteralImages = {
 "", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
-"\50", "\51", "\72", "\52", "\136", null, null, null, null, null, "\133", "\173", 
-null, "\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+"\50", "\51", "\72", "\136", null, null, null, "\133", "\173", null, "\124\117", 
+"\135", null, null, "\124\117", "\175", null, null, };
 
 /** Lexer state names. */
 public static final String[] lexStateNames = {
@@ -1072,18 +919,18 @@
 
 /** Lex State array. */
 public static final int[] jjnewLexState = {
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 
-   3, -1, 3, -1, -1, -1, 3, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, 2, 1, 3, -1, 3, 
+   -1, -1, -1, 3, -1, -1, 
 };
 static final long[] jjtoToken = {
-   0x3ffffff01L, 
+   0x7fffff01L, 
 };
 static final long[] jjtoSkip = {
    0x80L, 
 };
 protected JavaCharStream input_stream;
-private final int[] jjrounds = new int[36];
-private final int[] jjstateSet = new int[72];
+private final int[] jjrounds = new int[28];
+private final int[] jjstateSet = new int[56];
 protected char curChar;
 /** Constructor. */
 public StandardSyntaxParserTokenManager(JavaCharStream stream){
@@ -1110,7 +957,7 @@
 {
    int i;
    jjround = 0x80000001;
-   for (i = 36; i-- > 0;)
+   for (i = 28; i-- > 0;)
       jjrounds[i] = 0x80000000;
 }
 
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java	(revision 804409)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java	(working copy)
@@ -51,9 +51,9 @@
 import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.FuzzyQuery;
 import org.apache.lucene.search.IndexSearcher;
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(revision 804409)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(working copy)
@@ -54,10 +54,10 @@
 import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
 import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.FuzzyQuery;
 import org.apache.lucene.search.IndexSearcher;
