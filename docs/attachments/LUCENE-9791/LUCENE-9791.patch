diff --git a/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java b/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
index 41180b4cffa..8b2f9d716cf 100644
--- a/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
+++ b/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
@@ -40,9 +40,6 @@ import org.apache.lucene.util.ByteBlockPool.DirectAllocator;
 public final class BytesRefHash implements Accountable {
   private static final long BASE_RAM_BYTES =
       RamUsageEstimator.shallowSizeOfInstance(BytesRefHash.class)
-          +
-          // size of scratch1
-          RamUsageEstimator.shallowSizeOfInstance(BytesRef.class)
           +
           // size of Counter
           RamUsageEstimator.primitiveSizes.get(long.class);
@@ -54,7 +51,6 @@ public final class BytesRefHash implements Accountable {
   final ByteBlockPool pool;
   int[] bytesStart;
 
-  private final BytesRef scratch1 = new BytesRef();
   private int hashSize;
   private int hashHalfSize;
   private int hashMask;
@@ -174,8 +170,9 @@ public final class BytesRefHash implements Accountable {
   }
 
   private boolean equals(int id, BytesRef b) {
-    pool.setBytesRef(scratch1, bytesStart[id]);
-    return scratch1.bytesEquals(b);
+    final BytesRef scratch = new BytesRef();
+    pool.setBytesRef(scratch, bytesStart[id]);
+    return scratch.bytesEquals(b);
   }
 
   private boolean shrink(int targetSize) {
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestBytesRefHash.java b/lucene/core/src/test/org/apache/lucene/util/TestBytesRefHash.java
index 1368367202e..1921c8b3c76 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestBytesRefHash.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestBytesRefHash.java
@@ -16,14 +16,17 @@
  */
 package org.apache.lucene.util;
 
+import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
+import java.util.concurrent.atomic.AtomicInteger;
 import org.apache.lucene.util.BytesRefHash.MaxBytesLengthExceededException;
 import org.junit.Before;
 import org.junit.Test;
@@ -267,6 +270,44 @@ public class TestBytesRefHash extends LuceneTestCase {
     }
   }
 
+  @Test
+  public void testConcurrentFind() throws Exception {
+    int num = atLeast(2);
+    for (int j = 0; j < num; j++) {
+      List<String> strings = new ArrayList<>();
+      for (int i = 0; i < 797; i++) {
+        final String str = TestUtil.randomRealisticUnicodeString(random(), 1, 1000);
+        hash.add(new BytesRef(str));
+        assertTrue(strings.add(str));
+      }
+
+      AtomicInteger miss = new AtomicInteger();
+      Thread[] threads = new Thread[10];
+      for (int i = 0; i < threads.length; i++) {
+        int loops = atLeast(100);
+        threads[i] =
+            new Thread("t" + i) {
+              public void run() {
+                for (int k = 0; k < loops; k++) {
+                  BytesRef find = new BytesRef(strings.get(k % strings.size()));
+                  if (hash.find(find) < 0) {
+                    miss.incrementAndGet();
+                  }
+                }
+              }
+            };
+      }
+
+      for (Thread t : threads) t.start();
+      for (Thread t : threads) t.join();
+
+      assertEquals(0, miss.get());
+      hash.clear();
+      assertEquals(0, hash.size());
+      hash.reinit();
+    }
+  }
+
   @Test(expected = MaxBytesLengthExceededException.class)
   public void testLargeValue() {
     int[] sizes =
