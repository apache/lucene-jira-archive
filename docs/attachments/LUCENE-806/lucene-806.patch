Index: C:/workspace/Lucene trunk/src/java/org/apache/lucene/search/FieldSortedHitQueue.java
===================================================================
--- C:/workspace/Lucene trunk/src/java/org/apache/lucene/search/FieldSortedHitQueue.java	(revision 508357)
+++ C:/workspace/Lucene trunk/src/java/org/apache/lucene/search/FieldSortedHitQueue.java	(working copy)
@@ -17,11 +17,17 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.PriorityQueue;
 
 import java.io.IOException;
 import java.util.Locale;
+import java.util.concurrent.CountDownLatch;
 import java.text.Collator;
 
 /**
@@ -38,7 +44,6 @@
  */
 public class FieldSortedHitQueue
 extends PriorityQueue {
-
   /**
    * Creates a hit queue sorted by the given list of fields.
    * @param reader  Index to use.
@@ -54,7 +59,7 @@
     for (int i=0; i<n; ++i) {
       String fieldname = fields[i].getField();
       comparators[i] = getCachedComparator (reader, fieldname, fields[i].getType(), fields[i].getLocale(), fields[i].getFactory());
-      
+
       if (comparators[i].sortType() == SortField.STRING) {
     	  this.fields[i] = new SortField (fieldname, fields[i].getLocale(), fields[i].getReverse());
       } else {
@@ -89,7 +94,7 @@
   }
 
   // This overrides PriorityQueue.insert() so that insert(FieldDoc) that
-  // keeps track of the score isn't accidentally bypassed.  
+  // keeps track of the score isn't accidentally bypassed.
   // inherit javadoc
   public boolean insert(Object fdoc) {
     return insert((FieldDoc)fdoc);
@@ -144,7 +149,7 @@
   SortField[] getFields() {
     return fields;
   }
-  
+
   static ScoreDocComparator getCachedComparator (IndexReader reader, String field, int type, Locale locale, SortComparatorSource factory)
   throws IOException {
     if (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;
@@ -178,8 +183,15 @@
           comparator = comparatorFloat (reader, fieldname);
           break;
         case SortField.STRING:
-          if (locale != null) comparator = comparatorStringLocale (reader, fieldname, locale);
-          else comparator = comparatorString (reader, fieldname);
+          if (locale != null) {
+            if (usePerThreadLocaleComparators) {
+              comparator = comparatorStringLocalePerThread(reader, fieldname, locale);
+            } else {
+              comparator = comparatorStringLocale (reader, fieldname, locale);
+            }
+          } else {
+            comparator = comparatorString (reader, fieldname);
+          }
           break;
         case SortField.CUSTOM:
           comparator = factory.newComparator (reader, fieldname);
@@ -293,25 +305,29 @@
    */
   static ScoreDocComparator comparatorStringLocale (final IndexReader reader, final String fieldname, final Locale locale)
   throws IOException {
-    final Collator collator = Collator.getInstance (locale);
     final String field = fieldname.intern();
     final String[] index = FieldCache.DEFAULT.getStrings (reader, field);
+    return comparatorStringLocale(reader, index, locale);
+  }
+
+  private static ScoreDocComparator comparatorStringLocale(final IndexReader reader, final String[] index, final Locale locale) {
+    final Collator collator = Collator.getInstance (locale);
+
     return new ScoreDocComparator() {
+        public final int compare(final ScoreDoc i, final ScoreDoc j) {
+            String is = index[i.doc];
+            String js = index[j.doc];
+            if (is == js) {
+                return 0;
+            } else if (is == null) {
+                return -1;
+            } else if (js == null) {
+                return 1;
+            } else {
+                return collator.compare(is, js);
+            }
+        }
 
-    	public final int compare(final ScoreDoc i, final ScoreDoc j) {
-			String is = index[i.doc];
-			String js = index[j.doc];
-			if (is == js) {
-				return 0;
-			} else if (is == null) {
-				return -1;
-			} else if (js == null) {
-				return 1;
-			} else {
-				return collator.compare(is, js);
-			}
-		}
-
       public Comparable sortValue (final ScoreDoc i) {
         return index[i.doc];
       }
@@ -322,6 +338,32 @@
     };
   }
 
+  static ScoreDocComparator comparatorStringLocalePerThread(final IndexReader reader, final String fieldname, final Locale locale)
+  throws IOException {
+    final String field = fieldname.intern();
+    final String[] index = FieldCache.DEFAULT.getStrings (reader, field);
+
+    return new ScoreDocComparator() {
+      ThreadLocal perThreadLocal = new ThreadLocal() {
+        protected Object initialValue() {
+          return comparatorStringLocale(reader, index, locale);
+        }
+      };
+
+      public int compare(ScoreDoc i, ScoreDoc j) {
+        return ((ScoreDocComparator) perThreadLocal.get()).compare(i, j);
+      }
+
+      public Comparable sortValue(ScoreDoc i) {
+        return ((ScoreDocComparator) perThreadLocal.get()).sortValue(i);
+      }
+
+      public int sortType() {
+        return ((ScoreDocComparator) perThreadLocal.get()).sortType();
+      }
+    };
+  }
+
   /**
    * Returns a comparator for sorting hits according to values in the given field.
    * The terms in the field are looked at to determine whether they contain integers,
@@ -348,4 +390,80 @@
       throw new RuntimeException ("unknown data type in field '"+field+"'");
     }
   }
+
+  private static boolean usePerThreadLocaleComparators = false;
+
+  public static boolean usePerThreadLocaleComparators() {
+    return usePerThreadLocaleComparators;
+  }
+
+  public static void setUsePerThreadLocaleComparators(
+      boolean usePerThreadLocaleComparators) {
+    FieldSortedHitQueue.usePerThreadLocaleComparators = usePerThreadLocaleComparators;
+  }
+
+  public static void main(String[] args) throws Exception {
+    long shared = runTest(false);
+    long perThread = runTest(true);
+    System.out.println("Shared=" + shared);
+    System.out.println("PerThread=" + perThread);
+  }
+
+  public static long runTest(boolean perThread) throws Exception {
+    RAMDirectory directory = new RAMDirectory();
+    IndexWriter writer =
+      new IndexWriter(directory, new WhitespaceAnalyzer(), true);
+
+    Document d1 = new Document();
+    d1.add(new Field("default","peach", Field.Store.YES, Field.Index.TOKENIZED));
+    writer.addDocument(d1);
+
+    Document d2 = new Document();
+    d2.add(new Field("default","p\u00EAche", Field.Store.YES, Field.Index.TOKENIZED));
+    writer.addDocument(d2);
+
+    Document d3 = new Document();
+    d3.add(new Field("default","p\u00E9ch\u00E9", Field.Store.YES, Field.Index.TOKENIZED));
+    writer.addDocument(d3);
+
+    writer.close();
+
+    final IndexReader reader = IndexReader.open(directory);
+
+    final int threadCount = 20;
+    final int docCount = 10000;
+    final int queueSize = 200;
+    final CountDownLatch startSignal = new CountDownLatch(1);
+    final CountDownLatch doneSignal = new CountDownLatch(threadCount);
+
+    FieldSortedHitQueue.setUsePerThreadLocaleComparators(perThread);
+    for (int i = 0; i < threadCount; ++i) {
+      new Thread(new Runnable() {
+        public void run() {
+          try {
+            startSignal.await();
+            FieldSortedHitQueue queue = new FieldSortedHitQueue(
+                reader,
+                new SortField[] { new SortField("default", Locale.CANADA_FRENCH) },
+                queueSize);
+            for (int i = 0; i < docCount; i++) {
+              queue.insert(new FieldDoc(i % 3, 0.1f));
+              if (i % 1000 == 0)
+                System.out.print(".");
+            }
+            doneSignal.countDown();
+          } catch (InterruptedException ex) {
+          } catch (IOException ex) {
+          }
+        }
+      }).start();
+    }
+
+    long start = System.currentTimeMillis();
+    startSignal.countDown();
+    doneSignal.await();
+    System.out.println();
+    long end = System.currentTimeMillis();
+    return end - start;
+  }
 }
