Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(revision 1673463)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(working copy)
@@ -604,7 +604,9 @@
     w.commit();
 
     DirectoryReader reader = w.getReader();
-    final IndexSearcher searcher = newSearcher(reader);
+    // not LuceneTestCase.newSearcher to not have the asserting wrappers
+    // and do instanceof checks
+    final IndexSearcher searcher = new IndexSearcher(reader);
     searcher.setQueryCache(null); // to still have approximations
 
     PhraseQuery pq = new PhraseQuery();
@@ -666,7 +668,9 @@
     w.commit();
 
     DirectoryReader reader = w.getReader();
-    final IndexSearcher searcher = newSearcher(reader);
+    // not LuceneTestCase.newSearcher to not have the asserting wrappers
+    // and do instanceof checks
+    final IndexSearcher searcher = new IndexSearcher(reader);
     searcher.setQueryCache(null); // to still have approximations
 
     PhraseQuery pq = new PhraseQuery();
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java	(revision 1673463)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java	(working copy)
@@ -122,7 +122,7 @@
     IndexReader r = w.getReader();
     w.close();
 
-    IndexSearcher s = newSearcher(r);
+    IndexSearcher s = new IndexSearcher(r);
     BooleanQuery q1 = new BooleanQuery();
     q1.add(new TermQuery(new Term("field", "little")), BooleanClause.Occur.SHOULD);
     q1.add(new TermQuery(new Term("field", "diseases")), BooleanClause.Occur.SHOULD);
Index: lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java	(revision 1673463)
+++ lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java	(working copy)
@@ -65,21 +65,6 @@
       }
 
       @Override
-      public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
-        Scorer scorer = w.scorer(context, acceptDocs);
-        if (scorer != null) {
-          // check that scorer obeys disi contract for docID() before next()/advance
-          try {
-            int docid = scorer.docID();
-            assert docid == -1 || docid == DocIdSetIterator.NO_MORE_DOCS;
-          } catch (UnsupportedOperationException ignored) {
-            // from a top-level BS1
-          }
-        }
-        return scorer;
-      }
-
-      @Override
       public float getValueForNormalization() {
         throw new IllegalStateException("Weight already normalized.");
       }
@@ -88,6 +73,12 @@
   }
 
   @Override
+  public Weight createWeight(Query query, boolean needsScores) throws IOException {
+    // this adds assertions to the inner weights/scorers too
+    return new AssertingWeight(random, super.createWeight(query, needsScores));
+  }
+
+  @Override
   public Query rewrite(Query original) throws IOException {
     // TODO: use the more sophisticated QueryUtils.check sometimes!
     QueryUtils.check(original);
Index: lucene/test-framework/src/java/org/apache/lucene/search/AssertingLeafCollector.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/AssertingLeafCollector.java	(revision 1673463)
+++ lucene/test-framework/src/java/org/apache/lucene/search/AssertingLeafCollector.java	(working copy)
@@ -41,7 +41,7 @@
   @Override
   public void setScorer(Scorer scorer) throws IOException {
     this.scorer = scorer;
-    super.setScorer(AssertingScorer.getAssertingScorer(random, scorer));
+    super.setScorer(AssertingScorer.wrap(random, scorer));
   }
 
   @Override
Index: lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java	(revision 1673463)
+++ lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java	(working copy)
@@ -18,51 +18,22 @@
  */
 
 import java.io.IOException;
-import java.lang.ref.WeakReference;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.Map;
 import java.util.Random;
-import java.util.WeakHashMap;
 
 /** Wraps a Scorer with additional checks */
 public class AssertingScorer extends Scorer {
-  
-  // TODO: add asserts for two-phase intersection
 
-  static enum IteratorState { START, ITERATING, FINISHED };
+  static enum IteratorState { START, APPROXIMATING, ITERATING, FINISHED };
 
-  // we need to track scorers using a weak hash map because otherwise we
-  // could loose references because of eg.
-  // AssertingScorer.score(Collector) which needs to delegate to work correctly
-  private static Map<Scorer, WeakReference<AssertingScorer>> ASSERTING_INSTANCES = Collections.synchronizedMap(new WeakHashMap<Scorer, WeakReference<AssertingScorer>>());
-
   public static Scorer wrap(Random random, Scorer other) {
     if (other == null || other instanceof AssertingScorer) {
       return other;
     }
-    final AssertingScorer assertScorer = new AssertingScorer(random, other);
-    ASSERTING_INSTANCES.put(other, new WeakReference<>(assertScorer));
-    return assertScorer;
+    return new AssertingScorer(random, other);
   }
 
-  static Scorer getAssertingScorer(Random random, Scorer other) {
-    if (other == null || other instanceof AssertingScorer) {
-      return other;
-    }
-    final WeakReference<AssertingScorer> assertingScorerRef = ASSERTING_INSTANCES.get(other);
-    final AssertingScorer assertingScorer = assertingScorerRef == null ? null : assertingScorerRef.get();
-    if (assertingScorer == null) {
-      // can happen in case of memory pressure or if
-      // scorer1.score(collector) calls
-      // collector.setScorer(scorer2) with scorer1 != scorer2, such as
-      // BooleanScorer. In that case we can't enable all assertions
-      return new AssertingScorer(random, other);
-    } else {
-      return assertingScorer;
-    }
-  }
-
   final Random random;
   final Scorer in;
 
@@ -80,12 +51,13 @@
   }
 
   boolean iterating() {
+    // we cannot assert that state == ITERATING because of CachingScorerWrapper
     switch (docID()) {
     case -1:
     case NO_MORE_DOCS:
       return false;
     default:
-      return true;
+      return state != IteratorState.APPROXIMATING; // Matches must be confirmed before calling freq() or score()
     }
   }
 
@@ -114,6 +86,7 @@
 
   @Override
   public int docID() {
+    assert state != IteratorState.APPROXIMATING : "calling docId() on the Scorer while the match has not been confirmed";
     return in.docID();
   }
 
@@ -155,5 +128,70 @@
   public String toString() {
     return "AssertingScorer(" + in + ")";
   }
+
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    final TwoPhaseIterator in = this.in.asTwoPhaseIterator();
+    if (in == null) {
+      return null;
+    }
+    final DocIdSetIterator inApproximation = in.approximation();
+    assert inApproximation.docID() == doc;
+    final DocIdSetIterator assertingApproximation = new DocIdSetIterator() {
+
+      @Override
+      public int docID() {
+        return inApproximation.docID();
+      }
+
+      @Override
+      public int nextDoc() throws IOException {
+        assert state != IteratorState.FINISHED : "advance() called after NO_MORE_DOCS";
+        final int nextDoc = inApproximation.nextDoc();
+        assert nextDoc > doc : "backwards advance from: " + doc + " to: " + nextDoc;
+        if (nextDoc == NO_MORE_DOCS) {
+          state = IteratorState.FINISHED;
+        } else {
+          state = IteratorState.APPROXIMATING;
+        }
+        assert inApproximation.docID() == nextDoc;
+        return nextDoc;
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+        assert state != IteratorState.FINISHED : "advance() called after NO_MORE_DOCS";
+        assert target > doc : "target must be > docID(), got " + target + " <= " + doc;
+        final int advanced = inApproximation.advance(target);
+        assert advanced >= target : "backwards advance from: " + target + " to: " + advanced;
+        if (advanced == NO_MORE_DOCS) {
+          state = IteratorState.FINISHED;
+        } else {
+          state = IteratorState.APPROXIMATING;
+        }
+        assert inApproximation.docID() == advanced;
+        return advanced;
+      }
+
+      @Override
+      public long cost() {
+        return inApproximation.cost();
+      }
+
+    };
+    return new TwoPhaseIterator(assertingApproximation) {
+      @Override
+      public boolean matches() throws IOException {
+        assert state == IteratorState.APPROXIMATING;
+        final boolean matches = in.matches();
+        if (matches) {
+          assert AssertingScorer.this.in.docID() == inApproximation.docID() : "Approximation and scorer don't advance synchronously";
+          doc = inApproximation.docID();
+          state = IteratorState.ITERATING;
+        }
+        return matches;
+      }
+    };
+  }
 }
 
