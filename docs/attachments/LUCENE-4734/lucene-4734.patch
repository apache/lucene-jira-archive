diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList.java b/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList.java
index 4b564d2..f764adc 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList.java
@@ -75,33 +75,33 @@
       
       // if found, search the longest phrase
       phraseCandidate.add( ti );
-      while( true ){
-        ti = fieldTermStack.pop();
-        nextMap = null;
-        if( ti != null )
-          nextMap = currMap.getTermMap( ti.getText() );
-        if( ti == null || nextMap == null ){
-          if( ti != null )
-            fieldTermStack.push( ti );
-          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){
-            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );
-          }
-          else{
-            while( phraseCandidate.size() > 1 ){
-              fieldTermStack.push( phraseCandidate.removeLast() );
-              currMap = fieldQuery.searchPhrase( field, phraseCandidate );
-              if( currMap != null ){
-                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );
-                break;
-              }
-            }
-          }
+      int longest = currMap.isTerminal() ? 1 : 0;
+      for( TermInfo nextTerm : fieldTermStack.termList ){
+        // done searching if a dead or terminal state is reached
+        if(currMap.subMap.isEmpty()) {
           break;
         }
-        else{
-          phraseCandidate.add( ti );
-          currMap = nextMap;
+        
+        nextMap = currMap.getTermMap( nextTerm.getText() );
+        
+        // done searching if the next term is not within the max slop range
+        if( ( nextMap == null && currMap.maxSlop == 0 ) || !currMap.isValidSlop( ti.getPosition(), nextTerm.getPosition() ) ) {
+          break;
         }
+
+        if( nextMap != null ) {
+          phraseCandidate.add( nextTerm );
+          if( nextMap.isValidTermOrPhrase(phraseCandidate) ) {
+            longest = phraseCandidate.size();
+          }
+          currMap = nextMap;
+          ti = nextTerm;
+        }
+      }
+      
+      if( longest > 0 ) {
+        //TODO: it would be faster to add every phrase to a list, sort by start offset then filter out overlaps
+        addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate.subList(0, longest), currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );
       }
     }
   }
@@ -159,11 +159,11 @@
       return termsInfos;
     }
 
-    public WeightedPhraseInfo( LinkedList<TermInfo> terms, float boost ){
+    public WeightedPhraseInfo( List<TermInfo> terms, float boost ){
       this( terms, boost, 0 );
     }
     
-    public WeightedPhraseInfo( LinkedList<TermInfo> terms, float boost, int seqnum ){
+    public WeightedPhraseInfo( List<TermInfo> terms, float boost, int seqnum ){
       this.boost = boost;
       this.seqnum = seqnum;
       
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java b/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java
index 50ad247..69c921c 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java
@@ -325,6 +325,7 @@
 
     boolean terminal;
     int slop;   // valid if terminal == true and phraseHighlight == true
+    int maxSlop = 0; // valid if phraseHighlight == true
     float boost;  // valid if terminal == true
     int termOrPhraseNumber;   // valid if terminal == true
     FieldQuery fieldQuery;
@@ -348,20 +349,57 @@
       return map;
     }
 
-      void add( Query query, IndexReader reader ) {
+    void add( Query query, IndexReader reader ) {
       if( query instanceof TermQuery ){
         addTerm( ((TermQuery)query).getTerm(), query.getBoost() );
       }
       else if( query instanceof PhraseQuery ){
         PhraseQuery pq = (PhraseQuery)query;
         Term[] terms = pq.getTerms();
+        int[] positions = pq.getPositions();
+        int slop = pq.getSlop();
+        
+        // add largest position increment to slop
+        if (positions.length > 0) {
+          int lastPos = positions[0];
+          int largestInc = 0;
+          int sz = positions.length;
+          for (int i = 1; i < sz; i++) {
+            int pos = positions[i];
+            int inc = pos - lastPos;
+            if (inc > largestInc) {
+              largestInc = inc;
+            }
+            lastPos = pos;
+          }
+          if(largestInc > 1) {
+            slop += largestInc;
+          }
+        }
+        
         Map<String, QueryPhraseMap> map = subMap;
         QueryPhraseMap qpm = null;
         for( Term term : terms ){
           qpm = getOrNewMap( map, term.text() );
+          if( slop > qpm.maxSlop ){
+        	  qpm.maxSlop = slop;
+          }
           map = qpm.subMap;
         }
         qpm.markTerminal( pq.getSlop(), pq.getBoost() );
+        
+        // add the terms in reverse order for phrases with slop
+        if( pq.getSlop() > 1 && terms.length > 1) {
+          map = subMap;
+          for( int i = terms.length - 1; i >= 0; --i ){
+            qpm = getOrNewMap( map, terms[i].text() );
+            if( slop > qpm.maxSlop ){
+                qpm.maxSlop = slop;
+              }
+            map = qpm.subMap;
+          }
+          qpm.markTerminal( pq.getSlop() - 2, pq.getBoost() );
+        }
       }
       else
         throw new RuntimeException( "query \"" + query.toString() + "\" must be flatten first." );
@@ -382,6 +420,10 @@
       this.termOrPhraseNumber = fieldQuery.nextTermOrPhraseNumber();
     }
     
+    public boolean isValidSlop( int prevPos, int nextPos) {
+      return Math.abs( nextPos - prevPos - 1 ) <= maxSlop;
+    }
+    
     public boolean isTerminal(){
       return terminal;
     }
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldPhraseListTest.java b/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldPhraseListTest.java
index 45054e6..4780576 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldPhraseListTest.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldPhraseListTest.java
@@ -121,6 +121,30 @@
     assertEquals( 9, fpl.phraseList.get( 0 ).getEndOffset() );
   }
   
+  public void testProximityPhraseReverse() throws Exception {
+    make1d1fIndex( "z a a b c" );
+
+    FieldQuery fq = new FieldQuery( pqF( 2F, 3, "c", "a" ), true, true );
+    FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
+    FieldPhraseList fpl = new FieldPhraseList( stack, fq );
+    assertEquals( 1, fpl.phraseList.size() );
+    assertEquals( "ac(2.0)((4,5)(8,9))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 4, fpl.phraseList.get( 0 ).getStartOffset() );
+    assertEquals( 9, fpl.phraseList.get( 0 ).getEndOffset() );
+  }
+  
+  public void testProximityPhraseWithRepeatedTerms() throws Exception {
+    make1d1fIndex( "z a a b b z d" );
+
+    FieldQuery fq = new FieldQuery( pqF( 2F, 2, "a", "b", "d" ), true, true );
+    FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
+    FieldPhraseList fpl = new FieldPhraseList( stack, fq );
+    assertEquals( 1, fpl.phraseList.size() );
+    assertEquals( "abd(2.0)((2,3)(6,7)(12,13))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 2, fpl.phraseList.get( 0 ).getStartOffset() );
+    assertEquals( 13, fpl.phraseList.get( 0 ).getEndOffset() );
+  }
+  
   public void test2PhrasesOverlap() throws Exception {
     make1d1fIndex( "d a b c d" );
 
@@ -134,6 +158,34 @@
     assertEquals( "abc(1.0)((2,7))", fpl.phraseList.get( 0 ).toString() );
   }
   
+  public void test2PhraseSlopOverlap() throws Exception {
+    make1d1fIndex( "z a b z d e z" );
+
+    BooleanQuery query = new BooleanQuery();
+    query.add( pqF( 1F, 4, "a", "d" ), Occur.SHOULD );
+    query.add( pqF( 1F, 4, "b", "e" ), Occur.SHOULD );
+    FieldQuery fq = new FieldQuery( query, true, true );
+    FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
+    FieldPhraseList fpl = new FieldPhraseList( stack, fq );
+    assertEquals( 1, fpl.phraseList.size() );
+    assertEquals( "ad(1.0)((2,3)(8,9))", fpl.phraseList.get( 0 ).toString() );
+    //assertEquals( "be(1.0)((4,5)(10,11))", fpl.phraseList.get( 1 ).toString() );
+  }
+  
+  public void testPhraseTermSlopOverlap() throws Exception {
+    make1d1fIndex( "z a b z d e z" );
+
+    BooleanQuery query = new BooleanQuery();
+    query.add( pqF( 1F, 4, "a", "d" ), Occur.SHOULD );
+    query.add( tq( "b" ), Occur.SHOULD );
+    FieldQuery fq = new FieldQuery( query, true, true );
+    FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
+    FieldPhraseList fpl = new FieldPhraseList( stack, fq );
+    assertEquals( 1, fpl.phraseList.size() );
+    assertEquals( "ad(1.0)((2,3)(8,9))", fpl.phraseList.get( 0 ).toString() );
+    //assertEquals( "b(1.0)((4,5))", fpl.phraseList.get( 1 ).toString() );
+  }
+  
   public void test3TermsPhrase() throws Exception {
     make1d1fIndex( "d a b a b c d" );
 