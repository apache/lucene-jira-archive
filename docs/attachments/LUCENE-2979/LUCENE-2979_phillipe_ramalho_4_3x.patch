Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java	(revision 0)
@@ -0,0 +1,167 @@
+package org.apache.lucene.queryParser.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.HashMap;
+
+import org.apache.lucene.util.Attribute;
+import org.apache.lucene.util.AttributeSource;
+
+/**
+ * <p>
+ * This class is the base of {@link QueryConfigHandler} and {@link FieldConfig}.
+ * It has operations to set, unset and get configuration values.
+ * </p>
+ * <p>
+ * Each configuration is is a key->value pair. The key should be an unique
+ * {@link ConfigurationKey} instance and it also holds the value's type.
+ * </p>
+ * 
+ * NOTE: in future this class will no longer extend {@link AttributeSource}
+ * 
+ * @see ConfigurationKey
+ */
+public abstract class AbstractQueryConfig extends AttributeSource {
+  
+  final private HashMap<ConfigurationKey<?>, Object> configMap = new HashMap<ConfigurationKey<?>, Object>();
+  
+  AbstractQueryConfig() {
+    // although this class is public, it can only be constructed from package
+  }
+  
+  /**
+   * Returns the value held by the given key.
+   * 
+   * @param <T> the value's type
+   * 
+   * @param key the key, cannot be <code>null</code>
+   * 
+   * @return the value held by the given key
+   */
+  @SuppressWarnings("unchecked")
+  public <T> T get(ConfigurationKey<T> key) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    return (T) this.configMap.get(key);
+    
+  }
+
+  /**
+   * Returns the value held by the given key or the given default value if the
+   * key is not found.
+   * 
+   * @param <T> the value's type
+   * 
+   * @param key the key, cannot be <code>null</code>
+   * @param defaultValue the default value
+   * 
+   * @return the value held by the given key or the default value
+   */
+  @SuppressWarnings("unchecked")
+  public <T> T get(ConfigurationKey<T> key, T defaultValue) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    if (this.configMap.containsKey(key)) {
+      return (T) this.configMap.get(key);
+    } else {
+      return defaultValue;
+    }
+    
+  }
+
+  /**
+   * Returns true if there is a value set with the given key, otherwise false.
+   * 
+   * @param <T> @param <T> the value's type
+   * @param key the key, cannot be <code>null</code>
+   * @return true if there is a value set with the given key, otherwise false
+   */
+  public <T> boolean has(ConfigurationKey<T> key) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    return this.configMap.containsKey(key);
+    
+  }
+  
+  /**
+   * Sets a key and its value.
+   * 
+   * @param <T> the value's type
+   * @param key the key, cannot be <code>null</code>
+   * @param value
+   */
+  public <T> void set(ConfigurationKey<T> key, T value) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    if (value == null) {
+      unset(key);
+      
+    } else {
+      this.configMap.put(key, value);
+    }
+    
+  }
+  
+  @SuppressWarnings("deprecation")
+  @Override
+  public <A extends Attribute> A addAttribute(Class<A> attClass) {
+    
+    if (hasAttribute(attClass)) {
+      return getAttribute(attClass);
+    } else {
+      A attr = super.addAttribute(attClass);
+      
+      if (attr instanceof ConfigAttribute) {
+        ((ConfigAttribute) attr).setQueryConfigHandler(this);
+      }
+      
+      return attr;
+    }
+    
+  }
+
+  /**
+   * Unsets the given key and its value.
+   * 
+   * @param <T> the value's type
+   * @param key the key
+   * @return true if the key and value was set and removed, otherwise false
+   */
+  public <T> boolean unset(ConfigurationKey<T> key) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    return this.configMap.remove(key) != null;
+    
+  }
+  
+}

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java
___________________________________________________________________
Added: svn:eol-style
   + native
Added: svn:keywords
   + Rev Date

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigAttribute.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigAttribute.java	(revision 0)
@@ -0,0 +1,18 @@
+package org.apache.lucene.queryParser.core.config;
+
+import org.apache.lucene.util.Attribute;
+
+/**
+ * This class should be used by every class that extends {@link Attribute} to
+ * configure a {@link QueryConfigHandler}. It will be removed soon, it is only
+ * used during the transition from old configuration API to new configuration
+ * API.
+ * 
+ * @deprecated
+ */
+@Deprecated
+public interface ConfigAttribute {
+
+  void setQueryConfigHandler(AbstractQueryConfig config);
+  
+}

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigAttribute.java
___________________________________________________________________
Added: svn:eol-style
   + native
Added: svn:keywords
   + Rev Date

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java	(revision 0)
@@ -0,0 +1,42 @@
+package org.apache.lucene.queryParser.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * An instance of this class represents a key that is used to retrieve a value
+ * from {@link AbstractQueryConfig}. It also holds the value's type, which is
+ * defined in the generic argument.
+ * 
+ * @see AbstractQueryConfig
+ */
+final public class ConfigurationKey<T> {
+  
+  private ConfigurationKey() {}
+  
+  /**
+   * Creates a new instance.
+   * 
+   * @param <T> the value's type
+   * 
+   * @return a new instance
+   */
+  public static <T> ConfigurationKey<T> newInstance() {
+    return new ConfigurationKey<T>();
+  }
+  
+}

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java
___________________________________________________________________
Added: svn:eol-style
   + native
Added: svn:keywords
   + Rev Date

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfig.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfig.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfig.java	(working copy)
@@ -27,7 +27,7 @@
  * @see QueryConfigHandler
  * @see org.apache.lucene.util.Attribute
  */
-public class FieldConfig extends AttributeSource {
+public class FieldConfig extends AbstractQueryConfig {
 
   private String fieldName;
 
@@ -83,7 +83,7 @@
 
   @Override
   public String toString() {
-    return "<fieldconfig name=\"" + this.fieldName + "\" attributes=\""
+    return "<fieldconfig name=\"" + this.fieldName + "\" configurations=\""
         + super.toString() + "\"/>";
   }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfigListener.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfigListener.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfigListener.java	(working copy)
@@ -20,7 +20,7 @@
 /**
  * This interface should be implemented by classes that wants to listen for
  * field configuration requests. The implementation receives a
- * {@link FieldConfig} object and may add/change its attributes.
+ * {@link FieldConfig} object and may add/change its configuration.
  * 
  * @see FieldConfig
  * @see QueryConfigHandler
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java	(working copy)
@@ -43,8 +43,9 @@
  * @see FieldConfig
  * @see FieldConfigListener
  * @see QueryConfigHandler
+ * 
  */
-public abstract class QueryConfigHandler extends AttributeSource {
+public abstract class QueryConfigHandler extends AbstractQueryConfig {
 
   private LinkedList<FieldConfigListener> listeners = new LinkedList<FieldConfigListener>();
 
@@ -92,7 +93,7 @@
     return fieldConfig;
 
   }
-
+  
   /**
    * Adds a listener. The added listeners are called in the order they are
    * added.
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/package.html
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/package.html	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/package.html	(working copy)
@@ -25,7 +25,7 @@
 
 <h2>Query Configuration Interfaces</h2>
 <p>
-The package <tt>org.apache.lucene.queryParser.config</tt> contains query configuration handler
+The package <tt>org.apache.lucene.queryParser.core.config</tt> contains query configuration handler
 abstract class that all config handlers should extend.
 </p>
 <p>
@@ -33,18 +33,33 @@
 implementation.
 </p>
 <p>
-{@link org.apache.lucene.queryParser.core.config.FieldConfig} and {@link org.apache.lucene.queryParser.core.config.QueryConfigHandler}
- should use {@link org.apache.lucene.util.Attribute} to store all attributes
-required by the config implementation. See <tt>org.apache.lucene.queryParser.standard.config.*Attribute</tt>
-for reference implementation.
-</p>
-<p>
-The {@link org.apache.lucene.queryParser.core.config.QueryConfigHandler}, {@link org.apache.lucene.queryParser.core.config.FieldConfig},
- and {@link org.apache.lucene.util.Attribute}s are used in the processors to access config
+The {@link org.apache.lucene.queryParser.core.config.QueryConfigHandler} and {@link org.apache.lucene.queryParser.core.config.FieldConfig} are used in the processors to access config
 information in a flexible and independent way.
 See {@link org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor} for a 
 reference implementation.
 </p>
+<p>
+Since version 3.4, the configuration API has changed. It no longer uses {@link org.apache.lucene.util.Attribute} objects to configure
+a query parser. Instead, it uses {@link org.apache.lucene.queryParser.core.config.ConfigurationKey} objects to set any configuration
+to a {@link org.apache.lucene.queryParser.core.config.QueryConfigHandler}. For now, both configuration APIs are working, however, 
+they cannot be used at the same time. So if you start moving your code to the new API, move it completely or keep using the old API.
+</p>
+<p>
+Here is an example about how the new configuration API works:
+ <blockquote> 
+ <pre>
+
+...
+// this constant will be the key to get and set your configuration. This should be unique in your application.
+final public static {@link org.apache.lucene.queryParser.core.config.ConfigurationKey}<{@link java.text.NumberFormat}> MY_CONFIG = {@link org.apache.lucene.queryParser.core.config.ConfigurationKey}.newInstance();
+...
+// make sure to use your unique key instance to set and get your configuration
+queryConfigHandler.set(MY_CONFIG, {@link java.text.NumberFormat}.getInstance());
+{@link java.text.NumberFormat} numberFormat = queryConfigHandler.get(MY_CONFIG);
+...
+ </blockquote> 
+ </pre>
+</p>
 </body>
 </html
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/BooleanModifiersQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/BooleanModifiersQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/BooleanModifiersQueryNodeProcessor.java	(working copy)
@@ -29,8 +29,9 @@
 import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode.Modifier;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.precedence.PrecedenceQueryParser;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
 
 /**
  * <p>
@@ -44,7 +45,7 @@
  * if it is, the same operation when an {@link AndQueryNode} is found is applied to it.
  * </p>
  * 
- * @see DefaultOperatorAttribute
+ * @see ConfigurationKeys#DEFAULT_OPERATOR
  * @see PrecedenceQueryParser#setDefaultOperator
  */
 public class BooleanModifiersQueryNodeProcessor extends QueryNodeProcessorImpl {
@@ -59,14 +60,14 @@
 
   @Override
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-
-    if (!getQueryConfigHandler().hasAttribute(DefaultOperatorAttribute.class)) {
+    Operator op = getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
+    
+    if (op == null) {
       throw new IllegalArgumentException(
-          "DefaultOperatorAttribute should be set on the QueryConfigHandler");
+          "StandardQueryConfigHandler.ConfigurationKeys.DEFAULT_OPERATOR should be set on the QueryConfigHandler");
     }
 
-    this.usingAnd = Operator.AND == getQueryConfigHandler().getAttribute(
-        DefaultOperatorAttribute.class).getOperator();
+    this.usingAnd = StandardQueryConfigHandler.Operator.AND == op;
 
     return super.process(queryTree);
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java	(working copy)
@@ -36,17 +36,8 @@
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessor;
 import org.apache.lucene.queryParser.standard.builders.StandardQueryBuilder;
 import org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder;
-import org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute;
-import org.apache.lucene.queryParser.standard.config.AnalyzerAttribute;
-import org.apache.lucene.queryParser.standard.config.DateResolutionAttribute;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
-import org.apache.lucene.queryParser.standard.config.DefaultPhraseSlopAttribute;
-import org.apache.lucene.queryParser.standard.config.LocaleAttribute;
-import org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
-import org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute;
-import org.apache.lucene.queryParser.standard.config.RangeCollatorAttribute;
 import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
 import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
 import org.apache.lucene.search.BooleanClause;
@@ -136,11 +127,8 @@
 
   public Analyzer getAnalyzer() {
 
-    if (this.config != null
-        && this.config.hasAttribute(AnalyzerAttribute.class)) {
-
-      return this.config.getAttribute(AnalyzerAttribute.class).getAnalyzer();
-
+    if (this.config != null) {
+      return this.config.get(ConfigurationKeys.ANALYZER);
     }
 
     return null;
@@ -211,12 +199,8 @@
 
   public boolean getAllowLeadingWildcard() {
 
-    if (this.config != null
-        && this.config.hasAttribute(AllowLeadingWildcardAttribute.class)) {
-
-      return this.config.getAttribute(AllowLeadingWildcardAttribute.class)
-          .isAllowLeadingWildcard();
-
+    if (this.config != null) {
+      return this.config.get(ConfigurationKeys.ALLOW_LEADING_WILDCARD, false);
     }
 
     return false;
@@ -225,12 +209,9 @@
 
   public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
 
-    if (this.config != null
-        && this.config.hasAttribute(MultiTermRewriteMethodAttribute.class)) {
-
-      return this.config.getAttribute(MultiTermRewriteMethodAttribute.class)
-          .getMultiTermRewriteMethod();
-
+    if (this.config != null) {
+      return this.config.get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD,
+          MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
     }
 
     return MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;
@@ -243,14 +224,7 @@
       FieldConfig fieldConfig = this.config.getFieldConfig(fieldName);
 
       if (fieldConfig != null) {
-
-        if (this.config.hasAttribute(DateResolutionAttribute.class)) {
-
-          return this.config.getAttribute(DateResolutionAttribute.class)
-              .getDateResolution();
-
-        }
-
+        return fieldConfig.get(ConfigurationKeys.DATE_RESOLUTION);
       }
 
     }
@@ -261,12 +235,9 @@
 
   public boolean getEnablePositionIncrements() {
 
-    if (this.config != null
-        && this.config.hasAttribute(PositionIncrementsAttribute.class)) {
-
-      return this.config.getAttribute(PositionIncrementsAttribute.class)
-          .isPositionIncrementsEnabled();
-
+    if (this.config != null) {
+      return this.config.get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS,
+          false);
     }
 
     return false;
@@ -283,8 +254,8 @@
 
   public Locale getLocale() {
 
-    if (this.config != null && this.config.hasAttribute(LocaleAttribute.class)) {
-      return this.config.getAttribute(LocaleAttribute.class).getLocale();
+    if (this.config != null) {
+      return this.config.get(ConfigurationKeys.LOCALE, Locale.getDefault());
     }
 
     return Locale.getDefault();
@@ -293,12 +264,8 @@
 
   public boolean getLowercaseExpandedTerms() {
 
-    if (this.config != null
-        && this.config.hasAttribute(LowercaseExpandedTermsAttribute.class)) {
-
-      return this.config.getAttribute(LowercaseExpandedTermsAttribute.class)
-          .isLowercaseExpandedTerms();
-
+    if (this.config != null) {
+      return this.config.get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, true);
     }
 
     return true;
@@ -307,12 +274,8 @@
 
   public int getPhraseSlop() {
 
-    if (this.config != null
-        && this.config.hasAttribute(AllowLeadingWildcardAttribute.class)) {
-
-      return this.config.getAttribute(DefaultPhraseSlopAttribute.class)
-          .getDefaultPhraseSlop();
-
+    if (this.config != null) {
+      return this.config.get(ConfigurationKeys.PHRASE_SLOP, 0);
     }
 
     return 0;
@@ -321,12 +284,8 @@
 
   public Collator getRangeCollator() {
 
-    if (this.config != null
-        && this.config.hasAttribute(RangeCollatorAttribute.class)) {
-
-      return this.config.getAttribute(RangeCollatorAttribute.class)
-          .getRangeCollator();
-
+    if (this.config != null) {
+      return this.config.get(ConfigurationKeys.RANGE_COLLATOR);
     }
 
     return null;
@@ -383,11 +342,10 @@
 
   public Operator getDefaultOperator() {
 
-    if (this.config != null
-        && this.config.hasAttribute(DefaultOperatorAttribute.class)) {
+    if (this.config != null) {
 
-      return (this.config.getAttribute(DefaultOperatorAttribute.class)
-          .getOperator() == org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator.AND) ? AND_OPERATOR
+      return (this.config.get(ConfigurationKeys.DEFAULT_OPERATOR, org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator.OR)
+           == org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator.AND) ? AND_OPERATOR
           : OR_OPERATOR;
 
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java	(working copy)
@@ -23,27 +23,17 @@
 import java.util.TooManyListenersException;
 
 import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.DateTools.Resolution;
 import org.apache.lucene.document.DateTools;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.QueryParserHelper;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
 import org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder;
-import org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute;
-import org.apache.lucene.queryParser.standard.config.AnalyzerAttribute;
-import org.apache.lucene.queryParser.standard.config.DateResolutionAttribute;
 import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
-import org.apache.lucene.queryParser.standard.config.DefaultPhraseSlopAttribute;
-import org.apache.lucene.queryParser.standard.config.FieldBoostMapAttribute;
-import org.apache.lucene.queryParser.standard.config.FieldDateResolutionMapAttribute;
-import org.apache.lucene.queryParser.standard.config.FuzzyAttribute;
-import org.apache.lucene.queryParser.standard.config.LocaleAttribute;
-import org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute;
-import org.apache.lucene.queryParser.standard.config.MultiFieldAttribute;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
-import org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute;
-import org.apache.lucene.queryParser.standard.config.RangeCollatorAttribute;
+import org.apache.lucene.queryParser.standard.config.FuzzyConfig;
 import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
 import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
 import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
@@ -182,9 +172,8 @@
    * Gets implicit operator setting, which will be either {@link Operator#AND}
    * or {@link Operator#OR}.
    */
-  public Operator getDefaultOperator() {
-    DefaultOperatorAttribute attr = getQueryConfigHandler().getAttribute(DefaultOperatorAttribute.class);
-    return attr.getOperator();
+  public StandardQueryConfigHandler.Operator getDefaultOperator() {
+    return getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
   }
 
   /**
@@ -200,8 +189,7 @@
    *          the collator to use when constructing {@link RangeQueryNode}s
    */
   public void setRangeCollator(Collator collator) {
-    RangeCollatorAttribute attr = getQueryConfigHandler().getAttribute(RangeCollatorAttribute.class);
-    attr.setDateResolution(collator);
+    getQueryConfigHandler().set(ConfigurationKeys.RANGE_COLLATOR, collator);
   }
 
   /**
@@ -209,8 +197,7 @@
    *         RangeQuerys.
    */
   public Collator getRangeCollator() {
-    RangeCollatorAttribute attr = getQueryConfigHandler().getAttribute(RangeCollatorAttribute.class);
-    return attr.getRangeCollator();
+    return getQueryConfigHandler().get(ConfigurationKeys.RANGE_COLLATOR);
   }
 
   /**
@@ -220,10 +207,33 @@
    * <code>capital OR of OR Hungary</code>.<br/>
    * In {@link Operator#AND} mode terms are considered to be in conjunction: the
    * above mentioned query is parsed as <code>capital AND of AND Hungary</code>
+   * 
+   * @deprecated
+   */
+  @Deprecated
+  public void setDefaultOperator(DefaultOperatorAttribute.Operator operator) {
+    org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator newOperator;
+    
+    if (operator == DefaultOperatorAttribute.Operator.AND) {
+      newOperator = org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator.AND;
+    } else {
+      newOperator = org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator.OR;
+    }
+    
+    setDefaultOperator(newOperator);
+    
+  }
+  
+  /**
+   * Sets the boolean operator of the QueryParser. In default mode (
+   * {@link Operator#OR}) terms without any modifiers are considered optional:
+   * for example <code>capital of Hungary</code> is equal to
+   * <code>capital OR of OR Hungary</code>.<br/>
+   * In {@link Operator#AND} mode terms are considered to be in conjunction: the
+   * above mentioned query is parsed as <code>capital AND of AND Hungary</code>
    */
-  public void setDefaultOperator(Operator operator) {
-    DefaultOperatorAttribute attr = getQueryConfigHandler().getAttribute(DefaultOperatorAttribute.class);
-    attr.setOperator(operator);
+  public void setDefaultOperator(org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator operator) {
+    getQueryConfigHandler().set(ConfigurationKeys.DEFAULT_OPERATOR, operator);
   }
 
   /**
@@ -236,16 +246,22 @@
    * Default: false.
    */
   public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) {
-    LowercaseExpandedTermsAttribute attr = getQueryConfigHandler().getAttribute(LowercaseExpandedTermsAttribute.class);
-    attr.setLowercaseExpandedTerms(lowercaseExpandedTerms);
+    getQueryConfigHandler().set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, lowercaseExpandedTerms);
   }
 
   /**
    * @see #setLowercaseExpandedTerms(boolean)
    */
   public boolean getLowercaseExpandedTerms() {
-    LowercaseExpandedTermsAttribute attr = getQueryConfigHandler().getAttribute(LowercaseExpandedTermsAttribute.class);
-    return attr.isLowercaseExpandedTerms();
+    Boolean lowercaseExpandedTerms = getQueryConfigHandler().get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS);
+    
+    if (lowercaseExpandedTerms == null) {
+      return true;
+      
+    } else {
+      return lowercaseExpandedTerms;
+    }
+    
   }
 
   /**
@@ -258,8 +274,7 @@
    * Default: false.
    */
   public void setAllowLeadingWildcard(boolean allowLeadingWildcard) {
-    AllowLeadingWildcardAttribute attr = getQueryConfigHandler().getAttribute(AllowLeadingWildcardAttribute.class);
-    attr.setAllowLeadingWildcard(allowLeadingWildcard);
+    getQueryConfigHandler().set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, allowLeadingWildcard);
   }
 
   /**
@@ -272,16 +287,22 @@
    * Default: false.
    */
   public void setEnablePositionIncrements(boolean enabled) {
-    PositionIncrementsAttribute attr = getQueryConfigHandler().getAttribute(PositionIncrementsAttribute.class);
-    attr.setPositionIncrementsEnabled(enabled);
+    getQueryConfigHandler().set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, enabled);
   }
 
   /**
    * @see #setEnablePositionIncrements(boolean)
    */
   public boolean getEnablePositionIncrements() {
-    PositionIncrementsAttribute attr = getQueryConfigHandler().getAttribute(PositionIncrementsAttribute.class);
-    return attr.isPositionIncrementsEnabled();
+    Boolean enablePositionsIncrements = getQueryConfigHandler().get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS);
+    
+    if (enablePositionsIncrements == null) {
+       return false;
+       
+    } else {
+      return enablePositionsIncrements;
+    }
+    
   }
 
   /**
@@ -295,95 +316,127 @@
    * not relevant then use this change the rewrite method.
    */
   public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method) {
-    MultiTermRewriteMethodAttribute attr = getQueryConfigHandler().getAttribute(MultiTermRewriteMethodAttribute.class);
-    attr.setMultiTermRewriteMethod(method);
+    getQueryConfigHandler().set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, method);
   }
 
   /**
    * @see #setMultiTermRewriteMethod(org.apache.lucene.search.MultiTermQuery.RewriteMethod)
    */
   public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
-    MultiTermRewriteMethodAttribute attr = getQueryConfigHandler().getAttribute(MultiTermRewriteMethodAttribute.class);    
-    return attr.getMultiTermRewriteMethod();
+    return getQueryConfigHandler().get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD);
   }
 
+  /**
+   * Set the fields a query should be expanded to when the field is
+   * <code>null</code>
+   * 
+   * @param fields the fields used to expand the query
+   */
   public void setMultiFields(CharSequence[] fields) {
 
     if (fields == null) {
       fields = new CharSequence[0];
     }
 
-    MultiFieldAttribute attr = getQueryConfigHandler().addAttribute(MultiFieldAttribute.class);
-    attr.setFields(fields);
+    getQueryConfigHandler().set(ConfigurationKeys.MULTI_FIELDS, fields);
 
   }
 
   /**
+   * Returns the fields used to expand the query when the field for a
+   * certain query is <code>null</code>
+   * 
+   * @param fields the fields used to expand the query
+   */
+  public void getMultiFields(CharSequence[] fields) {
+    getQueryConfigHandler().get(ConfigurationKeys.MULTI_FIELDS);
+  }
+
+  /**
    * Set the prefix length for fuzzy queries. Default is 0.
    * 
    * @param fuzzyPrefixLength
    *          The fuzzyPrefixLength to set.
    */
   public void setFuzzyPrefixLength(int fuzzyPrefixLength) {
-    FuzzyAttribute attr = getQueryConfigHandler().addAttribute(FuzzyAttribute.class);
-    attr.setPrefixLength(fuzzyPrefixLength);
+    QueryConfigHandler config = getQueryConfigHandler();
+    FuzzyConfig fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      fuzzyConfig = new FuzzyConfig();
+      config.set(ConfigurationKeys.FUZZY_CONFIG, fuzzyConfig);
+    }
+
+    fuzzyConfig.setPrefixLength(fuzzyPrefixLength);
+    
   }
 
   /**
    * Set locale used by date range parsing.
    */
   public void setLocale(Locale locale) {
-    LocaleAttribute attr = getQueryConfigHandler().addAttribute(LocaleAttribute.class);
-    attr.setLocale(locale);
+    getQueryConfigHandler().set(ConfigurationKeys.LOCALE, locale);
   }
 
   /**
    * Returns current locale, allowing access by subclasses.
    */
   public Locale getLocale() {
-    LocaleAttribute attr = getQueryConfigHandler().addAttribute(LocaleAttribute.class);
-    return attr.getLocale();
+    return getQueryConfigHandler().get(ConfigurationKeys.LOCALE);
   }
 
   /**
    * Sets the default slop for phrases. If zero, then exact phrase matches are
    * required. Default value is zero.
+   * 
+   * @deprecated renamed to {@link #setPhraseSlop(int)}
    */
+  @Deprecated
   public void setDefaultPhraseSlop(int defaultPhraseSlop) {
-    DefaultPhraseSlopAttribute attr = getQueryConfigHandler().addAttribute(DefaultPhraseSlopAttribute.class);
-    attr.setDefaultPhraseSlop(defaultPhraseSlop);
+    getQueryConfigHandler().set(ConfigurationKeys.PHRASE_SLOP, defaultPhraseSlop);
+  }
+  
+  /**
+   * Sets the default slop for phrases. If zero, then exact phrase matches are
+   * required. Default value is zero.
+   */
+  public void setPhraseSlop(int defaultPhraseSlop) {
+    getQueryConfigHandler().set(ConfigurationKeys.PHRASE_SLOP, defaultPhraseSlop);
   }
 
   public void setAnalyzer(Analyzer analyzer) {
-    AnalyzerAttribute attr = getQueryConfigHandler().getAttribute(AnalyzerAttribute.class);
-    attr.setAnalyzer(analyzer);
+    getQueryConfigHandler().set(ConfigurationKeys.ANALYZER, analyzer);
   }
   
   public Analyzer getAnalyzer() {    
-    QueryConfigHandler config = this.getQueryConfigHandler();
-
-    if ( config.hasAttribute(AnalyzerAttribute.class)) {
-      AnalyzerAttribute attr = config.getAttribute(AnalyzerAttribute.class);
-      return attr.getAnalyzer();
-    }
-
-    return null;       
+    return getQueryConfigHandler().get(ConfigurationKeys.ANALYZER);       
   }
 
   /**
    * @see #setAllowLeadingWildcard(boolean)
    */
   public boolean getAllowLeadingWildcard() {
-    AllowLeadingWildcardAttribute attr = getQueryConfigHandler().addAttribute(AllowLeadingWildcardAttribute.class);
-    return attr.isAllowLeadingWildcard();
+    Boolean allowLeadingWildcard = getQueryConfigHandler().get(ConfigurationKeys.ALLOW_LEADING_WILDCARD);
+    
+    if (allowLeadingWildcard == null) {
+      return false;
+      
+    } else {
+      return allowLeadingWildcard;
+    }
   }
 
   /**
    * Get the minimal similarity for fuzzy queries.
    */
   public float getFuzzyMinSim() {
-    FuzzyAttribute attr = getQueryConfigHandler().addAttribute(FuzzyAttribute.class);
-    return attr.getFuzzyMinSimilarity();
+    FuzzyConfig fuzzyConfig = getQueryConfigHandler().get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      return FuzzyQuery.defaultMinSimilarity;
+    } else {
+      return fuzzyConfig.getMinSimilarity();
+    }
   }
 
   /**
@@ -392,16 +445,27 @@
    * @return Returns the fuzzyPrefixLength.
    */
   public int getFuzzyPrefixLength() {
-    FuzzyAttribute attr = getQueryConfigHandler().addAttribute(FuzzyAttribute.class);
-    return attr.getPrefixLength();
+    FuzzyConfig fuzzyConfig = getQueryConfigHandler().get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      return FuzzyQuery.defaultPrefixLength;
+    } else {
+      return fuzzyConfig.getPrefixLength();
+    }
   }
 
   /**
    * Gets the default slop for phrases.
    */
   public int getPhraseSlop() {
-    DefaultPhraseSlopAttribute attr = getQueryConfigHandler().addAttribute(DefaultPhraseSlopAttribute.class);
-    return attr.getDefaultPhraseSlop();
+    Integer phraseSlop = getQueryConfigHandler().get(ConfigurationKeys.PHRASE_SLOP);
+    
+    if (phraseSlop == null) {
+      return 0;
+      
+    } else {
+      return phraseSlop;
+    }
   }
 
   /**
@@ -409,23 +473,83 @@
    * {@link FuzzyQuery#defaultMinSimilarity}.
    */
   public void setFuzzyMinSim(float fuzzyMinSim) {
-    FuzzyAttribute attr = getQueryConfigHandler().addAttribute(FuzzyAttribute.class);
-    attr.setFuzzyMinSimilarity(fuzzyMinSim);
+    QueryConfigHandler config = getQueryConfigHandler();
+    FuzzyConfig fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      fuzzyConfig = new FuzzyConfig();
+      config.set(ConfigurationKeys.FUZZY_CONFIG, fuzzyConfig);
+    }
+
+    fuzzyConfig.setMinSimilarity(fuzzyMinSim);
   }
   
+  /**
+   * Sets the boost used for each field.
+   * 
+   * @param boosts a collection that maps a field to its boost 
+   */
   public void setFieldsBoost(Map<String, Float> boosts) {
-    FieldBoostMapAttribute attr = getQueryConfigHandler().addAttribute(FieldBoostMapAttribute.class);
-    attr.setFieldBoostMap(boosts);
+    getQueryConfigHandler().set(ConfigurationKeys.FIELD_BOOST_MAP, boosts);
+  }
+  
+  /**
+   * Returns the field to boost map used to set boost for each field.
+   * 
+   * @return the field to boost map 
+   */
+  public Map<String, Float> getFieldsBoost() {
+    return getQueryConfigHandler().get(ConfigurationKeys.FIELD_BOOST_MAP);
   }
 
+  /**
+   * Sets the default {@link Resolution} used for certain field when
+   * no {@link Resolution} is defined for this field.
+   * 
+   * @param dateResolution the default {@link Resolution}
+   */
   public void setDateResolution(DateTools.Resolution dateResolution) {
-    DateResolutionAttribute attr = getQueryConfigHandler().addAttribute(DateResolutionAttribute.class);
-    attr.setDateResolution(dateResolution);
+    getQueryConfigHandler().set(ConfigurationKeys.DATE_RESOLUTION, dateResolution);
+  }
+  
+  /**
+   * Returns the default {@link Resolution} used for certain field when
+   * no {@link Resolution} is defined for this field.
+   * 
+   * @return the default {@link Resolution}
+   */
+  public DateTools.Resolution getDateResolution() {
+    return getQueryConfigHandler().get(ConfigurationKeys.DATE_RESOLUTION);
   }
 
+  /**
+   * Sets the {@link Resolution} used for each field
+   * 
+   * @param dateRes a collection that maps a field to its {@link Resolution}
+   * 
+   * @deprecated this method was renamed to {@link #setDateResolutionMap(Map)} 
+   */
+  @Deprecated
   public void setDateResolution(Map<CharSequence, DateTools.Resolution> dateRes) {
-    FieldDateResolutionMapAttribute attr = getQueryConfigHandler().addAttribute(FieldDateResolutionMapAttribute.class);
-    attr.setFieldDateResolutionMap(dateRes);
+    setDateResolutionMap(dateRes);
+  }
+  
+  /**
+   * Returns the field to {@link Resolution} map used to normalize each date field.
+   * 
+   * @return the field to {@link Resolution} map
+   */
+  public Map<CharSequence, DateTools.Resolution> getDateResolutionMap() {
+    return getQueryConfigHandler().get(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP);
+  }
+  
+  /**
+   * Sets the {@link Resolution} used for each field
+   * 
+   * @param dateRes a collection that maps a field to its {@link Resolution}
+   */
+  public void setDateResolutionMap(Map<CharSequence, DateTools.Resolution> dateRes) {
+    getQueryConfigHandler().set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, dateRes);
   }
   
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java	(working copy)
@@ -20,8 +20,8 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
+import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.PrefixQuery;
 
@@ -42,7 +42,7 @@
     String text = wildcardNode.getText().subSequence(0, wildcardNode.getText().length() - 1).toString();
     PrefixQuery q = new PrefixQuery(new Term(wildcardNode.getFieldAsString(), text));
     
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
     if (method != null) {
       q.setRewriteMethod(method);
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java	(working copy)
@@ -21,8 +21,8 @@
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
+import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.TermRangeQuery;
 
@@ -57,7 +57,9 @@
         .getTextAsString(), upper.getTextAsString(), lowerInclusive,
         upperInclusive, rangeNode.getCollator());
     
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod) queryNode
+        .getTag(MultiTermRewriteMethodProcessor.TAG_ID);
+    
     if (method != null) {
       rangeQuery.setRewriteMethod(method);
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java	(working copy)
@@ -20,8 +20,8 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.WildcardQuery;
 
@@ -41,7 +41,7 @@
     WildcardQuery q = new WildcardQuery(new Term(wildcardNode.getFieldAsString(),
                                                  wildcardNode.getTextAsString()));
     
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
     if (method != null) {
       q.setRewriteMethod(method);
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttribute.java	(working copy)
@@ -26,7 +26,10 @@
  * must be defined in the {@link QueryConfigHandler}. It basically tells the
  * processor if it should allow leading wildcard. <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface AllowLeadingWildcardAttribute extends Attribute {
   public void setAllowLeadingWildcard(boolean allowLeadingWildcard);
   public boolean isAllowLeadingWildcard();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttributeImpl.java	(working copy)
@@ -17,7 +17,10 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.AllowLeadingWildcardProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -27,22 +30,25 @@
  * processor if it should allow leading wildcard. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute
+ * 
+ * @deprecated
  */
+@Deprecated
 public class AllowLeadingWildcardAttributeImpl extends AttributeImpl 
-				implements AllowLeadingWildcardAttribute {
+				implements AllowLeadingWildcardAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -2804763012723049527L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private boolean allowLeadingWildcard = false;  // default in 2.9
-
   public void setAllowLeadingWildcard(boolean allowLeadingWildcard) {
-    this.allowLeadingWildcard = allowLeadingWildcard;
+    config.set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, allowLeadingWildcard);
   }
 
   public boolean isAllowLeadingWildcard() {
-    return this.allowLeadingWildcard;
+    return config.get(ConfigurationKeys.ALLOW_LEADING_WILDCARD, false);
   }
 
   @Override
@@ -59,7 +65,7 @@
   public boolean equals(Object other) {
 
     if (other instanceof AllowLeadingWildcardAttributeImpl
-        && ((AllowLeadingWildcardAttributeImpl) other).allowLeadingWildcard == this.allowLeadingWildcard) {
+        && ((AllowLeadingWildcardAttributeImpl) other).isAllowLeadingWildcard() == isAllowLeadingWildcard()) {
 
       return true;
 
@@ -71,13 +77,22 @@
 
   @Override
   public int hashCode() {
-    return this.allowLeadingWildcard ? -1 : Integer.MAX_VALUE;
+    return isAllowLeadingWildcard() ? -1 : Integer.MAX_VALUE;
   }
 
   @Override
   public String toString() {
     return "<allowLeadingWildcard allowLeadingWildcard="
-        + this.allowLeadingWildcard + "/>";
+        + isAllowLeadingWildcard() + "/>";
+  }
+
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.ALLOW_LEADING_WILDCARD)) {
+     config.set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, false); // default in 2.9 
+    }
+    
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttribute.java	(working copy)
@@ -28,7 +28,10 @@
  * processor the {@link Analyzer}, if there is one, which will be used to
  * analyze the query terms. <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface AnalyzerAttribute extends Attribute {
   public void setAnalyzer(Analyzer analyzer);
   public Analyzer getAnalyzer();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttributeImpl.java	(working copy)
@@ -18,7 +18,10 @@
  */
 
 import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.AnalyzerQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -29,26 +32,28 @@
  * analyze the query terms. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.AnalyzerAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class AnalyzerAttributeImpl extends AttributeImpl 
-				implements AnalyzerAttribute {
+				implements AnalyzerAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -6804760312723049526L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private Analyzer analyzer;
-
-  public AnalyzerAttributeImpl() {
-    analyzer = null; //default value 2.4
-  }
+  public AnalyzerAttributeImpl() {}
 
   public void setAnalyzer(Analyzer analyzer) {
-    this.analyzer = analyzer;
+    config.set(ConfigurationKeys.ANALYZER, analyzer);
   }
 
   public Analyzer getAnalyzer() {
-    return this.analyzer;
+    return config.get(ConfigurationKeys.ANALYZER);
   }
 
   @Override
@@ -66,10 +71,12 @@
 
     if (other instanceof AnalyzerAttributeImpl) {
     	AnalyzerAttributeImpl analyzerAttr = (AnalyzerAttributeImpl) other;
+    	Analyzer otherAnalyzer = analyzerAttr.getAnalyzer();
+    	Analyzer thisAnalyzer = getAnalyzer();
 
-      if (analyzerAttr.analyzer == this.analyzer
-          || (this.analyzer != null && analyzerAttr.analyzer != null && this.analyzer
-              .equals(analyzerAttr.analyzer))) {
+      if (otherAnalyzer == thisAnalyzer
+          || (thisAnalyzer != null && otherAnalyzer != null && thisAnalyzer
+              .equals(otherAnalyzer))) {
 
         return true;
 
@@ -83,12 +90,17 @@
 
   @Override
   public int hashCode() {
-    return (this.analyzer == null) ? 0 : this.analyzer.hashCode();
+    Analyzer analyzer = getAnalyzer();
+    return (analyzer == null) ? 0 : analyzer.hashCode();
+  }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
   }
 
   @Override
   public String toString() {
-    return "<analyzerAttribute analyzer='" + this.analyzer + "'/>";
+    return "<analyzerAttribute analyzer='" + getAnalyzer() + "'/>";
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttribute.java	(working copy)
@@ -28,7 +28,10 @@
  * defined to it. <br/>
  * <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface BoostAttribute extends Attribute {
   public void setBoost(float boost);
   public float getBoost();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttributeImpl.java	(working copy)
@@ -17,7 +17,10 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.FieldConfig;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.MultiFieldQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -29,26 +32,30 @@
  * <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.BoostAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class BoostAttributeImpl extends AttributeImpl 
-				implements BoostAttribute {
+				implements BoostAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -2104763012523049527L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private float boost = 1.0f;
-
   public BoostAttributeImpl() {
     // empty constructor
   }
 
   public void setBoost(float boost) {
-    this.boost = boost;
+    config.set(ConfigurationKeys.BOOST, boost);
   }
 
   public float getBoost() {
-    return this.boost;
+    return config.get(ConfigurationKeys.BOOST, 1.0f);
   }
 
   @Override
@@ -65,7 +72,7 @@
   public boolean equals(Object other) {
 
     if (other instanceof BoostAttributeImpl
-        && ((BoostAttributeImpl) other).boost == this.boost) {
+        && ((BoostAttributeImpl) other).getBoost() == getBoost()) {
 
       return true;
 
@@ -77,12 +84,21 @@
 
   @Override
   public int hashCode() {
-    return Float.valueOf(this.boost).hashCode();
+    return Float.valueOf(getBoost()).hashCode();
   }
 
   @Override
   public String toString() {
-    return "<boostAttribute boost=" + this.boost + "/>";
+    return "<boostAttribute boost=" + getBoost() + "/>";
+  }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.BOOST)) {
+      config.set(ConfigurationKeys.BOOST, 1.0f);
+    }
+    
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttribute.java	(working copy)
@@ -29,7 +29,10 @@
  * and must be defined in the {@link QueryConfigHandler}. This attribute tells
  * the processor which {@link Resolution} to use when parsing the date. <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface DateResolutionAttribute extends Attribute {
   /**
    * Sets the default date resolution used by {@link RangeQueryNode}s for
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttributeImpl.java	(working copy)
@@ -19,7 +19,10 @@
 
 import org.apache.lucene.document.DateTools;
 import org.apache.lucene.document.DateTools.Resolution;
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -29,26 +32,28 @@
  * the processor which {@link Resolution} to use when parsing the date. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.DateResolutionAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class DateResolutionAttributeImpl extends AttributeImpl 
-				implements DateResolutionAttribute {
+				implements DateResolutionAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -6804360312723049526L;
 
   { enableBackwards = false; }
   
-  private DateTools.Resolution dateResolution = null;
-
-  public DateResolutionAttributeImpl() {
-	  dateResolution = null; //default in 2.4
-  }
+  private AbstractQueryConfig config;
+  
+  public DateResolutionAttributeImpl() {}
 
   public void setDateResolution(DateTools.Resolution dateResolution) {
-    this.dateResolution = dateResolution;
+    config.set(ConfigurationKeys.DATE_RESOLUTION, dateResolution);
   }
 
   public DateTools.Resolution getDateResolution() {
-    return this.dateResolution;
+    return config.get(ConfigurationKeys.DATE_RESOLUTION);
   }
 
   @Override
@@ -82,13 +87,18 @@
 
   @Override
   public int hashCode() {
-    return (this.dateResolution == null) ? 0 : this.dateResolution.hashCode();
+    DateTools.Resolution resolution = getDateResolution();
+    return (resolution == null) ? 0 : resolution.hashCode();
   }
 
   @Override
   public String toString() {
-    return "<dateResolutionAttribute dateResolution='" + this.dateResolution
+    return "<dateResolutionAttribute dateResolution='" + getDateResolution()
         + "'/>";
   }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+  }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttribute.java	(working copy)
@@ -26,8 +26,11 @@
  * be defined in the {@link QueryConfigHandler}. This attribute tells the
  * processor which is the default boolean operator when no operator is defined
  * between terms. <br/>
- *
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface DefaultOperatorAttribute extends Attribute {	
   public static enum Operator {
 	    AND, OR;
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttributeImpl.java	(working copy)
@@ -17,7 +17,10 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.GroupQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -28,16 +31,20 @@
  * between terms. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class DefaultOperatorAttributeImpl extends AttributeImpl
-				implements DefaultOperatorAttribute {
+				implements DefaultOperatorAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -6804760312723049526L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private Operator operator = Operator.OR;
-
   public DefaultOperatorAttributeImpl() {
     // empty constructor
   }
@@ -48,12 +55,29 @@
       throw new IllegalArgumentException("default operator cannot be null!");
     }
 
-    this.operator = operator;
+    org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator newOperator;
+    
+    if (operator == Operator.AND) {
+      newOperator = org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator.AND;
+    } else {
+      newOperator = org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator.OR;
+    }
+    
+    config.set(ConfigurationKeys.DEFAULT_OPERATOR, newOperator);
 
   }
 
   public Operator getOperator() {
-    return this.operator;
+    org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator newOperator = config.get(ConfigurationKeys.DEFAULT_OPERATOR, org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator.OR);
+    Operator oldOperator;
+    
+    if (newOperator == org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator.AND) {
+      oldOperator = Operator.OR;
+    } else {
+      oldOperator = Operator.AND;
+    }
+    
+    return oldOperator;
   }
 
   @Override
@@ -90,7 +114,16 @@
 
   @Override
   public String toString() {
-    return "<defaultOperatorAttribute operator=" + this.operator.name() + "/>";
+    return "<defaultOperatorAttribute operator=" + getOperator().name() + "/>";
+  }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.DEFAULT_OPERATOR)) {
+      setOperator(Operator.OR); 
+     }
+    
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttribute.java	(working copy)
@@ -27,7 +27,10 @@
  * processor what is the default phrase slop when no slop is defined in a
  * phrase. <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface DefaultPhraseSlopAttribute extends Attribute {
   public void setDefaultPhraseSlop(int defaultPhraseSlop);
   public int getDefaultPhraseSlop();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttributeImpl.java	(working copy)
@@ -17,7 +17,10 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.PhraseSlopQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -28,26 +31,28 @@
  * phrase. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class DefaultPhraseSlopAttributeImpl extends AttributeImpl 
-				implements DefaultPhraseSlopAttribute {
+				implements DefaultPhraseSlopAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -2104763012527049527L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private int defaultPhraseSlop = 0;
-
-  public DefaultPhraseSlopAttributeImpl() {
-	  defaultPhraseSlop = 0; //default value in 2.4
-  }
+  public DefaultPhraseSlopAttributeImpl() {}
 
   public void setDefaultPhraseSlop(int defaultPhraseSlop) {
-    this.defaultPhraseSlop = defaultPhraseSlop;
+    this.config.set(ConfigurationKeys.PHRASE_SLOP, defaultPhraseSlop);
   }
 
   public int getDefaultPhraseSlop() {
-    return this.defaultPhraseSlop;
+    return config.get(ConfigurationKeys.PHRASE_SLOP, 0);
   }
 
   @Override
@@ -64,7 +69,7 @@
   public boolean equals(Object other) {
 
     if (other instanceof DefaultPhraseSlopAttributeImpl
-        && ((DefaultPhraseSlopAttributeImpl) other).defaultPhraseSlop == this.defaultPhraseSlop) {
+        && ((DefaultPhraseSlopAttributeImpl) other).getDefaultPhraseSlop() == getDefaultPhraseSlop()) {
 
       return true;
 
@@ -76,13 +81,22 @@
 
   @Override
   public int hashCode() {
-    return Integer.valueOf(this.defaultPhraseSlop).hashCode();
+    return Integer.valueOf(getDefaultPhraseSlop()).hashCode();
   }
 
   @Override
   public String toString() {
-    return "<defaultPhraseSlop defaultPhraseSlop=" + this.defaultPhraseSlop
+    return "<defaultPhraseSlop defaultPhraseSlop=" + getDefaultPhraseSlop()
         + "/>";
   }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.PHRASE_SLOP)) {
+      setDefaultPhraseSlop(0);
+    }
+    
+  }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttribute.java	(working copy)
@@ -25,7 +25,11 @@
 /**
  * This attribute enables the user to define a default boost per field.
  * it's used by {@link FieldBoostMapFCListener#buildFieldConfig(FieldConfig)}
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface FieldBoostMapAttribute extends Attribute {
   /**
    * @param boosts a mapping from field name to its default boost
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttributeImpl.java	(working copy)
@@ -20,7 +20,10 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.FieldConfig;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.MultiFieldQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -32,27 +35,30 @@
  * <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.BoostAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class FieldBoostMapAttributeImpl extends AttributeImpl 
-				implements FieldBoostMapAttribute {
+				implements FieldBoostMapAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -2104763012523049527L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private Map<String, Float> boosts = new LinkedHashMap<String, Float>();
-  
-
   public FieldBoostMapAttributeImpl() {
     // empty constructor
   }
 
   public void setFieldBoostMap(Map<String, Float> boosts) {
-    this.boosts = boosts;
+    config.set(ConfigurationKeys.FIELD_BOOST_MAP, boosts);
   }
   
   public Map<String, Float> getFieldBoostMap() {
-    return this.boosts;
+    return config.get(ConfigurationKeys.FIELD_BOOST_MAP);
   }
 
   @Override
@@ -69,7 +75,7 @@
   public boolean equals(Object other) {
 
     if (other instanceof FieldBoostMapAttributeImpl
-        && ((FieldBoostMapAttributeImpl) other).boosts.equals(this.boosts) ) {
+        && ((FieldBoostMapAttributeImpl) other).getFieldBoostMap().equals(getFieldBoostMap()) ) {
 
       return true;
 
@@ -82,15 +88,25 @@
   @Override
   public int hashCode() {
     final int prime = 97;
-    if (this.boosts != null) 
-      return this.boosts.hashCode() * prime;
+    Map<String, Float> boostMap = getFieldBoostMap();
+    if (boostMap != null) 
+      return boostMap.hashCode() * prime;
     else 
       return Float.valueOf(prime).hashCode();
   }
 
   @Override
   public String toString() {
-    return "<fieldBoostMapAttribute map=" + this.boosts + "/>";
+    return "<fieldBoostMapAttribute map=" + getFieldBoostMap() + "/>";
+  }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.FIELD_BOOST_MAP)) {
+      setFieldBoostMap(new LinkedHashMap<String, Float>());
+    }
+    
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapFCListener.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapFCListener.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapFCListener.java	(working copy)
@@ -17,18 +17,21 @@
  * limitations under the License.
  */
 
+import java.util.Map;
+
 import org.apache.lucene.queryParser.core.config.FieldConfig;
 import org.apache.lucene.queryParser.core.config.FieldConfigListener;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 
 /**
  * This listener listens for every field configuration request and assign a
- * {@link BoostAttribute} to the equivalent {@link FieldConfig} based on a
- * defined map: fieldName -> boostValue store in {@link FieldBoostMapAttribute}
- * in the {@link FieldBoostMapAttribute}.
+ * {@link ConfigurationKeys#BOOST} to the
+ * equivalent {@link FieldConfig} based on a defined map: fieldName -> boostValue stored in
+ * {@link ConfigurationKeys#FIELD_BOOST_MAP}.
  * 
- * @see BoostAttribute
- * @see FieldBoostMapAttribute
+ * @see ConfigurationKeys#FIELD_BOOST_MAP
+ * @see ConfigurationKeys#BOOST
  * @see FieldConfig
  * @see FieldConfigListener
  */
@@ -42,15 +45,14 @@
     this.config = config;
   }
 
-  public void buildFieldConfig(FieldConfig fieldConfig) {    
-    if (this.config.hasAttribute(FieldBoostMapAttribute.class)) {
-      FieldBoostMapAttribute fieldBoostMapAttr = this.config.getAttribute(FieldBoostMapAttribute.class);
-      BoostAttribute boostAttr = fieldConfig.addAttribute(BoostAttribute.class);
-      
-      Float boost = fieldBoostMapAttr.getFieldBoostMap().get(fieldConfig.getField());
+  public void buildFieldConfig(FieldConfig fieldConfig) {
+    Map<String, Float> fieldBoostMap = this.config.get(ConfigurationKeys.FIELD_BOOST_MAP);
+    
+    if (fieldBoostMap != null) {
+      Float boost = fieldBoostMap.get(fieldConfig.getField());
 
       if (boost != null) {
-        boostAttr.setBoost(boost.floatValue());
+        fieldConfig.set(ConfigurationKeys.BOOST, boost);
       }
 
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionFCListener.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionFCListener.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionFCListener.java	(working copy)
@@ -21,6 +21,7 @@
 import org.apache.lucene.queryParser.core.config.FieldConfig;
 import org.apache.lucene.queryParser.core.config.FieldConfigListener;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 
 /**
  * This listener listens for every field configuration request and assign a
@@ -45,29 +46,18 @@
   }
 
   public void buildFieldConfig(FieldConfig fieldConfig) {
-    DateResolutionAttribute fieldDateResAttr = fieldConfig
-        .addAttribute(DateResolutionAttribute.class);
     DateTools.Resolution dateRes = null;
 
-    if (this.config.hasAttribute(FieldDateResolutionMapAttribute.class)) {
-      FieldDateResolutionMapAttribute dateResMapAttr = this.config
-          .addAttribute(FieldDateResolutionMapAttribute.class);
-      dateRes = dateResMapAttr.getFieldDateResolutionMap().get(
+    if (this.config.has(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP)) {
+      dateRes = this.config.get(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP).get(
           fieldConfig.getField());
     }
 
     if (dateRes == null) {
-
-      if (this.config.hasAttribute(DateResolutionAttribute.class)) {
-        DateResolutionAttribute dateResAttr = this.config
-            .addAttribute(DateResolutionAttribute.class);
-        dateRes = dateResAttr.getDateResolution();
-
-      }
-
+      dateRes = this.config.get(ConfigurationKeys.DATE_RESOLUTION);
     }
 
-    fieldDateResAttr.setDateResolution(dateRes);
+    fieldConfig.set(ConfigurationKeys.DATE_RESOLUTION, dateRes);
 
   }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttribute.java	(working copy)
@@ -25,7 +25,11 @@
 /**
  * This attribute enables the user to define a default DateResolution per field.
  * it's used by {@link FieldDateResolutionFCListener#buildFieldConfig(org.apache.lucene.queryParser.core.config.FieldConfig)}
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface FieldDateResolutionMapAttribute extends Attribute {
   /**
    * @param dateRes a mapping from field name to its default boost
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttributeImpl.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.apache.lucene.document.DateTools;
 import org.apache.lucene.document.DateTools.Resolution;
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.util.AttributeImpl;
 
 /**
@@ -29,27 +32,30 @@
  * it's used by {@link FieldDateResolutionFCListener#buildFieldConfig(org.apache.lucene.queryParser.core.config.FieldConfig)}
  *
  * @see FieldDateResolutionMapAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class FieldDateResolutionMapAttributeImpl extends AttributeImpl 
-				implements FieldDateResolutionMapAttribute {
+				implements FieldDateResolutionMapAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -2104763012523049527L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private Map<CharSequence, DateTools.Resolution> dateRes = new HashMap<CharSequence, DateTools.Resolution>();
-  
-
   public FieldDateResolutionMapAttributeImpl() {
     // empty constructor
   }
 
   public void setFieldDateResolutionMap(Map<CharSequence, DateTools.Resolution> dateRes) {
-    this.dateRes = dateRes;
+    config.set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, dateRes);
   }
   
   public Map<CharSequence, Resolution> getFieldDateResolutionMap() {
-    return this.dateRes;
+    return config.get(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP);
   }
 
   @Override
@@ -66,7 +72,8 @@
   public boolean equals(Object other) {
 
     if (other instanceof FieldDateResolutionMapAttributeImpl
-        && ((FieldDateResolutionMapAttributeImpl) other).dateRes.equals(this.dateRes) ) {
+        && ((FieldDateResolutionMapAttributeImpl) other)
+            .getFieldDateResolutionMap().equals(getFieldDateResolutionMap())) {
 
       return true;
 
@@ -79,15 +86,25 @@
   @Override
   public int hashCode() {
     final int prime = 97;
-    if (this.dateRes != null) 
-      return this.dateRes.hashCode() * prime;
+    Map<CharSequence, DateTools.Resolution> dateRes = getFieldDateResolutionMap();
+    if (dateRes != null) 
+      return dateRes.hashCode() * prime;
     else 
       return Float.valueOf(prime).hashCode();
   }
 
   @Override
   public String toString() {
-    return "<fieldDateResolutionMapAttribute map=" + this.dateRes + "/>";
+    return "<fieldDateResolutionMapAttribute map=" + getFieldDateResolutionMap() + "/>";
+  }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP)) {
+      setFieldDateResolutionMap(new HashMap<CharSequence, DateTools.Resolution>());
+    }
+    
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttribute.java	(working copy)
@@ -27,7 +27,10 @@
  * processor what is the default phrase slop when no slop is defined in a
  * phrase. <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface FuzzyAttribute extends Attribute {
   public void setPrefixLength(int prefixLength);
   public int getPrefixLength();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttributeImpl.java	(working copy)
@@ -17,9 +17,11 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.PhraseSlopQueryNodeProcessor;
-import org.apache.lucene.search.FuzzyQuery;
 import org.apache.lucene.util.AttributeImpl;
 
 /**
@@ -29,36 +31,52 @@
  * phrase. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.FuzzyAttribute
+ * 
+ * @deprecated
+ * 
  */
-public class FuzzyAttributeImpl extends AttributeImpl 
-				implements FuzzyAttribute {
+@Deprecated
+public class FuzzyAttributeImpl extends AttributeImpl implements
+    FuzzyAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -2104763012527049527L;
 
-  { enableBackwards = false; }
-  
-  private int prefixLength = FuzzyQuery.defaultPrefixLength;
+  private AbstractQueryConfig config;
 
-  private float minSimilarity = FuzzyQuery.defaultMinSimilarity;
+  {
+    enableBackwards = false;
+  }
 
   public FuzzyAttributeImpl() {
     // empty constructor
   }
 
   public void setPrefixLength(int prefixLength) {
-    this.prefixLength = prefixLength;
+    getFuzzyConfig().setPrefixLength(prefixLength);
   }
 
   public int getPrefixLength() {
-    return this.prefixLength;
+    return getFuzzyConfig().getPrefixLength();
   }
 
   public void setFuzzyMinSimilarity(float minSimilarity) {
-    this.minSimilarity = minSimilarity;
+    getFuzzyConfig().setMinSimilarity(minSimilarity);
+  }
+  
+  private FuzzyConfig getFuzzyConfig() {
+    FuzzyConfig fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      fuzzyConfig = new FuzzyConfig();
+      config.set(ConfigurationKeys.FUZZY_CONFIG, fuzzyConfig);
+    }
+    
+    return fuzzyConfig;
+    
   }
 
   public float getFuzzyMinSimilarity() {
-    return this.minSimilarity;
+    return getFuzzyConfig().getMinSimilarity();
   }
 
   @Override
@@ -75,7 +93,7 @@
   public boolean equals(Object other) {
 
     if (other instanceof FuzzyAttributeImpl
-        && ((FuzzyAttributeImpl) other).prefixLength == this.prefixLength) {
+        && ((FuzzyAttributeImpl) other).getPrefixLength() == getPrefixLength()) {
 
       return true;
 
@@ -87,12 +105,23 @@
 
   @Override
   public int hashCode() {
-    return Integer.valueOf(this.prefixLength).hashCode();
+    return Integer.valueOf(getPrefixLength()).hashCode();
   }
 
   @Override
   public String toString() {
-    return "<fuzzyAttribute prefixLength=" + this.prefixLength + ",minSimilarity=" + this.minSimilarity + "/>";
+    FuzzyConfig fuzzyConfig = getFuzzyConfig();
+    return "<fuzzyAttribute prefixLength=" + fuzzyConfig.getPrefixLength()
+        + ",minSimilarity=" + fuzzyConfig.getMinSimilarity() + "/>";
+  }
+
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+
+    if (!config.has(ConfigurationKeys.FUZZY_CONFIG)) {
+      config.set(ConfigurationKeys.FUZZY_CONFIG, new FuzzyConfig());
+    }
+
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java	(revision 0)
@@ -0,0 +1,46 @@
+package org.apache.lucene.queryParser.standard.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.search.FuzzyQuery;
+
+public class FuzzyConfig {
+  
+  private int prefixLength = FuzzyQuery.defaultPrefixLength;
+
+  private float minSimilarity = FuzzyQuery.defaultMinSimilarity;
+  
+  public FuzzyConfig() {}
+
+  public int getPrefixLength() {
+    return prefixLength;
+  }
+
+  public void setPrefixLength(int prefixLength) {
+    this.prefixLength = prefixLength;
+  }
+
+  public float getMinSimilarity() {
+    return minSimilarity;
+  }
+
+  public void setMinSimilarity(float minSimilarity) {
+    this.minSimilarity = minSimilarity;
+  }
+  
+}

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java
___________________________________________________________________
Added: svn:eol-style
   + native
Added: svn:keywords
   + Rev Date

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttribute.java	(working copy)
@@ -28,7 +28,10 @@
  * and must be defined in the {@link QueryConfigHandler}. This attribute tells
  * the processor what is the default {@link Locale} used to parse a date. <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface LocaleAttribute extends Attribute {
   public void setLocale(Locale locale);
   public Locale getLocale();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttributeImpl.java	(working copy)
@@ -19,7 +19,10 @@
 
 import java.util.Locale;
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -29,26 +32,30 @@
  * the processor what is the default {@link Locale} used to parse a date. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.LocaleAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class LocaleAttributeImpl extends AttributeImpl
-				implements LocaleAttribute {
+				implements LocaleAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -6804760312720049526L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
   private Locale locale = Locale.getDefault();
 
-  public LocaleAttributeImpl() {
-	  locale = Locale.getDefault(); //default in 2.4
-  }
+  public LocaleAttributeImpl() {}
 
   public void setLocale(Locale locale) {
-    this.locale = locale;
+    config.set(ConfigurationKeys.LOCALE, locale);
   }
 
   public Locale getLocale() {
-    return this.locale;
+    return config.get(ConfigurationKeys.LOCALE);
   }
 
   @Override
@@ -90,5 +97,14 @@
   public String toString() {
     return "<localeAttribute locale=" + this.locale + "/>";
   }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.LOCALE)) {
+      config.set(ConfigurationKeys.LOCALE, Locale.getDefault());
+    }
+    
+  }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttribute.java	(working copy)
@@ -28,7 +28,10 @@
  * and must be defined in the {@link QueryConfigHandler}. This attribute tells
  * the processor what is the default {@link Locale} used to parse a date. <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface LowercaseExpandedTermsAttribute extends Attribute {
   public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms);
   public boolean isLowercaseExpandedTerms();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttributeImpl.java	(working copy)
@@ -19,7 +19,10 @@
 
 import java.util.Locale;
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -29,26 +32,28 @@
  * the processor what is the default {@link Locale} used to parse a date. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class LowercaseExpandedTermsAttributeImpl extends AttributeImpl
-				implements LowercaseExpandedTermsAttribute {
+				implements LowercaseExpandedTermsAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -2804760312723049527L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private boolean lowercaseExpandedTerms = true;
-
-  public LowercaseExpandedTermsAttributeImpl() {
-    lowercaseExpandedTerms = true; // default in 2.4
-  }
+  public LowercaseExpandedTermsAttributeImpl() {}
 
   public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) {
-	  this.lowercaseExpandedTerms = lowercaseExpandedTerms; 
+      config.set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, lowercaseExpandedTerms); 
   }
 
   public boolean isLowercaseExpandedTerms() {
-    return this.lowercaseExpandedTerms;
+    return config.get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, true);
   }
 
   @Override
@@ -65,7 +70,8 @@
   public boolean equals(Object other) {
 
     if (other instanceof LowercaseExpandedTermsAttributeImpl
-        && ((LowercaseExpandedTermsAttributeImpl) other).lowercaseExpandedTerms == this.lowercaseExpandedTerms) {
+        && ((LowercaseExpandedTermsAttributeImpl) other)
+            .isLowercaseExpandedTerms() == isLowercaseExpandedTerms()) {
 
       return true;
 
@@ -77,13 +83,22 @@
 
   @Override
   public int hashCode() {
-    return this.lowercaseExpandedTerms ? -1 : Integer.MAX_VALUE;
+    return isLowercaseExpandedTerms() ? -1 : Integer.MAX_VALUE;
   }
 
   @Override
   public String toString() {
     return "<lowercaseExpandedTerms lowercaseExpandedTerms="
-        + this.lowercaseExpandedTerms + "/>";
+        + isLowercaseExpandedTerms() + "/>";
+  }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS)) {
+      config.set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, true);
+    }
+    
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttribute.java	(working copy)
@@ -26,7 +26,10 @@
  * must be defined in the {@link QueryConfigHandler}. This attribute tells the
  * processor to which fields the terms in the query should be expanded. <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface MultiFieldAttribute extends Attribute {
   public void setFields(CharSequence[] fields);
   public CharSequence[] getFields();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttributeImpl.java	(working copy)
@@ -19,7 +19,10 @@
 
 import java.util.Arrays;
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.MultiFieldQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -29,26 +32,30 @@
  * processor to which fields the terms in the query should be expanded. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.MultiFieldAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class MultiFieldAttributeImpl extends AttributeImpl
-				implements MultiFieldAttribute {
+				implements MultiFieldAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -6809760312720049526L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private CharSequence[] fields;
-
   public MultiFieldAttributeImpl() {
     // empty constructor
   }
 
   public void setFields(CharSequence[] fields) {
-    this.fields = fields;
+    config.set(ConfigurationKeys.MULTI_FIELDS, fields);
   }
 
   public CharSequence[] getFields() {
-    return this.fields;
+    return config.get(ConfigurationKeys.MULTI_FIELDS);
   }
 
   @Override
@@ -67,7 +74,7 @@
     if (other instanceof MultiFieldAttributeImpl) {
     	MultiFieldAttributeImpl fieldsAttr = (MultiFieldAttributeImpl) other;
 
-      return Arrays.equals(this.fields, fieldsAttr.fields);
+      return Arrays.equals(getFields(), fieldsAttr.getFields());
 
     }
 
@@ -77,12 +84,16 @@
 
   @Override
   public int hashCode() {
-    return Arrays.hashCode(this.fields);
+    return Arrays.hashCode(getFields());
   }
 
   @Override
   public String toString() {
-    return "<fieldsAttribute fields=" + Arrays.toString(this.fields) + "/>";
+    return "<fieldsAttribute fields=" + Arrays.toString(getFields()) + "/>";
+  }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
 import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
@@ -29,10 +30,13 @@
  * processor. It basically tells the processor which {@link RewriteMethod} to
  * use. <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface MultiTermRewriteMethodAttribute extends Attribute {
   
-  public static final String TAG_ID = "MultiTermRewriteMethodAttribute";
+  public static final String TAG_ID = MultiTermRewriteMethodProcessor.TAG_ID;
   
   public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method);
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java	(working copy)
@@ -17,7 +17,10 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
@@ -30,26 +33,30 @@
  * use. <br/>
  * 
  * @see MultiTermRewriteMethodAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class MultiTermRewriteMethodAttributeImpl extends AttributeImpl
-    implements MultiTermRewriteMethodAttribute {
+    implements MultiTermRewriteMethodAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -2104763012723049527L;
   
+  private AbstractQueryConfig config;
+  
   { enableBackwards = false; }
   
-  private MultiTermQuery.RewriteMethod multiTermRewriteMethod = MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;
-
   public MultiTermRewriteMethodAttributeImpl() {
     // empty constructor
   }
 
   public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method) {
-    multiTermRewriteMethod = method;
+   config.set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, method);
   }
 
   public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
-    return multiTermRewriteMethod;
+    return config.get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD);
   }
 
   @Override
@@ -66,7 +73,7 @@
   public boolean equals(Object other) {
 
     if (other instanceof MultiTermRewriteMethodAttributeImpl
-        && ((MultiTermRewriteMethodAttributeImpl) other).multiTermRewriteMethod == this.multiTermRewriteMethod) {
+        && ((MultiTermRewriteMethodAttributeImpl) other).getMultiTermRewriteMethod() == getMultiTermRewriteMethod()) {
 
       return true;
 
@@ -78,13 +85,22 @@
 
   @Override
   public int hashCode() {
-    return multiTermRewriteMethod.hashCode();
+    return getMultiTermRewriteMethod().hashCode();
   }
 
   @Override
   public String toString() {
     return "<multiTermRewriteMethod multiTermRewriteMethod="
-        + this.multiTermRewriteMethod + "/>";
+        + getMultiTermRewriteMethod() + "/>";
+  }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD)) {
+      config.set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
+    }
+    
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttribute.java	(working copy)
@@ -25,8 +25,11 @@
  * This attribute is used by {@link AnalyzerQueryNodeProcessor} processor and
  * must be defined in the {@link QueryConfigHandler}. This attribute tells the
  * processor if the position increment is enabled. <br/>
- *
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface PositionIncrementsAttribute extends Attribute {
   public void setPositionIncrementsEnabled(boolean positionIncrementsEnabled);
   public boolean isPositionIncrementsEnabled();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttributeImpl.java	(working copy)
@@ -17,7 +17,10 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.AnalyzerQueryNodeProcessor;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -27,26 +30,28 @@
  * processor if the position increment is enabled. <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class PositionIncrementsAttributeImpl extends AttributeImpl
-				implements PositionIncrementsAttribute {
+				implements PositionIncrementsAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -2804763012793049527L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private boolean positionIncrementsEnabled = false;
-
-  public PositionIncrementsAttributeImpl() {
-	  positionIncrementsEnabled = false; //default in 2.4
-  }
+  public PositionIncrementsAttributeImpl() {}
 
   public void setPositionIncrementsEnabled(boolean positionIncrementsEnabled) {
-    this.positionIncrementsEnabled = positionIncrementsEnabled;
+    config.set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, positionIncrementsEnabled);
   }
 
   public boolean isPositionIncrementsEnabled() {
-    return this.positionIncrementsEnabled;
+    return config.get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, false);
   }
 
   @Override
@@ -63,7 +68,8 @@
   public boolean equals(Object other) {
 
     if (other instanceof PositionIncrementsAttributeImpl
-        && ((PositionIncrementsAttributeImpl) other).positionIncrementsEnabled == this.positionIncrementsEnabled) {
+        && ((PositionIncrementsAttributeImpl) other)
+            .isPositionIncrementsEnabled() == isPositionIncrementsEnabled()) {
 
       return true;
 
@@ -75,13 +81,22 @@
 
   @Override
   public int hashCode() {
-    return this.positionIncrementsEnabled ? -1 : Integer.MAX_VALUE;
+    return isPositionIncrementsEnabled() ? -1 : Integer.MAX_VALUE;
   }
 
   @Override
   public String toString() {
     return "<positionIncrements positionIncrementsEnabled="
-        + this.positionIncrementsEnabled + "/>";
+        + isPositionIncrementsEnabled() + "/>";
+  }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+    
+    if (!config.has(ConfigurationKeys.ENABLE_POSITION_INCREMENTS)) {
+      config.set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, false);
+    }
+    
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/RangeCollatorAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/RangeCollatorAttribute.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/RangeCollatorAttribute.java	(working copy)
@@ -30,7 +30,10 @@
  * the processor which {@link Collator} should be used for a
  * {@link TermRangeQuery} <br/>
  * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public interface RangeCollatorAttribute extends Attribute {
   public void setDateResolution(Collator rangeCollator);
   public Collator getRangeCollator();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/RangeCollatorAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/RangeCollatorAttributeImpl.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/RangeCollatorAttributeImpl.java	(working copy)
@@ -19,7 +19,10 @@
 
 import java.text.Collator;
 
+import org.apache.lucene.queryParser.core.config.AbstractQueryConfig;
+import org.apache.lucene.queryParser.core.config.ConfigAttribute;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.util.AttributeImpl;
@@ -31,26 +34,28 @@
  * {@link TermRangeQuery} <br/>
  * 
  * @see org.apache.lucene.queryParser.standard.config.RangeCollatorAttribute
+ * 
+ * @deprecated
+ * 
  */
+@Deprecated
 public class RangeCollatorAttributeImpl extends AttributeImpl
-				implements RangeCollatorAttribute {
+				implements RangeCollatorAttribute, ConfigAttribute {
 
   private static final long serialVersionUID = -6804360312723049526L;
+  
+  private AbstractQueryConfig config;
 
   { enableBackwards = false; }
   
-  private Collator rangeCollator;
-
-  public RangeCollatorAttributeImpl() {
-	  rangeCollator = null; // default value for 2.4
-  }
+  public RangeCollatorAttributeImpl() {}
 
   public void setDateResolution(Collator rangeCollator) {
-    this.rangeCollator = rangeCollator;
+    config.set(ConfigurationKeys.RANGE_COLLATOR, rangeCollator);
   }
 
   public Collator getRangeCollator() {
-    return this.rangeCollator;
+    return config.get(ConfigurationKeys.RANGE_COLLATOR);
   }
 
   @Override
@@ -68,9 +73,12 @@
 
     if (other instanceof RangeCollatorAttributeImpl) {
     	RangeCollatorAttributeImpl rangeCollatorAttr = (RangeCollatorAttributeImpl) other;
+    	
+    	Collator thisCollator = getRangeCollator();
+    	Collator otherCollator = rangeCollatorAttr.getRangeCollator();
 
-      if (rangeCollatorAttr.rangeCollator == this.rangeCollator
-          || rangeCollatorAttr.rangeCollator.equals(this.rangeCollator)) {
+      if (otherCollator == thisCollator
+          || otherCollator.equals(thisCollator)) {
 
         return true;
 
@@ -84,13 +92,18 @@
 
   @Override
   public int hashCode() {
-    return (this.rangeCollator == null) ? 0 : this.rangeCollator.hashCode();
+    Collator collator = getRangeCollator();
+    return (collator == null) ? 0 : collator.hashCode();
   }
 
   @Override
   public String toString() {
-    return "<rangeCollatorAttribute rangeCollator='" + this.rangeCollator
+    return "<rangeCollatorAttribute rangeCollator='" + getRangeCollator()
         + "'/>";
   }
+  
+  public void setQueryConfigHandler(AbstractQueryConfig config) {
+    this.config = config;
+  }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java	(working copy)
@@ -17,27 +17,205 @@
  * limitations under the License.
  */
 
+import java.text.Collator;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.DateTools.Resolution;
+import org.apache.lucene.queryParser.core.config.ConfigurationKey;
+import org.apache.lucene.queryParser.core.config.FieldConfig;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.StandardQueryParser;
 import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
 
 /**
  * This query configuration handler is used for almost every processor defined
- * in the {@link StandardQueryNodeProcessorPipeline} processor pipeline. It holds
- * attributes that reproduces the configuration that could be set on the old
- * lucene 2.4 QueryParser class. <br/>
+ * in the {@link StandardQueryNodeProcessorPipeline} processor pipeline. It
+ * holds attributes that reproduces the configuration that could be set on the
+ * old lucene 2.4 QueryParser class. <br/>
  * 
  * @see StandardQueryNodeProcessorPipeline
  */
 public class StandardQueryConfigHandler extends QueryConfigHandler {
 
+  final public static class ConfigurationKeys {
+
+    /**
+     * Key used to set whether position increments is enabled
+     * 
+     * @see StandardQueryParser#setEnablePositionIncrements(boolean)
+     * @see StandardQueryParser#getEnablePositionIncrements()
+     */
+    final public static ConfigurationKey<Boolean> ENABLE_POSITION_INCREMENTS = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set whether expanded terms should be expanded
+     * 
+     * @see StandardQueryParser#setLowercaseExpandedTerms(boolean)
+     * @see StandardQueryParser#getLowercaseExpandedTerms()
+     */
+    final public static ConfigurationKey<Boolean> LOWERCASE_EXPANDED_TERMS = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set whether leading wildcards are supported
+     * 
+     * @see StandardQueryParser#setAllowLeadingWildcard(boolean)
+     * @see StandardQueryParser#getAllowLeadingWildcard()
+     */
+    final public static ConfigurationKey<Boolean> ALLOW_LEADING_WILDCARD = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set the {@link Analyzer} used for terms found in the query
+     * 
+     * @see StandardQueryParser#setAnalyzer(Analyzer)
+     * @see StandardQueryParser#getAnalyzer()
+     */
+    final public static ConfigurationKey<Analyzer> ANALYZER = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set the default boolean operator
+     * 
+     * @see StandardQueryParser#setDefaultOperator(org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator)
+     * @see StandardQueryParser#getDefaultOperator()
+     */
+    final public static ConfigurationKey<Operator> DEFAULT_OPERATOR = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set the default phrase slop
+     * 
+     * @see StandardQueryParser#setPhraseSlop(int)
+     * @see StandardQueryParser#getPhraseSlop()
+     */
+    final public static ConfigurationKey<Integer> PHRASE_SLOP = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set the {@link Locale} used when parsing the query
+     * 
+     * @see StandardQueryParser#setLocale(Locale)
+     * @see StandardQueryParser#getLocale()
+     */
+    final public static ConfigurationKey<Locale> LOCALE = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set the {@link RewriteMethod} used when creating queries
+     * 
+     * @see StandardQueryParser#setMultiTermRewriteMethod(org.apache.lucene.search.MultiTermQuery.RewriteMethod)
+     * @see StandardQueryParser#getMultiTermRewriteMethod()
+     */
+    final public static ConfigurationKey<MultiTermQuery.RewriteMethod> MULTI_TERM_REWRITE_METHOD = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set the fields a query should be expanded to when the field
+     * is <code>null</code>
+     * 
+     * @see StandardQueryParser#setMultiFields(CharSequence[])
+     * @see StandardQueryParser#getMultiFields(CharSequence[])
+     */
+    final public static ConfigurationKey<CharSequence[]> MULTI_FIELDS = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set a field to boost map that is used to set the boost for
+     * each field
+     * 
+     * @see StandardQueryParser#setFieldsBoost(Map)
+     * @see StandardQueryParser#getFieldsBoost()
+     */
+    final public static ConfigurationKey<Map<String, Float>> FIELD_BOOST_MAP = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set a field to {@link Resolution} map that is used to
+     * normalize each date field value.
+     * 
+     * @see StandardQueryParser#setDateResolutionMap(Map)
+     * @see StandardQueryParser#getDateResolutionMap()
+     */
+    final public static ConfigurationKey<Map<CharSequence, DateTools.Resolution>> FIELD_DATE_RESOLUTION_MAP = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set the {@link FuzzyConfig} used to create fuzzy queries.
+     * 
+     * @see StandardQueryParser#setFuzzyMinSim(float)
+     * @see StandardQueryParser#setFuzzyPrefixLength(int)
+     * @see StandardQueryParser#getFuzzyMinSim()
+     * @see StandardQueryParser#getFuzzyPrefixLength()
+     */
+    final public static ConfigurationKey<FuzzyConfig> FUZZY_CONFIG = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set default {@link Resolution}.
+     * 
+     * @see StandardQueryParser#setDateResolution(org.apache.lucene.document.DateTools.Resolution)
+     * @see StandardQueryParser#getDateResolution()
+     */
+    final public static ConfigurationKey<DateTools.Resolution> DATE_RESOLUTION = ConfigurationKey
+        .newInstance();
+
+    /**
+     * Key used to set the boost value in {@link FieldConfig} objects.
+     * 
+     * @see StandardQueryParser#setFieldsBoost(Map)
+     * @see StandardQueryParser#getFieldsBoost()
+     */
+    final public static ConfigurationKey<Float> BOOST = ConfigurationKey
+        .newInstance();
 
+    /**
+     * Key used to set the {@link Collator} used when creating {@link TermRangeQuery}s.
+     * 
+     * @see StandardQueryParser#setRangeCollator(Collator)
+     * @see StandardQueryParser#getRangeCollator()
+     */
+    final public static ConfigurationKey<Collator> RANGE_COLLATOR = ConfigurationKey
+        .newInstance();
 
+  }
+
+  public static enum Operator {
+    AND, OR;
+  }
+
+  @SuppressWarnings("deprecation")
   public StandardQueryConfigHandler() {
-    // Add listener that will build the FieldConfig attributes.
+    // Add listener that will build the FieldConfig.
     addFieldConfigListener(new FieldBoostMapFCListener(this));
     addFieldConfigListener(new FieldDateResolutionFCListener(this));
 
     // Default Values
+    set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, false); // default in 2.9
+    set(ConfigurationKeys.ANALYZER, null); // default value 2.4
+    set(ConfigurationKeys.DEFAULT_OPERATOR, Operator.OR);
+    set(ConfigurationKeys.PHRASE_SLOP, 0); // default value 2.4
+    set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, true); // default value 2.4
+    set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, false); // default value
+                                                              // 2.4
+    set(ConfigurationKeys.FIELD_BOOST_MAP, new LinkedHashMap<String, Float>());
+    set(ConfigurationKeys.FUZZY_CONFIG, new FuzzyConfig());
+    set(ConfigurationKeys.LOCALE, Locale.getDefault());
+    set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD,
+        MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
+    set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP,
+        new HashMap<CharSequence, DateTools.Resolution>());
+    
+    // still add old attributes
     addAttribute(RangeCollatorAttribute.class);
     addAttribute(DefaultOperatorAttribute.class);
     addAttribute(AnalyzerAttribute.class);
@@ -49,7 +227,7 @@
     addAttribute(LocaleAttribute.class);
     addAttribute(DefaultPhraseSlopAttribute.class);
     addAttribute(MultiTermRewriteMethodAttribute.class);   
-    
+
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/package.html
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/package.html	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/package.html	(working copy)
@@ -24,7 +24,7 @@
 <h2>Standard Lucene Query Configuration</h2>
 <p>
 The package org.apache.lucene.queryParser.standard.config contains the Lucene
-query configuration handler and all the attributes used by it. This configuration
+query configuration handler (StandardQueryConfigHandler). This configuration
 handler reproduces almost everything that could be set on the old query parser.
 </p>
 <p>
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java	(working copy)
@@ -21,7 +21,7 @@
 
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.standard.config.RangeCollatorAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
 
 /**
@@ -29,7 +29,7 @@
  * be used by the range query and if the constant score rewrite is enabled. <br/>
  * 
  * @see ParametricRangeQueryNodeProcessor
- * @see RangeCollatorAttribute
+ * @see ConfigurationKeys#RANGE_COLLATOR
  * @see org.apache.lucene.search.TermRangeQuery
  */
 public class RangeQueryNode extends ParametricRangeQueryNode {
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java	(working copy)
@@ -26,18 +26,18 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
-import org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
 
 /**
- * This processor verifies if the attribute
- * {@link AllowLeadingWildcardAttribute} is defined in the
+ * This processor verifies if
+ * {@link ConfigurationKeys#ALLOW_LEADING_WILDCARD} is defined in the
  * {@link QueryConfigHandler}. If it is and leading wildcard is not allowed, it
  * looks for every {@link WildcardQueryNode} contained in the query node tree
  * and throws an exception if any of them has a leading wildcard ('*' or '?'). <br/>
  * 
- * @see AllowLeadingWildcardAttribute
+ * @see ConfigurationKeys#ALLOW_LEADING_WILDCARD
  */
 public class AllowLeadingWildcardProcessor extends QueryNodeProcessorImpl {
 
@@ -47,11 +47,11 @@
 
   @Override
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    Boolean allowsLeadingWildcard = getQueryConfigHandler().get(ConfigurationKeys.ALLOW_LEADING_WILDCARD);
 
-    if (getQueryConfigHandler().hasAttribute(AllowLeadingWildcardAttribute.class)) {
+    if (allowsLeadingWildcard != null) {
 
-      AllowLeadingWildcardAttribute alwAttr= getQueryConfigHandler().getAttribute(AllowLeadingWildcardAttribute.class);
-      if (!alwAttr.isAllowLeadingWildcard()) {
+      if (!allowsLeadingWildcard) {
         return super.process(queryTree);
       }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java	(working copy)
@@ -40,14 +40,13 @@
 import org.apache.lucene.queryParser.core.nodes.TextableQueryNode;
 import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.AnalyzerAttribute;
-import org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 
 /**
- * This processor verifies if the attribute {@link AnalyzerQueryNodeProcessor}
+ * This processor verifies if {@link ConfigurationKeys#ANALYZER}
  * is defined in the {@link QueryConfigHandler}. If it is and the analyzer is
  * not <code>null</code>, it looks for every {@link FieldQueryNode} that is not
  * {@link WildcardQueryNode}, {@link FuzzyQueryNode} or
@@ -64,6 +63,7 @@
  * If no term is returned by the analyzer a {@link NoTokenFoundQueryNode} object
  * is returned. <br/>
  * 
+ * @see ConfigurationKeys#ANALYZER
  * @see Analyzer
  * @see TokenStream
  */
@@ -79,24 +79,15 @@
 
   @Override
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-
-    if (getQueryConfigHandler().hasAttribute(AnalyzerAttribute.class)) {
-
-      this.analyzer = getQueryConfigHandler().getAttribute(
-          AnalyzerAttribute.class).getAnalyzer();
-
+    Analyzer analyzer = getQueryConfigHandler().get(ConfigurationKeys.ANALYZER);
+    
+    if (analyzer != null) {
+      this.analyzer = analyzer;
       this.positionIncrementsEnabled = false;
-
-      if (getQueryConfigHandler().hasAttribute(
-          PositionIncrementsAttribute.class)) {
-
-        if (getQueryConfigHandler().getAttribute(
-            PositionIncrementsAttribute.class).isPositionIncrementsEnabled()) {
-
-          this.positionIncrementsEnabled = true;
-
-        }
+      Boolean positionIncrementsEnabled = getQueryConfigHandler().get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS);
 
+      if (positionIncrementsEnabled != null) {
+          this.positionIncrementsEnabled = positionIncrementsEnabled;
       }
 
       if (this.analyzer != null) {
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BoostQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BoostQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BoostQueryNodeProcessor.java	(working copy)
@@ -27,14 +27,14 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.util.StringUtils;
-import org.apache.lucene.queryParser.standard.config.BoostAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 
 /**
  * This processor iterates the query node tree looking for every
- * {@link FieldableNode} that has the attribute {@link BoostAttribute} in its
+ * {@link FieldableNode} that has {@link ConfigurationKeys#BOOST} in its
  * config. If there is, the boost is applied to that {@link FieldableNode}. <br/>
  * 
- * @see BoostAttribute
+ * @see ConfigurationKeys#BOOST
  * @see QueryConfigHandler
  * @see FieldableNode
  */
@@ -53,10 +53,12 @@
         CharSequence field = fieldNode.getField();
         FieldConfig fieldConfig = config.getFieldConfig(StringUtils.toString(field));
 
-        if (fieldConfig != null && fieldConfig.hasAttribute(BoostAttribute.class)) {
-          BoostAttribute boostAttr = fieldConfig.getAttribute(BoostAttribute.class);
+        if (fieldConfig != null) {
+          Float boost = fieldConfig.get(ConfigurationKeys.BOOST);
 
-          return new BoostQueryNode(node, boostAttr.getBoost());
+          if (boost != null) {
+            return new BoostQueryNode(node, boost);
+          }
 
         }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java	(working copy)
@@ -25,19 +25,19 @@
 import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.DefaultPhraseSlopAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
 
 /**
- * This processor verifies if the attribute {@link DefaultPhraseSlopAttribute}
+ * This processor verifies if {@link ConfigurationKeys#PHRASE_SLOP}
  * is defined in the {@link QueryConfigHandler}. If it is, it looks for every
  * {@link TokenizedPhraseQueryNode} and {@link MultiPhraseQueryNode} that does
  * not have any {@link SlopQueryNode} applied to it and creates an
  * {@link SlopQueryNode} and apply to it. The new {@link SlopQueryNode} has the
- * same slop value defined in the attribute. <br/>
+ * same slop value defined in the configuration. <br/>
  * 
  * @see SlopQueryNode
- * @see DefaultPhraseSlopAttribute
+ * @see ConfigurationKeys#PHRASE_SLOP
  */
 public class DefaultPhraseSlopQueryNodeProcessor extends QueryNodeProcessorImpl {
 
@@ -54,10 +54,10 @@
     QueryConfigHandler queryConfig = getQueryConfigHandler();
 
     if (queryConfig != null) {
-
-      if (queryConfig.hasAttribute(DefaultPhraseSlopAttribute.class)) {
-        this.defaultPhraseSlop = queryConfig.getAttribute(
-            DefaultPhraseSlopAttribute.class).getDefaultPhraseSlop();
+      Integer defaultPhraseSlop = queryConfig.get(ConfigurationKeys.PHRASE_SLOP); 
+      
+      if (defaultPhraseSlop != null) {
+        this.defaultPhraseSlop = defaultPhraseSlop;
 
         return super.process(queryTree);
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/FuzzyQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/FuzzyQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/FuzzyQueryNodeProcessor.java	(working copy)
@@ -24,17 +24,19 @@
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.FuzzyAttribute;
+import org.apache.lucene.queryParser.standard.config.FuzzyConfig;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.search.FuzzyQuery;
 
 /**
  * This processor iterates the query node tree looking for every
  * {@link FuzzyQueryNode}, when this kind of node is found, it checks on the
- * query configuration for {@link FuzzyAttribute}, gets the fuzzy prefix length
- * and default similarity from it and set to the fuzzy node. For more
- * information about fuzzy prefix length check: {@link FuzzyQuery}. <br/>
+ * query configuration for
+ * {@link ConfigurationKeys#FUZZY_CONFIG}, gets the
+ * fuzzy prefix length and default similarity from it and set to the fuzzy node.
+ * For more information about fuzzy prefix length check: {@link FuzzyQuery}. <br/>
  * 
- * @see FuzzyAttribute
+ * @see ConfigurationKeys#FUZZY_CONFIG
  * @see FuzzyQuery
  * @see FuzzyQueryNode
  */
@@ -54,18 +56,17 @@
       FuzzyQueryNode fuzzyNode = (FuzzyQueryNode) node;
       QueryConfigHandler config = getQueryConfigHandler();
 
-      if (config != null && config.hasAttribute(FuzzyAttribute.class)) {
-        FuzzyAttribute fuzzyAttr = config.getAttribute(FuzzyAttribute.class);
-        fuzzyNode.setPrefixLength(fuzzyAttr.getPrefixLength());
+      FuzzyConfig fuzzyConfig = null;
+      
+      if (config != null && (fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG)) != null) {
+        fuzzyNode.setPrefixLength(fuzzyConfig.getPrefixLength());
 
         if (fuzzyNode.getSimilarity() < 0) {
-          fuzzyNode.setSimilarity(fuzzyAttr.getFuzzyMinSimilarity());
-
+          fuzzyNode.setSimilarity(fuzzyConfig.getMinSimilarity());
         }
-
+        
       } else if (fuzzyNode.getSimilarity() < 0) {
-        throw new IllegalArgumentException("No "
-            + FuzzyAttribute.class.getName() + " set in the config");
+        throw new IllegalArgumentException("No FUZZY_CONFIG set in the config");
       }
 
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/GroupQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/GroupQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/GroupQueryNodeProcessor.java	(working copy)
@@ -31,8 +31,9 @@
 import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode.Modifier;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessor;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
 import org.apache.lucene.queryParser.standard.nodes.BooleanModifierNode;
 
 /**
@@ -64,14 +65,14 @@
   }
 
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-
-    if (!getQueryConfigHandler().hasAttribute(DefaultOperatorAttribute.class)) {
+    Operator defaultOperator = getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
+    
+    if (defaultOperator == null) {
       throw new IllegalArgumentException(
-          "DefaultOperatorAttribute should be set on the QueryConfigHandler");
+          "DEFAULT_OPERATOR should be set on the QueryConfigHandler");
     }
 
-    this.usingAnd = Operator.AND == getQueryConfigHandler()
-        .getAttribute(DefaultOperatorAttribute.class).getOperator();
+    this.usingAnd = StandardQueryConfigHandler.Operator.AND == defaultOperator;
 
     if (queryTree instanceof GroupQueryNode) {
       queryTree = ((GroupQueryNode) queryTree).getChild();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java	(working copy)
@@ -27,18 +27,18 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
-import org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 
 /**
- * This processor verifies if the attribute
- * {@link LowercaseExpandedTermsAttribute} is defined in the
+ * This processor verifies if 
+ * {@link ConfigurationKeys#LOWERCASE_EXPANDED_TERMS} is defined in the
  * {@link QueryConfigHandler}. If it is and the expanded terms should be
  * lower-cased, it looks for every {@link WildcardQueryNode},
  * {@link FuzzyQueryNode} and {@link ParametricQueryNode} and lower-case its
  * term. <br/>
  * 
- * @see LowercaseExpandedTermsAttribute
+ * @see ConfigurationKeys#LOWERCASE_EXPANDED_TERMS
  */
 public class LowercaseExpandedTermsQueryNodeProcessor extends
     QueryNodeProcessorImpl {
@@ -49,17 +49,10 @@
 
   @Override
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-
-    if (getQueryConfigHandler().hasAttribute(
-        LowercaseExpandedTermsAttribute.class)) {
+    Boolean lowercaseExpandedTerms = getQueryConfigHandler().get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS);
 
-      if (getQueryConfigHandler().getAttribute(
-          LowercaseExpandedTermsAttribute.class).isLowercaseExpandedTerms()) {
-        
-        return super.process(queryTree);
-        
-      }
-
+    if (lowercaseExpandedTerms != null && lowercaseExpandedTerms) {
+      return super.process(queryTree);
     }
 
     return queryTree;
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiFieldQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiFieldQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiFieldQueryNodeProcessor.java	(working copy)
@@ -27,7 +27,7 @@
 import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.MultiFieldAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 
 /**
  * This processor is used to expand terms so the query looks for the same term
@@ -35,13 +35,13 @@
  * <br/>
  * This processor looks for every {@link FieldableNode} contained in the query
  * node tree. If a {@link FieldableNode} is found, it checks if there is a
- * {@link MultiFieldAttribute} defined in the {@link QueryConfigHandler}. If
+ * {@link ConfigurationKeys#MULTI_FIELDS} defined in the {@link QueryConfigHandler}. If
  * there is, the {@link FieldableNode} is cloned N times and the clones are
  * added to a {@link BooleanQueryNode} together with the original node. N is
  * defined by the number of fields that it will be expanded to. The
  * {@link BooleanQueryNode} is returned. <br/>
  * 
- * @see MultiFieldAttribute
+ * @see ConfigurationKeys#MULTI_FIELDS
  */
 public class MultiFieldQueryNodeProcessor extends QueryNodeProcessorImpl {
 
@@ -78,15 +78,13 @@
       FieldableNode fieldNode = (FieldableNode) node;
 
       if (fieldNode.getField() == null) {
+        CharSequence[] fields = getQueryConfigHandler().get(ConfigurationKeys.MULTI_FIELDS);
 
-        if (!getQueryConfigHandler().hasAttribute(MultiFieldAttribute.class)) {
+        if (fields == null) {
           throw new IllegalArgumentException(
-              "MultiFieldAttribute should be set on the QueryConfigHandler");
+              "StandardQueryConfigHandler.ConfigurationKeys.MULTI_FIELDS should be set on the QueryConfigHandler");
         }
 
-        CharSequence[] fields = getQueryConfigHandler().getAttribute(
-            MultiFieldAttribute.class).getFields();
-
         if (fields != null && fields.length > 0) {
           fieldNode.setField(fields[0]);
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java	(working copy)
@@ -22,7 +22,7 @@
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.MultiTermQuery;
 
@@ -34,6 +34,8 @@
  */
 public class MultiTermRewriteMethodProcessor extends QueryNodeProcessorImpl {
 
+  public static final String TAG_ID = "MultiTermRewriteMethodConfiguration";
+
   @Override
   protected QueryNode postProcessNode(QueryNode node) {
 
@@ -42,20 +44,20 @@
     if (node instanceof WildcardQueryNode
         || node instanceof ParametricRangeQueryNode) {
 
-      if (!getQueryConfigHandler().hasAttribute(
-          MultiTermRewriteMethodAttribute.class)) {
+
+      // read the attribute value and use a TAG to take the value to the Builder
+      MultiTermQuery.RewriteMethod rewriteMethod = getQueryConfigHandler()
+          .get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD);
+      
+      if (rewriteMethod == null) {
         // This should not happen, this attribute is created in the
         // StandardQueryConfigHandler
         throw new IllegalArgumentException(
-            "MultiTermRewriteMethodAttribute should be set on the QueryConfigHandler");
+            "StandardQueryConfigHandler.ConfigurationKeys.MULTI_TERM_REWRITE_METHOD should be set on the QueryConfigHandler");
       }
 
-      // read the attribute value and use a TAG to take the value to the Builder
-      MultiTermQuery.RewriteMethod rewriteMethod = getQueryConfigHandler()
-          .getAttribute(MultiTermRewriteMethodAttribute.class)
-          .getMultiTermRewriteMethod();
 
-      node.setTag(MultiTermRewriteMethodAttribute.TAG_ID, rewriteMethod);
+      node.setTag(MultiTermRewriteMethodProcessor.TAG_ID, rewriteMethod);
 
     }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java	(working copy)
@@ -35,9 +35,7 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.DateResolutionAttribute;
-import org.apache.lucene.queryParser.standard.config.LocaleAttribute;
-import org.apache.lucene.queryParser.standard.config.RangeCollatorAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
 
 /**
@@ -45,24 +43,19 @@
  * {@link RangeQueryNode} objects. It reads the lower and upper bounds value
  * from the {@link ParametricRangeQueryNode} object and try to parse their
  * values using a {@link DateFormat}. If the values cannot be parsed to a date
- * value, it will only create the {@link RangeQueryNode} using the non-parsed
- * values. <br/>
+ * value, it will only create the {@link RangeQueryNode} using the
+ * non-parsed values. <br/>
  * <br/>
- * If a {@link LocaleAttribute} is defined in the {@link QueryConfigHandler} it
+ * If a {@link ConfigurationKeys#LOCALE} is defined in the {@link QueryConfigHandler} it
  * will be used to parse the date, otherwise {@link Locale#getDefault()} will be
  * used. <br/>
  * <br/>
- * If a {@link DateResolutionAttribute} is defined and the {@link Resolution} is
+ * If a {@link ConfigurationKeys#DATE_RESOLUTION} is defined and the {@link Resolution} is
  * not <code>null</code> it will also be used to parse the date value. <br/>
  * <br/>
- * This processor will also try to retrieve a {@link RangeCollatorAttribute}
- * from the {@link QueryConfigHandler}. If a {@link RangeCollatorAttribute} is
- * found and the {@link Collator} is not <code>null</code>, it's set on the
- * {@link RangeQueryNode}. <br/>
  * 
- * @see RangeCollatorAttribute
- * @see DateResolutionAttribute
- * @see LocaleAttribute
+ * @see ConfigurationKeys#DATE_RESOLUTION
+ * @see ConfigurationKeys#LOCALE
  * @see RangeQueryNode
  * @see ParametricRangeQueryNode
  */
@@ -79,25 +72,16 @@
       ParametricRangeQueryNode parametricRangeNode = (ParametricRangeQueryNode) node;
       ParametricQueryNode upper = parametricRangeNode.getUpperBound();
       ParametricQueryNode lower = parametricRangeNode.getLowerBound();
-      Locale locale = Locale.getDefault();
-      Collator collator = null;
       DateTools.Resolution dateRes = null;
       boolean inclusive = false;
-
-      if (getQueryConfigHandler().hasAttribute(RangeCollatorAttribute.class)) {
-
-        collator = getQueryConfigHandler().getAttribute(
-            RangeCollatorAttribute.class).getRangeCollator();
-
-      }
-
-      if (getQueryConfigHandler().hasAttribute(LocaleAttribute.class)) {
-
-        locale = getQueryConfigHandler().getAttribute(LocaleAttribute.class)
-            .getLocale();
-
-      }
-
+      
+      Locale locale = getQueryConfigHandler().get(ConfigurationKeys.LOCALE,
+          Locale.getDefault());
+      
+      Collator collator = getQueryConfigHandler().get(
+          ConfigurationKeys.RANGE_COLLATOR);
+      
+      
       CharSequence field = parametricRangeNode.getField();
       String fieldStr = null;
 
@@ -109,14 +93,7 @@
           .getFieldConfig(fieldStr);
 
       if (fieldConfig != null) {
-
-        if (fieldConfig.hasAttribute(DateResolutionAttribute.class)) {
-
-          dateRes = fieldConfig.getAttribute(DateResolutionAttribute.class)
-              .getDateResolution();
-
-        }
-
+        dateRes = fieldConfig.get(ConfigurationKeys.DATE_RESOLUTION);
       }
 
       if (upper.getOperator() == CompareOperator.LE) {
Index: contrib/queryparser/src/java/overview.html
===================================================================
--- contrib/queryparser/src/java/overview.html	(revision 1151708)
+++ contrib/queryparser/src/java/overview.html	(working copy)
@@ -108,8 +108,7 @@
 </dl>
 
 <p>
-Furthermore, the query parser uses flexible configuration objects, which
-are based on AttributeSource/Attribute. It also uses message classes that
+Furthermore, the query parser uses flexible configuration objects. It also uses message classes that
 allow to attach resource bundles. This makes it possible to translate
 messages, which is an important feature of a query parser.
 </p>
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	(working copy)
@@ -43,7 +43,7 @@
 import org.apache.lucene.queryParser.TestQueryParser;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
 import org.apache.lucene.queryParser.standard.parser.ParseException;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.FuzzyQuery;
@@ -132,7 +132,7 @@
       a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
     PrecedenceQueryParser qp = new PrecedenceQueryParser();
     qp.setAnalyzer(a);
-    qp.setDefaultOperator(Operator.OR);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
     return qp;
   }
 
@@ -178,7 +178,7 @@
       a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
     PrecedenceQueryParser qp = new PrecedenceQueryParser();
     qp.setAnalyzer(a);
-    qp.setDefaultOperator(Operator.AND);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     return qp.parse(query, "field");
   }
 
@@ -238,11 +238,11 @@
     PrecedenceQueryParser qp = new PrecedenceQueryParser();
     qp.setAnalyzer(new MockAnalyzer(random));
     // make sure OR is the default:
-    assertEquals(Operator.OR, qp.getDefaultOperator());
-    qp.setDefaultOperator(Operator.AND);
-    assertEquals(Operator.AND, qp.getDefaultOperator());
-    qp.setDefaultOperator(Operator.OR);
-    assertEquals(Operator.OR, qp.getDefaultOperator());
+    assertEquals(StandardQueryConfigHandler.Operator.OR, qp.getDefaultOperator());
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
+    assertEquals(StandardQueryConfigHandler.Operator.AND, qp.getDefaultOperator());
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
+    assertEquals(StandardQueryConfigHandler.Operator.OR, qp.getDefaultOperator());
 
     assertQueryEquals("a OR !b", null, "a -b");
     assertQueryEquals("a OR ! b", null, "a -b");
@@ -623,7 +623,7 @@
     query2 = parser.parse("A (-B +C)", "field");
     assertEquals(query1, query2);
     
-    parser.setDefaultOperator(Operator.AND);
+    parser.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     query1 = parser.parse("A AND B OR C AND D", "field");
     query2 = parser.parse("(A AND B) OR (C AND D)", "field");
     assertEquals(query1, query2);
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryConfigHandler.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryConfigHandler.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryConfigHandler.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.config.ConfigurationKey;
 import org.apache.lucene.queryParser.core.config.FieldConfig;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
 
@@ -27,9 +28,11 @@
  * It does not return any configuration for a field in specific.
  */
 public class SpansQueryConfigHandler extends QueryConfigHandler {
-
+  
+  final public static ConfigurationKey<String> UNIQUE_FIELD = ConfigurationKey.newInstance();
+  
   public SpansQueryConfigHandler() {
-    addAttribute(UniqueFieldAttribute.class);
+    // empty constructor
   }
 
   @Override
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java	(working copy)
@@ -127,11 +127,10 @@
     return getSpanQuery("", query);
   }
 
-  public SpanQuery getSpanQuery(CharSequence uniqueField, CharSequence query)
+  public SpanQuery getSpanQuery(String uniqueField, CharSequence query)
       throws QueryNodeException {
-    UniqueFieldAttribute uniqueFieldAtt = this.spanQueryConfigHandler
-        .getAttribute(UniqueFieldAttribute.class);
-    uniqueFieldAtt.setUniqueField(uniqueField);
+    
+    this.spanQueryConfigHandler.set(SpansQueryConfigHandler.UNIQUE_FIELD, uniqueField);
 
     QueryNode queryTree = this.queryParser.parse(query, "defaultField");
     queryTree = this.spanProcessorPipeline.process(queryTree);
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java	(working copy)
@@ -104,9 +104,7 @@
     // create a config handler with a attribute used in
     // UniqueFieldQueryNodeProcessor
     QueryConfigHandler spanQueryConfigHandler = new SpansQueryConfigHandler();
-    UniqueFieldAttribute uniqueFieldAtt = spanQueryConfigHandler
-        .getAttribute(UniqueFieldAttribute.class);
-    uniqueFieldAtt.setUniqueField("index");
+    spanQueryConfigHandler.set(SpansQueryConfigHandler.UNIQUE_FIELD, "index");
 
     // set up the processor pipeline with the ConfigHandler
     // and create the pipeline for this simple demo
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldQueryNodeProcessor.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldQueryNodeProcessor.java	(working copy)
@@ -57,14 +57,12 @@
             "A config handler is expected by the processor UniqueFieldQueryNodeProcessor!");
       }
 
-      if (!queryConfig.hasAttribute(UniqueFieldAttribute.class)) {
+      if (!queryConfig.has(SpansQueryConfigHandler.UNIQUE_FIELD)) {
         throw new IllegalArgumentException(
             "UniqueFieldAttribute should be defined in the config handler!");
       }
 
-      CharSequence uniqueField = queryConfig.getAttribute(
-          UniqueFieldAttribute.class).getUniqueField();
-
+      String uniqueField = queryConfig.get(SpansQueryConfigHandler.UNIQUE_FIELD);
       fieldNode.setField(uniqueField);
 
     }
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerQPHelper.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerQPHelper.java	(working copy)
@@ -29,7 +29,7 @@
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.TypeAttribute;
 import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
 import org.apache.lucene.util.LuceneTestCase;
 
 /**
@@ -43,6 +43,7 @@
 
   private static int multiToken = 0;
 
+  @SuppressWarnings("deprecation")
   public void testMultiAnalyzer() throws QueryNodeException {
 
     StandardQueryParser qp = new StandardQueryParser();
@@ -103,7 +104,7 @@
     qp.setDefaultPhraseSlop(0);
 
     // non-default operator:
-    qp.setDefaultOperator(Operator.AND);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     assertEquals("+(multi multi2) +foo", qp.parse("multi foo", "").toString());
 
   }
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerWrapper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerWrapper.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerWrapper.java	(working copy)
@@ -43,6 +43,7 @@
 
   private static int multiToken = 0;
 
+  @SuppressWarnings("deprecation")
   public void testMultiAnalyzer() throws ParseException {
 
     QueryParserWrapper qp = new QueryParserWrapper("", new MultiAnalyzer());
@@ -125,6 +126,7 @@
   //    
   // }
 
+  @SuppressWarnings("deprecation")
   public void testPosIncrementAnalyzer() throws ParseException {
     QueryParserWrapper qp = new QueryParserWrapper("",
         new PosIncrementAnalyzer());
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java	(working copy)
@@ -24,12 +24,11 @@
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
@@ -134,7 +133,7 @@
     assertEquals("(b:one t:one) f:two", q.toString());
 
     // AND mode:
-    mfqp.setDefaultOperator(Operator.AND);
+    mfqp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     q = mfqp.parse("one two", null);
     assertEquals("+(b:one t:one) +(b:two t:two)", q.toString());
     q = mfqp.parse("\"aa bb cc\" \"dd ee\"", null);
@@ -330,7 +329,7 @@
 
     mfqp.setMultiFields(new String[] { "body" });
     mfqp.setAnalyzer(analyzer);
-    mfqp.setDefaultOperator(Operator.AND);
+    mfqp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     Query q = mfqp.parse("the footest", null);
     IndexSearcher is = new IndexSearcher(ramDir, true);
     ScoreDoc[] hits = is.search(q, null, 1000).scoreDocs;
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(working copy)
@@ -59,7 +59,8 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
@@ -196,7 +197,7 @@
     StandardQueryParser qp = new StandardQueryParser();
     qp.setAnalyzer(a);
 
-    qp.setDefaultOperator(Operator.OR);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
 
     return qp;
 
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/config/TestAttributes.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/config/TestAttributes.java	(revision 1151708)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/config/TestAttributes.java	(working copy)
@@ -1,67 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.util._TestUtil;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.MultiTermQuery;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Locale;
-
-public class TestAttributes extends LuceneTestCase {
-
-  // this checks using reflection API if the defaults are correct
-  public void testAttributes() {
-    _TestUtil.assertAttributeReflection(new AllowLeadingWildcardAttributeImpl(),
-      Collections.singletonMap(AllowLeadingWildcardAttribute.class.getName()+"#allowLeadingWildcard", false));
-    _TestUtil.assertAttributeReflection(new AnalyzerAttributeImpl(),
-      Collections.singletonMap(AnalyzerAttribute.class.getName()+"#analyzer", null));
-    _TestUtil.assertAttributeReflection(new BoostAttributeImpl(),
-      Collections.singletonMap(BoostAttribute.class.getName()+"#boost", 1.0f));
-    _TestUtil.assertAttributeReflection(new DateResolutionAttributeImpl(),
-      Collections.singletonMap(DateResolutionAttribute.class.getName()+"#dateResolution", null));
-    _TestUtil.assertAttributeReflection(new DefaultOperatorAttributeImpl(),
-      Collections.singletonMap(DefaultOperatorAttribute.class.getName()+"#operator", DefaultOperatorAttribute.Operator.OR));
-    _TestUtil.assertAttributeReflection(new DefaultPhraseSlopAttributeImpl(),
-      Collections.singletonMap(DefaultPhraseSlopAttribute.class.getName()+"#defaultPhraseSlop", 0));
-    _TestUtil.assertAttributeReflection(new FieldBoostMapAttributeImpl(),
-      Collections.singletonMap(FieldBoostMapAttribute.class.getName()+"#boosts", Collections.emptyMap()));
-    _TestUtil.assertAttributeReflection(new FieldDateResolutionMapAttributeImpl(),
-      Collections.singletonMap(FieldDateResolutionMapAttribute.class.getName()+"#dateRes", Collections.emptyMap()));
-    _TestUtil.assertAttributeReflection(new FuzzyAttributeImpl(), new HashMap<String,Object>() {{
-      put(FuzzyAttribute.class.getName()+"#prefixLength", FuzzyQuery.defaultPrefixLength);
-      put(FuzzyAttribute.class.getName()+"#minSimilarity", FuzzyQuery.defaultMinSimilarity);
-    }});
-    _TestUtil.assertAttributeReflection(new LocaleAttributeImpl(),
-      Collections.singletonMap(LocaleAttribute.class.getName()+"#locale", Locale.getDefault()));
-    _TestUtil.assertAttributeReflection(new LowercaseExpandedTermsAttributeImpl(),
-      Collections.singletonMap(LowercaseExpandedTermsAttribute.class.getName()+"#lowercaseExpandedTerms", true));
-    _TestUtil.assertAttributeReflection(new MultiFieldAttributeImpl(),
-      Collections.singletonMap(MultiFieldAttribute.class.getName()+"#fields", null));
-    _TestUtil.assertAttributeReflection(new MultiTermRewriteMethodAttributeImpl(),
-      Collections.singletonMap(MultiTermRewriteMethodAttribute.class.getName()+"#multiTermRewriteMethod", MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT));
-    _TestUtil.assertAttributeReflection(new PositionIncrementsAttributeImpl(),
-      Collections.singletonMap(PositionIncrementsAttribute.class.getName()+"#positionIncrementsEnabled", false));
-    _TestUtil.assertAttributeReflection(new RangeCollatorAttributeImpl(),
-      Collections.singletonMap(RangeCollatorAttribute.class.getName()+"#rangeCollator", null));
-  }
-
-}
