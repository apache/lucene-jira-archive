Index: lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDReader.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDReader.java	(revision 1714528)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDReader.java	(working copy)
@@ -33,8 +33,9 @@
 
 class SimpleTextBKDReader extends BKDReader {
 
-  public SimpleTextBKDReader(IndexInput datIn, int numDims, int maxPointsInLeafNode, int bytesPerDim, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {
-    super(datIn, numDims, maxPointsInLeafNode, bytesPerDim, leafBlockFPs, splitPackedValues);
+  public SimpleTextBKDReader(IndexInput datIn, int numDims, int maxPointsInLeafNode, int bytesPerDim,
+                             long[] leafBlockFPs, byte[] splitPackedValues, int approxDocsPerBlock) throws IOException {
+    super(datIn, numDims, maxPointsInLeafNode, bytesPerDim, leafBlockFPs, splitPackedValues, approxDocsPerBlock);
   }
 
   @Override
Index: lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDimensionalReader.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDimensionalReader.java	(revision 1714528)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDimensionalReader.java	(working copy)
@@ -107,7 +107,8 @@
       System.arraycopy(br.bytes, br.offset, splitPackedValues, (1 + bytesPerDim) * i + 1, bytesPerDim);
     }
 
-    return new SimpleTextBKDReader(dataIn, numDims, maxPointsInLeafNode, bytesPerDim, leafBlockFPs, splitPackedValues);
+    // nocommit
+    return new SimpleTextBKDReader(dataIn, numDims, maxPointsInLeafNode, bytesPerDim, leafBlockFPs, splitPackedValues, -1);
   }
 
   private void readLine(IndexInput in) throws IOException {
Index: lucene/core/src/java/org/apache/lucene/index/DimensionalValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/DimensionalValues.java	(revision 1714528)
+++ lucene/core/src/java/org/apache/lucene/index/DimensionalValues.java	(working copy)
@@ -54,9 +54,21 @@
      *  determine how to further recurse down the treer. */
     Relation compare(byte[] minPackedValue, byte[] maxPackedValue);
 
-    /** Notifies the caller that this many documents (from one block) are about
+    /** Optional: notifies the caller that this many documents are about
      *  to be visited */
     default void grow(int count) {};
+
+    /** Optional: returns the minimum point in the box containing the query,
+     *  or null if the full space should be searched. */
+    default byte[] getMinInclusive() {
+      return null;
+    }
+
+    /** Optional: returns the maximum point in the box containing the query,
+     *  or null if the full space should be searched. */
+    default byte[] getMaxInclusive() {
+      return null;
+    }
   }
 
   /** Finds all documents and points matching the provided visitor.
Index: lucene/core/src/java/org/apache/lucene/search/DimensionalRangeQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DimensionalRangeQuery.java	(revision 1714528)
+++ lucene/core/src/java/org/apache/lucene/search/DimensionalRangeQuery.java	(working copy)
@@ -206,6 +206,16 @@
                            }
 
                            @Override
+                           public byte[] getMinInclusive() {
+                             return packedLowerIncl;
+                           }
+
+                           @Override
+                           public byte[] getMaxInclusive() {
+                             return packedUpperIncl;
+                           }
+
+                           @Override
                            public void visit(int docID, byte[] packedValue) {
                              for(int dim=0;dim<numDims;dim++) {
                                int offset = dim*bytesPerDim;
Index: lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader.java	(revision 1714528)
+++ lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader.java	(working copy)
@@ -25,7 +25,9 @@
 import org.apache.lucene.index.DimensionalValues.Relation;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.Accountable;
+import org.apache.lucene.util.BytesRef; // nocommit remove
 import org.apache.lucene.util.RamUsageEstimator;
+import org.apache.lucene.util.StringHelper;
 
 /** Handles intersection of an multi-dimensional shape in byte[] space with a block KD-tree previously written with {@link BKDWriter}.
  *
@@ -40,6 +42,7 @@
   final int bytesPerDim;
   final IndexInput in;
   final int maxPointsInLeafNode;
+  final int approxDocsPerBlock;
   protected final int packedBytesLength;
 
   /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */
@@ -54,6 +57,8 @@
     int numLeaves = in.readVInt();
     leafNodeOffset = numLeaves;
 
+    approxDocsPerBlock = in.readVInt();
+
     splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];
     in.readBytes(splitPackedValues, 0, splitPackedValues.length);
 
@@ -70,7 +75,7 @@
   }
 
   /** Called by consumers that have their own on-disk format for the index */
-  protected BKDReader(IndexInput in, int numDims, int maxPointsInLeafNode, int bytesPerDim, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {
+  protected BKDReader(IndexInput in, int numDims, int maxPointsInLeafNode, int bytesPerDim, long[] leafBlockFPs, byte[] splitPackedValues, int approxDocsPerBlock) throws IOException {
     this.in = in;
     this.numDims = numDims;
     this.maxPointsInLeafNode = maxPointsInLeafNode;
@@ -79,6 +84,7 @@
     this.leafNodeOffset = leafBlockFPs.length;
     this.leafBlockFPs = leafBlockFPs;
     this.splitPackedValues = splitPackedValues;
+    this.approxDocsPerBlock = approxDocsPerBlock;
   }
 
   private static final class IntersectState {
@@ -102,12 +108,135 @@
     IntersectState state = new IntersectState(in.clone(), packedBytesLength,
                                               maxPointsInLeafNode,
                                               visitor);
-    byte[] rootMinPacked = new byte[packedBytesLength];
-    byte[] rootMaxPacked = new byte[packedBytesLength];
-    Arrays.fill(rootMaxPacked, (byte) 0xff);
-    intersect(state, 1, rootMinPacked, rootMaxPacked);
+    byte[] queryMin = visitor.getMinInclusive();
+    byte[] queryMax = visitor.getMaxInclusive();
+    if (numDims == 1 && queryMin != null && queryMax != null) {
+      intersect1D(queryMin, queryMax, state);
+    } else {
+      byte[] rootMinPacked = new byte[packedBytesLength];
+      byte[] rootMaxPacked = new byte[packedBytesLength];
+      Arrays.fill(rootMaxPacked, (byte) 0xff);
+      intersect(state, 1, rootMinPacked, rootMaxPacked);
+    }
   }
 
+  /** Specialized implementation for the 1D case, where we can estimate up front how many hits we'll have,
+   *  and we can do a simple linear scan of the blocks */
+  private void intersect1D(byte[] queryMinIncl, byte[] queryMaxIncl, IntersectState state) throws IOException {
+
+    //System.out.println("OPTO");
+    //System.out.println("  " + leafBlockFPs.length + " leaves");
+
+    // Find the start lower block (lowest block that could contain the query's min point):
+    int startLowerNodeID = 1;
+    while (startLowerNodeID < leafNodeOffset) {
+      //System.out.println("node=" + startLowerNodeID + " split=" + new BytesRef(splitPackedValues, 1+startLowerNodeID*(1+bytesPerDim), bytesPerDim) + " vs " + new BytesRef(queryMinIncl, 0, bytesPerDim));
+      int cmp = StringHelper.compare(bytesPerDim, queryMinIncl, 0, splitPackedValues, 1+startLowerNodeID*(1+bytesPerDim));
+      if (cmp <= 0) {
+        // Recurse left
+        startLowerNodeID *= 2;
+      } else {
+        // Recurse right
+        startLowerNodeID = 2*startLowerNodeID + 1;
+      }
+    }
+
+    // Find the start upper block (highest block that could contain the query's min point):
+    int startUpperNodeID = 1;
+    while (startUpperNodeID < leafNodeOffset) {
+      int cmp = StringHelper.compare(bytesPerDim, queryMinIncl, 0, splitPackedValues, 1+startUpperNodeID*(1+bytesPerDim));
+      if (cmp < 0) {
+        // Recurse left
+        startUpperNodeID *= 2;
+      } else {
+        // Recurse right
+        startUpperNodeID = 2*startUpperNodeID + 1;
+      }
+    }
+
+    // Find the end lower block (lowest block that could contain the query's max point):
+    int endLowerNodeID = 1;
+    while (endLowerNodeID < leafNodeOffset) {
+      int cmp = StringHelper.compare(bytesPerDim, queryMaxIncl, 0, splitPackedValues, 1+endLowerNodeID*(1+bytesPerDim));
+      if (cmp > 0) {
+        // Recurse right
+        endLowerNodeID = 2*endLowerNodeID + 1;
+      } else {
+        // Recurse left
+        endLowerNodeID *= 2;
+      }
+    }
+
+    // Find the end lower block (lowest block that could contain the query's max point):
+    int endUpperNodeID = 1;
+    while (endUpperNodeID < leafNodeOffset) {
+      int cmp = StringHelper.compare(bytesPerDim, queryMaxIncl, 0, splitPackedValues, 1+endUpperNodeID*(1+bytesPerDim));
+      if (cmp >= 0) {
+        // Recurse right
+        endUpperNodeID = 2*endUpperNodeID + 1;
+      } else {
+        // Recurse left
+        endUpperNodeID *= 2;
+      }
+    }
+    //System.out.println("start: " + startLowerNodeID + " to " + startUpperNodeID);
+    //System.out.println("end: " + endLowerNodeID + " to " + endUpperNodeID);
+
+    state.in.seek(leafBlockFPs[startLowerNodeID-leafNodeOffset]);
+
+    // Rough estimate of how many hits we'll see.  Note that in the degenerate case
+    // (index same value many times) this could be a big over-estimate, but in the typical
+    // case it's good:
+    state.visitor.grow(approxDocsPerBlock * (endUpperNodeID - startLowerNodeID + 1));
+
+    // nocommit doesn't work w/ SimpleText:
+    int[] scratchDocIDs = state.scratchDocIDs;
+    byte[] scratchPackedValue = state.scratchPackedValue;
+
+    int block = startLowerNodeID;
+    while (block <= startUpperNodeID) {
+      //System.out.println("start filter block");
+      // How many points are stored in this leaf cell:
+      int count = state.in.readVInt();
+      for(int i=0;i<count;i++) {
+        scratchDocIDs[i] = state.in.readInt();
+      }
+      for(int i=0;i<count;i++) {
+        state.in.readBytes(scratchPackedValue, 0, scratchPackedValue.length);
+        //System.out.println("  doc=" + scratchDocIDs[i] + " value=" + new BytesRef(scratchPackedValue));
+        state.visitor.visit(scratchDocIDs[i], scratchPackedValue);
+      }
+      block++;
+    }
+
+    while (block < endLowerNodeID) {
+      //System.out.println("mid block");
+      int count = state.in.readVInt();
+      for(int i=0;i<count;i++) {
+        state.visitor.visit(state.in.readInt());
+        //System.out.println("  doc=" + scratchDocIDs[i]);
+      }
+      // nocommit must skip values
+      state.in.seek(state.in.getFilePointer() + bytesPerDim * count);
+      
+      block++;
+    }
+
+    while (block <= endUpperNodeID) {
+      //System.out.println("end filter block");
+      int count = state.in.readVInt();
+      for(int i=0;i<count;i++) {
+        scratchDocIDs[i] = state.in.readInt();
+        //System.out.println("  doc=" + scratchDocIDs[i]);
+      }
+      for(int i=0;i<count;i++) {
+        state.in.readBytes(scratchPackedValue, 0, scratchPackedValue.length);
+        state.visitor.visit(scratchDocIDs[i], scratchPackedValue);
+      }
+      block++;
+    }
+  }
+
   /** Fast path: this is called when the query box fully encompasses all cells under this node. */
   private void addAll(IntersectState state, int nodeID) throws IOException {
     //System.out.println("R: addAll nodeID=" + nodeID);
@@ -167,6 +296,8 @@
     }
     */
 
+    // nocommit use query min/max here too
+
     Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);
 
     if (r == Relation.CELL_OUTSIDE_QUERY) {
Index: lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java	(revision 1714528)
+++ lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java	(working copy)
@@ -473,6 +473,8 @@
     out.writeVInt(bytesPerDim);
 
     out.writeVInt(leafBlockFPs.length);
+    // approxDocsPerBlock
+    out.writeVInt((int) (pointCount / leafBlockFPs.length));
 
     // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)
 
