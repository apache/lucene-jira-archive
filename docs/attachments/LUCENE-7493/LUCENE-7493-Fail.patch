diff --git a/lucene/facet/src/java/org/apache/lucene/facet/FacetsCollector.java b/lucene/facet/src/java/org/apache/lucene/facet/FacetsCollector.java
index d3f2eb8..c9819e8 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/FacetsCollector.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/FacetsCollector.java
@@ -36,6 +36,7 @@ import org.apache.lucene.search.TopDocsCollector;
 import org.apache.lucene.search.TopFieldCollector;
 import org.apache.lucene.search.TopFieldDocs;
 import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.search.TotalHitCountCollector;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BitDocIdSet;
 import org.apache.lucene.util.FixedBitSet;
@@ -251,23 +252,33 @@ public class FacetsCollector extends SimpleCollector implements Collector {
                                          + after.doc + " limit=" + limit);
     }
 
-    TopDocsCollector<?> hitsCollector;
-    if (sort != null) {
-      if (after != null && !(after instanceof FieldDoc)) {
-        // TODO: if we fix type safety of TopFieldDocs we can
-        // remove this
-        throw new IllegalArgumentException("after must be a FieldDoc; got " + after);
-      }
-      boolean fillFields = true;
-      hitsCollector = TopFieldCollector.create(sort, n,
-                                               (FieldDoc) after,
-                                               fillFields,
-                                               doDocScores,
-                                               doMaxScore);
-    } else {
-      hitsCollector = TopScoreDocCollector.create(n, after);
+    TopDocs topDocs = null;
+    if(n==0){
+          TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();
+          FacetsCollector facetCollector = new FacetsCollector();
+          searcher.search(q, MultiCollector.wrap(totalHitCountCollector, facetCollector));
+          topDocs = new TopDocs(totalHitCountCollector.getTotalHits(), new ScoreDoc[0], Float.NaN);
+    }else{
+          TopDocsCollector<?> hitsCollector;
+          if (sort != null) {
+            if (after != null && !(after instanceof FieldDoc)) {
+              // TODO: if we fix type safety of TopFieldDocs we can
+              // remove this
+              throw new IllegalArgumentException("after must be a FieldDoc; got " + after);
+            }
+            boolean fillFields = true;
+            hitsCollector = TopFieldCollector.create(sort, n,
+                                                     (FieldDoc) after,
+                                                     fillFields,
+                                                     doDocScores,
+                                                     doMaxScore);
+          } else {
+            hitsCollector = TopScoreDocCollector.create(n, after);
+          }
+          searcher.search(q, MultiCollector.wrap(hitsCollector, fc));
+    
+          topDocs = hitsCollector.topDocs();
     }
-    searcher.search(q, MultiCollector.wrap(hitsCollector, fc));
-    return hitsCollector.topDocs();
+    return topDocs;
   }
 }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/TestDrillDownQuery.java b/lucene/facet/src/test/org/apache/lucene/facet/TestDrillDownQuery.java
index f76e839..c1442bd 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/TestDrillDownQuery.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/TestDrillDownQuery.java
@@ -182,6 +182,17 @@ public class TestDrillDownQuery extends FacetTestCase {
     assertEquals(10, docs.totalHits);
   }
   
+  public void testZeroLimit() throws IOException {
+    IndexSearcher searcher = newSearcher(reader);
+    DrillDownQuery q = new DrillDownQuery(config);
+    q.add("b", "1");
+    int limit = 0;
+    FacetsCollector facetCollector = new FacetsCollector();
+    FacetsCollector.search(searcher, q, limit, facetCollector);
+    Facets facets = getTaxonomyFacetCounts(taxo, config, facetCollector, config.getDimConfig("b").indexFieldName);
+    assertNotNull((facets.getTopChildren(10, "b")));
+  }
+  
   public void testScoring() throws IOException {
     // verify that drill-down queries do not modify scores
     IndexSearcher searcher = newSearcher(reader);
