Index: lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java	(revision 1636503)
+++ lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java	(working copy)
@@ -27,7 +27,7 @@
  * on the assumption that if the explanations work out right for them,
  * they should work for anything.
  */
-public class TestComplexExplanations extends TestExplanations {
+public class TestComplexExplanations extends BaseExplanationTestCase {
 
   /**
    * Override the Similarity used in our searcher with one that plays
Index: lucene/core/src/test/org/apache/lucene/search/TestExplanations.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestExplanations.java	(revision 1636503)
+++ lucene/core/src/test/org/apache/lucene/search/TestExplanations.java	(working copy)
@@ -1,222 +0,0 @@
-package org.apache.lucene.search;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.SortedDocValuesField;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.spans.SpanFirstQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-
-/**
- * Tests primitive queries (ie: that rewrite to themselves) to
- * insure they match the expected set of docs, and that the score of each
- * match is equal to the value of the scores explanation.
- *
- * <p>
- * The assumption is that if all of the "primitive" queries work well,
- * then anything that rewrites to a primitive will work well also.
- * </p>
- *
- * @see "Subclasses for actual tests"
- */
-public class TestExplanations extends LuceneTestCase {
-  protected static IndexSearcher searcher;
-  protected static IndexReader reader;
-  protected static Directory directory;
-  
-  public static final String KEY = "KEY";
-  // boost on this field is the same as the iterator for the doc
-  public static final String FIELD = "field";
-  // same contents, but no field boost
-  public static final String ALTFIELD = "alt";
-  
-  @AfterClass
-  public static void afterClassTestExplanations() throws Exception {
-    searcher = null;
-    reader.close();
-    reader = null;
-    directory.close();
-    directory = null;
-  }
-  
-  @BeforeClass
-  public static void beforeClassTestExplanations() throws Exception {
-    directory = newDirectory();
-    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
-    for (int i = 0; i < docFields.length; i++) {
-      Document doc = new Document();
-      doc.add(newStringField(KEY, ""+i, Field.Store.NO));
-      doc.add(new SortedDocValuesField(KEY, new BytesRef(""+i)));
-      Field f = newTextField(FIELD, docFields[i], Field.Store.NO);
-      f.setBoost(i);
-      doc.add(f);
-      doc.add(newTextField(ALTFIELD, docFields[i], Field.Store.NO));
-      writer.addDocument(doc);
-    }
-    reader = writer.getReader();
-    writer.close();
-    searcher = newSearcher(reader);
-  }
-
-  protected static final String[] docFields = {
-    "w1 w2 w3 w4 w5",
-    "w1 w3 w2 w3 zz",
-    "w1 xx w2 yy w3",
-    "w1 w3 xx w2 yy w3 zz"
-  };
-  
-  /** check the expDocNrs first, then check the query (and the explanations) */
-  public void qtest(Query q, int[] expDocNrs) throws Exception {
-    CheckHits.checkHitCollector(random(), q, FIELD, searcher, expDocNrs);
-  }
-
-  /**
-   * Tests a query using qtest after wrapping it with both optB and reqB
-   * @see #qtest
-   * @see #reqB
-   * @see #optB
-   */
-  public void bqtest(Query q, int[] expDocNrs) throws Exception {
-    qtest(reqB(q), expDocNrs);
-    qtest(optB(q), expDocNrs);
-  }
-  
-  /** 
-   * Convenience subclass of FieldCacheTermsFilter
-   */
-  public static class ItemizedFilter extends DocValuesTermsFilter {
-    private static String[] int2str(int [] terms) {
-      String [] out = new String[terms.length];
-      for (int i = 0; i < terms.length; i++) {
-        out[i] = ""+terms[i];
-      }
-      return out;
-    }
-    public ItemizedFilter(int [] keys) {
-      super(KEY, int2str(keys));
-    }
-  }
-
-  /** helper for generating MultiPhraseQueries */
-  public static Term[] ta(String[] s) {
-    Term[] t = new Term[s.length];
-    for (int i = 0; i < s.length; i++) {
-      t[i] = new Term(FIELD, s[i]);
-    }
-    return t;
-  }
-
-  /** MACRO for SpanTermQuery */
-  public SpanTermQuery st(String s) {
-    return new SpanTermQuery(new Term(FIELD,s));
-  }
-  
-  /** MACRO for SpanNotQuery */
-  public SpanNotQuery snot(SpanQuery i, SpanQuery e) {
-    return new SpanNotQuery(i,e);
-  }
-
-  /** MACRO for SpanOrQuery containing two SpanTerm queries */
-  public SpanOrQuery sor(String s, String e) {
-    return sor(st(s), st(e));
-  }
-  /** MACRO for SpanOrQuery containing two SpanQueries */
-  public SpanOrQuery sor(SpanQuery s, SpanQuery e) {
-    return new SpanOrQuery(s, e);
-  }
-  
-  /** MACRO for SpanOrQuery containing three SpanTerm queries */
-  public SpanOrQuery sor(String s, String m, String e) {
-    return sor(st(s), st(m), st(e));
-  }
-  /** MACRO for SpanOrQuery containing two SpanQueries */
-  public SpanOrQuery sor(SpanQuery s, SpanQuery m, SpanQuery e) {
-    return new SpanOrQuery(s, m, e);
-  }
-  
-  /** MACRO for SpanNearQuery containing two SpanTerm queries */
-  public SpanNearQuery snear(String s, String e, int slop, boolean inOrder) {
-    return snear(st(s), st(e), slop, inOrder);
-  }
-  /** MACRO for SpanNearQuery containing two SpanQueries */
-  public SpanNearQuery snear(SpanQuery s, SpanQuery e,
-                             int slop, boolean inOrder) {
-    return new SpanNearQuery(new SpanQuery[] { s, e }, slop, inOrder);
-  }
-  
-  
-  /** MACRO for SpanNearQuery containing three SpanTerm queries */
-  public SpanNearQuery snear(String s, String m, String e,
-                             int slop, boolean inOrder) {
-    return snear(st(s), st(m), st(e), slop, inOrder);
-  }
-  /** MACRO for SpanNearQuery containing three SpanQueries */
-  public SpanNearQuery snear(SpanQuery s, SpanQuery m, SpanQuery e,
-                             int slop, boolean inOrder) {
-    return new SpanNearQuery(new SpanQuery[] { s, m, e }, slop, inOrder);
-  }
-  
-  /** MACRO for SpanFirst(SpanTermQuery) */
-  public SpanFirstQuery sf(String s, int b) {
-    return new SpanFirstQuery(st(s), b);
-  }
-
-  /**
-   * MACRO: Wraps a Query in a BooleanQuery so that it is optional, along
-   * with a second prohibited clause which will never match anything
-   */
-  public Query optB(Query q) throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(q, BooleanClause.Occur.SHOULD);
-    bq.add(new TermQuery(new Term("NEVER","MATCH")), BooleanClause.Occur.MUST_NOT);
-    return bq;
-  }
-
-  /**
-   * MACRO: Wraps a Query in a BooleanQuery so that it is required, along
-   * with a second optional clause which will match everything
-   */
-  public Query reqB(Query q) throws Exception {
-    BooleanQuery bq = new BooleanQuery(true);
-    bq.add(q, BooleanClause.Occur.MUST);
-    bq.add(new TermQuery(new Term(FIELD,"w1")), BooleanClause.Occur.SHOULD);
-    return bq;
-  }
-  
-  /**
-   * Placeholder: JUnit freaks if you don't have one test ... making
-   * class abstract doesn't help
-   */
-  public void testNoop() {
-    /* NOOP */
-  }
-}
Index: lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java	(revision 1636503)
+++ lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java	(working copy)
@@ -22,7 +22,7 @@
 /**
  * TestExplanations subclass focusing on basic query types
  */
-public class TestSimpleExplanations extends TestExplanations {
+public class TestSimpleExplanations extends BaseExplanationTestCase {
 
   // we focus on queries that don't rewrite to other queries.
   // if we get those covered well, then the ones that rewrite should
Index: lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java	(revision 1636503)
+++ lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java	(working copy)
@@ -20,7 +20,7 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.TestExplanations;
+import org.apache.lucene.search.BaseExplanationTestCase;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.util.BytesRef;
 
@@ -27,7 +27,7 @@
 /**
  * TestExplanations subclass focusing on payload queries
  */
-public class TestPayloadExplanations extends TestExplanations {
+public class TestPayloadExplanations extends BaseExplanationTestCase {
   private PayloadFunction functions[] = new PayloadFunction[] { 
       new AveragePayloadFunction(),
       new MinPayloadFunction(),
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java	(revision 1636503)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java	(working copy)
@@ -23,7 +23,7 @@
 /**
  * TestExplanations subclass focusing on span queries
  */
-public class TestSpanExplanations extends TestExplanations {
+public class TestSpanExplanations extends BaseExplanationTestCase {
 
   /* simple SpanTermQueries */
   
Index: lucene/queries/src/java/org/apache/lucene/queries/CustomScoreQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/CustomScoreQuery.java	(revision 1636503)
+++ lucene/queries/src/java/org/apache/lucene/queries/CustomScoreQuery.java	(working copy)
@@ -263,11 +263,11 @@
         valSrcExpls[i] = valSrcWeights[i].explain(info, doc);
       }
       Explanation customExp = CustomScoreQuery.this.getCustomScoreProvider(info).customExplain(doc,subQueryExpl,valSrcExpls);
-      float sc = getBoost() * customExp.getValue();
+      float sc = queryWeight * customExp.getValue();
       Explanation res = new ComplexExplanation(
         true, sc, CustomScoreQuery.this.toString() + ", product of:");
       res.addDetail(customExp);
-      res.addDetail(new Explanation(getBoost(), "queryBoost")); // actually using the q boost as q weight (== weight value)
+      res.addDetail(new Explanation(queryWeight, "queryWeight"));
       return res;
     }
 
Index: lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreExplanations.java
===================================================================
--- lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreExplanations.java	(revision 0)
+++ lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreExplanations.java	(working copy)
@@ -0,0 +1,53 @@
+package org.apache.lucene.queries;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queries.function.FunctionQuery;
+import org.apache.lucene.queries.function.valuesource.ConstValueSource;
+import org.apache.lucene.search.BaseExplanationTestCase;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+
+public class TestCustomScoreExplanations extends BaseExplanationTestCase {
+  public void testOneTerm() throws Exception {
+    Query q = new TermQuery(new Term(FIELD, "w1"));
+    CustomScoreQuery csq = new CustomScoreQuery(q, new FunctionQuery(new ConstValueSource(5)));
+    qtest(csq, new int[] { 0,1,2,3 });
+  }
+  
+  public void testBoost() throws Exception {
+    Query q = new TermQuery(new Term(FIELD, "w1"));
+    CustomScoreQuery csq = new CustomScoreQuery(q, new FunctionQuery(new ConstValueSource(5)));
+    csq.setBoost(4);
+    qtest(csq, new int[] { 0,1,2,3 });
+  }
+  
+  public void testTopLevelBoost() throws Exception {
+    Query q = new TermQuery(new Term(FIELD, "w1"));
+    CustomScoreQuery csq = new CustomScoreQuery(q, new FunctionQuery(new ConstValueSource(5)));
+    BooleanQuery bq = new BooleanQuery();
+    bq.add(new MatchAllDocsQuery(), BooleanClause.Occur.MUST);
+    bq.add(csq, BooleanClause.Occur.MUST);
+    bq.setBoost(6);
+    qtest(bq, new int[] { 0,1,2,3 });
+  }
+}

Property changes on: lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreExplanations.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java	(revision 1636503)
+++ lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java	(working copy)
@@ -48,7 +48,7 @@
  *
  * @see "Subclasses for actual tests"
  */
-public class TestExplanations extends LuceneTestCase {
+public abstract class BaseExplanationTestCase extends LuceneTestCase {
   protected static IndexSearcher searcher;
   protected static IndexReader reader;
   protected static Directory directory;
@@ -211,12 +211,4 @@
     bq.add(new TermQuery(new Term(FIELD,"w1")), BooleanClause.Occur.SHOULD);
     return bq;
   }
-  
-  /**
-   * Placeholder: JUnit freaks if you don't have one test ... making
-   * class abstract doesn't help
-   */
-  public void testNoop() {
-    /* NOOP */
-  }
 }
