Index: src/java/org/apache/lucene/index/LogDocMergePolicy.java
===================================================================
--- src/java/org/apache/lucene/index/LogDocMergePolicy.java	(revision 0)
+++ src/java/org/apache/lucene/index/LogDocMergePolicy.java	(revision 0)
@@ -0,0 +1,25 @@
+package org.apache.lucene.index;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class LogDocMergePolicy extends LogMergePolicy {
+  protected long size(SegmentInfo info) {
+    return info.docCount;
+  }
+}
+

Property changes on: src/java/org/apache/lucene/index/LogDocMergePolicy.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: src/java/org/apache/lucene/index/LogByteSizeMergePolicy.java
===================================================================
--- src/java/org/apache/lucene/index/LogByteSizeMergePolicy.java	(revision 0)
+++ src/java/org/apache/lucene/index/LogByteSizeMergePolicy.java	(revision 0)
@@ -0,0 +1,27 @@
+package org.apache.lucene.index;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+public class LogByteSizeMergePolicy extends LogMergePolicy {
+  protected long size(SegmentInfo info) throws IOException {
+    return info.sizeInBytes();
+  }
+}
+

Property changes on: src/java/org/apache/lucene/index/LogByteSizeMergePolicy.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: src/java/org/apache/lucene/index/SegmentInfo.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfo.java	(revision 566393)
+++ src/java/org/apache/lucene/index/SegmentInfo.java	(working copy)
@@ -65,6 +65,8 @@
   private List files;                             // cached list of files that this segment uses
                                                   // in the Directory
 
+  long sizeInBytes = -1;                          // total byte size of all of our files (computed on demand)
+
   private int docStoreOffset;                     // if this segment shares stored fields & vectors, this
                                                   // offset is where in that file this segment's docs begin
   private String docStoreSegment;                 // name used to derive fields/vectors file we share with
@@ -104,7 +106,7 @@
    * Copy everything from src SegmentInfo into our instance.
    */
   void reset(SegmentInfo src) {
-    files = null;
+    clearFiles();
     name = src.name;
     docCount = src.docCount;
     dir = src.dir;
@@ -199,6 +201,19 @@
     }
   }
 
+  /** Returns total size in bytes of all of files used by
+   *  this segment. */
+  long sizeInBytes() throws IOException {
+    if (sizeInBytes == -1) {
+      List files = files();
+      final int size = files.size();
+      sizeInBytes = 0;
+      for(int i=0;i<size;i++) 
+        sizeInBytes += dir.fileLength((String) files.get(i));
+    }
+    return sizeInBytes;
+  }
+
   boolean hasDeletions()
     throws IOException {
     // Cases:
@@ -231,12 +246,12 @@
     } else {
       delGen++;
     }
-    files = null;
+    clearFiles();
   }
 
   void clearDelGen() {
     delGen = NO;
-    files = null;
+    clearFiles();
   }
 
   public Object clone () {
@@ -345,7 +360,7 @@
     } else {
       normGen[fieldIndex]++;
     }
-    files = null;
+    clearFiles();
   }
 
   /**
@@ -392,7 +407,7 @@
     } else {
       this.isCompoundFile = NO;
     }
-    files = null;
+    clearFiles();
   }
 
   /**
@@ -419,7 +434,7 @@
   
   void setDocStoreIsCompoundFile(boolean v) {
     docStoreIsCompoundFile = v;
-    files = null;
+    clearFiles();
   }
   
   String getDocStoreSegment() {
@@ -428,7 +443,7 @@
   
   void setDocStoreOffset(int offset) {
     docStoreOffset = offset;
-    files = null;
+    clearFiles();
   }
   
   /**
@@ -561,4 +576,11 @@
     }
     return files;
   }
+
+  /* Called whenever any change is made that affects which
+   * files this segment has. */
+  private void clearFiles() {
+    files = null;
+    sizeInBytes = -1;
+  }
 }
Index: src/java/org/apache/lucene/index/LogMergePolicy.java
===================================================================
--- src/java/org/apache/lucene/index/LogMergePolicy.java	(revision 0)
+++ src/java/org/apache/lucene/index/LogMergePolicy.java	(revision 0)
@@ -0,0 +1,213 @@
+package org.apache.lucene.index;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.List;
+import java.util.ArrayList;
+
+abstract class LogMergePolicy implements MergePolicy {
+
+  public static final double LEVEL_LOG_SPAN = 0.75;
+
+  public static final int DEFAULT_MERGE_FACTOR = 10;
+  public static final int DEFAULT_MAX_MERGE_DOCS = Integer.MAX_VALUE;
+
+  private int mergeFactor = DEFAULT_MERGE_FACTOR;
+  private int maxMergeDocs = DEFAULT_MAX_MERGE_DOCS;
+
+  private boolean useCompoundFile = true;
+  private boolean useCompoundDocStore = true;
+
+  public int getMergeFactor() {
+    return mergeFactor;
+  }
+  public void setMergeFactor(int mergeFactor) {
+    this.mergeFactor = mergeFactor;
+  }
+
+  public int getMaxMergeDocs() {
+    return maxMergeDocs;
+  }
+  public void setMaxMergeDocs(int maxMergeDocs) {
+    this.maxMergeDocs = maxMergeDocs;
+  }
+
+  public boolean useCompoundFile(SegmentInfos infos, SegmentInfo info) {
+    return useCompoundFile;
+  }
+
+  public void setUseCompoundFile(boolean useCompoundFile) {
+    this.useCompoundFile = useCompoundFile;
+  }
+
+  public boolean getUseCompoundFile() {
+    return useCompoundFile;
+  }
+
+  public boolean useCompoundDocStore(SegmentInfos infos) {
+    return useCompoundDocStore;
+  }
+
+  public void setUseCompoundDocStore(boolean useCompoundDocStore) {
+    this.useCompoundDocStore = useCompoundDocStore;
+  }
+
+  public boolean getUseCompoundDocStore() {
+    return useCompoundDocStore;
+  }
+
+  public void close() {
+  }
+
+  SegmentInfos segmentInfos(SegmentInfos all, int first, int last) {
+    SegmentInfos subset = new SegmentInfos();
+    /* synchronized(all) */ {
+      subset.addAll(all.subList(first, last));
+    }
+    return subset;
+  }
+
+  public void optimize(SegmentInfos segmentInfos, IndexMerger merger) throws IOException, CorruptIndexException {
+
+    if (segmentInfos.size() > 0) {
+
+      while ((segmentInfos.size() > 1) ||
+              SegmentReader.hasDeletions(segmentInfos.info(0)) ||
+              SegmentReader.hasSeparateNorms(segmentInfos.info(0)) ||
+              (segmentInfos.info(0).dir != merger.getDirectory()) ||
+              (useCompoundFile && (!SegmentReader.usesCompoundFile(segmentInfos.info(0))))) {
+
+        MergeSpecification spec = new MergeSpecification();
+
+        int first = segmentInfos.size() - mergeFactor;
+        first =  first < 0 ? 0 : first;
+        int last =  segmentInfos.size();
+
+        spec.segments = segmentInfos(segmentInfos, first, last);
+        spec.useCompoundFile = useCompoundFile;
+
+        merger.merge(spec);
+      }
+    }
+  }
+
+  private boolean mergeOnlyAdjacent = true;
+  private IndexWriter writer;
+
+  void copy(SegmentInfos segmentInfos,
+            IndexMerger merger,
+            int first,
+            int last)    
+    throws CorruptIndexException, IOException {
+
+    MergeSpecification spec = new MergeSpecification();
+    spec.segments = segmentInfos(segmentInfos, first, last);
+    spec.useCompoundFile = useCompoundFile;
+
+    merger.merge(spec);
+  }
+
+  abstract protected long size(SegmentInfo info) throws IOException;
+
+  public void merge(SegmentInfos infos, IndexMerger merger) throws CorruptIndexException, IOException {
+    mergeInternal(infos, merger);
+    // Now copy any segments whose dir doesn't match
+    copyDirSegments(infos, merger);
+  }
+
+  private void mergeInternal(SegmentInfos infos, IndexMerger merger) throws CorruptIndexException, IOException {
+
+    // Compute levels, which is just log (base mergeFactor)
+    // of the size of each segment
+    final int numSegments = infos.size();
+    float[] levels = new float[numSegments];
+    final float norm = (float) Math.log(mergeFactor);
+    for(int i=0;i<numSegments;i++) {
+      long size = size(infos.info(i));
+      if (size < mergeFactor)
+        // Floor level @ 0.0
+        size = mergeFactor;
+      levels[i] = (float) Math.log(size)/norm;
+    }
+
+    // Now, we quantize the log values into levels.  The
+    // first level is any segment whose log size is within
+    // LEVEL_LOG_SPAN of the max size, or, who has such as
+    // segment "to the right".  Then, we find the max of all
+    // other segments and use that to define the next level
+    // segment, etc.
+
+    int start = 0;
+    while(start < numSegments) {
+
+      // Find max level of all segments not already
+      // quantized.
+      float maxLevel = levels[start];
+      for(int i=1+start;i<numSegments;i++) {
+        final float level = levels[i];
+        if (level > maxLevel)
+          maxLevel = level;
+      }
+
+      // Now search backwards for the rightmost segment that
+      // falls into this level:
+      int upto = numSegments-1;
+      final float levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);
+      while(upto >= start) {
+        if (levels[upto] > levelBottom)
+          break;
+        upto--;
+      }
+
+      // Finally, we now have N segments from start to upto
+      // that are at the same quantized level.  If this is
+      // more than mergeFactor segments, we merge them.
+      if (1+upto-start >= mergeFactor) {
+        boolean anyTooLarge = false;
+        final int limit = start+mergeFactor;
+        for(int i=start;i<limit;i++)
+          anyTooLarge |= infos.info(i).docCount >= maxMergeDocs;
+
+        if (!anyTooLarge) {
+          MergeSpecification spec = new MergeSpecification();
+          spec.useCompoundFile = useCompoundFile;
+          spec.segments = segmentInfos(infos, start, start+mergeFactor);
+          merger.merge(spec);
+          // Recurse to cacscade
+          mergeInternal(infos, merger);
+          break;
+        }
+      }
+      start = 1+upto;
+    }
+
+  }
+
+  private void copyDirSegments(SegmentInfos infos, IndexMerger merger) throws CorruptIndexException, IOException {
+    final int numSegments = infos.size();
+    for(int i=0;i<numSegments;i++) {
+      SegmentInfo info = infos.info(i);
+      if (info.dir != merger.getDirectory()) {
+        if (info.docCount >= maxMergeDocs)
+          throw new IllegalArgumentException("Cannot add index that contains segments > maxMergeDocs");
+        copy(infos, merger, i, 1+i);
+      }
+    }
+  }
+}

Property changes on: src/java/org/apache/lucene/index/LogMergePolicy.java
___________________________________________________________________
Name: svn:eol-style
   + native

