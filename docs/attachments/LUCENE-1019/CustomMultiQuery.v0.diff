Index: src/test/org/apache/lucene/search/function/TestCustomMultiScoreQuery.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestCustomMultiScoreQuery.java	(revision 0)
+++ src/test/org/apache/lucene/search/function/TestCustomMultiScoreQuery.java	(revision 0)
@@ -0,0 +1,300 @@
+package org.apache.lucene.search.function;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.TopDocs;
+
+/**
+ * Test CustomScoreQuery search.
+ */
+public class TestCustomMultiScoreQuery extends FunctionTestSetup {
+
+	/* @override constructor */
+	public TestCustomMultiScoreQuery(String name) {
+		super(name);
+	}
+
+	/* @override */
+	protected void tearDown() throws Exception {
+		super.tearDown();
+	}
+
+	/* @override */
+	protected void setUp() throws Exception {
+		// prepare a small index with just a few documents.
+		super.setUp();
+	}
+
+	/** Test that CustomScoreQuery of Type.BYTE returns the expected scores. */
+	public void testCustomScoreByte() throws CorruptIndexException, Exception {
+		// INT field values are small enough to be parsed as byte
+		doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.BYTE, 1.0);
+		doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.BYTE, 2.0);
+	}
+
+	/** Test that CustomScoreQuery of Type.SHORT returns the expected scores. */
+	public void testCustomScoreShort() throws CorruptIndexException, Exception {
+		// INT field values are small enough to be parsed as short
+		doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.SHORT, 1.0);
+		doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.SHORT, 3.0);
+	}
+
+	/** Test that CustomScoreQuery of Type.INT returns the expected scores. */
+	public void testCustomScoreInt() throws CorruptIndexException, Exception {
+		doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.INT, 1.0);
+		doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.INT, 4.0);
+	}
+
+	/** Test that CustomScoreQuery of Type.FLOAT returns the expected scores. */
+	public void testCustomScoreFloat() throws CorruptIndexException, Exception {
+		// INT field can be parsed as float
+		doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.FLOAT, 1.0);
+		doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.FLOAT, 5.0);
+		// same values, but in flot format
+		doTestCustomScore(FLOAT_FIELD, FieldScoreQuery.Type.FLOAT, 1.0);
+		doTestCustomScore(FLOAT_FIELD, FieldScoreQuery.Type.FLOAT, 6.0);
+	}
+
+	// Test that FieldScoreQuery returns docs with expected score.
+	private void doTestCustomScore(String field, FieldScoreQuery.Type tp,
+			double dboost) throws CorruptIndexException, Exception {
+		float boost = (float) dboost;
+		IndexSearcher s = new IndexSearcher(dir);
+		FieldScoreQuery qValSrcA = new FieldScoreQuery(field, tp);
+		FieldScoreQuery qValSrcB = new FieldScoreQuery(field, tp);
+		ValueSourceQuery[] qValSrcs = new ValueSourceQuery[] { qValSrcA, qValSrcB };
+		QueryParser qp = new QueryParser(TEXT_FIELD, anlzr);
+		String qtxt = "bleeding person chain knowledge";
+		
+		// regular (boolean) query.
+		Query q1 = qp.parse(qtxt);
+		log(q1);
+
+		// custom query, that should score the same as q1.
+		CustomMultiScoreQuery q2CustomNeutral = new CustomMultiScoreQuery(q1);
+		q2CustomNeutral.setBoost(boost);
+		log(q2CustomNeutral);
+
+		// custom query, that should (by default) multiply the scores of q1 by
+		// that of the fields
+		CustomMultiScoreQuery q3CustomMul = new CustomMultiScoreQuery(q1, qValSrcs);
+		q3CustomMul.setStrict(true);
+		q3CustomMul.setBoost(boost);
+		log(q3CustomMul);
+
+		// custom query, that should add the scores of q1 to that of the fields
+		CustomMultiScoreQuery q4CustomAdd = new CustomMultiScoreQuery(q1, qValSrcs) {
+			/*
+			 * (non-Javadoc)
+			 * 
+			 * @see org.apache.lucene.search.function.CustomScoreQuery#name()
+			 */
+			public String name() {
+				return "customAdd";
+			}
+
+			/*
+			 * (non-Javadoc)
+			 * 
+			 * @see org.apache.lucene.search.function.CustomScoreQuery#customScore(int,
+			 *      float, float)
+			 */
+			public float customScore(int doc, float subQueryScore,
+					float[] valSrcScore) {
+				float score = subQueryScore;
+				for(int i =0; i < valSrcScore.length; i++ )
+				{
+					score += valSrcScore[i];
+				}
+				return score;
+			}
+
+			/*
+			 * (non-Javadoc)@see
+			 * org.apache.lucene.search.function.CustomScoreQuery#customExplain(int,
+			 * org.apache.lucene.search.Explanation,
+			 * org.apache.lucene.search.Explanation)
+			 */
+			public Explanation customExplain(int doc, Explanation subQueryExpl,
+					Explanation[] valSrcExpl) {
+				float score = 0;
+				for (int i = 0; i < valSrcExpl.length; i++) {
+					valSrcExpl[i].getValue();
+				}
+				Explanation exp = new Explanation(score
+						+ subQueryExpl.getValue(), "custom score: sum of:");
+				exp.addDetail(subQueryExpl);
+				for (int i = 0; i < valSrcExpl.length; i++) {
+					exp.addDetail(valSrcExpl[i]);
+				}
+				return exp;
+			}
+		};
+		q4CustomAdd.setStrict(true);
+		q4CustomAdd.setBoost(boost);
+		log(q4CustomAdd);
+
+		// custom query, that multiplies and adds the field score to that of q1
+		CustomMultiScoreQuery q5CustomMulAdd = new CustomMultiScoreQuery(q1, qValSrcs) {
+			/*
+			 * (non-Javadoc)
+			 * 
+			 * @see org.apache.lucene.search.function.CustomScoreQuery#name()
+			 */
+			public String name() {
+				return "customMulAdd";
+			}
+
+			/*
+			 * (non-Javadoc)
+			 * 
+			 * @see org.apache.lucene.search.function.CustomScoreQuery#customScore(int,
+			 *      float, float)
+			 */
+			public float customScore(int doc, float subQueryScore,
+					float[] valSrcScore) {
+				return (valSrcScore[0] + subQueryScore) * valSrcScore[1];
+			}
+
+			/*
+			 * (non-Javadoc)@see
+			 * org.apache.lucene.search.function.CustomScoreQuery#customExplain(int,
+			 * org.apache.lucene.search.Explanation,
+			 * org.apache.lucene.search.Explanation)
+			 */
+			public Explanation customExplain(int doc, Explanation subQueryExpl,
+					Explanation[] valSrcExpl) {
+				Explanation exp = new Explanation(1 + subQueryExpl.getValue(),
+						"sum of:");
+				exp.addDetail(subQueryExpl);
+				exp.addDetail(valSrcExpl[0]);
+				Explanation exp2 = new Explanation(valSrcExpl[1].getValue()
+						* exp.getValue(), "custom score: product of:");
+				exp2.addDetail(valSrcExpl[1]);
+				exp2.addDetail(exp);
+				return exp2;
+			}
+		};
+		q5CustomMulAdd.setStrict(true);
+		q5CustomMulAdd.setBoost(boost);
+		log(q5CustomMulAdd);
+
+		// do al the searches
+		TopDocs td1 = s.search(q1, null, 1000);
+		TopDocs td2CustomNeutral = s.search(q2CustomNeutral, null, 1000);
+		TopDocs td3CustomMul = s.search(q3CustomMul, null, 1000);
+		TopDocs td4CustomAdd = s.search(q4CustomAdd, null, 1000);
+		TopDocs td5CustomMulAdd = s.search(q5CustomMulAdd, null, 1000);
+
+		// put results in map so we can verify the scores although they have
+		// changed
+		HashMap h1 = topDocsToMap(td1);
+		HashMap h2CustomNeutral = topDocsToMap(td2CustomNeutral);
+		HashMap h3CustomMul = topDocsToMap(td3CustomMul);
+		HashMap h4CustomAdd = topDocsToMap(td4CustomAdd);
+		HashMap h5CustomMulAdd = topDocsToMap(td5CustomMulAdd);
+
+		verifyResults(boost, s, h1, h2CustomNeutral, h3CustomMul, h4CustomAdd,
+				h5CustomMulAdd, q1, q2CustomNeutral, q3CustomMul, q4CustomAdd,
+				q5CustomMulAdd);
+	}
+
+	// verify results are as expected.
+	private void verifyResults(float boost, IndexSearcher s, HashMap h1,
+			HashMap h2customNeutral, HashMap h3CustomMul, HashMap h4CustomAdd,
+			HashMap h5CustomMulAdd, Query q1, Query q2, Query q3, Query q4,
+			Query q5) throws Exception {
+
+		// verify numbers of matches
+		log("#hits = " + h1.size());
+		assertEquals("queries should have same #hits", h1.size(),
+				h2customNeutral.size());
+		assertEquals("queries should have same #hits", h1.size(), h3CustomMul
+				.size());
+		assertEquals("queries should have same #hits", h1.size(), h4CustomAdd
+				.size());
+		assertEquals("queries should have same #hits", h1.size(),
+				h5CustomMulAdd.size());
+
+		// verify scores ratios
+		for (Iterator it = h1.keySet().iterator(); it.hasNext();) {
+			Integer x = (Integer) it.next();
+
+			int doc = x.intValue();
+			log("doc = " + doc);
+
+			float fieldScore = expectedFieldScore(s.getIndexReader().document(
+					doc).get(ID_FIELD));
+			log("fieldScore = " + fieldScore);
+			assertTrue("fieldScore should not be 0", fieldScore > 0);
+
+			float score1 = ((Float) h1.get(x)).floatValue();
+			logResult("score1=", s, q1, doc, score1);
+
+			float score2 = ((Float) h2customNeutral.get(x)).floatValue();
+			logResult("score2=", s, q2, doc, score2);
+			assertEquals("same score (just boosted) for neutral", boost
+					* score1, score2, TEST_SCORE_TOLERANCE_DELTA);
+
+			float score3 = ((Float) h3CustomMul.get(x)).floatValue();
+			logResult("score3=", s, q3, doc, score3);
+			assertEquals("new score for custom mul", boost * fieldScore
+					* score1, score3, TEST_SCORE_TOLERANCE_DELTA);
+
+			float score4 = ((Float) h4CustomAdd.get(x)).floatValue();
+			logResult("score4=", s, q4, doc, score4);
+			assertEquals("new score for custom add", boost
+					* (fieldScore + score1), score4, TEST_SCORE_TOLERANCE_DELTA);
+
+			float score5 = ((Float) h5CustomMulAdd.get(x)).floatValue();
+			logResult("score5=", s, q5, doc, score5);
+			assertEquals("new score for custom mul add", boost * fieldScore
+					* (score1 + 1), score5, TEST_SCORE_TOLERANCE_DELTA);
+		}
+	}
+
+	private void logResult(String msg, IndexSearcher s, Query q, int doc,
+			float score1) throws IOException {
+		QueryUtils.check(q, s);
+		log(msg + " " + score1);
+		log("Explain by: " + q);
+		log(s.explain(q, doc));
+	}
+
+	// since custom scoring modifies the order of docs, map results
+	// by doc ids so that we can later compare/verify them
+	private HashMap topDocsToMap(TopDocs td) {
+		HashMap h = new HashMap();
+		for (int i = 0; i < td.totalHits; i++) {
+			h.put(new Integer(td.scoreDocs[i].doc), new Float(
+					td.scoreDocs[i].score));
+		}
+		return h;
+	}
+
+}

Property changes on: src/test/org/apache/lucene/search/function/TestCustomMultiScoreQuery.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Revision
Name: svn:eol-style
   + native

Index: src/java/org/apache/lucene/search/function/CustomMultiScoreQuery.java
===================================================================
--- src/java/org/apache/lucene/search/function/CustomMultiScoreQuery.java	(revision 0)
+++ src/java/org/apache/lucene/search/function/CustomMultiScoreQuery.java	(revision 0)
@@ -0,0 +1,466 @@
+package org.apache.lucene.search.function;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.ComplexExplanation;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.Similarity;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.util.ToStringUtils;
+
+/**
+ * Query that sets document score as a programmatic function of (up to) two
+ * (sub) scores.
+ * <ol>
+ * <li>the score of its subQuery (any query)</li>
+ * <li>(optional) the score of its ValueSourtceQuery, for most
+ * simple/convineient use case this query would be a
+ * {@link org.apache.lucene.search.function.FieldScoreQuery FieldScoreQuery}</li>
+ * </ol>
+ * Subclasses can modify the computation by overriding
+ * {@link #customScore(int, float, float)}.
+ * 
+ * <p>
+ * <font color="#FF0000"> WARNING: The status of the <b>search.function</b>
+ * package is experimental. The APIs introduced here might change in the future
+ * and will not be supported anymore in such a case.</font>
+ */
+@SuppressWarnings("serial")
+public class CustomMultiScoreQuery extends Query {
+
+	private Query subQuery;
+	private ValueSourceQuery[] valSrcQueries;
+	private boolean strict = false; // if true, valueSource part of query does
+
+	// not take part in weights normalization.
+
+	/**
+	 * Create a CustomScoreQuery over input subQuery and a
+	 * {@link ValueSourceQuery}.
+	 * 
+	 * @param subQuery
+	 *            the sub query whose score is being customed. Must not be null.
+	 * @param valSrcQueries
+	 *            a value source query whose scores are used in the custom score
+	 *            computation. For most simple/convineient use case this would
+	 *            be a
+	 *            {@link org.apache.lucene.search.function.FieldScoreQuery FieldScoreQuery}.
+	 *            This parameter is optional - it can be null.
+	 */
+	public CustomMultiScoreQuery(Query subQuery,
+			ValueSourceQuery[] valSrcQueries) {
+		super();
+		this.subQuery = subQuery;
+		this.valSrcQueries = valSrcQueries;
+		if (subQuery == null)
+			throw new IllegalArgumentException("<subquery> must not be null!");
+	}
+
+	public CustomMultiScoreQuery(Query subQuery) {
+		this(subQuery, new ValueSourceQuery[0]);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader)
+	 */
+	public Query rewrite(IndexReader reader) throws IOException {
+		subQuery = subQuery.rewrite(reader);
+		if (valSrcQueries != null) {
+			for (int i = 0; i < valSrcQueries.length; i++)
+				valSrcQueries[i] = (ValueSourceQuery) valSrcQueries[i]
+						.rewrite(reader);
+		}
+		return this;
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.apache.lucene.search.Query#extractTerms(java.util.Set)
+	 */
+	@SuppressWarnings("unchecked")
+	public void extractTerms(Set terms) {
+		subQuery.extractTerms(terms);
+		for (int i = 0; i < valSrcQueries.length; i++) {
+			valSrcQueries[i].extractTerms(terms);
+		}
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.apache.lucene.search.Query#clone()
+	 */
+	public Object clone() {
+		CustomMultiScoreQuery clone = (CustomMultiScoreQuery) super.clone();
+		clone.subQuery = (Query) subQuery.clone();
+		for (int i = 0; i < valSrcQueries.length; i++) {
+			clone.valSrcQueries[i] = (ValueSourceQuery) valSrcQueries[i]
+					.clone();
+		}
+		return clone;
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.apache.lucene.search.Query#toString(java.lang.String)
+	 */
+	public String toString(String field) {
+		StringBuffer sb = new StringBuffer(name()).append("(");
+		sb.append(subQuery.toString(field));
+		for (int i = 0; i < valSrcQueries.length; i++) {
+			sb.append(", ").append(valSrcQueries[i].toString(field));
+		}
+		sb.append(")");
+		sb.append(strict ? " STRICT" : "");
+		return sb.toString() + ToStringUtils.boost(getBoost());
+	}
+
+	/** Returns true if <code>o</code> is equal to this. */
+	public boolean equals(Object o) {
+		if (getClass() != o.getClass()) {
+			return false;
+		}
+		CustomMultiScoreQuery other = (CustomMultiScoreQuery) o;
+		return this.getBoost() == other.getBoost()
+				&& this.subQuery.equals(other.subQuery)
+				&& (this.valSrcQueries == null ? other.valSrcQueries == null
+						: this.valSrcQueries.equals(other.valSrcQueries));
+	}
+
+	/** Returns a hash code value for this object. */
+	public int hashCode() {
+		int valSrcHash = valSrcQueries == null ? 0 : valSrcQueries.hashCode();
+		return (getClass().hashCode() + subQuery.hashCode() + valSrcHash)
+				^ Float.floatToIntBits(getBoost());
+	}
+
+	/**
+	 * Compute a custom score by the subQuery score and the ValueSourceQuery
+	 * score.
+	 * <p>
+	 * Subclasses can override this method to modify the custom score.
+	 * <p>
+	 * The default computation herein is:
+	 * 
+	 * <pre>
+	 *     ModifiedScore = valSrcScore * subQueryScore.
+	 * </pre>
+	 * 
+	 * @param doc
+	 *            id of scored doc.
+	 * @param subQueryScore
+	 *            score of that doc by the subQuery.
+	 * @param valSrcScore
+	 *            score of that doc by the ValueSourceQuery.
+	 * @return custom score.
+	 */
+	public float customScore(int doc, float subQueryScore, float[] valSrcScores) {
+		float score = subQueryScore;
+		for (int i = 0; i < valSrcScores.length; i++)
+			score *= valSrcScores[i];
+		return score;
+	}
+
+	/**
+	 * Explain the custom score. Whenever overriding
+	 * {@link #customScore(int, float, float)}, this method should also be
+	 * overriden to provide the correct explanation for the part of the custom
+	 * scoring.
+	 * 
+	 * @param doc
+	 *            doc being explained.
+	 * @param subQueryExpl
+	 *            explanation for the sub-query part.
+	 * @param valSrcExpl
+	 *            explanation for the value source part.
+	 * @return an explanation for the custom score
+	 */
+	public Explanation customExplain(int doc, Explanation subQueryExpl,
+			Explanation[] valSrcExpl) {
+		float valSrcScore = 1;
+		for(int i = 0; i < valSrcExpl.length; i++)
+		{
+			valSrcScore *= valSrcExpl[i].getValue();
+		}
+		Explanation exp = new Explanation(
+				valSrcScore * subQueryExpl.getValue(),
+				"custom score: product of:");
+		exp.addDetail(subQueryExpl);
+		for(int i = 0; i < valSrcExpl.length; i++)
+		{
+			exp.addDetail(valSrcExpl[i]);
+		}
+		return exp;
+	}
+
+	// =========================== W E I G H T ============================
+
+	private class CustomWeight implements Weight {
+		Searcher searcher;
+		Weight subQueryWeight;
+		Weight[] valSrcWeights; // optional
+		boolean qStrict;
+
+		public CustomWeight(Searcher searcher) throws IOException {
+			this.searcher = searcher;
+			this.subQueryWeight = subQuery.weight(searcher);
+			this.valSrcWeights = new Weight[valSrcQueries.length];
+			for (int i = 0; i < valSrcQueries.length; i++) {
+				this.valSrcWeights[i] = valSrcQueries[i].createWeight(searcher);
+			}
+			this.qStrict = strict;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Weight#getQuery()
+		 */
+		public Query getQuery() {
+			return CustomMultiScoreQuery.this;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Weight#getValue()
+		 */
+		public float getValue() {
+			return getBoost();
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Weight#sumOfSquaredWeights()
+		 */
+		public float sumOfSquaredWeights() throws IOException {
+			float sum = subQueryWeight.sumOfSquaredWeights();
+			for (int i = 0; i < valSrcWeights.length; i++) {
+				if (qStrict) {
+					valSrcWeights[i].sumOfSquaredWeights(); // do not include
+					// ValueSource
+					// part in the query
+					// normalization
+				} else {
+					sum += valSrcWeights[i].sumOfSquaredWeights();
+				}
+			}
+			sum *= getBoost() * getBoost(); // boost each sub-weight
+			return sum;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Weight#normalize(float)
+		 */
+		public void normalize(float norm) {
+			norm *= getBoost(); // incorporate boost
+			subQueryWeight.normalize(norm);
+			for (int i = 0; i < valSrcWeights.length; i++) {
+				if (qStrict) {
+					valSrcWeights[i].normalize(1); // do not normalize the
+					// ValueSource part
+				} else {
+					valSrcWeights[i].normalize(norm);
+				}
+			}
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Weight#scorer(org.apache.lucene.index.IndexReader)
+		 */
+		public Scorer scorer(IndexReader reader) throws IOException {
+			Scorer subQueryScorer = subQueryWeight.scorer(reader);
+			Scorer[] valSrcScorers = new Scorer[valSrcWeights.length];
+			for (int i = 0; i < valSrcWeights.length; i++) {
+				valSrcScorers[i] = valSrcWeights[i].scorer(reader);
+			}
+			return new CustomScorer(getSimilarity(searcher), reader, this,
+					subQueryScorer, valSrcScorers);
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Weight#explain(org.apache.lucene.index.IndexReader,
+		 *      int)
+		 */
+		public Explanation explain(IndexReader reader, int doc)
+				throws IOException {
+			return scorer(reader).explain(doc);
+		}
+	}
+
+	// =========================== S C O R E R ============================
+
+	/**
+	 * A scorer that applies a (callback) function on scores of the subQuery.
+	 */
+	private class CustomScorer extends Scorer {
+		private final CustomWeight weight;
+		private final float qWeight;
+		private Scorer subQueryScorer;
+		private Scorer[] valSrcScorers; // optional
+		private IndexReader reader;
+
+		// constructor
+		private CustomScorer(Similarity similarity, IndexReader reader,
+				CustomWeight w, Scorer subQueryScorer, Scorer[] valSrcScorers)
+				throws IOException {
+			super(similarity);
+			this.weight = w;
+			this.qWeight = w.getValue();
+			this.subQueryScorer = subQueryScorer;
+			this.valSrcScorers = valSrcScorers;
+			this.reader = reader;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Scorer#next()
+		 */
+		public boolean next() throws IOException {
+			boolean hasNext = subQueryScorer.next();
+			for (int i = 0; i < valSrcScorers.length; i++) {
+				valSrcScorers[i].skipTo(subQueryScorer.doc());
+			}
+			return hasNext;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Scorer#doc()
+		 */
+		public int doc() {
+			return subQueryScorer.doc();
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Scorer#score()
+		 */
+		public float score() throws IOException {
+			float[] valSrcScore = new float[valSrcScorers.length];
+			for (int i = 0; i < valSrcScorers.length; i++) {
+				valSrcScore[i] = valSrcScorers[i].score();
+			}
+
+			return qWeight
+					* customScore(subQueryScorer.doc(), subQueryScorer.score(),
+							valSrcScore);
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Scorer#skipTo(int)
+		 */
+		public boolean skipTo(int target) throws IOException {
+			boolean hasNext = subQueryScorer.skipTo(target);
+			for (int i = 0; i < valSrcScorers.length; i++) {
+				valSrcScorers[i].skipTo(subQueryScorer.doc());
+			}
+			return hasNext;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * 
+		 * @see org.apache.lucene.search.Scorer#explain(int)
+		 */
+		public Explanation explain(int doc) throws IOException {
+
+			Explanation subQueryExpl = weight.subQueryWeight.explain(reader,
+					doc);
+			if (!subQueryExpl.isMatch()) {
+				return subQueryExpl;
+			}
+			Explanation valSrcExpl[] = new Explanation[valSrcScorers.length];
+			for (int i = 0; i < valSrcScorers.length; i++) {
+				valSrcExpl[i] = valSrcScorers[i].explain(doc);
+			}
+			Explanation customExp = customExplain(doc, subQueryExpl, valSrcExpl);
+			float sc = qWeight * customExp.getValue();
+			Explanation res = new ComplexExplanation(true, sc,
+					CustomMultiScoreQuery.this.toString() + ", product of:");
+			res.addDetail(customExp);
+			res.addDetail(new Explanation(qWeight, "queryBoost"));
+			return res;
+
+		}
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.apache.lucene.search.Query#createWeight(org.apache.lucene.search.Searcher)
+	 */
+	protected Weight createWeight(Searcher searcher) throws IOException {
+		return new CustomWeight(searcher);
+	}
+
+	/**
+	 * Checks if this is strict custom scoring. In strict custom scoring, the
+	 * ValueSource part of does not participate in weight normalization. This
+	 * may be useful when one wants full control over how scores are modified,
+	 * and does not care about normalizing by the ValueSource part. One
+	 * particular case where this is useful if for testing this query.
+	 * <P>
+	 * Note: only has effect when the ValueSource part is not null.
+	 */
+	public boolean isStrict() {
+		return strict;
+	}
+
+	/**
+	 * Set the strict mode of this query.
+	 * 
+	 * @param strict
+	 *            The strict mode to set.
+	 * @see #isStrict()
+	 */
+	public void setStrict(boolean strict) {
+		this.strict = strict;
+	}
+
+	/**
+	 * A short name of this query, used in {@link #toString(String)}.
+	 */
+	public String name() {
+		return "custom";
+	}
+
+}

Property changes on: src/java/org/apache/lucene/search/function/CustomMultiScoreQuery.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Revision
Name: svn:eol-style
   + native

Index: src/java/org/apache/lucene/search/function/CustomScoreQuery.java
===================================================================
--- src/java/org/apache/lucene/search/function/CustomScoreQuery.java	(revision 582011)
+++ src/java/org/apache/lucene/search/function/CustomScoreQuery.java	(working copy)
@@ -45,18 +45,14 @@
  * The APIs introduced here might change in the future and will not be 
  * supported anymore in such a case.</font>
  */
-public class CustomScoreQuery extends Query {
+public class CustomScoreQuery extends CustomMultiScoreQuery {
 
-  private Query subQuery;
-  private ValueSourceQuery valSrcQuery; // optional, can be null
-  private boolean strict = false; // if true, valueSource part of query does not take part in weights normalization.  
-  
   /**
    * Create a CustomScoreQuery over input subQuery.
    * @param subQuery the sub query whose scored is being customed. Must not be null. 
    */
   public CustomScoreQuery(Query subQuery) {
-    this(subQuery,null);
+    super(subQuery);
   }
 
   /**
@@ -68,277 +64,14 @@
    * This parameter is optional - it can be null.
    */
   public CustomScoreQuery(Query subQuery, ValueSourceQuery valSrcQuery) {
-    super();
-    this.subQuery = subQuery;
-    this.valSrcQuery = valSrcQuery;
-    if (subQuery == null) throw new IllegalArgumentException("<subqyery> must not be null!");
+    super(subQuery, new ValueSourceQuery[] { valSrcQuery});
   }
-
-  /*(non-Javadoc) @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) */
-  public Query rewrite(IndexReader reader) throws IOException {
-    subQuery = subQuery.rewrite(reader);
-    if (valSrcQuery!=null) {
-      valSrcQuery = (ValueSourceQuery) valSrcQuery.rewrite(reader);
-    }
-    return this;
+  
+  public float customScore(int doc, float subQueryScore, float[] valSrcScore) {
+	  return customScore(doc, subQueryScore, valSrcScore.length == 0 ? 0 : valSrcScore[0]);
   }
-
-  /*(non-Javadoc) @see org.apache.lucene.search.Query#extractTerms(java.util.Set) */
-  public void extractTerms(Set terms) {
-    subQuery.extractTerms(terms);
-    if (valSrcQuery!=null) {
-      valSrcQuery.extractTerms(terms);
-    }
-  }
-
-  /*(non-Javadoc) @see org.apache.lucene.search.Query#clone() */
-  public Object clone() {
-    CustomScoreQuery clone = (CustomScoreQuery)super.clone();
-    clone.subQuery = (Query) subQuery.clone();
-    if (valSrcQuery!=null) {
-      clone.valSrcQuery = (ValueSourceQuery) valSrcQuery.clone();
-    }
-    return clone;
-  }
-
-  /* (non-Javadoc) @see org.apache.lucene.search.Query#toString(java.lang.String) */
-  public String toString(String field) {
-    StringBuffer sb = new StringBuffer(name()).append("(");
-    sb.append(subQuery.toString(field));
-    if (valSrcQuery!=null) {
-      sb.append(", ").append(valSrcQuery.toString(field));
-    }
-    sb.append(")");
-    sb.append(strict?" STRICT" : "");
-    return sb.toString() + ToStringUtils.boost(getBoost());
-  }
-
-  /** Returns true if <code>o</code> is equal to this. */
-  public boolean equals(Object o) {
-    if (getClass() != o.getClass()) {
-      return false;
-    }
-    CustomScoreQuery other = (CustomScoreQuery)o;
-    return this.getBoost() == other.getBoost()
-           && this.subQuery.equals(other.subQuery)
-           && (this.valSrcQuery==null ? other.valSrcQuery==null 
-               : this.valSrcQuery.equals(other.valSrcQuery));
-  }
-
-  /** Returns a hash code value for this object. */
-  public int hashCode() {
-    int valSrcHash = valSrcQuery==null ? 0 : valSrcQuery.hashCode();
-    return (getClass().hashCode() + subQuery.hashCode() + valSrcHash) ^ Float.floatToIntBits(getBoost());
-  }  
   
-  /**
-   * Compute a custom score by the subQuery score and the ValueSourceQuery score.
-   * <p> 
-   * Subclasses can override this method to modify the custom score.
-   * <p>
-   * The default computation herein is:
-   * <pre>
-   *     ModifiedScore = valSrcScore * subQueryScore.
-   * </pre>
-   * 
-   * @param doc id of scored doc. 
-   * @param subQueryScore score of that doc by the subQuery.
-   * @param valSrcScore score of that doc by the ValueSourceQuery.
-   * @return custom score.
-   */
   public float customScore(int doc, float subQueryScore, float valSrcScore) {
-    return valSrcScore * subQueryScore;
+	  return valSrcScore * subQueryScore;
   }
-
-  /**
-   * Explain the custom score.
-   * Whenever overriding {@link #customScore(int, float, float)}, 
-   * this method should also be overriden to provide the correct explanation
-   * for the part of the custom scoring. 
-   * @param doc doc being explained.
-   * @param subQueryExpl explanation for the sub-query part.
-   * @param valSrcExpl explanation for the value source part.
-   * @return an explanation for the custom score
-   */
-  public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
-    float valSrcScore = valSrcExpl==null ? 1 : valSrcExpl.getValue();
-    Explanation exp = new Explanation( valSrcScore * subQueryExpl.getValue(), "custom score: product of:");
-    exp.addDetail(subQueryExpl);
-    if (valSrcExpl != null) {
-      exp.addDetail(valSrcExpl);
-    }
-    return exp;
-  }
-  //=========================== W E I G H T ============================
-  
-  private class CustomWeight implements Weight {
-    Searcher searcher;
-    Weight subQueryWeight;
-    Weight valSrcWeight; // optional
-    boolean qStrict;
-
-    public CustomWeight(Searcher searcher) throws IOException {
-      this.searcher = searcher;
-      this.subQueryWeight = subQuery.weight(searcher); 
-      if (valSrcQuery!=null) {
-        this.valSrcWeight = valSrcQuery.createWeight(searcher);
-      }
-      this.qStrict = strict;
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#getQuery() */
-    public Query getQuery() {
-      return CustomScoreQuery.this;
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#getValue() */
-    public float getValue() {
-      return getBoost();
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#sumOfSquaredWeights() */
-    public float sumOfSquaredWeights() throws IOException {
-      float sum = subQueryWeight.sumOfSquaredWeights();
-      if (valSrcWeight!=null) {
-        if (qStrict) {
-          valSrcWeight.sumOfSquaredWeights(); // do not include ValueSource part in the query normalization
-        } else {
-          sum += valSrcWeight.sumOfSquaredWeights();
-        }
-      }
-      sum *= getBoost() * getBoost(); // boost each sub-weight
-      return sum ;
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#normalize(float) */
-    public void normalize(float norm) {
-      norm *= getBoost(); // incorporate boost
-      subQueryWeight.normalize(norm);
-      if (valSrcWeight!=null) {
-        if (qStrict) {
-          valSrcWeight.normalize(1); // do not normalize the ValueSource part
-        } else {
-          valSrcWeight.normalize(norm);
-        }
-      }
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#scorer(org.apache.lucene.index.IndexReader) */
-    public Scorer scorer(IndexReader reader) throws IOException {
-      Scorer subQueryScorer = subQueryWeight.scorer(reader);
-      Scorer valSrcScorer = (valSrcWeight==null ? null : valSrcWeight.scorer(reader));
-      return new CustomScorer(getSimilarity(searcher), reader, this, subQueryScorer, valSrcScorer);
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#explain(org.apache.lucene.index.IndexReader, int) */
-    public Explanation explain(IndexReader reader, int doc) throws IOException {
-      return scorer(reader).explain(doc);
-    }
-  }
-
-
-  //=========================== S C O R E R ============================
-  
-  /**
-   * A scorer that applies a (callback) function on scores of the subQuery.
-   */
-  private class CustomScorer extends Scorer {
-    private final CustomWeight weight;
-    private final float qWeight;
-    private Scorer subQueryScorer;
-    private Scorer valSrcScorer; // optional
-    private IndexReader reader;
-
-    // constructor
-    private CustomScorer(Similarity similarity, IndexReader reader, CustomWeight w,
-        Scorer subQueryScorer, Scorer valSrcScorer) throws IOException {
-      super(similarity);
-      this.weight = w;
-      this.qWeight = w.getValue();
-      this.subQueryScorer = subQueryScorer;
-      this.valSrcScorer = valSrcScorer;
-      this.reader = reader;
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Scorer#next() */
-    public boolean next() throws IOException {
-      boolean hasNext = subQueryScorer.next();
-      if (valSrcScorer!=null && hasNext) {
-        valSrcScorer.skipTo(subQueryScorer.doc());
-      }
-      return hasNext;
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Scorer#doc() */
-    public int doc() {
-      return subQueryScorer.doc();
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Scorer#score() */
-    public float score() throws IOException {
-      float valSrcScore = (valSrcScorer==null ? 1 : valSrcScorer.score());
-      return qWeight * customScore(subQueryScorer.doc(), subQueryScorer.score(), valSrcScore);
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Scorer#skipTo(int) */
-    public boolean skipTo(int target) throws IOException {
-      boolean hasNext = subQueryScorer.skipTo(target);
-      if (valSrcScorer!=null && hasNext) {
-        valSrcScorer.skipTo(subQueryScorer.doc());
-      }
-      return hasNext;
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Scorer#explain(int) */
-    public Explanation explain(int doc) throws IOException {
-      Explanation subQueryExpl = weight.subQueryWeight.explain(reader,doc);
-      if (!subQueryExpl.isMatch()) {
-        return subQueryExpl;
-      }
-      // match
-      Explanation valSrcExpl = valSrcScorer==null ? null : valSrcScorer.explain(doc);
-      Explanation customExp = customExplain(doc,subQueryExpl,valSrcExpl);
-      float sc = qWeight * customExp.getValue();
-      Explanation res = new ComplexExplanation(
-        true, sc, CustomScoreQuery.this.toString() + ", product of:");
-      res.addDetail(customExp);
-      res.addDetail(new Explanation(qWeight, "queryBoost")); // actually using the q boost as q weight (== weight value)
-      return res;
-    }
-  }
-
-  /*(non-Javadoc) @see org.apache.lucene.search.Query#createWeight(org.apache.lucene.search.Searcher) */
-  protected Weight createWeight(Searcher searcher) throws IOException {
-    return new CustomWeight(searcher);
-  }
-
-  /**
-   * Checks if this is strict custom scoring.
-   * In strict custom scoring, the ValueSource part of does not participate in weight normalization.
-   * This may be useful when one wants full control over how scores are modified, and does 
-   * not care about normalizing by the ValueSource part.
-   * One particular case where this is useful if for testing this query.   
-   * <P>
-   * Note: only has effect when the ValueSource part is not null.
-   */
-  public boolean isStrict() {
-    return strict;
-  }
-
-  /**
-   * Set the strict mode of this query. 
-   * @param strict The strict mode to set.
-   * @see #isStrict()
-   */
-  public void setStrict(boolean strict) {
-    this.strict = strict;
-  }
-
-  /**
-   * A short name of this query, used in {@link #toString(String)}.
-   */
-  public String name() {
-    return "custom";
-  }
-
 }
