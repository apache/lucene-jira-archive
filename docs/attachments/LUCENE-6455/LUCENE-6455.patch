Index: lucene/core/src/java/org/apache/lucene/search/QueryCachingPolicy.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/QueryCachingPolicy.java	(revision 1676582)
+++ lucene/core/src/java/org/apache/lucene/search/QueryCachingPolicy.java	(working copy)
@@ -62,20 +62,23 @@
      *  cached while ensuring that at most <tt>33</tt> segments can make it to
      *  the cache (given that some implementations such as {@link LRUQueryCache}
      *  perform better when the number of cached segments is low). */
-    public static final CacheOnLargeSegments DEFAULT = new CacheOnLargeSegments(0.03f);
+    public static final CacheOnLargeSegments DEFAULT = new CacheOnLargeSegments(10000, 0.03f);
 
+    private final int minIndexSize;
     private final float minSizeRatio;
 
     /**
      * Create a {@link CacheOnLargeSegments} instance that only caches on a
-     * given segment if its number of documents divided by the total number of
-     * documents in the index is greater than or equal to
-     * <code>minSizeRatio</code>.
+     * given segment if the total number of documents in the index is greater
+     * than {@code minIndexSize} and the number of documents in the segment
+     * divided by the total number of documents in the index is greater than
+     * or equal to {@code minSizeRatio}.
      */
-    public CacheOnLargeSegments(float minSizeRatio) {
+    public CacheOnLargeSegments(int minIndexSize, float minSizeRatio) {
       if (minSizeRatio <= 0 || minSizeRatio >= 1) {
         throw new IllegalArgumentException("minSizeRatio must be in ]0, 1[, got " + minSizeRatio);
       }
+      this.minIndexSize = minIndexSize;
       this.minSizeRatio = minSizeRatio;
     }
 
@@ -85,6 +88,9 @@
     @Override
     public boolean shouldCache(Query query, LeafReaderContext context) throws IOException {
       final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(context);
+      if (topLevelContext.reader().maxDoc() < minIndexSize) {
+        return false;
+      }
       final float sizeRatio = (float) context.reader().maxDoc() / topLevelContext.reader().maxDoc();
       return sizeRatio >= minSizeRatio;
     }
Index: lucene/core/src/java/org/apache/lucene/search/UsageTrackingQueryCachingPolicy.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/UsageTrackingQueryCachingPolicy.java	(revision 1676582)
+++ lucene/core/src/java/org/apache/lucene/search/UsageTrackingQueryCachingPolicy.java	(working copy)
@@ -58,13 +58,15 @@
   /**
    * Create a new instance.
    *
+   * @param minIndexSize              the minimum size of the top-level index
    * @param minSizeRatio              the minimum size ratio for segments to be cached, see {@link QueryCachingPolicy.CacheOnLargeSegments}
    * @param historySize               the number of recently used filters to track
    */
   public UsageTrackingQueryCachingPolicy(
+      int minIndexSize,
       float minSizeRatio,
       int historySize) {
-    this(new QueryCachingPolicy.CacheOnLargeSegments(minSizeRatio), historySize);
+    this(new QueryCachingPolicy.CacheOnLargeSegments(minIndexSize, minSizeRatio), historySize);
   }
 
   /** Create a new instance with an history size of 256. */
Index: lucene/core/src/test/org/apache/lucene/search/TestFilterCachingPolicy.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestFilterCachingPolicy.java	(revision 1676582)
+++ lucene/core/src/test/org/apache/lucene/search/TestFilterCachingPolicy.java	(working copy)
@@ -38,13 +38,14 @@
     }
     final IndexReader reader = w.getReader();
     for (float minSizeRatio : new float[] {Float.MIN_VALUE, 0.01f, 0.1f, 0.9f}) {
-      final QueryCachingPolicy policy = new QueryCachingPolicy.CacheOnLargeSegments(minSizeRatio);
+      final QueryCachingPolicy policy = new QueryCachingPolicy.CacheOnLargeSegments(0, minSizeRatio);
       for (LeafReaderContext ctx : reader.leaves()) {
         final Filter filter = new QueryWrapperFilter(new TermQuery(new Term("field", "value")));
-        final DocIdSet set = null;
         final boolean shouldCache = policy.shouldCache(filter, ctx);
         final float sizeRatio = (float) ctx.reader().maxDoc() / reader.maxDoc();
         assertEquals(sizeRatio >= minSizeRatio, shouldCache);
+        assertTrue(new QueryCachingPolicy.CacheOnLargeSegments(numDocs, Float.MIN_VALUE).shouldCache(filter, ctx));
+        assertFalse(new QueryCachingPolicy.CacheOnLargeSegments(numDocs + 1, Float.MIN_VALUE).shouldCache(filter, ctx));
       }
     }
     reader.close();
