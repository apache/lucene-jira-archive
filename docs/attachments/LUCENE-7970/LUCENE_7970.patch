Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexCircle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexCircle.java	(revision )
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexCircle.java	(revision )
@@ -0,0 +1,248 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial3d.geom;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Circular area with a center and radius.
+ *
+ * @lucene.experimental
+ */
+class GeoComplexCircle extends GeoBaseCircle {
+  /** Center of circle */
+  protected final GeoPoint center;
+  /** Cutoff angle of circle (not quite the same thing as radius) */
+  protected final double cutoffAngle;
+  /** The plane describing the outer ellipse. Ideally all points of
+   * the shphere should be container*/
+  protected final SidedPlane outerCirclePlane;
+  /** The plane describing the inner ellipse. Ideally
+   * the sphere should contain the elipse defined by this plane*/
+  protected final SidedPlane innerCirclePlane;
+  /** A point that is on the world and on the circle plane */
+  protected final GeoPoint[] edgePoints;
+  /** Notable points for a circle -- there aren't any */
+  protected static final GeoPoint[] circlePoints = new GeoPoint[0];
+
+  /** Constructor.
+   *@param planetModel is the planet model.
+   *@param lat is the center latitude.
+   *@param lon is the center longitude.
+   *@param cutoffAngle is the cutoff angle for the circle.
+   */
+  public GeoComplexCircle(final PlanetModel planetModel, final double lat, final double lon, final double cutoffAngle) {
+    super(planetModel);
+    if (lat < -Math.PI * 0.5 || lat > Math.PI * 0.5)
+      throw new IllegalArgumentException("Latitude out of bounds");
+    if (lon < -Math.PI || lon > Math.PI)
+      throw new IllegalArgumentException("Longitude out of bounds");
+    if (cutoffAngle < 0.0 || cutoffAngle > Math.PI)
+      throw new IllegalArgumentException("Cutoff angle out of bounds");
+    if (cutoffAngle < Vector.MINIMUM_RESOLUTION)
+      throw new IllegalArgumentException("Cutoff angle cannot be effectively zero");
+
+    this.center = new GeoPoint(planetModel, lat, lon);
+    this.cutoffAngle = cutoffAngle;
+
+    if (Math.abs(cutoffAngle - Math.PI) < Vector.MINIMUM_RESOLUTION) {
+      // Circle is the whole world
+      this.outerCirclePlane = null;
+      this.innerCirclePlane = null;
+      this.edgePoints = new GeoPoint[0];
+    } else {
+      // Construct the spheroid normal vector at the center of the circle
+      Vector normalVector = new Vector(planetModel.inverseAbSquared * center.x,
+          planetModel.inverseAbSquared * center.y,
+          planetModel.inverseCSquared * center.z).normalize();
+
+      // Longest side is the side going from the center to the equator
+      GeoPoint zPoint;
+      if (center.getLatitude()>=0){
+         zPoint = planetModel.pointOnBearing(center, cutoffAngle, Math.PI);
+      }
+      else {
+        zPoint = planetModel.pointOnBearing(center, cutoffAngle, 0);
+      }
+
+      //This factor seems to work but not real proof
+      double factor = (planetModel.c / planetModel.ab) * (planetModel.c / planetModel.ab);
+      if (planetModel.flattening >= 0) {
+        //For big circles close to Math.PI, this should be null
+        this.outerCirclePlane = new SidedPlane(center, normalVector, -normalVector.dotProduct(zPoint));
+        GeoPoint rightPoint = planetModel.pointOnBearing(center, factor * cutoffAngle, 0.5 * Math.PI);
+        //For small circles this should be null as well
+        this.innerCirclePlane = new SidedPlane(center, normalVector, -normalVector.dotProduct(rightPoint));
+      } else {
+        this.innerCirclePlane = new SidedPlane(center, normalVector, -normalVector.dotProduct(zPoint));
+        GeoPoint rightPoint = planetModel.pointOnBearing(center, factor * cutoffAngle, 0.5 * Math.PI);
+        this.outerCirclePlane = new SidedPlane(center, normalVector, -normalVector.dotProduct(rightPoint));
+      }
+
+      if (innerCirclePlane == null && outerCirclePlane == null)
+        throw new IllegalArgumentException("Couldn't construct circle plane, probably too small?  Cutoff angle = " + cutoffAngle);
+      this.edgePoints = new GeoPoint[]{zPoint};
+    }
+  }
+
+
+  /**
+   * Constructor for deserialization.
+   * @param planetModel is the planet model.
+   * @param inputStream is the input stream.
+   */
+  public GeoComplexCircle(final PlanetModel planetModel, final InputStream inputStream) throws IOException {
+    this(planetModel, 
+      SerializableObject.readDouble(inputStream),
+      SerializableObject.readDouble(inputStream),
+      SerializableObject.readDouble(inputStream));
+  }
+
+  @Override
+  public void write(final OutputStream outputStream) throws IOException {
+    SerializableObject.writeDouble(outputStream, center.getLatitude());
+    SerializableObject.writeDouble(outputStream, center.getLongitude());
+    SerializableObject.writeDouble(outputStream, cutoffAngle);
+  }
+
+  @Override
+  public double getRadius() {
+    return cutoffAngle;
+  }
+
+  @Override
+  public GeoPoint getCenter() {
+    return center;
+  }
+
+  @Override
+  protected double distance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(this.center, x, y, z);
+  }
+
+  @Override
+  protected void distanceBounds(final Bounds bounds, final DistanceStyle distanceStyle, final double distanceValue) {
+    // TBD: Compute actual bounds based on distance
+    getBounds(bounds);
+  }
+
+  @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(planetModel, outerCirclePlane, x, y, z);
+  }
+
+  @Override
+  public boolean isWithin(final double x, final double y, final double z) {
+    if (outerCirclePlane == null && innerCirclePlane == null) {
+      return true;
+    }
+    // Fastest way of determining membership
+    boolean isWithIn =  outerCirclePlane == null ? true : outerCirclePlane.isWithin(x, y, z);
+    if (!isWithIn){
+      return isWithIn;
+    }
+    isWithIn =  innerCirclePlane == null ? false : innerCirclePlane.isWithin(x, y, z);
+    if (isWithIn){
+      return isWithIn;
+    }
+    return planetModel.surfaceDistance(center, new GeoPoint(x, y, z)) - cutoffAngle < Vector.MINIMUM_ANGULAR_RESOLUTION;
+  }
+
+  @Override
+  public GeoPoint[] getEdgePoints() {
+    return edgePoints;
+  }
+
+  @Override
+  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {
+    if (outerCirclePlane == null && innerCirclePlane == null) {
+      return false;
+    }
+    boolean intersectsOuter = outerCirclePlane == null ? false : outerCirclePlane.intersects(planetModel, p, notablePoints, circlePoints, bounds);
+    boolean intersectsInner = innerCirclePlane == null ? false : innerCirclePlane.intersects(planetModel, p, notablePoints, circlePoints, bounds);
+    if (intersectsInner == intersectsOuter)
+    {
+      return intersectsInner;
+    }
+    //This should be surface distance to account for spheroids
+    double dist = p.arcDistance(planetModel, center, bounds);
+    return dist - cutoffAngle < Vector.MINIMUM_ANGULAR_RESOLUTION;
+
+  }
+
+  @Override
+  public boolean intersects(GeoShape geoShape) {
+    if (outerCirclePlane == null && innerCirclePlane == null) {
+      return false;
+    }
+    boolean intersectsOuter = outerCirclePlane == null ? false : geoShape.intersects(outerCirclePlane, circlePoints);
+    boolean intersectsInner = innerCirclePlane == null ? false : geoShape.intersects(innerCirclePlane, circlePoints);
+    if (intersectsInner == intersectsOuter)
+    {
+      return intersectsInner;
+    }
+    if (geoShape instanceof GeoOutsideDistance) {
+      GeoOutsideDistance geoOutsideDistance = (GeoOutsideDistance) geoShape;
+      //This should be surface distance to account for spheroids
+      double dist = geoOutsideDistance.computeOutsideDistance(DistanceStyle.ARC, getCenter());
+      if (dist == 0.0) {
+        return true;
+      }
+      return dist - cutoffAngle < Vector.MINIMUM_ANGULAR_RESOLUTION;
+    }
+    return geoShape.intersects(outerCirclePlane, circlePoints);
+  }
+
+
+  @Override
+  public void getBounds(Bounds bounds) {
+    super.getBounds(bounds);
+    if (outerCirclePlane == null && innerCirclePlane == null) {
+      // Entire world; should already be covered
+      return;
+    }
+    bounds.addPoint(planetModel.pointOnBearing(center, cutoffAngle,  0));
+    bounds.addPoint(planetModel.pointOnBearing(center, cutoffAngle,  0.5 * Math.PI));
+    bounds.addPoint(planetModel.pointOnBearing(center, cutoffAngle,   Math.PI));
+    bounds.addPoint(planetModel.pointOnBearing(center, cutoffAngle,  -0.5 * Math.PI));
+
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (!(o instanceof GeoComplexCircle))
+      return false;
+    GeoComplexCircle other = (GeoComplexCircle) o;
+    return super.equals(other) && other.center.equals(center) && other.cutoffAngle == cutoffAngle;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    result = 31 * result + center.hashCode();
+    long temp = Double.doubleToLongBits(cutoffAngle);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "GeoComplexCircle: {planetmodel=" + planetModel+", center=" + center + ", radius=" + cutoffAngle + "(" + cutoffAngle * 180.0 / Math.PI + ")}";
+  }
+}
Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java	(revision 277bc3a94be284d41c001291dc0ff5d03dae11e1)
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java	(revision )
@@ -322,6 +322,96 @@
     return c * A * (sigma - deltaSigma);
   }
 
+  public GeoPoint pointOnBearing(GeoPoint from, double dist, double bearing) {
+    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)
+    // which takes into account that planets may not be spherical.
+    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html
+
+    double lat = from.getLatitude();
+    double lon = from.getLongitude();
+    double sinα1 = Math.sin(bearing);
+    double cosα1 = Math.cos(bearing);
+
+    double tanU1 = (1 - flattening) * Math.tan(lat);
+    double cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1));
+    double sinU1 = tanU1 * cosU1;
+
+    double σ1 = Math.atan2(tanU1, cosα1);
+    double sinα = cosU1 * sinα1;
+    double cosSqα = 1 - sinα * sinα;
+    double uSq = cosSqα * squareRatio;
+    double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
+    double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
+
+    double cos2σM;
+    double sinσ;
+    double cosσ;
+    double Δσ;
+
+    double σ = dist / (c * A);
+    double σʹ;
+    double iterations = 0;
+    do {
+      cos2σM = Math.cos(2 * σ1 + σ);
+      sinσ = Math.sin(σ);
+      cosσ = Math.cos(σ);
+      Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -
+          B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));
+      σʹ = σ;
+      σ = dist / (c * A) + Δσ;
+    } while (Math.abs(σ - σʹ) > Vector.MINIMUM_ANGULAR_RESOLUTION && ++iterations < 200);
+
+    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;
+    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - flattening) * Math.sqrt(sinα * sinα + x * x));
+    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);
+    double C = flattening / 16 * cosSqα * (4 + flattening * (4 - 3 * cosSqα));
+    double L = λ - (1 - C) * flattening * sinα *
+        (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));
+    double λ2 = (lon + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI;  // normalise to -180..+180
+
+    return new GeoPoint(this, φ2, λ2 );
+  }
+
+  public Double vincentyDistance( GeoPoint from, GeoPoint to) {
+    double L = from.getLongitude() - to.getLongitude();
+    double tanU1 = (1-flattening) * Math.tan(to.getLatitude()), cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1 * cosU1;
+    double tanU2 = (1-flattening) * Math.tan(from.getLatitude()), cosU2 = 1 / Math.sqrt((1 + tanU2*tanU2)), sinU2 = tanU2 * cosU2;
+
+    double cosSqα;
+    double sinσ;
+    double cos2σM;
+    double cosσ;
+    double σ;
+
+    double λ = L, λʹ, iterationLimit = 100;
+    do {
+      double sinλ = Math.sin(λ), cosλ = Math.cos(λ);
+      double sinSqσ = (cosU2*sinλ) * (cosU2*sinλ) + (cosU1*sinU2-sinU1*cosU2*cosλ) * (cosU1*sinU2-sinU1*cosU2*cosλ);
+       sinσ = Math.sqrt(sinSqσ);
+      if (sinσ==0) return 0.;  // co-incident points
+      cosσ = sinU1*sinU2 + cosU1*cosU2*cosλ;
+      σ = Math.atan2(sinσ, cosσ);
+      double sinα = cosU1 * cosU2 * sinλ / sinσ;
+      cosSqα = 1 - sinα*sinα;
+      cos2σM = cosσ - 2*sinU1*sinU2/cosSqα;
+      if (Double.isNaN(cos2σM)) cos2σM = 0.;  // equatorial line: cosSqα=0 (§6)
+      double C = flattening/16*cosSqα*(4+flattening*(4-3*cosSqα));
+      λʹ = λ;
+      λ = L + (1-C) * flattening * sinα * (σ + C*sinσ*(cos2σM+C*cosσ*(-1+2*cos2σM*cos2σM)));
+    } while (Math.abs(λ-λʹ) > 1e-12 && --iterationLimit>0);
+    //if (iterationLimit==0) throw new Error('Formula failed to converge');
+
+    double uSq = cosSqα * ( ab* ab -  c* c) / (c* c);
+    double A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
+    double B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));
+    double Δσ = B*sinσ*(cos2σM+B/4*(cosσ*(-1+2*cos2σM*cos2σM)-
+        B/6*cos2σM*(-3+4*sinσ*sinσ)*(-3+4*cos2σM*cos2σM)));
+
+    return c*A*(σ-Δσ);
+
+  }
+
+
   @Override
   public boolean equals(final Object o) {
     if (!(o instanceof PlanetModel))
