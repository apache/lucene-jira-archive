Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java	(revision 277bc3a94be284d41c001291dc0ff5d03dae11e1)
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java	(revision )
@@ -322,6 +322,57 @@
     return c * A * (sigma - deltaSigma);
   }
 
+  public GeoPoint pointOnBearing(GeoPoint from, double dist, double bearing) {
+    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)
+    // which takes into account that planets may not be spherical.
+    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html
+
+    double lat = from.getLatitude();
+    double lon = from.getLongitude();
+    double sinα1 = Math.sin(bearing);
+    double cosα1 = Math.cos(bearing);
+
+    double tanU1 = (1 - flattening) * Math.tan(lat);
+    double cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1));
+    double sinU1 = tanU1 * cosU1;
+
+    double σ1 = Math.atan2(tanU1, cosα1);
+    double sinα = cosU1 * sinα1;
+    double cosSqα = 1 - sinα * sinα;
+    double uSq = cosSqα * squareRatio;// (planetModel.ab* planetModel.ab - planetModel.c*planetModel.c) / (planetModel.c*planetModel.c);
+    double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
+    double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
+
+    double cos2σM;
+    double sinσ;
+    double cosσ;
+    double Δσ;
+
+    double σ = dist / (c * A);
+    double σʹ;
+    double iterations = 0;
+    do {
+      cos2σM = Math.cos(2 * σ1 + σ);
+      sinσ = Math.sin(σ);
+      cosσ = Math.cos(σ);
+      Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -
+          B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));
+      σʹ = σ;
+      σ = dist / (c * A) + Δσ;
+    } while (Math.abs(σ - σʹ) > Vector.MINIMUM_RESOLUTION && ++iterations < 40);
+
+    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;
+    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - flattening) * Math.sqrt(sinα * sinα + x * x));
+    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);
+    double C = flattening / 16 * cosSqα * (4 + flattening * (4 - 3 * cosSqα));
+    double L = λ - (1 - C) * flattening * sinα *
+        (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));
+    double λ2 = (lon + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI;  // normalise to -180..+180
+
+    return new GeoPoint(this, φ2, λ2 );
+  }
+
+
   @Override
   public boolean equals(final Object o) {
     if (!(o instanceof PlanetModel))
Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoStandardCircle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoStandardCircle.java	(revision 277bc3a94be284d41c001291dc0ff5d03dae11e1)
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoStandardCircle.java	(revision )
@@ -59,24 +59,9 @@
     this.cutoffAngle = cutoffAngle;
     // Compute two points on the circle, with the right angle from the center.  We'll use these
     // to obtain the perpendicular plane to the circle.
-    double upperLat = lat + cutoffAngle;
-    double upperLon = lon;
-    if (upperLat > Math.PI * 0.5) {
-      upperLon += Math.PI;
-      if (upperLon > Math.PI)
-        upperLon -= 2.0 * Math.PI;
-      upperLat = Math.PI - upperLat;
-    }
-    double lowerLat = lat - cutoffAngle;
-    double lowerLon = lon;
-    if (lowerLat < -Math.PI * 0.5) {
-      lowerLon += Math.PI;
-      if (lowerLon > Math.PI)
-        lowerLon -= 2.0 * Math.PI;
-      lowerLat = -Math.PI - lowerLat;
-    }
-    final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);
-    final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);
+    final GeoPoint upperPoint = planetModel.pointOnBearing(center, cutoffAngle, 0);
+    final GeoPoint lowerPoint = planetModel.pointOnBearing(center, cutoffAngle, Math.PI);
+
     if (Math.abs(cutoffAngle - Math.PI) < Vector.MINIMUM_RESOLUTION) {
       // Circle is the whole world
       this.circlePlane = null;
