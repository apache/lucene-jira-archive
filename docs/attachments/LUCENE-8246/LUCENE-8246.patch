diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index 8ba460d70b..c90decda2a 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -5221,4 +5221,24 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable {
     return false;
   }
 
+
+  /**
+   * Returns the number of deletes a merge would claim back if the given segment is merged.
+   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, CodecReader)
+   * @param info the segment to get the number of deletes for
+   * @lucene.experimental
+   */
+  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {
+    MergePolicy mergePolicy = config.getMergePolicy();
+    final ReadersAndUpdates rld = readerPool.get(info, false);
+    int numDeletesToMerge;
+    if (rld != null) {
+      numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);
+    } else {
+      numDeletesToMerge = mergePolicy.numDeletesToMerge(info,  0, null);
+    }
+    assert numDeletesToMerge <= info.info.maxDoc() :
+    "numDeletesToMerge: " + numDeletesToMerge + " > maxDoc: " + info.info.maxDoc();
+    return numDeletesToMerge;
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/index/LogMergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/LogMergePolicy.java
index 78025634b4..134f6ff848 100644
--- a/lucene/core/src/java/org/apache/lucene/index/LogMergePolicy.java
+++ b/lucene/core/src/java/org/apache/lucene/index/LogMergePolicy.java
@@ -150,7 +150,7 @@ public abstract class LogMergePolicy extends MergePolicy {
    *  #setCalibrateSizeByDeletes} is set. */
   protected long sizeDocs(SegmentCommitInfo info, IndexWriter writer) throws IOException {
     if (calibrateSizeByDeletes) {
-      int delCount = writer.numDeletedDocs(info);
+      int delCount = writer.numDeletesToMerge(info);
       assert delCount <= info.info.maxDoc();
       return (info.info.maxDoc() - (long)delCount);
     } else {
@@ -388,7 +388,7 @@ public abstract class LogMergePolicy extends MergePolicy {
     assert writer != null;
     for(int i=0;i<numSegments;i++) {
       final SegmentCommitInfo info = segmentInfos.info(i);
-      int delCount = writer.numDeletedDocs(info);
+      int delCount = writer.numDeletesToMerge(info);
       if (delCount > 0) {
         if (verbose(writer)) {
           message("  segment " + info.info.name + " has deletions", writer);
diff --git a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java
index c0d9748b6f..2a41b57ce7 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java
@@ -30,6 +30,7 @@ import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.BooleanSupplier;
 import java.util.stream.Collectors;
 
+import org.apache.lucene.document.Field;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.MergeInfo;
 
@@ -310,7 +311,7 @@ public abstract class MergePolicy {
      * input total size. This is only set once the merge is
      * initialized by IndexWriter.
      */
-    public long totalBytesSize() throws IOException {
+    public long totalBytesSize() {
       return totalMergeBytes;
     }
 
@@ -318,7 +319,7 @@ public abstract class MergePolicy {
      * Returns the total number of documents that are included with this merge.
      * Note that this does not indicate the number of documents after the merge.
      * */
-    public int totalNumDocs() throws IOException {
+    public int totalNumDocs() {
       int total = 0;
       for (SegmentCommitInfo info : segments) {
         total += info.info.maxDoc();
@@ -551,7 +552,7 @@ public abstract class MergePolicy {
    *  non-deleted documents is set. */
   protected long size(SegmentCommitInfo info, IndexWriter writer) throws IOException {
     long byteSize = info.sizeInBytes();
-    int delCount = writer.numDeletedDocs(info);
+    int delCount = writer.numDeletesToMerge(info);
     double delRatio = info.info.maxDoc() <= 0 ? 0.0f : (float) delCount / (float) info.info.maxDoc();
     assert delRatio <= 1.0;
     return (info.info.maxDoc() <= 0 ? byteSize : (long) (byteSize * (1.0 - delRatio)));
@@ -562,7 +563,7 @@ public abstract class MergePolicy {
    *  writer, and matches the current compound file setting */
   protected final boolean isMerged(SegmentInfos infos, SegmentCommitInfo info, IndexWriter writer) throws IOException {
     assert writer != null;
-    boolean hasDeletions = writer.numDeletedDocs(info) > 0;
+    boolean hasDeletions = writer.numDeletesToMerge(info) > 0;
     return !hasDeletions &&
       info.info.dir == writer.getDirectory() &&
       useCompoundFile(infos, info, writer) == info.info.getUseCompoundFile();
@@ -612,4 +613,21 @@ public abstract class MergePolicy {
   public boolean keepFullyDeletedSegment(CodecReader reader) throws IOException {
     return false;
   }
+
+  /**
+   * Returns the number of deletes that a merge would claim on the given segment. This method will by default return
+   * the sum of the del count on disk and the pending delete count. Yet, subclasses that wrap merge readers
+   * might modify this to reflect deletes that are carried over to the target segment in the case of soft deletes.
+   *
+   * Soft deletes all deletes to survive across merges in order to control when the soft-deleted data is claimed.
+   * @see IndexWriter#softUpdateDocument(Term, Iterable, Field...)
+   * @see IndexWriterConfig#setSoftDeletesField(String)
+   *
+   * @param info the segment info that identifies the segment
+   * @param pendingDeleteCount the number of pending deletes for this segment
+   * @param reader a reader if available otherwise <code>null</code>
+   */
+  public int numDeletesToMerge(SegmentCommitInfo info, int pendingDeleteCount, CodecReader reader) throws IOException {
+    return info.getDelCount() + pendingDeleteCount;
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/index/MergePolicyWrapper.java b/lucene/core/src/java/org/apache/lucene/index/MergePolicyWrapper.java
index 606f3c2bd4..978cbca791 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MergePolicyWrapper.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MergePolicyWrapper.java
@@ -90,4 +90,9 @@ public class MergePolicyWrapper extends MergePolicy {
   public boolean keepFullyDeletedSegment(CodecReader reader) throws IOException {
     return in.keepFullyDeletedSegment(reader);
   }
+
+  @Override
+  public int numDeletesToMerge(SegmentCommitInfo info, int pendingDeleteCount, CodecReader reader) throws IOException {
+    return in.numDeletesToMerge(info, pendingDeleteCount, reader);
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/index/NoMergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/NoMergePolicy.java
index 4387f25051..42c5df2b91 100644
--- a/lucene/core/src/java/org/apache/lucene/index/NoMergePolicy.java
+++ b/lucene/core/src/java/org/apache/lucene/index/NoMergePolicy.java
@@ -73,6 +73,11 @@ public final class NoMergePolicy extends MergePolicy {
     return super.keepFullyDeletedSegment(reader);
   }
 
+  @Override
+  public int numDeletesToMerge(SegmentCommitInfo info, int pendingDeleteCount, CodecReader reader) throws IOException {
+    return  super.numDeletesToMerge(info, pendingDeleteCount, reader);
+  }
+
   @Override
   public String toString() {
     return "NoMergePolicy";
diff --git a/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java b/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java
index 3e06acad17..6fbafb77e1 100644
--- a/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java
+++ b/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java
@@ -201,7 +201,7 @@ final class ReadersAndUpdates {
     reader.incRef();
     return reader;
   }
-  
+
   public synchronized void release(SegmentReader sr) throws IOException {
     assert info == sr.getSegmentInfo();
     sr.decRef();
@@ -249,6 +249,21 @@ final class ReadersAndUpdates {
     }
   }
 
+  synchronized int numDeletesToMerge(MergePolicy policy) throws IOException {
+    if (this.reader != null) {
+      // we only use a reader to make a decisions like this if we have one. This prevents opening readers
+      // for every numDeletesToMerge call. We also don't have to mark liveDocs as shared as we execute this under a lock.
+      if (reader.getLiveDocs() != pendingDeletes.getLiveDocs()
+          || reader.numDeletedDocs() != info.getDelCount() - pendingDeletes.numPendingDeletes()) {
+        // we have a reader but it's life-docs are out of sync. let's create a temporary one that we never share
+        SegmentReader newReader = new SegmentReader(reader.getSegmentInfo(), reader, pendingDeletes.getLiveDocs(),
+            info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());
+        swapReader(newReader);
+      }
+    }
+    return policy.numDeletesToMerge(info, pendingDeletes.numPendingDeletes(), reader);
+  }
+
 
   public synchronized Bits getLiveDocs() {
     return pendingDeletes.getLiveDocs();
@@ -677,17 +692,7 @@ final class ReadersAndUpdates {
     // if there is a reader open, reopen it to reflect the updates
     if (reader != null) {
       SegmentReader newReader = new SegmentReader(info, reader, pendingDeletes.getLiveDocs(), info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());
-      boolean success2 = false;
-      try {
-        pendingDeletes.onNewReader(newReader, info);
-        reader.decRef();
-        reader = newReader;
-        success2 = true;
-      } finally {
-        if (success2 == false) {
-          newReader.decRef();
-        }
-      }
+      swapReader(newReader);
     }
 
     // writing field updates succeeded
@@ -713,6 +718,20 @@ final class ReadersAndUpdates {
     return true;
   }
 
+  private void swapReader(SegmentReader newReader) throws IOException {
+    boolean success2 = false;
+    try {
+      pendingDeletes.onNewReader(newReader, info);
+      reader.decRef();
+      reader = newReader;
+      success2 = true;
+    } finally {
+      if (success2 == false) {
+        newReader.decRef();
+      }
+    }
+  }
+
   synchronized public void setIsMerging() {
     // This ensures any newly resolved doc value updates while we are merging are
     // saved for re-applying after this segment is done merging:
diff --git a/lucene/core/src/java/org/apache/lucene/index/SoftDeletesRetentionMergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/SoftDeletesRetentionMergePolicy.java
index b0887557be..5f5290cca0 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SoftDeletesRetentionMergePolicy.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SoftDeletesRetentionMergePolicy.java
@@ -167,4 +167,27 @@ public final class SoftDeletesRetentionMergePolicy extends OneMergeWrappingMerge
         return numDocs;
       }
     };
-  }}
+  }
+
+  @Override
+  public int numDeletesToMerge(SegmentCommitInfo info, int pendingDeleteCount, CodecReader reader) throws IOException {
+    int numDeletesToMerge = super.numDeletesToMerge(info, pendingDeleteCount, reader);
+    if (numDeletesToMerge != 0 && reader != null) {
+      if (reader.getLiveDocs() != null) {
+        Scorer scorer = getScorer(field, retentionQuerySupplier.get(), wrapLiveDocs(reader, null, reader.maxDoc()));
+        if (scorer != null) {
+          DocIdSetIterator iterator = scorer.iterator();
+          Bits liveDocs = reader.getLiveDocs();
+          int numDeletedDocs = reader.numDeletedDocs();
+          while (iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
+            if (liveDocs.get(iterator.docID()) == false) {
+              numDeletedDocs--;
+            }
+          }
+          return numDeletedDocs;
+        }
+      }
+    }
+    return numDeletesToMerge;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy.java
index cdfdea6e5a..bdd3a8a6ac 100644
--- a/lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy.java
+++ b/lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy.java
@@ -597,7 +597,7 @@ public class TieredMergePolicy extends MergePolicy {
     final List<SegmentCommitInfo> eligible = new ArrayList<>();
     final Set<SegmentCommitInfo> merging = writer.getMergingSegments();
     for(SegmentCommitInfo info : infos) {
-      double pctDeletes = 100.*((double) writer.numDeletedDocs(info))/info.info.maxDoc();
+      double pctDeletes = 100.*((double) writer.numDeletesToMerge(info))/info.info.maxDoc();
       if (pctDeletes > forceMergeDeletesPctAllowed && !merging.contains(info)) {
         eligible.add(info);
       }
