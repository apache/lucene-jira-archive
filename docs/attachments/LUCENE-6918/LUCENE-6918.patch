Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1717734)
+++ lucene/CHANGES.txt	(working copy)
@@ -113,6 +113,11 @@
 * LUCENE-6900: Grouping sortWithinGroup variables used to allow null to mean
   Sort.RELEVANCE.  Null is no longer permitted.  (David Smiley)
 
+Bug Fixes
+
+* LUCENE-6918: LRUQueryCache.onDocIdSetEviction is not only called when at
+  least one DocIdSet is being evicted. (Adrien Grand)
+
 ======================= Lucene 5.4.0 =======================
 
 New Features
Index: lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java	(revision 1717734)
+++ lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java	(working copy)
@@ -297,7 +297,13 @@
     final LeafCache leafCache = cache.remove(coreKey);
     if (leafCache != null) {
       ramBytesUsed -= HASHTABLE_RAM_BYTES_PER_ENTRY;
-      onDocIdSetEviction(coreKey, leafCache.cache.size(), leafCache.ramBytesUsed);
+      final int numEntries = leafCache.cache.size();
+      if (numEntries > 0) {
+        onDocIdSetEviction(coreKey, numEntries, leafCache.ramBytesUsed);
+      } else {
+        assert numEntries == 0;
+        assert leafCache.ramBytesUsed == 0;
+      }
     }
   }
 
Index: lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java	(revision 1717734)
+++ lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java	(working copy)
@@ -1164,4 +1164,31 @@
     searcher.getIndexReader().close();
     dir.close();
   }
+
+  public void testEvictEmptySegmentCache() throws IOException {
+    Directory dir = newDirectory();
+    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    w.addDocument(new Document());
+    final DirectoryReader reader = w.getReader();
+    final IndexSearcher searcher = newSearcher(reader);
+    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000) {
+      @Override
+      protected void onDocIdSetEviction(Object readerCoreKey, int numEntries, long sumRamBytesUsed) {
+        super.onDocIdSetEviction(readerCoreKey, numEntries, sumRamBytesUsed);
+        assertTrue(numEntries > 0);
+      }
+    };
+
+    searcher.setQueryCache(queryCache);
+    searcher.setQueryCachingPolicy(QueryCachingPolicy.ALWAYS_CACHE);
+
+    Query query = new DummyQuery();
+    searcher.count(query);
+    assertEquals(Collections.singletonList(query), queryCache.cachedQueries());
+    queryCache.clearQuery(query);
+
+    reader.close(); // make sure this does not trigger eviction of segment caches with no entries
+    w.close();
+    dir.close();
+  }
 }
