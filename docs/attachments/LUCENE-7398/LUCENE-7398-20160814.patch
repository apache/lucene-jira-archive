diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
index f405473..196c03f 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
@@ -46,7 +46,9 @@ public class NearSpansOrdered extends ConjunctionSpans {
 
   protected int matchStart = -1;
   protected int matchEnd = -1;
-  protected int matchWidth = -1;
+  protected int matchSlop = -1;
+
+  private boolean firstSubSpansAfterMatch = true;
 
   private final int allowedSlop;
 
@@ -60,11 +62,19 @@ public class NearSpansOrdered extends ConjunctionSpans {
   boolean twoPhaseCurrentDocMatches() throws IOException {
     assert unpositioned();
     oneExhaustedInCurrentDoc = false;
-    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
-      if (stretchToOrder() && matchWidth <= allowedSlop) {
+    subSpans[0].nextStartPosition();
+    while (subSpans[0].startPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
+      if (stretchToOrder()) {
+        if (matchSlop <= allowedSlop) {
+          firstSubSpansAfterMatch = false;
+          return atFirstInCurrentDoc = true;
+        }
+        if (shrinkToDecreaseSlop()) {
+          firstSubSpansAfterMatch = true;
           return atFirstInCurrentDoc = true;
         }
       }
+    }
     return false;
   }
 
@@ -82,12 +92,24 @@ public class NearSpansOrdered extends ConjunctionSpans {
       atFirstInCurrentDoc = false;
       return matchStart;
     }
+
+    if (! firstSubSpansAfterMatch) {
+      subSpans[0].nextStartPosition();
+    }
+
     oneExhaustedInCurrentDoc = false;
-    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
-      if (stretchToOrder() && matchWidth <= allowedSlop) {
+    while (subSpans[0].startPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
+      if (stretchToOrder()) {
+        if (matchSlop <= allowedSlop) {
+          firstSubSpansAfterMatch = false;
+          return matchStart;
+        }
+        if (shrinkToDecreaseSlop()) {
+          firstSubSpansAfterMatch = true;
           return matchStart;
         }
       }
+    }
     return matchStart = matchEnd = NO_MORE_POSITIONS;
   }
 
@@ -102,7 +124,8 @@ public class NearSpansOrdered extends ConjunctionSpans {
     matchStart = prevSpans.startPosition();
     assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
     assert prevSpans.endPosition() != NO_MORE_POSITIONS;
-    matchWidth = 0;
+    matchSlop = 0;
+
     for (int i = 1; i < subSpans.length; i++) {
       Spans spans = subSpans[i];
       assert spans.startPosition() != NO_MORE_POSITIONS;
@@ -111,13 +134,73 @@ public class NearSpansOrdered extends ConjunctionSpans {
         oneExhaustedInCurrentDoc = true;
         return false;
       }
-      matchWidth += (spans.startPosition() - prevSpans.endPosition());
+      assert spans.startPosition() >= prevSpans.endPosition();
+      matchSlop += spans.startPosition() - prevSpans.endPosition();
       prevSpans = spans;
     }
     matchEnd = subSpans[subSpans.length - 1].endPosition();
     return true; // all subSpans ordered and non overlapping
   }
 
+  /** The subSpans are ordered in the same doc and matchSlop is too big.
+   * Try and decrease the slop by calling nextStartPosition() on all subSpans except the last one in reverse order.
+   * Return true iff an ordered match was found with small enough slop.
+   */
+  private boolean shrinkToDecreaseSlop() throws IOException {
+    int lastStart = subSpans[subSpans.length - 1].startPosition();
+
+    for (int i = subSpans.length - 2; i >= 1; i--) { // intermediate spans for subSpans.length >= 3
+      Spans prevSpans = subSpans[i];
+      int prevStart = prevSpans.startPosition();
+      int prevEnd = prevSpans.endPosition();
+      while (true) { // Advance prevSpans until it is after (lastStart, lastEnd) or the slop increases.
+        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {
+          oneExhaustedInCurrentDoc = true;
+          break; // Check remaining subSpans for final match in current doc
+        } else {
+          int ppStart = prevSpans.startPosition();
+          int ppEnd = prevSpans.endPosition();
+          if (ppEnd > lastStart) { // no more ordered
+            break; // Check remaining subSpans.
+          } else { // prevSpans still before lastStart
+            int slopIncrease = (prevEnd - prevStart) - (ppEnd - ppStart); // span length decrease is slop increase
+            if (slopIncrease > 0) {
+              break; // Check remaining subSpans.
+            } else { // slop did not increase
+              prevStart = ppStart;
+              prevEnd = ppEnd;
+              matchSlop += slopIncrease;
+            }
+          }
+        }
+      }
+      lastStart = prevStart;
+    }
+
+    while (true) { // for subSpans[0] only the end position influences the match slop.
+      int prevEnd = subSpans[0].endPosition();
+      if (subSpans[0].nextStartPosition() == NO_MORE_POSITIONS) {
+        oneExhaustedInCurrentDoc = true;
+        break;
+      }
+      int ppEnd = subSpans[0].endPosition();
+      if (ppEnd > lastStart) { // no more ordered
+        break;
+      }
+      int slopIncrease = prevEnd - ppEnd;
+      if (slopIncrease > 0) {
+        break;
+      }
+      // slop did not increase:
+      matchStart = subSpans[0].startPosition();
+      matchSlop += slopIncrease;
+    }
+
+    boolean match = matchSlop <= allowedSlop;
+    return match; // ordered and allowed slop
+  }
+
+
   private static int advancePosition(Spans spans, int position) throws IOException {
     if (spans instanceof SpanNearQuery.GapSpans) {
       return ((SpanNearQuery.GapSpans)spans).skipToPosition(position);
@@ -140,9 +223,10 @@ public class NearSpansOrdered extends ConjunctionSpans {
 
   @Override
   public int width() {
-    return matchWidth;
+    return matchSlop;
   }
 
+  /** FIXME: the subspans may be after the current match. */
   @Override
   public void collect(SpanCollector collector) throws IOException {
     for (Spans span : subSpans) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
index 2b42a76..98c094d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
@@ -92,7 +92,9 @@ public class TestSpanCollection extends LuceneTestCase {
       "w1 w2 w3 w4 w5",
       "w1 w3 w2 w3 zz",
       "w1 xx w2 yy w4",
-      "w1 w2 w1 w4 w2 w3"
+      "w1 w2 w1 w4 w2 w3",
+      "coordinate gene mapping research",
+      "coordinate gene research"
   };
 
   private void checkCollectedTerms(Spans spans, TermCollector collector, Term... expectedTerms) throws IOException {
@@ -105,6 +107,45 @@ public class TestSpanCollection extends LuceneTestCase {
   }
 
   @Test
+  public void testNestedOrQuery() throws IOException {
+    SpanNearQuery snq = SpanNearQuery.newOrderedNearQuery(FIELD)
+        .addClause(new SpanTermQuery(new Term(FIELD, "coordinate")))
+        .addClause(new SpanOrQuery(
+            new SpanTermQuery(new Term(FIELD, "gene")),
+            SpanNearQuery.newOrderedNearQuery(FIELD)
+                .addClause(new SpanTermQuery(new Term(FIELD, "gene")))
+                .addClause(new SpanTermQuery(new Term(FIELD, "mapping")))
+                .build()
+        ))
+        .addClause(new SpanTermQuery(new Term(FIELD, "research")))
+        .build();
+
+    Spans spans = snq.createWeight(searcher, false, 1).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(4, spans.advance(4));
+    assertEquals(5, spans.nextDoc());
+  }
+
+  @Test
+  public void testNestedOrQuerySlop() throws IOException {
+    SpanNearQuery snq = SpanNearQuery.newOrderedNearQuery(FIELD)
+        .setSlop(1)
+        .addClause(new SpanTermQuery(new Term(FIELD, "w1")))
+        .addClause(new SpanOrQuery(
+            new SpanTermQuery(new Term(FIELD, "w2")),
+            SpanNearQuery.newOrderedNearQuery(FIELD)
+                .addClause(new SpanTermQuery(new Term(FIELD, "w3")))
+                .addClause(new SpanTermQuery(new Term(FIELD, "w4")))
+                .build()
+        ))
+        .addClause(new SpanTermQuery(new Term(FIELD, "w5")))
+        .build();
+
+    Spans spans = snq.createWeight(searcher, false, 1).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    assertEquals(Spans.NO_MORE_DOCS, spans.nextDoc());
+  }
+
+  @Test
   public void testNestedNearQuery() throws IOException {
 
     // near(w1, near(w2, or(w3, w4)))
@@ -130,6 +171,42 @@ public class TestSpanCollection extends LuceneTestCase {
     spans.nextStartPosition();
     checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
 
+    SpanNearQuery q23 = new SpanNearQuery(new SpanQuery[]{q2, q3}, 0, true);
+    SpanOrQuery q223 = new SpanOrQuery(q2, q23);
+
+    SpanNearQuery q1q2q3q4 = new SpanNearQuery(new SpanQuery[]{q1, q2, q3, q4}, 0, true);
+    SpanNearQuery q1q23q4 = new SpanNearQuery(new SpanQuery[]{q1, q23, q4}, 0, true);
+    SpanNearQuery q1q223q4 = new SpanNearQuery(new SpanQuery[]{q1, q223, q4}, 0, true);
+    SpanNearQuery q223q4 = new SpanNearQuery(new SpanQuery[]{q223, q4}, 0, true);
+    SpanNearQuery q1q223 = new SpanNearQuery(new SpanQuery[]{q1, q223}, 0, true);
+
+    spans = q1q2q3q4.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"), new Term(FIELD, "w4"));
+
+    spans = q1q23q4.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"), new Term(FIELD, "w4"));
+
+    spans = q223q4.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"), new Term(FIELD, "w3"), new Term(FIELD, "w4"));
+
+    // near/0(w1, or(w2, near/0(w2, w3)))
+    spans =q1q223.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
+
+    spans =q1q223q4.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"), new Term(FIELD, "w4"));
+
+
   }
 
   @Test
