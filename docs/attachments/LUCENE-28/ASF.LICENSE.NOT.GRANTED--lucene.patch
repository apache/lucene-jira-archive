Index: src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java,v
retrieving revision 1.2
diff -c -5 -r1.2 MultiFieldQueryParser.java
*** src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	22 Mar 2002 03:22:33 -0000	1.2
--- src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	12 Apr 2002 16:29:58 -0000
***************
*** 52,61 ****
--- 52,62 ----
   * individuals on behalf of the Apache Software Foundation.  For more
   * information on the Apache Software Foundation, please see
   * <http://www.apache.org/>.
   */
  
+ import java.io.IOException;
  import org.apache.lucene.analysis.Analyzer;
  import org.apache.lucene.queryParser.CharStream;
  import org.apache.lucene.queryParser.ParseException;
  import org.apache.lucene.queryParser.QueryParser;
  import org.apache.lucene.queryParser.QueryParserTokenManager;
***************
*** 103,115 ****
       * @param query Query string to parse
       * @param fields Fields to search on
       * @param analyzer Analyzer to use
       * @throws ParserException if query parsing fails
       * @throws TokenMgrError if query parsing fails
       */
      public static Query parse(String query, String[] fields, Analyzer analyzer)
! 	throws ParseException
      {
          BooleanQuery bQuery = new BooleanQuery();
          for (int i = 0; i < fields.length; i++)
          {
              Query q = parse(query, fields[i], analyzer);
--- 104,118 ----
       * @param query Query string to parse
       * @param fields Fields to search on
       * @param analyzer Analyzer to use
       * @throws ParserException if query parsing fails
       * @throws TokenMgrError if query parsing fails
+      * @throws IOException if the Analyzer's tokenStream fails to tokenize
+      *                     terms in the query.
       */
      public static Query parse(String query, String[] fields, Analyzer analyzer)
! 	throws ParseException, IOException
      {
          BooleanQuery bQuery = new BooleanQuery();
          for (int i = 0; i < fields.length; i++)
          {
              Query q = parse(query, fields[i], analyzer);
***************
*** 145,158 ****
       * @param fields Fields to search on
       * @param flags Flags describing the fields
       * @param analyzer Analyzer to use
       * @throws ParserException if query parsing fails
       * @throws TokenMgrError if query parsing fails
       */
      public static Query parse(String query, String[] fields, int[] flags,
  	Analyzer analyzer)
! 	throws ParseException
      {
          BooleanQuery bQuery = new BooleanQuery();
          for (int i = 0; i < fields.length; i++)
          {
              Query q = parse(query, fields[i], analyzer);
--- 148,163 ----
       * @param fields Fields to search on
       * @param flags Flags describing the fields
       * @param analyzer Analyzer to use
       * @throws ParserException if query parsing fails
       * @throws TokenMgrError if query parsing fails
+      * @throws IOException if the Analyzer's tokenStream fails to tokenize
+      *                     terms in the query.
       */
      public static Query parse(String query, String[] fields, int[] flags,
  	Analyzer analyzer)
! 	throws ParseException, IOException
      {
          BooleanQuery bQuery = new BooleanQuery();
          for (int i = 0; i < fields.length; i++)
          {
              Query q = parse(query, fields[i], analyzer);
Index: src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj,v
retrieving revision 1.15
diff -c -5 -r1.15 QueryParser.jj
*** src/java/org/apache/lucene/queryParser/QueryParser.jj	22 Feb 2002 21:06:16 -0000	1.15
--- src/java/org/apache/lucene/queryParser/QueryParser.jj	12 Apr 2002 16:29:59 -0000
***************
*** 110,122 ****
     *  @param query	the query string to be parsed.
     *  @param field	the default field for query terms.
     *  @param analyzer   used to find terms in the query text.
     *  @throws ParseException if the parsing fails
     *  @throws TokenMgrError if the parsing fails
     */
    static public Query parse(String query, String field, Analyzer analyzer)
!        throws ParseException, TokenMgrError {
      QueryParser parser = new QueryParser(field, analyzer);
      return parser.parse(query);
    }
         
    Analyzer analyzer;
--- 110,124 ----
     *  @param query	the query string to be parsed.
     *  @param field	the default field for query terms.
     *  @param analyzer   used to find terms in the query text.
     *  @throws ParseException if the parsing fails
     *  @throws TokenMgrError if the parsing fails
+    *  @throws IOException if the Analyzer's tokenStream fails to tokenize
+    *                      terms in the query.
     */
    static public Query parse(String query, String field, Analyzer analyzer)
!        throws ParseException, TokenMgrError, IOException {
      QueryParser parser = new QueryParser(field, analyzer);
      return parser.parse(query);
    }
         
    Analyzer analyzer;
***************
*** 135,147 ****
  
    /** Parses a query string, returning a
     * <a href="lucene.search.Query.html">Query</a>.
     *  @param query	the query string to be parsed.
     *  @throws ParseException if the parsing fails
!    *  @throws TokenMgrError if ther parsing fails
     */
!   public Query parse(String query) throws ParseException, TokenMgrError {
      ReInit(new FastCharStream(new StringReader(query)));
      return Query(field);
    }
  
    /** Sets the default slop for phrases.  If zero, then exact phrase matches
--- 137,152 ----
  
    /** Parses a query string, returning a
     * <a href="lucene.search.Query.html">Query</a>.
     *  @param query	the query string to be parsed.
     *  @throws ParseException if the parsing fails
!    *  @throws TokenMgrError if the parsing fails
!    *  @throws IOException if the Analyzer's tokenStream fails to tokenize
!    *                      terms in the query.
     */
!   public Query parse(String query) 
!     throws ParseException, TokenMgrError, IOException {
      ReInit(new FastCharStream(new StringReader(query)));
      return Query(field);
    }
  
    /** Sets the default slop for phrases.  If zero, then exact phrase matches
***************
*** 176,205 ****
      clauses.addElement(new BooleanClause(q, required, prohibited));
    }
  
    private Query getFieldQuery(String field, 
                                Analyzer analyzer, 
!                               String queryText) {
      // Use the analyzer to get all the tokens, and then build a TermQuery,
      // PhraseQuery, or nothing based on the term count
      
      TokenStream source = analyzer.tokenStream(field, 
                                                new StringReader(queryText));
      Vector v = new Vector();
      org.apache.lucene.analysis.Token t;
  
!     while (true) {
!       try {
!         t = source.next();
!       } 
!       catch (IOException e) {
!         t = null;
!       }
!       if (t == null) 
!         break;
        v.addElement(t.termText());
      }
      if (v.size() == 0) 
        return null;
      else if (v.size() == 1) 
        return new TermQuery(new Term(field, (String) v.elementAt(0)));
      else {
--- 181,206 ----
      clauses.addElement(new BooleanClause(q, required, prohibited));
    }
  
    private Query getFieldQuery(String field, 
                                Analyzer analyzer, 
!                               String queryText) throws IOException {
      // Use the analyzer to get all the tokens, and then build a TermQuery,
      // PhraseQuery, or nothing based on the term count
      
      TokenStream source = analyzer.tokenStream(field, 
                                                new StringReader(queryText));
      Vector v = new Vector();
      org.apache.lucene.analysis.Token t;
  
!     try {
!       t = source.next();
        v.addElement(t.termText());
+     } finally {
+       source.close();
      }
+ 
      if (v.size() == 0) 
        return null;
      else if (v.size() == 1) 
        return new TermQuery(new Term(field, (String) v.elementAt(0)));
      else {
***************
*** 213,249 ****
    }
  
    private Query getRangeQuery(String field, 
                                Analyzer analyzer, 
                                String queryText, 
!                               boolean inclusive) 
    {
      // Use the analyzer to get all the tokens.  There should be 1 or 2.
      TokenStream source = analyzer.tokenStream(field, 
                                                new StringReader(queryText));
      Term[] terms = new Term[2];
-     org.apache.lucene.analysis.Token t;
  
!     for (int i = 0; i < 2; i++)
!     {
!       try 
!       {
!         t = source.next();
!       } 
!       catch (IOException e) 
!       {
!         t = null;
!       }
!       if (t != null)
!       {
          String text = t.termText();
!         if (!text.equalsIgnoreCase("NULL"))
!         {
            terms[i] = new Term(field, text);
          }
        }
      }
      return new RangeQuery(terms[0], terms[1], inclusive);
    }
  
    public static void main(String[] args) throws Exception {
      QueryParser qp = new QueryParser("field", 
--- 214,242 ----
    }
  
    private Query getRangeQuery(String field, 
                                Analyzer analyzer, 
                                String queryText, 
!                               boolean inclusive) throws IOException
    {
      // Use the analyzer to get all the tokens.  There should be 1 or 2.
      TokenStream source = analyzer.tokenStream(field, 
                                                new StringReader(queryText));
      Term[] terms = new Term[2];
  
!     try {
!       for (int i = 0; i < 2; i++) {
!         org.apache.lucene.analysis.Token t = source.next();
          String text = t.termText();
!         if (!text.equalsIgnoreCase("NULL")) {
            terms[i] = new Term(field, text);
          }
        }
+     } finally {
+       source.close();
      }
+ 
      return new RangeQuery(terms[0], terms[1], inclusive);
    }
  
    public static void main(String[] args) throws Exception {
      QueryParser qp = new QueryParser("field", 
***************
*** 328,338 ****
       | <NOT> { ret = MOD_NOT; }
    ]
    { return ret; }
  }
  
! Query Query(String field) :
  {
    Vector clauses = new Vector();
    Query q, firstQuery=null;
    int conj, mods; 
  }
--- 321,331 ----
       | <NOT> { ret = MOD_NOT; }
    ]
    { return ret; }
  }
  
! Query Query(String field) throws IOException :
  {
    Vector clauses = new Vector();
    Query q, firstQuery=null;
    int conj, mods; 
  }
***************
*** 357,367 ****
          return query;
        }
      }
  }
  
! Query Clause(String field) : {
    Query q;
    Token fieldToken=null;
  }
  {
    [
--- 350,360 ----
          return query;
        }
      }
  }
  
! Query Clause(String field) throws IOException : {
    Query q;
    Token fieldToken=null;
  }
  {
    [
***************
*** 377,387 ****
        return q;
      }
  }
      
  
! Query Term(String field) : { 
    Token term, boost=null, slop=null;
    boolean prefix = false;
    boolean wildcard = false;
    boolean fuzzy = false;
    boolean rangein = false;
--- 370,380 ----
        return q;
      }
  }
      
  
! Query Term(String field) throws IOException : { 
    Token term, boost=null, slop=null;
    boolean prefix = false;
    boolean wildcard = false;
    boolean fuzzy = false;
    boolean rangein = false;
