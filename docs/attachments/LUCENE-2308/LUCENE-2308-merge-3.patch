Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/package.html
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/package.html	(revision 1159870)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/package.html	(working copy)
@@ -25,7 +25,7 @@
 <li>support N-gram fields</li>
 <li>support phrase-unit highlighting with slops</li>
 <li>need Java 1.5</li>
-<li>highlight fields need to be TermVector.WITH_POSITIONS_OFFSETS</li>
+<li>highlight fields need to be stored with Positions and Offsets</li>
 <li>take into account query boost to score fragments</li>
 <li>support colored highlight tags</li>
 <li>pluggable FragListBuilder</li>
@@ -95,7 +95,7 @@
 
 <h3>Step 2.</h3>
 <p>In Step 2, Fast Vector Highlighter generates {@link org.apache.lucene.search.vectorhighlight.FieldTermStack}. Fast Vector Highlighter uses {@link org.apache.lucene.index.TermFreqVector} data
-(must be stored {@link org.apache.lucene.document.Field.TermVector#WITH_POSITIONS_OFFSETS})
+(must be stored {@link org.apache.lucene.document.FieldType#setStoreTermVectorOffsets(boolean)} and {@link org.apache.lucene.document.FieldType#setStoreTermVectorPositions(boolean)})
 to generate it. <code>FieldTermStack</code> keeps the terms in the user query.
 Therefore, in this sample case, Fast Vector Highlighter generates the following <code>FieldTermStack</code>:</p>
 <pre>
Index: lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager.java
===================================================================
--- lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager.java	(revision 1159870)
+++ lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager.java	(working copy)
@@ -33,7 +33,6 @@
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.codecs.CodecProvider;
Index: lucene/src/java/org/apache/lucene/analysis/package.html
===================================================================
--- lucene/src/java/org/apache/lucene/analysis/package.html	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/analysis/package.html	(working copy)
@@ -120,7 +120,7 @@
   Applications usually do not invoke analysis &ndash; Lucene does it for them:
   <ul>
     <li>At indexing, as a consequence of 
-        {@link org.apache.lucene.index.IndexWriter#addDocument(org.apache.lucene.document.Document) addDocument(doc)},
+        {@link org.apache.lucene.index.IndexWriter#addDocument(Iterable) addDocument(doc)},
         the Analyzer in effect for indexing is invoked for each indexed field of the added document.
     </li>
     <li>At search, a QueryParser may invoke the Analyzer during parsing.  Note that for some queries, analysis does not
@@ -170,7 +170,7 @@
 </p>
 <h3>Field Section Boundaries</h3>
 <p>
-  When {@link org.apache.lucene.document.Document#add(org.apache.lucene.document.Fieldable) document.add(field)}
+  When {@link org.apache.lucene.document.Document#add(org.apache.lucene.index.IndexableField) document.add(field)}
   is called multiple times for the same field name, we could say that each such call creates a new 
   section for that field in that document. 
   In fact, a separate call to 
Index: lucene/src/java/org/apache/lucene/document/Field.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/Field.java	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/document/Field.java	(working copy)
@@ -237,22 +237,20 @@
   public float boost() {
     return boost;
   }
-  
-  /**
-   * Sets the boost factor hits on this field. This value will be multiplied
-   * into the score of all hits on this this field of this document.
-   * 
-   * <p>
-   * Boost is used to compute the norm factor for the field. By default, in the
-   * {@link org.apache.lucene.search.Similarity#computeNorm(FieldInvertState)}
-   * method, the boost value is multiplied by the length normalization factor
-   * and then rounded by
-   * {@link org.apache.lucene.search.Similarity#encodeNormValue(float)} before
-   * it is stored in the index. One should attempt to ensure that this product
-   * does not overflow the range of that encoding.
-   * 
+
+  /** Sets the boost factor hits on this field.  This value will be
+   * multiplied into the score of all hits on this this field of this
+   * document.
+   *
+   * <p>The boost is used to compute the norm factor for the field.  By
+   * default, in the {@link org.apache.lucene.search.Similarity#computeNorm(FieldInvertState)} method, 
+   * the boost value is multiplied by the length normalization factor and then
+   * rounded by {@link org.apache.lucene.search.DefaultSimilarity#encodeNormValue(float)} before it is stored in the
+   * index.  One should attempt to ensure that this product does not overflow
+   * the range of that encoding.
+   *
    * @see org.apache.lucene.search.Similarity#computeNorm(FieldInvertState)
-   * @see org.apache.lucene.search.Similarity#encodeNormValue(float)
+   * @see org.apache.lucene.search.DefaultSimilarity#encodeNormValue(float)
    */
   public void setBoost(float boost) {
     this.boost = boost;
Index: lucene/src/java/org/apache/lucene/document/Fieldable.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/Fieldable.java	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/document/Fieldable.java	(working copy)
@@ -1,238 +0,0 @@
-package org.apache.lucene.document;
-
-/**
- * Copyright 2004 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.index.FieldInvertState; // for javadocs
-import org.apache.lucene.index.values.IndexDocValues;
-import org.apache.lucene.index.values.PerDocFieldValues;
-import org.apache.lucene.index.values.ValueType;
-import org.apache.lucene.search.PhraseQuery; // for javadocs
-import org.apache.lucene.search.spans.SpanQuery; // for javadocs
-
-import java.io.Reader;
-
-/**
- * Synonymous with {@link Field}.
- *
- * <p><bold>WARNING</bold>: This interface may change within minor versions, despite Lucene's backward compatibility requirements.
- * This means new methods may be added from version to version.  This change only affects the Fieldable API; other backwards
- * compatibility promises remain intact. For example, Lucene can still
- * read and write indices created within the same major version.
- * </p>
- *
- **/
-public interface Fieldable {
-  /** Sets the boost factor hits on this field.  This value will be
-   * multiplied into the score of all hits on this this field of this
-   * document.
-   *
-   * <p>The boost is multiplied by {@link org.apache.lucene.document.Document#getBoost()} of the document
-   * containing this field.  If a document has multiple fields with the same
-   * name, all such values are multiplied together.  This product is then
-   * used to compute the norm factor for the field.  By
-   * default, in the {@link
-   * org.apache.lucene.search.Similarity#computeNorm(FieldInvertState)} method, the boost value is multiplied
-   * by the length normalization factor
-   * and then rounded by {@link org.apache.lucene.search.DefaultSimilarity#encodeNormValue(float)} before it is stored in the
-   * index.  One should attempt to ensure that this product does not overflow
-   * the range of that encoding.
-   *
-   * @see org.apache.lucene.document.Document#setBoost(float)
-   * @see org.apache.lucene.search.Similarity#computeNorm(FieldInvertState)
-   * @see org.apache.lucene.search.DefaultSimilarity#encodeNormValue(float)
-   */
-  void setBoost(float boost);
-
-  /** Returns the boost factor for hits for this field.
-   *
-   * <p>The default value is 1.0.
-   *
-   * <p>Note: this value is not stored directly with the document in the index.
-   * Documents returned from {@link org.apache.lucene.index.IndexReader#document(int)} and
-   * {@link org.apache.lucene.search.IndexSearcher#doc(int)} may thus not have the same value present as when
-   * this field was indexed.
-   *
-   * @see #setBoost(float)
-   */
-  float getBoost();
-
-  /** Returns the name of the field.
-   * For example "date", "title", "body", ...
-   */
-  String name();
-
-  /** The value of the field as a String, or null.
-   * <p>
-   * For indexing, if isStored()==true, the stringValue() will be used as the stored field value
-   * unless isBinary()==true, in which case getBinaryValue() will be used.
-   *
-   * If isIndexed()==true and isTokenized()==false, this String value will be indexed as a single token.
-   * If isIndexed()==true and isTokenized()==true, then tokenStreamValue() will be used to generate indexed tokens if not null,
-   * else readerValue() will be used to generate indexed tokens if not null, else stringValue() will be used to generate tokens.
-   */
-  public String stringValue();
-  
-  /** The value of the field as a Reader, which can be used at index time to generate indexed tokens.
-   * @see #stringValue()
-   */
-  public Reader readerValue();
-  
-  /** The TokenStream for this field to be used when indexing, or null.
-   * @see #stringValue()
-   */
-  public TokenStream tokenStreamValue();
-
-  /** True if the value of the field is to be stored in the index for return
-    with search hits. */
-  boolean  isStored();
-
-  /** True if the value of the field is to be indexed, so that it may be
-    searched on. */
-  boolean  isIndexed();
-
-  /** True if the value of the field should be tokenized as text prior to
-    indexing.  Un-tokenized fields are indexed as a single word and may not be
-    Reader-valued. */
-  boolean  isTokenized();
-
-  /** True if the term or terms used to index this field are stored as a term
-   *  vector, available from {@link org.apache.lucene.index.IndexReader#getTermFreqVector(int,String)}.
-   *  These methods do not provide access to the original content of the field,
-   *  only to terms used to index it. If the original content must be
-   *  preserved, use the <code>stored</code> attribute instead.
-   *
-   * @see org.apache.lucene.index.IndexReader#getTermFreqVector(int, String)
-   */
-  boolean isTermVectorStored();
-
-  /**
-   * True if terms are stored as term vector together with their offsets 
-   * (start and end positon in source text).
-   */
-  boolean isStoreOffsetWithTermVector();
-
-  /**
-   * True if terms are stored as term vector together with their token positions.
-   */
-  boolean isStorePositionWithTermVector();
-
-  /** True if the value of the field is stored as binary */
-  boolean  isBinary();
-
-  /** True if norms are omitted for this indexed field */
-  boolean getOmitNorms();
-
-  /** Expert:
-   *
-   * If set, omit normalization factors associated with this indexed field.
-   * This effectively disables indexing boosts and length normalization for this field.
-   */
-  void setOmitNorms(boolean omitNorms);
-
-  /**
-   * Indicates whether a Field is Lazy or not.  The semantics of Lazy loading are such that if a Field is lazily loaded, retrieving
-   * it's values via {@link #stringValue()} or {@link #getBinaryValue()} is only valid as long as the {@link org.apache.lucene.index.IndexReader} that
-   * retrieved the {@link Document} is still open.
-   *  
-   * @return true if this field can be loaded lazily
-   */
-  boolean isLazy();
-  
-  /**
-   * Returns offset into byte[] segment that is used as value, if Field is not binary
-   * returned value is undefined
-   * @return index of the first character in byte[] segment that represents this Field value
-   */
-  abstract int getBinaryOffset();
-  
-  /**
-   * Returns length of byte[] segment that is used as value, if Field is not binary
-   * returned value is undefined
-   * @return length of byte[] segment that represents this Field value
-   */
-  abstract int getBinaryLength();
-
-  /**
-   * Return the raw byte[] for the binary field.  Note that
-   * you must also call {@link #getBinaryLength} and {@link
-   * #getBinaryOffset} to know which range of bytes in this
-   * returned array belong to the field.
-   * @return reference to the Field value as byte[].
-   */
-  abstract byte[] getBinaryValue();
-
-  /**
-   * Return the raw byte[] for the binary field.  Note that
-   * you must also call {@link #getBinaryLength} and {@link
-   * #getBinaryOffset} to know which range of bytes in this
-   * returned array belong to the field.<p>
-   * About reuse: if you pass in the result byte[] and it is
-   * used, likely the underlying implementation will hold
-   * onto this byte[] and return it in future calls to
-   * {@link #getBinaryValue()}.
-   * So if you subsequently re-use the same byte[] elsewhere
-   * it will alter this Fieldable's value.
-   * @param result  User defined buffer that will be used if
-   *  possible.  If this is null or not large enough, a new
-   *  buffer is allocated
-   * @return reference to the Field value as byte[].
-   */
-  abstract byte[] getBinaryValue(byte[] result);
-  
-  /** @see #setIndexOptions */
-  IndexOptions getIndexOptions();
-  
-  /** Expert:
-  *
-  * If set, omit term freq, and optionally positions and payloads from
-  * postings for this field.
-  *
-  * <p><b>NOTE</b>: While this option reduces storage space
-  * required in the index, it also means any query
-  * requiring positional information, such as {@link
-  * PhraseQuery} or {@link SpanQuery} subclasses will
-  * fail with an exception.
-  */
-  void setIndexOptions(IndexOptions indexOptions);
-  
-  /**
-   * Returns the {@link PerDocFieldValues}
-   */
-  public PerDocFieldValues getDocValues();
-
-  /**
-   * Sets the {@link PerDocFieldValues} for this field. If
-   * {@link PerDocFieldValues} is set this field will store per-document values
-   * 
-   * @see IndexDocValues
-   */
-  public void setDocValues(PerDocFieldValues docValues);
-
-  /**
-   * Returns <code>true</code> iff {@link PerDocFieldValues} are set on this
-   * field.
-   */
-  public boolean hasDocValues();
-
-  /**
-   * Returns the {@link ValueType} of the set {@link PerDocFieldValues} or
-   * <code>null</code> if not set.
-   */
-  public ValueType docValuesType();
-}
Index: lucene/src/java/org/apache/lucene/document/IndexDocValuesField.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/IndexDocValuesField.java	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/document/IndexDocValuesField.java	(working copy)
@@ -26,7 +26,7 @@
 
 /**
  * <p>
- * This class provides a {@link AbstractField} that enables storing of typed
+ * This class provides a {@link Field} that enables storing of typed
  * per-document values for scoring, sorting or value retrieval. Here's an
  * example usage, adding an int value:
  * 
@@ -51,9 +51,9 @@
  * </pre>
  * 
  * <p>
- * If doc values are stored in addition to an indexed ({@link Index}) or stored
- * ({@link Store}) value it's recommended to use the {@link IndexDocValuesField}'s
- * {@link #set(AbstractField)} API:
+ * If doc values are stored in addition to an indexed ({@link FieldType#setIndexed(boolean)}) or stored
+ * ({@link FieldType#setStored(boolean)}) value it's recommended to use the {@link IndexDocValuesField}'s
+ * {@link #set(Field)} API:
  * 
  * <pre>
  *  IndexDocValuesField field = new IndexDocValuesField(name);
@@ -322,7 +322,7 @@
   }
 
   /**
-   * Sets this {@link IndexDocValuesField} to the given {@link AbstractField} and
+   * Sets this {@link IndexDocValuesField} to the given {@link Field} and
    * returns the given field. Any modifications to this instance will be visible
    * to the given field.
    */
Index: lucene/src/java/org/apache/lucene/document/NumericField.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/NumericField.java	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/document/NumericField.java	(working copy)
@@ -76,7 +76,7 @@
  *
  * <p>By default, a <code>NumericField</code>'s value is not stored but
  * is indexed for range filtering and sorting.  You can use
- * the {@link #NumericField(String,Field.Store,boolean)}
+ * the {@link #NumericField(String, FieldType)}
  * constructor if you need to change these defaults.</p>
  *
  * <p>You may add the same field name as a <code>NumericField</code> to
@@ -104,7 +104,7 @@
  * default value, 4, was selected for a reasonable tradeoff
  * of disk space consumption versus performance.  You can
  * use the expert constructor {@link
- * #NumericField(String,int,Field.Store,boolean)} if you'd
+ * #NumericField(String,int,FieldType)} if you'd
  * like to change the value.  Note that you must also
  * specify a congruent value when creating {@link
  * NumericRangeQuery} or {@link NumericRangeFilter}.
Index: lucene/src/java/org/apache/lucene/document/package.html
===================================================================
--- lucene/src/java/org/apache/lucene/document/package.html	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/document/package.html	(working copy)
@@ -22,16 +22,16 @@
 <body>
 <p>The logical representation of a {@link org.apache.lucene.document.Document} for indexing and searching.</p>
 <p>The document package provides the user level logical representation of content to be indexed and searched.  The
-package also provides utilities for working with {@link org.apache.lucene.document.Document}s and {@link org.apache.lucene.document.Fieldable}s.</p>
-<h2>Document and Fieldable</h2>
-<p>A {@link org.apache.lucene.document.Document} is a collection of {@link org.apache.lucene.document.Fieldable}s.  A
-  {@link org.apache.lucene.document.Fieldable} is a logical representation of a user's content that needs to be indexed or stored.
-  {@link org.apache.lucene.document.Fieldable}s have a number of properties that tell Lucene how to treat the content (like indexed, tokenized,
-  stored, etc.)  See the {@link org.apache.lucene.document.Field} implementation of {@link org.apache.lucene.document.Fieldable}
+package also provides utilities for working with {@link org.apache.lucene.document.Document}s and {@link org.apache.lucene.index.IndexableField}s.</p>
+<h2>Document and IndexableField</h2>
+<p>A {@link org.apache.lucene.document.Document} is a collection of {@link org.apache.lucene.index.IndexableField}s.  A
+  {@link org.apache.lucene.index.IndexableField} is a logical representation of a user's content that needs to be indexed or stored.
+  {@link org.apache.lucene.index.IndexableField}s have a number of properties that tell Lucene how to treat the content (like indexed, tokenized,
+  stored, etc.)  See the {@link org.apache.lucene.document.Field} implementation of {@link org.apache.lucene.index.IndexableField}
   for specifics on these properties.
 </p>
 <p>Note: it is common to refer to {@link org.apache.lucene.document.Document}s having {@link org.apache.lucene.document.Field}s, even though technically they have
-{@link org.apache.lucene.document.Fieldable}s.</p>
+{@link org.apache.lucene.index.IndexableField}s.</p>
 <h2>Working with Documents</h2>
 <p>First and foremost, a {@link org.apache.lucene.document.Document} is something created by the user application.  It is your job
   to create Documents based on the content of the files you are working with in your application (Word, txt, PDF, Excel or any other format.)
@@ -45,7 +45,7 @@
 to simplify indexing of numeric values (and also dates) for fast range range queries with {@link org.apache.lucene.search.NumericRangeQuery}
 (using a special sortable string representation of numeric values).</p>
 <p>The {@link org.apache.lucene.document.FieldSelector} class provides a mechanism to tell Lucene how to load Documents from
-storage.  If no FieldSelector is used, all Fieldables on a Document will be loaded.  As an example of the FieldSelector usage, consider
+storage.  If no FieldSelector is used, all IndexableFields on a Document will be loaded.  As an example of the FieldSelector usage, consider
   the common use case of
 displaying search results on a web page and then having users click through to see the full document.  In this scenario, it is often
   the case that there are many small fields and one or two large fields (containing the contents of the original file). Before the FieldSelector,
Index: lucene/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java	(working copy)
@@ -22,7 +22,6 @@
 import java.util.Map;
 
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.index.codecs.FieldsConsumer;
 import org.apache.lucene.index.codecs.PostingsConsumer;
Index: lucene/src/java/org/apache/lucene/index/ParallelReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/ParallelReader.java	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/index/ParallelReader.java	(working copy)
@@ -18,7 +18,6 @@
  */
 
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.codecs.PerDocValues;
 import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.util.Bits;
Index: lucene/src/java/org/apache/lucene/index/StoredFieldsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/StoredFieldsWriter.java	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/index/StoredFieldsWriter.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.RamUsageEstimator;
Index: lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java	(working copy)
@@ -19,14 +19,14 @@
 import java.util.Comparator;
 
 import org.apache.lucene.document.IndexDocValuesField;
-import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField; // for javadoc
 import org.apache.lucene.index.codecs.DocValuesConsumer;
 import org.apache.lucene.util.BytesRef;
 
 /**
  * Per document and field values consumed by {@link DocValuesConsumer}. 
  * @see IndexDocValuesField
- * @see Fieldable#setDocValues(PerDocFieldValues)
+ * @see IndexableField#setDocValues(PerDocFieldValues)
  * 
  * @lucene.experimental
  */
Index: lucene/src/java/org/apache/lucene/search/TFIDFSimilarity.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/TFIDFSimilarity.java	(revision 1159870)
+++ lucene/src/java/org/apache/lucene/search/TFIDFSimilarity.java	(working copy)
@@ -454,12 +454,8 @@
  *      <b><i>norm(t,d)</i></b> encapsulates a few (indexing time) boost and length factors:
  *
  *      <ul>
- *        <li><b>Document boost</b> - set by calling
- *        {@link org.apache.lucene.document.Document#setBoost(float) doc.setBoost()}
- *        before adding the document to the index.
- *        </li>
  *        <li><b>Field boost</b> - set by calling
- *        {@link org.apache.lucene.document.Fieldable#setBoost(float) field.setBoost()}
+ *        {@link org.apache.lucene.document.Field#setBoost(float) field.setBoost()}
  *        before adding the field to a document.
  *        </li>
  *        <li><b>lengthNorm</b> - computed
@@ -480,8 +476,6 @@
  *        <tr>
  *          <td valign="middle" align="right" rowspan="1">
  *            norm(t,d) &nbsp; = &nbsp;
- *            {@link org.apache.lucene.document.Document#getBoost() doc.getBoost()}
- *            &nbsp;&middot;&nbsp;
  *            lengthNorm
  *            &nbsp;&middot;&nbsp;
  *          </td>
@@ -489,7 +483,7 @@
  *            <big><big><big>&prod;</big></big></big>
  *          </td>
  *          <td valign="middle" align="right" rowspan="1">
- *            {@link org.apache.lucene.document.Fieldable#getBoost() f.getBoost}()
+ *            {@link org.apache.lucene.index.IndexableField#boost() f.boost}()
  *          </td>
  *        </tr>
  *        <tr valigh="top">
Index: lucene/src/test-framework/org/apache/lucene/util/_TestUtil.java
===================================================================
--- lucene/src/test-framework/org/apache/lucene/util/_TestUtil.java	(revision 1159870)
+++ lucene/src/test-framework/org/apache/lucene/util/_TestUtil.java	(working copy)
@@ -36,7 +36,6 @@
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.CheckIndex;
 import org.apache.lucene.index.ConcurrentMergeScheduler;
 import org.apache.lucene.index.FieldInfos;
Index: modules/queries/src/test/org/apache/lucene/queries/function/FunctionTestSetup.java
===================================================================
--- modules/queries/src/test/org/apache/lucene/queries/function/FunctionTestSetup.java	(revision 1159870)
+++ modules/queries/src/test/org/apache/lucene/queries/function/FunctionTestSetup.java	(working copy)
@@ -4,7 +4,6 @@
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.RandomIndexWriter;
Index: solr/core/src/java/org/apache/solr/schema/DoubleField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/DoubleField.java	(revision 1159870)
+++ solr/core/src/java/org/apache/solr/schema/DoubleField.java	(working copy)
@@ -17,7 +17,6 @@
 
 package org.apache.solr.schema;
 
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.DoubleFieldSource;
 import org.apache.lucene.index.IndexableField;
Index: solr/core/src/java/org/apache/solr/schema/FieldType.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/FieldType.java	(revision 1159870)
+++ solr/core/src/java/org/apache/solr/schema/FieldType.java	(working copy)
@@ -268,8 +268,6 @@
    * Fields per SchemaField
    * @param name The name of the field
    * @param val The _internal_ value to index
-   * @param omitNorms true if norms should be omitted
-   * @param options options for what should be indexed in the postings
    * @param type {@link org.apache.lucene.document.FieldType}
    * @param boost The boost value
    * @return the {@link org.apache.lucene.index.IndexableField}.
Index: solr/core/src/java/org/apache/solr/schema/SortableDoubleField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/SortableDoubleField.java	(revision 1159870)
+++ solr/core/src/java/org/apache/solr/schema/SortableDoubleField.java	(working copy)
@@ -27,7 +27,6 @@
 import org.apache.lucene.util.mutable.MutableValue;
 import org.apache.lucene.util.mutable.MutableValueDouble;
 import org.apache.solr.search.QParser;
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.IndexableField;
 import org.apache.solr.util.NumberUtils;
Index: solr/core/src/java/org/apache/solr/search/Grouping.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/Grouping.java	(revision 1159870)
+++ solr/core/src/java/org/apache/solr/search/Grouping.java	(working copy)
@@ -19,7 +19,6 @@
 
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.queries.function.DocValues;
