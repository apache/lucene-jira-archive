Index: contrib/regex/src/test/org/apache/lucene/search/regex/TestSpanRegexQuery.java
===================================================================
--- contrib/regex/src/test/org/apache/lucene/search/regex/TestSpanRegexQuery.java	(revision 784881)
+++ contrib/regex/src/test/org/apache/lucene/search/regex/TestSpanRegexQuery.java	(working copy)
@@ -17,32 +17,46 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+
 import junit.framework.TestCase;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
+
 import org.apache.lucene.analysis.SimpleAnalyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MultiSearcher;
+import org.apache.lucene.search.spans.SpanFirstQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanFirstQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.LockObtainFailedException;
+import org.apache.lucene.store.RAMDirectory;
 
 public class TestSpanRegexQuery extends TestCase {
+  Directory indexStoreA = new RAMDirectory();
+
+  Directory indexStoreB = new RAMDirectory();
+
   public void testSpanRegex() throws Exception {
     RAMDirectory directory = new RAMDirectory();
     IndexWriter writer = new IndexWriter(directory, new SimpleAnalyzer(), true);
     Document doc = new Document();
-//    doc.add(new Field("field", "the quick brown fox jumps over the lazy dog", Field.Store.NO, Field.Index.ANALYZED));
-//    writer.addDocument(doc);
-//    doc = new Document();
-    doc.add(new Field("field", "auto update", Field.Store.NO, Field.Index.ANALYZED));
+    // doc.add(new Field("field", "the quick brown fox jumps over the lazy dog",
+    // Field.Store.NO, Field.Index.ANALYZED));
+    // writer.addDocument(doc);
+    // doc = new Document();
+    doc.add(new Field("field", "auto update", Field.Store.NO,
+        Field.Index.ANALYZED));
     writer.addDocument(doc);
     doc = new Document();
-    doc.add(new Field("field", "first auto update", Field.Store.NO, Field.Index.ANALYZED));
+    doc.add(new Field("field", "first auto update", Field.Store.NO,
+        Field.Index.ANALYZED));
     writer.addDocument(doc);
     writer.optimize();
     writer.close();
@@ -50,8 +64,63 @@
     IndexSearcher searcher = new IndexSearcher(directory);
     SpanRegexQuery srq = new SpanRegexQuery(new Term("field", "aut.*"));
     SpanFirstQuery sfq = new SpanFirstQuery(srq, 1);
-//    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {srq, stq}, 6, true);
+    // SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {srq, stq}, 6,
+    // true);
     Hits hits = searcher.search(sfq);
     assertEquals(1, hits.length());
   }
+
+  public void testSpanRegexBug() throws CorruptIndexException, IOException {
+    createRAMDirectories();
+
+    SpanRegexQuery srq = new SpanRegexQuery(new Term("field", "a.*"));
+    SpanRegexQuery stq = new SpanRegexQuery(new Term("field", "b.*"));
+    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] { srq, stq }, 6,
+        true);
+
+    // 1. Search the same store which works
+    IndexSearcher[] arrSearcher = new IndexSearcher[2];
+    arrSearcher[0] = new IndexSearcher(indexStoreA);
+    arrSearcher[1] = new IndexSearcher(indexStoreB);
+    MultiSearcher searcher = new MultiSearcher(arrSearcher);
+    Hits hits = searcher.search(query);
+    arrSearcher[0].close();
+    arrSearcher[1].close();
+
+    // Will fail here
+    // We expect 2 but only one matched
+    // The rewriter function only write it once on the first IndexSearcher
+    // So it's using term: a1 b1 to search on the second IndexSearcher
+    // As a result, it won't match the document in the second IndexSearcher
+    assertEquals(2, hits.length());
+    indexStoreA.close();
+    indexStoreB.close();
+  }
+
+  private void createRAMDirectories() throws CorruptIndexException,
+      LockObtainFailedException, IOException {
+    // creating a document to store
+    Document lDoc = new Document();
+    lDoc.add(new Field("field", "a1 b1", Field.Store.NO,
+        Field.Index.ANALYZED_NO_NORMS));
+
+    // creating a document to store
+    Document lDoc2 = new Document();
+    lDoc2.add(new Field("field", "a2 b2", Field.Store.NO,
+        Field.Index.ANALYZED_NO_NORMS));
+
+    // creating first index writer
+    IndexWriter writerA = new IndexWriter(indexStoreA, new StandardAnalyzer(),
+        true, IndexWriter.MaxFieldLength.LIMITED);
+    writerA.addDocument(lDoc);
+    writerA.optimize();
+    writerA.close();
+
+    // creating second index writer
+    IndexWriter writerB = new IndexWriter(indexStoreB, new StandardAnalyzer(),
+        true, IndexWriter.MaxFieldLength.LIMITED);
+    writerB.addDocument(lDoc2);
+    writerB.optimize();
+    writerB.close();
+  }
 }
Index: src/java/org/apache/lucene/search/spans/SpanNearQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(revision 787851)
+++ src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(working copy)
@@ -151,6 +151,17 @@
       return this;                         // no clauses rewrote
     }
   }
+  
+  public Object clone() {
+    int sz = clauses.size();
+    SpanQuery[] newClauses = new SpanQuery[sz];
+
+    for (int i = 0; i < sz; i++) {
+      SpanQuery clause = (SpanQuery) clauses.get(i);
+      newClauses[i] = (SpanQuery) clause.clone();
+    }
+    return new SpanNearQuery(newClauses, slop, inOrder);
+  }
 
   /** Returns true iff <code>o</code> is equal to this. */
   public boolean equals(Object o) {
Index: src/java/org/apache/lucene/search/spans/SpanNotQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(revision 787851)
+++ src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(working copy)
@@ -27,7 +27,7 @@
 import java.util.Set;
 
 /** Removes matches which overlap with another SpanQuery. */
-public class SpanNotQuery extends SpanQuery {
+public class SpanNotQuery extends SpanQuery implements Cloneable {
   private SpanQuery include;
   private SpanQuery exclude;
 
@@ -68,6 +68,9 @@
     return buffer.toString();
   }
 
+  public Object clone() {
+    return  new SpanNotQuery((SpanQuery)include.clone(),(SpanQuery) exclude.clone());
+  }
 
   public Spans getSpans(final IndexReader reader) throws IOException {
     return new PayloadSpans() {
Index: src/java/org/apache/lucene/search/spans/SpanOrQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(revision 787851)
+++ src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(working copy)
@@ -31,7 +31,7 @@
 import org.apache.lucene.search.Query;
 
 /** Matches the union of its clauses.*/
-public class SpanOrQuery extends SpanQuery {
+public class SpanOrQuery extends SpanQuery implements Cloneable {
   private List clauses;
   private String field;
 
@@ -79,6 +79,18 @@
       clause.extractTerms(terms);
     }
   }
+  
+  public Object clone() {
+    int sz = clauses.size();
+    SpanQuery[] newClauses = new SpanQuery[sz];
+
+    for (int i = 0; i < sz; i++) {
+      SpanQuery clause = (SpanQuery) clauses.get(i);
+      newClauses[i] = (SpanQuery) clause.clone();
+    }
+    SpanOrQuery soq = new SpanOrQuery(newClauses);
+    return soq;
+  }
 
   public Query rewrite(IndexReader reader) throws IOException {
     SpanOrQuery clone = null;

