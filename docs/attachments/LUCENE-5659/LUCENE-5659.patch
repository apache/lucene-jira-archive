Index: lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java	(revision 1593505)
+++ lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.util.ArrayList;
+import java.util.BitSet;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.IdentityHashMap;
@@ -455,6 +456,14 @@
     if (a.isSingleton()) return true;
     return isFiniteSlow(a.initial, new HashSet<State>());
   }
+
+  /**
+   * Returns true if the language of this automaton is finite.
+   */
+  public static boolean isFiniteRecursive(Automaton a) {
+    if (a.isSingleton()) return true;
+    return isFiniteRecursive(a.initial, new BitSet(a.getNumberOfStates()), new BitSet(a.getNumberOfStates()));
+  }
   
   /**
    * Checks whether there is a loop containing s. (This is sufficient since
@@ -462,6 +471,21 @@
    */
   // TODO: not great that this is recursive... in theory a
   // large automata could exceed java's stack
+  private static boolean isFiniteRecursive(State s, BitSet path, BitSet visited) {
+    path.set(s.number);
+    for (Transition t : s.getTransitions())
+      if (path.get(t.to.number) || (!visited.get(t.to.number) && !isFiniteRecursive(t.to, path, visited))) return false;
+    path.clear(s.number);
+    visited.set(s.number);
+    return true;
+  }
+  
+  /**
+   * Checks whether there is a loop containing s. (This is sufficient since
+   * there are never transitions to dead states.)
+   */
+  // TODO: not great that this is recursive... in theory a
+  // large automata could exceed java's stack
   private static boolean isFiniteSlow(State s, HashSet<State> path) {
     path.add(s);
     for (Transition t : s.getTransitions())
Index: lucene/core/src/test/org/apache/lucene/util/automaton/TestSpecialOperations.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/automaton/TestSpecialOperations.java	(revision 1593505)
+++ lucene/core/src/test/org/apache/lucene/util/automaton/TestSpecialOperations.java	(working copy)
@@ -33,12 +33,15 @@
   /**
    * tests against the original brics implementation.
    */
-  public void testIsFinite() {
+  public void testIsFiniteBasic() {
     int num = atLeast(200);
     for (int i = 0; i < num; i++) {
       Automaton a = AutomatonTestUtil.randomAutomaton(random());
       Automaton b = a.clone();
+      Automaton a2 = a.clone();
+      Automaton b2 = a2.clone();
       assertEquals(AutomatonTestUtil.isFiniteSlow(a), SpecialOperations.isFinite(b));
+      assertEquals(AutomatonTestUtil.isFiniteRecursive(a2), SpecialOperations.isFinite(b2));
     }
   }
 
@@ -51,6 +54,16 @@
     }
     return result;
   }
+
+  /** Pass false for testOthers if the automaton may be too large */
+  private boolean isFinite(Automaton a, boolean testOthers) {
+    boolean result = SpecialOperations.isFinite(a);
+    if (testOthers) {
+      assertEquals(AutomatonTestUtil.isFiniteSlow(a), result);
+      assertEquals(AutomatonTestUtil.isFiniteRecursive(a), result);
+    }
+    return result;
+  }
   
   /**
    * Basic test for getFiniteStrings
@@ -84,6 +97,16 @@
     assertTrue(strings.contains(scratch));
   }
 
+  public void testIsFiniteEatsStack() {
+    char[] chars = new char[50000];
+    TestUtil.randomFixedLengthUnicodeString(random(), chars, 0, chars.length);
+    String bigString1 = new String(chars);
+    TestUtil.randomFixedLengthUnicodeString(random(), chars, 0, chars.length);
+    String bigString2 = new String(chars);
+    Automaton a = BasicOperations.union(BasicAutomata.makeString(bigString1), BasicAutomata.makeString(bigString2));
+    assertTrue(isFinite(a, false));
+  }
+
   public void testRandomFiniteStrings1() {
 
     int numStrings = atLeast(100);
@@ -177,9 +200,9 @@
         SpecialOperations.getFiniteStrings(a, TestUtil.nextInt(random(), 1, 1000));
         // NOTE: cannot do this, because the method is not
         // guaranteed to detect cycles when you have a limit
-        //assertTrue(SpecialOperations.isFinite(a));
+        //assertTrue(isFinite(a, true));
       } catch (IllegalArgumentException iae) {
-        assertFalse(SpecialOperations.isFinite(a));
+        assertFalse(isFinite(a, true));
       }
     }
   }
Index: lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations.java	(revision 1593505)
+++ lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations.java	(working copy)
@@ -68,29 +68,6 @@
   }
   
   /**
-   * Returns true if the language of this automaton is finite.
-   */
-  public static boolean isFinite(Automaton a) {
-    if (a.isSingleton()) return true;
-    return isFinite(a.initial, new BitSet(a.getNumberOfStates()), new BitSet(a.getNumberOfStates()));
-  }
-  
-  /**
-   * Checks whether there is a loop containing s. (This is sufficient since
-   * there are never transitions to dead states.)
-   */
-  // TODO: not great that this is recursive... in theory a
-  // large automata could exceed java's stack
-  private static boolean isFinite(State s, BitSet path, BitSet visited) {
-    path.set(s.number);
-    for (Transition t : s.getTransitions())
-      if (path.get(t.to.number) || (!visited.get(t.to.number) && !isFinite(t.to, path, visited))) return false;
-    path.clear(s.number);
-    visited.set(s.number);
-    return true;
-  }
-  
-  /**
    * Returns the longest string that is a prefix of all accepted strings and
    * visits each state at most once.
    * 
@@ -260,6 +237,14 @@
       }
       return label++;
     }
+
+    /** Returns next transition leaving this state. */
+    public Transition nextTransition() {
+      if (transition >= state.numTransitions()) {
+        return null;
+      }
+      return state.transitionsArray[transition++];
+    }
   }
 
   private static PathNode getNode(PathNode[] nodes, int index) {
@@ -371,4 +356,69 @@
 
     return results;
   }
+
+  /**
+   * Returns true if the language of this automaton is finite.
+   */
+  public static boolean isFinite(Automaton a) {
+    if (a.isSingleton()) {
+      // Easy case: automaton accepts only 1 string, so it is finite.
+      return true;
+    } else if (a.initial.numTransitions() > 0) {
+
+      BitSet visited = new BitSet(a.getNumberOfStates());
+      BitSet path = new BitSet(a.getNumberOfStates());
+
+      // Stack to hold our current state in the
+      // recursion/iteration:
+      PathNode[] nodes = new PathNode[4];
+
+      path.set(a.initial.number);
+      PathNode root = getNode(nodes, 0);
+      root.resetState(a.initial);
+
+      int length = 1;
+
+      while (length > 0) {
+
+        PathNode node = nodes[length-1];
+
+        // Get next transition leaving the current node:
+        Transition t = node.nextTransition();
+
+        if (t != null) {
+          if (path.get(t.to.number)) {
+            // Our current path cycled back on itself, so we have a cycle and we are not finite:
+            return false;
+          }
+
+          if (visited.get(t.to.number) == false && t.to.numTransitions() != 0) {
+            // We haven't yet visited this dest; so now we recurse:
+
+            // Add node to our current path:
+            path.set(t.to.number);
+
+            // Push node onto stack:
+            if (nodes.length == length) {
+              PathNode[] newNodes = new PathNode[ArrayUtil.oversize(nodes.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
+              System.arraycopy(nodes, 0, newNodes, 0, nodes.length);
+              nodes = newNodes;
+            }
+            getNode(nodes, length).resetState(t.to);
+            length++;
+          }
+        } else {
+          // No more transitions leaving this state,
+          // pop/return back to previous state:
+          assert path.get(node.state.number);
+          visited.set(node.state.number);
+          path.clear(node.state.number);
+          length--;
+        }
+      }
+    }
+
+    // No cycles found, so we are finite:
+    return true;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java	(revision 1593505)
+++ lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java	(working copy)
@@ -598,8 +598,8 @@
     State[] states = getNumberedStates();
     for (State s : states) {
       b.append("  ").append(s.number);
-      if (s.accept) b.append(" [shape=doublecircle,label=\"\"];\n");
-      else b.append(" [shape=circle,label=\"\"];\n");
+      if (s.accept) b.append(" [shape=doublecircle,label=\"" + s.number + "\"];\n");
+      else b.append(" [shape=circle,label=\" " + s.number + "\"];\n");
       if (s == initial) {
         b.append("  initial [shape=plaintext,label=\"\"];\n");
         b.append("  initial -> ").append(s.number).append("\n");
