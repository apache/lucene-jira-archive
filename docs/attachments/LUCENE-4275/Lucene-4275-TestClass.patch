Index: lucene/test-framework/src/java/org/apache/lucene/codecs/dummy/TestNonCoreDummyPostingsFormat.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/codecs/dummy/TestNonCoreDummyPostingsFormat.java	(revision 0)
+++ lucene/test-framework/src/java/org/apache/lucene/codecs/dummy/TestNonCoreDummyPostingsFormat.java	(working copy)
@@ -0,0 +1,146 @@
+package org.apache.lucene.codecs.dummy;
+
+import java.io.IOException;
+
+import org.apache.lucene.codecs.FieldsConsumer;
+import org.apache.lucene.codecs.FieldsProducer;
+import org.apache.lucene.codecs.PostingsFormat;
+import org.apache.lucene.codecs.TermsConsumer;
+import org.apache.lucene.codecs.lucene40.Lucene40PostingsFormat;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentReadState;
+import org.apache.lucene.index.SegmentWriteState;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.IOUtils;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This class is designed to illustrate an issue with the test framework for custom PostingFormats.
+ * It is a simplification of the behaviour in the PostingsFormat introduced in Lucene-4069 that writes
+ * a supplementary new file alongside the usual postings files.
+ * When running the test framework, roughly one in four runs with this PF will fail to read back the file that written.
+ * 
+ *    > Caused by: java.lang.IllegalStateException: Missing file:_f_TestNonCoreDummyPostingsFormat_0.foobar
+ *    >  at org.apache.lucene.codecs.dummy.TestNonCoreDummyPostingsFormat.fieldsProducer(TestNonCoreDummyPostingsFormat.java:70)
+ *    >  at org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsReader.<init>(PerFieldPostingsFormat.java:186)
+ * 
+ * The suspected cause of this is MockDirectoryWrapper deleting files in a non-threadsafe fashion.
+ * 
+ * My test env is WinXP 64Bit JDK 1.6.0_24
+ * The test is invoked via: 
+ *    ant test-core  -Dtestcase=TestIndexWriterCommit -Dtests.method=testCommitThreadSafety -Dtests.seed=EA320250471B75AE -Dtests.slow=true -Dtests.postingsformat=TestNonCoreDummyPostingsFormat -Dtests.locale=no -Dtests.timezone=Europe/Belfast -Dtests.file.encoding=UTF-8
+ * 
+ */
+public class TestNonCoreDummyPostingsFormat extends PostingsFormat
+{
+  public static final String FILE_IS_VALID_STRING = "file Is Valid";
+  //Taking longer to write the supplementary file seems to increase the probability of a failure
+  public static final int numCopiesOfStringStored=1000;
+  static final String MY_FILE_EXTENSION = "foobar";
+
+  private PostingsFormat delegate=new Lucene40PostingsFormat();
+
+  
+  public TestNonCoreDummyPostingsFormat() {
+    super("TestNonCoreDummyPostingsFormat");
+  }  
+
+  @Override
+  public FieldsConsumer fieldsConsumer(SegmentWriteState state)
+      throws IOException {
+    return new TestNonCoreDummyPostingsFieldConsumer(state,delegate.fieldsConsumer(state));
+  }
+
+  @Override
+  public FieldsProducer fieldsProducer(SegmentReadState readState)
+      throws IOException {
+    
+    String myFileName = IndexFileNames.segmentFileName(
+        readState.segmentInfo.name, readState.segmentSuffix, MY_FILE_EXTENSION);
+    
+    //check supplementary file still exists
+    //TODO - notice inconsistency between SegmentReadState and SegmentWriteState in how they refer 
+    // to "dir" and "directory" respectively.
+    if (!readState.dir.fileExists(myFileName)) {
+      throw new IllegalStateException("Missing file:" + myFileName);
+    }    
+    
+    //check dummy content in file is valid
+    IndexInput fileInput = null;
+    try {
+      fileInput = readState.dir.openInput(myFileName, readState.context);
+      for(int i=0;i<numCopiesOfStringStored;i++)
+      {
+        String s=fileInput.readString();
+        if(!FILE_IS_VALID_STRING.equals(s))
+        {
+          throw new IllegalStateException("File not saved properly:"+s);
+        }
+      }
+      
+    } finally {
+      IOUtils.close(fileInput);
+    }      
+    
+    return delegate.fieldsProducer(readState);
+  }
+  
+  static class TestNonCoreDummyPostingsFieldConsumer extends FieldsConsumer
+  {
+
+    private FieldsConsumer delegateConsumer;
+    private SegmentWriteState writeState;
+
+    public TestNonCoreDummyPostingsFieldConsumer(SegmentWriteState state,FieldsConsumer fieldsConsumer) {
+      this.delegateConsumer=fieldsConsumer;
+      this.writeState=state;
+    }
+
+    @Override
+    public TermsConsumer addField(FieldInfo field) throws IOException {
+      return delegateConsumer.addField(field);
+    }
+
+    @Override
+    public void close() throws IOException {
+      
+        delegateConsumer.close();
+        String myFileName = IndexFileNames.segmentFileName(
+            writeState.segmentInfo.name, writeState.segmentSuffix, MY_FILE_EXTENSION);
+
+        //Write dummy content to a custom file
+        IndexOutput fileOutput = null;
+        try {
+          //TODO - notice inconsistency between SegmentReadState and SegmentWriteState in how they refer 
+          // to "dir" and "directory" respectively.
+          fileOutput = writeState.directory
+              .createOutput(myFileName, writeState.context);
+          for(int i=0;i<numCopiesOfStringStored;i++)
+          {
+            fileOutput.writeString(FILE_IS_VALID_STRING);
+          }
+          
+        } finally {
+          IOUtils.close(fileOutput);
+        }
+    }
+  }
+}
Index: lucene/test-framework/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat
===================================================================
--- lucene/test-framework/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat	(revision 1367462)
+++ lucene/test-framework/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat	(working copy)
@@ -21,4 +21,6 @@
 org.apache.lucene.codecs.ramonly.RAMOnlyPostingsFormat
 org.apache.lucene.codecs.lucene40ords.Lucene40WithOrds
 org.apache.lucene.codecs.asserting.AssertingPostingsFormat
+org.apache.lucene.codecs.dummy.TestNonCoreDummyPostingsFormat
 
+
