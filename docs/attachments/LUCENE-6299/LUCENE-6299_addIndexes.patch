Index: lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/IndexWriter.java	(revision 1662323)
+++ lucene/core/src/java/org/apache/lucene/index/IndexWriter.java	(working copy)
@@ -2317,6 +2317,8 @@
    * @throws IOException if there is a low-level IO error
    * @throws LockObtainFailedException if we were unable to
    *   acquire the write lock in at least one directory
+   * @throws IllegalStateException if addIndexes would cause
+   *   the index to exceed {@link #MAX_DOCS}
    */
   public void addIndexes(Directory... dirs) throws IOException {
     ensureOpen();
@@ -2335,9 +2337,10 @@
       flush(false, true);
 
       List<SegmentCommitInfo> infos = new ArrayList<>();
-      int totalDocCount = 0;
+      long totalDocCount = 0;
       boolean success = false;
       try {
+        List<SegmentInfos> commits = new ArrayList<>(dirs.length);
         for (Directory dir : dirs) {
           if (infoStream.isEnabled("IW")) {
             infoStream.message("IW", "addIndexes: process directory " + dir);
@@ -2344,7 +2347,16 @@
           }
           SegmentInfos sis = SegmentInfos.readLatestCommit(dir); // read infos from dir
           totalDocCount += sis.totalDocCount();
+          commits.add(sis);
+        }
+        
+        // prevent any overflows, and best-effort check before we actually start copying.
+        if (pendingNumDocs.get() + totalDocCount > actualMaxDocs) {
+          // TODO: more of an invalid argument whenever we hit this condition?
+          throw new IllegalStateException("number of documents in the index cannot exceed " + actualMaxDocs);
+        }
 
+        for (SegmentInfos sis : commits) {
           for (SegmentCommitInfo info : sis) {
             assert !infos.contains(info): "dup info dir=" + info.info.dir + " name=" + info.info.name;
 
@@ -2383,7 +2395,7 @@
           ensureOpen();
           // Make sure adding the new documents to this index won't
           // exceed the limit:
-          reserveDocs(totalDocCount);
+          reserveDocs(Math.toIntExact(totalDocCount));
           success = true;
         } finally {
           if (!success) {
Index: lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMaxDocs.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMaxDocs.java	(revision 1662323)
+++ lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMaxDocs.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 
@@ -28,6 +29,9 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.FilterDirectory;
+import org.apache.lucene.store.MockDirectoryWrapper;
+import org.apache.lucene.store.NoLockFactory;
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
@@ -369,7 +373,54 @@
     dir.close();
     dir2.close();
   }
+  
+  /** 
+   * Test if addindexes(Dir) prevents exceeding max docs.
+   */
+  public void testAddTooManyIndexesDir() throws Exception {
+    // we cheat and add the same one over again... IW wants a write lock on each
+    Directory dir = newDirectory(random(), NoLockFactory.INSTANCE);
+    Document doc = new Document();
+    IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(null));
+    for (int i = 0; i < 100000; i++) {
+      w.addDocument(doc);
+    }
+    w.forceMerge(1);
+    w.commit();
+    w.close();
+    
+    // wrap this with disk full, so test fails faster and doesn't fill up real disks.
+    MockDirectoryWrapper dir2 = newMockDirectory();
+    w = new IndexWriter(dir2, new IndexWriterConfig(null));
+    w.commit(); // don't confuse checkindex
+    dir2.setMaxSizeInBytes(dir2.sizeInBytes() + 65536); // 64KB
+    Directory dirs[] = new Directory[1 + (IndexWriter.MAX_DOCS / 100000)];
+    for (int i = 0; i < dirs.length; i++) {
+      // bypass iw check for duplicate dirs
+      dirs[i] = new FilterDirectory(dir) {};
+    }
 
+    try {
+      w.addIndexes(dirs);
+      fail("didn't get expected exception");
+    } catch (IllegalStateException expected) {
+      // pass
+    } catch (IOException fakeDiskFull) {
+      final Exception e;
+      if (fakeDiskFull.getMessage() != null && fakeDiskFull.getMessage().startsWith("fake disk full")) {
+        e = new RuntimeException("test failed: IW checks aren't working and we are executing addIndexes");
+        e.addSuppressed(fakeDiskFull);
+      } else {
+        e = fakeDiskFull;
+      }
+      throw e;
+    }
+    
+    w.close();
+    dir.close();
+    dir2.close();
+  }
+
   public void testTooLargeMaxDocs() throws Exception {
     try {
       IndexWriter.setMaxDocs(Integer.MAX_VALUE);
Index: lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryWrapper.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryWrapper.java	(revision 1662323)
+++ lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryWrapper.java	(working copy)
@@ -28,13 +28,13 @@
 // do NOT make any methods in this class synchronized, volatile
 // do NOT import anything from the concurrency package.
 // no randoms, no nothing.
-public class BaseDirectoryWrapper extends FilterDirectory {
+public abstract class BaseDirectoryWrapper extends FilterDirectory {
   
   private boolean checkIndexOnClose = true;
   private boolean crossCheckTermVectorsOnClose = true;
   protected volatile boolean isOpen = true;
 
-  public BaseDirectoryWrapper(Directory delegate) {
+  protected BaseDirectoryWrapper(Directory delegate) {
     super(delegate);
   }
 
@@ -72,10 +72,4 @@
   public boolean getCrossCheckTermVectorsOnClose() {
     return crossCheckTermVectorsOnClose;
   }
-
-  // why does this class override this method?
-  @Override
-  public void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {
-    in.copyFrom(from, src, dest, context);
-  }
 }
Index: lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java	(revision 1662323)
+++ lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java	(working copy)
@@ -122,6 +122,10 @@
 
   public MockDirectoryWrapper(Random random, Directory delegate) {
     super(delegate);
+    if (delegate instanceof MockDirectoryWrapper) {
+      // TODO: wtf
+      throw new IllegalArgumentException("don't wrap mockdirectorywrapper in mockdirectorywrapper, it corrupts ramdir!!!!");
+    }
     // must make a private random since our methods are
     // called from different threads; else test failures may
     // not be reproducible from the original seed
@@ -1051,20 +1055,38 @@
     public boolean isLocked() throws IOException {
       return delegateLock.isLocked();
     }
+  }  
+  
+  /** Use this when throwing fake {@code IOException},
+   *  e.g. from {@link MockDirectoryWrapper.Failure}. */
+  public static class FakeIOException extends IOException {
   }
 
-  // TODO: why does this class override this method?
-  // we should use the default implementation so all of our checks work?
   @Override
-  public synchronized void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {
-    maybeYield();
-    // randomize the IOContext here?
-    in.copyFrom(from, src, dest, context);
+  public String toString() {
+    if (maxSize != 0) {
+      return "MockDirectoryWrapper(" + in + ", current=" + maxUsedSize + ",max=" + maxSize + ")";
+    } else {
+      return super.toString();
+    }
   }
+
+
+  // don't override optional methods like copyFrom: we need the default impl for things like disk 
+  // full checks. we randomly exercise "raw" directories anyway. We ensure default impls are used:
   
-  /** Use this when throwing fake {@code IOException},
-   *  e.g. from {@link MockDirectoryWrapper.Failure}. */
-  public static class FakeIOException extends IOException {
+  @Override
+  public final ChecksumIndexInput openChecksumInput(String name, IOContext context) throws IOException {
+    return super.openChecksumInput(name, context);
   }
 
+  @Override
+  public final void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {
+    super.copyFrom(from, src, dest, context);
+  }
+
+  @Override
+  protected final void ensureOpen() throws AlreadyClosedException {
+    super.ensureOpen();
+  }
 }
Index: lucene/test-framework/src/java/org/apache/lucene/store/RawDirectoryWrapper.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/store/RawDirectoryWrapper.java	(revision 0)
+++ lucene/test-framework/src/java/org/apache/lucene/store/RawDirectoryWrapper.java	(working copy)
@@ -0,0 +1,49 @@
+package org.apache.lucene.store;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+/**
+ * Delegates all operations, even optional ones, to the wrapped directory.
+ * <p>
+ * This class is used if you want the most realistic testing, but still
+ * with a checkindex on close. If you want asserts and evil things,
+ * use MockDirectoryWrapper instead.
+ */
+public final class RawDirectoryWrapper extends BaseDirectoryWrapper {
+
+  public RawDirectoryWrapper(Directory delegate) {
+    super(delegate);
+  }
+  
+  @Override
+  public void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {
+    in.copyFrom(from, src, dest, context);
+  }
+  
+  @Override
+  public ChecksumIndexInput openChecksumInput(String name, IOContext context) throws IOException {
+    return in.openChecksumInput(name, context);
+  }
+
+  @Override
+  protected void ensureOpen() throws AlreadyClosedException {
+    in.ensureOpen();
+  }
+}

Property changes on: lucene/test-framework/src/java/org/apache/lucene/store/RawDirectoryWrapper.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(revision 1662323)
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -82,6 +82,7 @@
 import com.carrotsearch.randomizedtesting.rules.NoInstanceHooksOverridesRule;
 import com.carrotsearch.randomizedtesting.rules.StaticFieldsInvariantRule;
 import com.carrotsearch.randomizedtesting.rules.SystemPropertiesInvariantRule;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Field;
@@ -110,6 +111,7 @@
 import org.apache.lucene.store.MockDirectoryWrapper;
 import org.apache.lucene.store.MockDirectoryWrapper.Throttling;
 import org.apache.lucene.store.NRTCachingDirectory;
+import org.apache.lucene.store.RawDirectoryWrapper;
 import org.apache.lucene.util.automaton.AutomatonTestUtil;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
 import org.apache.lucene.util.automaton.RegExp;
@@ -1317,7 +1319,7 @@
     }
 
     if (bare) {
-      BaseDirectoryWrapper base = new BaseDirectoryWrapper(directory);
+      BaseDirectoryWrapper base = new RawDirectoryWrapper(directory);
       closeAfterSuite(new CloseableDirectory(base, suiteFailureMarker));
       return base;
     } else {
