diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/Intervals.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/Intervals.java
index e8c4cb01aa..9fcf772c91 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/Intervals.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/Intervals.java
@@ -54,6 +54,9 @@ public final class Intervals {
    * Return an {@link IntervalsSource} exposing intervals for a phrase consisting of a list of terms
    */
   public static IntervalsSource phrase(String... terms) {
+    if (terms.length == 1) {
+      return Intervals.term(terms[0]);
+    }
     IntervalsSource[] sources = new IntervalsSource[terms.length];
     int i = 0;
     for (String term : terms) {
@@ -67,6 +70,9 @@ public final class Intervals {
    * Return an {@link IntervalsSource} exposing intervals for a phrase consisting of a list of IntervalsSources
    */
   public static IntervalsSource phrase(IntervalsSource... subSources) {
+    if (subSources.length == 1) {
+      return subSources[0];
+    }
     return new ConjunctionIntervalsSource(Arrays.asList(subSources), IntervalFunction.BLOCK);
   }
 
@@ -158,6 +164,9 @@ public final class Intervals {
    * @param subSources  an ordered set of {@link IntervalsSource} objects
    */
   public static IntervalsSource ordered(IntervalsSource... subSources) {
+    if (subSources.length == 1) {
+      return subSources[0];
+    }
     return new MinimizingConjunctionIntervalsSource(Arrays.asList(subSources), IntervalFunction.ORDERED);
   }
 
@@ -181,6 +190,9 @@ public final class Intervals {
    * @param allowOverlaps whether or not the sources should be allowed to overlap in a hit
    */
   public static IntervalsSource unordered(boolean allowOverlaps, IntervalsSource... subSources) {
+    if (subSources.length == 1) {
+      return subSources[0];
+    }
     return new MinimizingConjunctionIntervalsSource(Arrays.asList(subSources),
         allowOverlaps ? IntervalFunction.UNORDERED : IntervalFunction.UNORDERED_NO_OVERLAP);
   }
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestSimplifications.java b/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestSimplifications.java
new file mode 100644
index 0000000000..3c7293b5c2
--- /dev/null
+++ b/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestSimplifications.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.intervals;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestSimplifications extends LuceneTestCase {
+
+  public void testStringPhrases() {
+    IntervalsSource actual = Intervals.phrase("term");
+    assertEquals(Intervals.term("term"), actual);
+  }
+
+  public void testSourcePhrases() {
+    IntervalsSource actual = Intervals.phrase(Intervals.term("term"));
+    assertEquals(Intervals.term("term"), actual);
+  }
+
+  public void testOrdered() {
+    IntervalsSource actual = Intervals.ordered(Intervals.term("term"));
+    assertEquals(Intervals.term("term"), actual);
+  }
+
+  public void testUnordered() {
+    IntervalsSource actual = Intervals.unordered(Intervals.term("term"));
+    assertEquals(Intervals.term("term"), actual);
+  }
+
+  public void testUnorderedOverlaps() {
+    IntervalsSource actual = Intervals.unordered(true, Intervals.term("term"));
+    assertEquals(Intervals.term("term"), actual);
+  }
+
+}
