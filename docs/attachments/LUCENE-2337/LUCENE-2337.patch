Index: src/java/org/apache/lucene/search/DisjunctionSumScorer.java
===================================================================
--- src/java/org/apache/lucene/search/DisjunctionSumScorer.java	(revision 925745)
+++ src/java/org/apache/lucene/search/DisjunctionSumScorer.java	(working copy)
@@ -22,9 +22,7 @@
 
 import org.apache.lucene.util.ScorerDocQueue;
 
-/** A Scorer for OR like queries, counterpart of <code>ConjunctionScorer</code>.
- * This Scorer implements {@link Scorer#skipTo(int)} and uses skipTo() on the given Scorers. 
- */
+/** A Scorer for OR like queries. */
 class DisjunctionSumScorer extends Scorer {
   /** The number of subscorers. */ 
   private final int nrScorers;
@@ -37,12 +35,12 @@
   
   /** The scorerDocQueue contains all subscorers ordered by their current doc(),
    * with the minimum at the top.
-   * <br>The scorerDocQueue is initialized the first time next() or skipTo() is called.
+   * <br>The scorerDocQueue is initialized the first time next() or advance() is called.
    * <br>An exhausted scorer is immediately removed from the scorerDocQueue.
    * <br>If less than the minimumNrMatchers scorers
-   * remain in the scorerDocQueue next() and skipTo() return false.
+   * remain in the scorerDocQueue next() and advance() return NO_MORE_DOCS.
    * <p>
-   * After each to call to next() or skipTo()
+   * After each to call to next() or advance()
    * <code>currentSumScore</code> is the total score of the current matching doc,
    * <code>nrMatchers</code> is the number of matching scorers,
    * and all scorers are after the matching doc, or are exhausted.
@@ -85,14 +83,14 @@
     initScorerDocQueue();
   }
   
-  /** Construct a <code>DisjunctionScorer</code>, using one as the minimum number
+  /** Construct a <code>DisjunctionSumScorer</code>, using one as the minimum number
    * of matching subscorers.
    */
   public DisjunctionSumScorer(List<Scorer> subScorers) throws IOException {
     this(subScorers, 1);
   }
 
-  /** Called the first time next() or skipTo() is called to
+  /** Called the first time next() or advance() is called to
    * initialize <code>scorerDocQueue</code>.
    */
   private void initScorerDocQueue() throws IOException {
@@ -152,8 +150,8 @@
    * @return true iff there is a match.
    * <br>In case there is a match, </code>currentDoc</code>, </code>currentSumScore</code>,
    * and </code>nrMatchers</code> describe the match.
-   *
-   * TODO: Investigate whether it is possible to use skipTo() when
+   * <p>
+   * TODO: Investigate whether it is possible to use advance() when
    * the minimum number of matchers is bigger than one, ie. try and use the
    * character of ConjunctionScorer for the minimum number of matchers.
    * Also delay calling score() on the sub scorers until the minimum number of
@@ -208,7 +206,6 @@
   /**
    * Advances to the first match beyond the current whose document number is
    * greater than or equal to a given target. <br>
-   * The implementation uses the skipTo() method on the subscorers.
    * 
    * @param target
    *          The target document number.
@@ -226,7 +223,7 @@
     do {
       if (scorerDocQueue.topDoc() >= target) {
         return advanceAfterCurrent() ? currentDoc : (currentDoc = NO_MORE_DOCS);
-      } else if (!scorerDocQueue.topSkipToAndAdjustElsePop(target)) {
+      } else if (!scorerDocQueue.topAdvanceAndAdjustElsePop(target)) {
         if (scorerDocQueue.size() < minimumNrMatchers) {
           return currentDoc = NO_MORE_DOCS;
         }
Index: src/java/org/apache/lucene/util/ScorerDocQueue.java
===================================================================
--- src/java/org/apache/lucene/util/ScorerDocQueue.java	(revision 925745)
+++ src/java/org/apache/lucene/util/ScorerDocQueue.java	(working copy)
@@ -30,7 +30,7 @@
  *
  * @lucene.internal
  */
-public class ScorerDocQueue {  // later: SpansQueue for spans with doc and term positions
+public class ScorerDocQueue {
   private final HeapedScorerDoc[] heap;
   private final int maxSize;
   private int size;
@@ -53,7 +53,6 @@
 
   /** Create a ScorerDocQueue with a maximum size. */
   public ScorerDocQueue(int maxSize) {
-    // assert maxSize >= 0;
     size = 0;
     int heapSize = maxSize + 1;
     heap = new HeapedScorerDoc[heapSize];
@@ -98,7 +97,6 @@
    * Should not be used when the queue is empty.
    */
   public final Scorer top() {
-    // assert size > 0;
     return topHSD.scorer;
   }
 
@@ -107,12 +105,10 @@
    * Should not be used when the queue is empty.
    */
   public final int topDoc() {
-    // assert size > 0;
     return topHSD.doc;
   }
   
   public final float topScore() throws IOException {
-    // assert size > 0;
     return topHSD.scorer.score();
   }
 
@@ -120,7 +116,7 @@
     return checkAdjustElsePop(topHSD.scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);
   }
 
-  public final boolean topSkipToAndAdjustElsePop(int target) throws IOException {
+  public final boolean topAdvanceAndAdjustElsePop(int target) throws IOException {
     return checkAdjustElsePop(topHSD.scorer.advance(target) != DocIdSetIterator.NO_MORE_DOCS);
   }
   
@@ -141,7 +137,6 @@
    * Should not be used when the queue is empty.
    */
   public final Scorer pop() {
-    // assert size > 0;
     Scorer result = topHSD.scorer;
     popNoResult();
     return result;
@@ -165,7 +160,6 @@
    * </pre>
    */
   public final void adjustTop() {
-    // assert size > 0;
     topHSD.adjust();
     downHeap();
   }
