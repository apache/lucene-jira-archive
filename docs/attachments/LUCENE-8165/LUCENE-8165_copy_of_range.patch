diff --git a/lucene/analysis/common/src/test/org/apache/lucene/analysis/ngram/NGramTokenizerTest.java b/lucene/analysis/common/src/test/org/apache/lucene/analysis/ngram/NGramTokenizerTest.java
index 46a0c1c143..c0a51ced2e 100644
--- a/lucene/analysis/common/src/test/org/apache/lucene/analysis/ngram/NGramTokenizerTest.java
+++ b/lucene/analysis/common/src/test/org/apache/lucene/analysis/ngram/NGramTokenizerTest.java
@@ -179,7 +179,9 @@ public class NGramTokenizerTest extends BaseTokenStreamTestCase {
           }
         }
         assertTrue(grams.incrementToken());
-        assertArrayEquals(Arrays.copyOfRange(codePoints, start, end), toCodePoints(termAtt));
+        final int[] termBuff = new int[end - start];
+        System.arraycopy(codePoints, start, termBuff, 0, termBuff.length);
+        assertArrayEquals(termBuff, toCodePoints(termAtt));
         assertEquals(1, posIncAtt.getPositionIncrement());
         assertEquals(1, posLenAtt.getPositionLength());
         assertEquals(offsets[start], offsetAtt.startOffset());
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.java b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.java
index 034202b10d..2993727035 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.java
@@ -540,7 +540,7 @@ final class SimpleTextBKDWriter implements Closeable {
         }
       };
       assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),
-          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),
+          BytesRef.deepCopyOf(new BytesRef(leafValues, (leafCount - 1) * packedBytesLength, packedBytesLength)).bytes,
           packedValues, leafDocs, 0);
       writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);
     }
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat.java b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat.java
index 8a71c6df7d..35eb7b41c2 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat.java
@@ -158,8 +158,8 @@ public class SimpleTextSegmentInfoFormat extends SegmentInfoFormat {
       
       SimpleTextUtil.readLine(input, scratch);
       assert StringHelper.startsWith(scratch.get(), SI_ID);
-      final byte[] id = Arrays.copyOfRange(scratch.bytes(), SI_ID.length, scratch.length());
-      
+      final byte[] id = new byte[scratch.length() - SI_ID.length];
+      System.arraycopy(scratch.bytes(), SI_ID.length, id, 0, id.length);
       if (!Arrays.equals(segmentID, id)) {
         throw new CorruptIndexException("file mismatch, expected: " + StringHelper.idToString(segmentID)
                                                         + ", got: " + StringHelper.idToString(id), input);
diff --git a/lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter.java b/lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter.java
index 22be7e50ba..c35d745df2 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter.java
@@ -164,7 +164,8 @@ class SortedSetDocValuesWriter extends DocValuesWriter {
         }
         docOrds[upto++] = ord;
       }
-      ords[newDocID] = Arrays.copyOfRange(docOrds, 0, upto);
+      ords[newDocID] = new long[upto];
+      System.arraycopy(docOrds, 0, ords[newDocID], 0, upto);
     }
     return ords;
   }
diff --git a/lucene/core/src/java/org/apache/lucene/index/SortingLeafReader.java b/lucene/core/src/java/org/apache/lucene/index/SortingLeafReader.java
index eb9f7ed8a5..d765b7c4f9 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SortingLeafReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SortingLeafReader.java
@@ -1230,7 +1230,8 @@ class SortingLeafReader extends FilterLeafReader {
             }
             docOrds[upto++] = ord;
           }
-          ords[newDocID] = Arrays.copyOfRange(docOrds, 0, upto);
+          ords[newDocID] = new long[upto];
+          System.arraycopy(docOrds, 0, ords[newDocID], 0, upto);
         }
         cachedSortedSetDVs.put(field, ords);
       }
diff --git a/lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.java b/lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.java
index 689d64a50d..149fa2080a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.java
@@ -333,7 +333,7 @@ public abstract class PointInSetQuery extends Query {
 
             upto++;
             BytesRef next = iterator.next();
-            return Arrays.copyOfRange(next.bytes, next.offset, next.length);
+            return BytesRef.deepCopyOf(next).bytes;
           }
         };
       }
diff --git a/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java
index 7e48383b47..4d0681b94c 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java
@@ -392,9 +392,13 @@ public abstract class PointRangeQuery extends Query {
       int startOffset = bytesPerDim * i;
 
       sb.append('[');
-      sb.append(toString(i, Arrays.copyOfRange(lowerPoint, startOffset, startOffset + bytesPerDim)));
+      byte[] lowerBuffer = new byte[bytesPerDim];
+      System.arraycopy(lowerPoint, startOffset, lowerBuffer, 0, bytesPerDim);
+      sb.append(toString(i, lowerBuffer));
       sb.append(" TO ");
-      sb.append(toString(i, Arrays.copyOfRange(upperPoint, startOffset, startOffset + bytesPerDim)));
+      byte[] upperBuffer = new byte[bytesPerDim];
+      System.arraycopy(upperPoint, startOffset, upperBuffer, 0, bytesPerDim);
+      sb.append(toString(i, upperBuffer));
       sb.append(']');
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/BytesRef.java b/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
index 42c4e87ad5..1782eb46d4 100644
--- a/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
@@ -16,9 +16,6 @@
  */
 package org.apache.lucene.util;
 
-
-import java.util.Arrays;
-
 /** Represents byte[], as a slice (offset + length) into an
  *  existing byte[].  The {@link #bytes} member should never be null;
  *  use {@link #EMPTY_BYTES} if necessary.
@@ -173,7 +170,8 @@ public final class BytesRef implements Comparable<BytesRef>,Cloneable {
    */
   public static BytesRef deepCopyOf(BytesRef other) {
     BytesRef copy = new BytesRef();
-    copy.bytes = Arrays.copyOfRange(other.bytes, other.offset, other.offset + other.length);
+    copy.bytes = new byte[other.length];
+    System.arraycopy(other.bytes, other.offset, copy.bytes, 0, other.length);
     copy.offset = 0;
     copy.length = other.length;
     return copy;
diff --git a/lucene/core/src/java/org/apache/lucene/util/CharsRef.java b/lucene/core/src/java/org/apache/lucene/util/CharsRef.java
index eb839a85fa..418da3504e 100644
--- a/lucene/core/src/java/org/apache/lucene/util/CharsRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/CharsRef.java
@@ -17,7 +17,6 @@
 package org.apache.lucene.util;
 
 
-import java.util.Arrays;
 import java.util.Comparator;
 
 /**
@@ -202,7 +201,12 @@ public final class CharsRef implements Comparable<CharsRef>, CharSequence, Clone
    * and an offset of zero.
    */
   public static CharsRef deepCopyOf(CharsRef other) {
-    return new CharsRef(Arrays.copyOfRange(other.chars, other.offset, other.offset + other.length), 0, other.length);
+    CharsRef copy = new CharsRef();
+    copy.chars = new char[other.length];
+    System.arraycopy(other.chars, other.offset, copy.chars, 0, other.length);
+    copy.offset = 0;
+    copy.length = other.length;
+    return copy;
   }
   
   /** 
diff --git a/lucene/core/src/java/org/apache/lucene/util/IntsRef.java b/lucene/core/src/java/org/apache/lucene/util/IntsRef.java
index aa7bbcee11..ebeea07db9 100644
--- a/lucene/core/src/java/org/apache/lucene/util/IntsRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/IntsRef.java
@@ -16,8 +16,6 @@
  */
 package org.apache.lucene.util;
 
-import java.util.Arrays;
-
 
 /** Represents int[], as a slice (offset + length) into an
  *  existing int[].  The {@link #ints} member should never be null; use
@@ -127,7 +125,12 @@ public final class IntsRef implements Comparable<IntsRef>, Cloneable {
    * and an offset of zero.
    */
   public static IntsRef deepCopyOf(IntsRef other) {
-    return new IntsRef(Arrays.copyOfRange(other.ints, other.offset, other.offset + other.length), 0, other.length);
+    IntsRef copy = new IntsRef();
+    copy.ints = new int[other.length];
+    System.arraycopy(other.ints, other.offset, copy.ints, 0, other.length);
+    copy.offset = 0;
+    copy.length = other.length;
+    return copy;
   }
   
   /** 
diff --git a/lucene/core/src/java/org/apache/lucene/util/LongsRef.java b/lucene/core/src/java/org/apache/lucene/util/LongsRef.java
index 952d189a2a..33eb548651 100644
--- a/lucene/core/src/java/org/apache/lucene/util/LongsRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/LongsRef.java
@@ -16,8 +16,6 @@
  */
 package org.apache.lucene.util;
 
-import java.util.Arrays;
-
 
 /** Represents long[], as a slice (offset + length) into an
  *  existing long[].  The {@link #longs} member should never be null; use
@@ -126,7 +124,12 @@ public final class LongsRef implements Comparable<LongsRef>, Cloneable {
    * and an offset of zero.
    */
   public static LongsRef deepCopyOf(LongsRef other) {
-    return new LongsRef(Arrays.copyOfRange(other.longs, other.offset, other.offset + other.length), 0, other.length);
+    LongsRef copy = new LongsRef();
+    copy.longs = new long[other.length];
+    System.arraycopy(other.longs, other.offset, copy.longs, 0, other.length);
+    copy.offset = 0;
+    copy.length = other.length;
+    return copy;
   }
   
   /** 
diff --git a/lucene/core/src/java/org/apache/lucene/util/StringHelper.java b/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
index 4c6d4fac3a..9df20d6c28 100644
--- a/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
+++ b/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
@@ -303,16 +303,16 @@ public abstract class StringHelper {
       nextId = nextId.add(BigInteger.ONE).and(mask128);
     }
     
+    final byte[] result = new byte[ID_LENGTH];
     // toByteArray() always returns a sign bit, so it may require an extra byte (always zero)
     if (bits.length > ID_LENGTH) {
       assert bits.length == ID_LENGTH + 1;
       assert bits[0] == 0;
-      return Arrays.copyOfRange(bits, 1, bits.length);
+      System.arraycopy(bits, 1, result, 0, result.length);
     } else {
-      byte[] result = new byte[ID_LENGTH];
       System.arraycopy(bits, 0, result, result.length - bits.length, bits.length);
-      return result;
     }
+    return result;
   }
   
   /** 
diff --git a/lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java b/lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java
index 7f55895842..0eece4223c 100644
--- a/lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java
@@ -688,7 +688,7 @@ public class BKDWriter implements Closeable {
         }
       };
       assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),
-          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),
+          BytesRef.deepCopyOf(new BytesRef(leafValues, (leafCount - 1) * packedBytesLength, packedBytesLength)).bytes,
           packedValues, leafDocs, 0);
       writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);
       out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());
diff --git a/lucene/core/src/test/org/apache/lucene/analysis/TestCharacterUtils.java b/lucene/core/src/test/org/apache/lucene/analysis/TestCharacterUtils.java
index 53b3f568e8..d34081899b 100644
--- a/lucene/core/src/test/org/apache/lucene/analysis/TestCharacterUtils.java
+++ b/lucene/core/src/test/org/apache/lucene/analysis/TestCharacterUtils.java
@@ -20,9 +20,9 @@ package org.apache.lucene.analysis;
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
-import java.util.Arrays;
 
 import org.apache.lucene.analysis.CharacterUtils.CharacterBuffer;
+import org.apache.lucene.util.FutureArrays;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 import org.junit.Test;
@@ -42,7 +42,7 @@ public class TestCharacterUtils extends LuceneTestCase {
     final int codePointCount = CharacterUtils.toCodePoints(orig, o1, orig.length - o1, buf, o2);
     final int charCount = CharacterUtils.toChars(buf, o2, codePointCount, restored, o3);
     assertEquals(orig.length - o1, charCount);
-    assertArrayEquals(Arrays.copyOfRange(orig, o1, o1 + charCount), Arrays.copyOfRange(restored, o3, o3 + charCount));
+    assertTrue(FutureArrays.equals(orig, o1, o1 + charCount, restored, o3, o3 + charCount));
   }
 
   @Test
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode.java b/lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode.java
index 045b19ad80..ddc35492cc 100644
--- a/lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode.java
+++ b/lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode.java
@@ -23,6 +23,7 @@ import java.util.Arrays;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.store.ByteArrayDataOutput;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.FutureArrays;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 
@@ -71,14 +72,14 @@ public abstract class AbstractTestCompressionMode extends LuceneTestCase {
   static byte[] decompress(Decompressor decompressor, byte[] compressed, int originalLength) throws IOException {
     final BytesRef bytes = new BytesRef();
     decompressor.decompress(new ByteArrayDataInput(compressed), originalLength, 0, originalLength, bytes);
-    return Arrays.copyOfRange(bytes.bytes, bytes.offset, bytes.offset + bytes.length);
+    return BytesRef.deepCopyOf(bytes).bytes;
   }
 
   byte[] decompress(byte[] compressed, int originalLength, int offset, int length) throws IOException {
     Decompressor decompressor = mode.newDecompressor();
     final BytesRef bytes = new BytesRef();
     decompressor.decompress(new ByteArrayDataInput(compressed), originalLength, offset, length, bytes);
-    return Arrays.copyOfRange(bytes.bytes, bytes.offset, bytes.offset + bytes.length);
+    return BytesRef.deepCopyOf(bytes).bytes;
   }
 
   public void testDecompress() throws IOException {
@@ -89,7 +90,7 @@ public abstract class AbstractTestCompressionMode extends LuceneTestCase {
       final int len = random().nextBoolean() ? decompressed.length - off : TestUtil.nextInt(random(), 0, decompressed.length - off);
       final byte[] compressed = compress(decompressed, off, len);
       final byte[] restored = decompress(compressed, len);
-      assertArrayEquals(Arrays.copyOfRange(decompressed, off, off+len), restored);
+      assertTrue(FutureArrays.equals(decompressed, off, off+len, restored, 0, len));
     }
   }
 
@@ -106,7 +107,7 @@ public abstract class AbstractTestCompressionMode extends LuceneTestCase {
         length = random().nextInt(decompressed.length - offset);
       }
       final byte[] restored = decompress(compressed, decompressed.length, offset, length);
-      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);
+      assertTrue(FutureArrays.equals(decompressed, offset, offset+length, restored, 0, length));
     }
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestForUtil.java b/lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestForUtil.java
index 3fe003e1dc..d9b528b431 100644
--- a/lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestForUtil.java
+++ b/lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestForUtil.java
@@ -22,13 +22,13 @@ import static org.apache.lucene.codecs.lucene50.ForUtil.MAX_DATA_SIZE;
 import static org.apache.lucene.codecs.lucene50.ForUtil.MAX_ENCODED_SIZE;
 
 import java.io.IOException;
-import java.util.Arrays;
 
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.util.FutureArrays;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.packed.PackedInts;
 
@@ -39,7 +39,7 @@ public class TestForUtil extends LuceneTestCase {
   public void testEncodeDecode() throws IOException {
     final int iterations = RandomNumbers.randomIntBetween(random(), 1, 1000);
     final float acceptableOverheadRatio = random().nextFloat();
-    final int[] values = new int[(iterations - 1) * BLOCK_SIZE + ForUtil.MAX_DATA_SIZE];
+    final int[] values = new int[iterations * BLOCK_SIZE];
     for (int i = 0; i < iterations; ++i) {
       final int bpv = random().nextInt(32);
       if (bpv == 0) {
@@ -64,9 +64,10 @@ public class TestForUtil extends LuceneTestCase {
       final ForUtil forUtil = new ForUtil(acceptableOverheadRatio, out);
       
       for (int i = 0; i < iterations; ++i) {
-        forUtil.writeBlock(
-            Arrays.copyOfRange(values, i * BLOCK_SIZE, values.length),
-            new byte[MAX_ENCODED_SIZE], out);
+        // Although values after BLOCK_SIZE are garbage, we need to allocate extra bytes to avoid AIOOBE.
+        final int[] block = new int[MAX_DATA_SIZE];
+        System.arraycopy(values, i * BLOCK_SIZE, block, 0, BLOCK_SIZE);
+        forUtil.writeBlock(block, new byte[MAX_ENCODED_SIZE], out);
       }
       endPointer = out.getFilePointer();
       out.close();
@@ -83,8 +84,8 @@ public class TestForUtil extends LuceneTestCase {
         }
         final int[] restored = new int[MAX_DATA_SIZE];
         forUtil.readBlock(in, new byte[MAX_ENCODED_SIZE], restored);
-        assertArrayEquals(Arrays.copyOfRange(values, i * BLOCK_SIZE, (i + 1) * BLOCK_SIZE),
-            Arrays.copyOf(restored, BLOCK_SIZE));
+        int offset = i * BLOCK_SIZE;
+        assertTrue(FutureArrays.equals(values, offset, offset + BLOCK_SIZE, restored, 0, BLOCK_SIZE));
       }
       assertEquals(endPointer, in.getFilePointer());
       in.close();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDoubleValuesSource.java b/lucene/core/src/test/org/apache/lucene/search/TestDoubleValuesSource.java
index 5a5a3aee42..97189f92a1 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDoubleValuesSource.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDoubleValuesSource.java
@@ -122,7 +122,9 @@ public class TestDoubleValuesSource extends LuceneTestCase {
     };
     Collections.shuffle(Arrays.asList(fields), random());
     int numSorts = TestUtil.nextInt(random(), 1, fields.length);
-    return new Sort(Arrays.copyOfRange(fields, 0, numSorts));
+    SortField[] selectedFields = new SortField[numSorts];
+    System.arraycopy(fields, 0, selectedFields, 0, numSorts);
+    return new Sort(selectedFields);
   }
 
   // Take a Sort, and replace any field sorts with Sortables
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestLongValuesSource.java b/lucene/core/src/test/org/apache/lucene/search/TestLongValuesSource.java
index 8b20be5169..3a9ab2486b 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestLongValuesSource.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestLongValuesSource.java
@@ -103,7 +103,9 @@ public class TestLongValuesSource extends LuceneTestCase {
     };
     Collections.shuffle(Arrays.asList(fields), random());
     int numSorts = TestUtil.nextInt(random(), 1, fields.length);
-    return new Sort(Arrays.copyOfRange(fields, 0, numSorts));
+    SortField[] selectedFields = new SortField[numSorts];
+    System.arraycopy(fields, 0, selectedFields, 0, numSorts);
+    return new Sort(selectedFields);
   }
 
   // Take a Sort, and replace any field sorts with Sortables
diff --git a/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java b/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java
index 2db901baa1..96c6db4865 100644
--- a/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java
+++ b/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java
@@ -64,7 +64,9 @@ public abstract class BaseSortTestCase extends LuceneTestCase {
     System.arraycopy(arr, 0, toSort, o, arr.length);
     final Sorter sorter = newSorter(toSort);
     sorter.sort(o, o + arr.length);
-    assertSorted(arr, Arrays.copyOfRange(toSort, o, o + arr.length));
+    final Entry[] sorted = new Entry[arr.length];
+    System.arraycopy(toSort, o, sorted, 0, sorted.length);
+    assertSorted(arr, sorted);
   }
 
   enum Strategy {
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestBytesRef.java b/lucene/core/src/test/org/apache/lucene/util/TestBytesRef.java
index 3a5bb53c74..2a869adca3 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestBytesRef.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestBytesRef.java
@@ -48,4 +48,12 @@ public class TestBytesRef extends LuceneTestCase {
     // only for 4.x
     assertEquals("\uFFFF", new BytesRef("\uFFFF").utf8ToString());
   }
+
+  public void testInvalidDeepCopy() {
+    BytesRef from = new BytesRef(new byte[] { 1, 2 });
+    from.offset += 1; // now invalid
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      BytesRef.deepCopyOf(from);
+    });
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java b/lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java
index 0a4c8844c8..079b3b774b 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java
@@ -125,4 +125,12 @@ public class TestCharsRef extends LuceneTestCase {
       c.subSequence(2, 1);
     });
   }
+  
+  public void testInvalidDeepCopy() {
+    CharsRef from = new CharsRef(new char[] { 'a', 'b' }, 0, 2);
+    from.offset += 1; // now invalid
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      CharsRef.deepCopyOf(from);
+    });
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestIntsRef.java b/lucene/core/src/test/org/apache/lucene/util/TestIntsRef.java
index b9976592fa..654e77d133 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestIntsRef.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestIntsRef.java
@@ -37,4 +37,12 @@ public class TestIntsRef extends LuceneTestCase {
     
     assertFalse(i.equals(i2));
   }
+  
+  public void testInvalidDeepCopy() {
+    IntsRef from = new IntsRef(new int[] { 1, 2 }, 0, 2);
+    from.offset += 1; // now invalid
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      IntsRef.deepCopyOf(from);
+    });
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestLongsRef.java b/lucene/core/src/test/org/apache/lucene/util/TestLongsRef.java
new file mode 100644
index 0000000000..ec4575fa48
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/util/TestLongsRef.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.util;
+
+public class TestLongsRef extends LuceneTestCase {
+  public void testEmpty() {
+    LongsRef i = new LongsRef();
+    assertEquals(LongsRef.EMPTY_LONGS, i.longs);
+    assertEquals(0, i.offset);
+    assertEquals(0, i.length);
+  }
+  
+  public void testFromLongs() {
+    long longs[] = new long[] { 1, 2, 3, 4 };
+    LongsRef i = new LongsRef(longs, 0, 4);
+    assertEquals(longs, i.longs);
+    assertEquals(0, i.offset);
+    assertEquals(4, i.length);
+    
+    LongsRef i2 = new LongsRef(longs, 1, 3);
+    assertEquals(new LongsRef(new long[] { 2, 3, 4 }, 0, 3), i2);
+    
+    assertFalse(i.equals(i2));
+  }
+  
+  public void testInvalidDeepCopy() {
+    LongsRef from = new LongsRef(new long[] { 1, 2 }, 0, 2);
+    from.offset += 1; // now invalid
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      LongsRef.deepCopyOf(from);
+    });
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java b/lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java
index a675e0b8cd..ba35ae3607 100644
--- a/lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java
+++ b/lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java
@@ -34,6 +34,7 @@ import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.util.FutureArrays;
 import org.apache.lucene.util.LongValues;
 import org.apache.lucene.util.LongsRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -903,8 +904,7 @@ public class TestPackedInts extends LuceneTestCase {
         // 3. re-encode
         final long[] blocks2 = new long[blocksOffset2 + blocksLen];
         encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);
-        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),
-            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));
+        assertTrue(msg, FutureArrays.equals(blocks, blocksOffset, blocks.length, blocks2, blocksOffset2, blocks2.length));
         // test encoding from int[]
         if (bpv <= 32) {
           final long[] blocks3 = new long[blocks2.length];
diff --git a/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java b/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
index cb24f6fe2a..7fa8546e73 100644
--- a/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
+++ b/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
@@ -109,7 +109,9 @@ public class TestExpressionSorts extends LuceneTestCase {
       };
       Collections.shuffle(Arrays.asList(fields), random());
       int numSorts = TestUtil.nextInt(random(), 1, fields.length);
-      assertQuery(query, new Sort(Arrays.copyOfRange(fields, 0, numSorts)));
+      SortField[] selectedFields = new SortField[numSorts];
+      System.arraycopy(fields, 0, selectedFields, 0, numSorts);
+      assertQuery(query, new Sort(selectedFields));
     }
   }
 
diff --git a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java
index 3242e7e623..9bc947fbbd 100644
--- a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java
+++ b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java
@@ -19,7 +19,6 @@ package org.apache.lucene.spatial.prefix.tree;
 import java.io.PrintStream;
 import java.text.NumberFormat;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 import java.util.Locale;
@@ -245,7 +244,8 @@ public class QuadPrefixTree extends LegacyPrefixTree {
 
     protected BytesRef concat(BytesRef source, byte b) {
       //+2 for new char + potential leaf
-      final byte[] buffer = Arrays.copyOfRange(source.bytes, source.offset, source.offset + source.length + 2);
+      final byte[] buffer = new byte[source.length + 2];
+      System.arraycopy(source.bytes, source.offset, buffer, 0, source.length);
       BytesRef target = new BytesRef(buffer);
       target.length = source.length;
       target.bytes[target.length++] = b;
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/document/TestContextQuery.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/document/TestContextQuery.java
index 2c5dcd8e54..b587575517 100644
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/document/TestContextQuery.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/suggest/document/TestContextQuery.java
@@ -521,7 +521,7 @@ public class TestContextQuery extends LuceneTestCase {
           query.addContext(contexts.get(i), i + 1);
         }
         TopSuggestDocs suggest = suggestIndexSearcher.suggest(query, 4, false);
-        assertSuggestions(suggest, Arrays.copyOfRange(expectedResults, 0, 4));
+        assertSuggestions(suggest, expectedResults[0], expectedResults[1], expectedResults[2], expectedResults[3]);
       }
     }
   }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java
index 60e2cca024..22592798b6 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java
@@ -559,8 +559,7 @@ public abstract class BaseStoredFieldsFormatTestCase extends BaseIndexFileFormat
       for (int j = 0; j < data[docId].length; ++j) {
         final byte[] arr = data[docId][j];
         final BytesRef arr2Ref = doc.getBinaryValue("bytes" + j);
-        final byte[] arr2 = Arrays.copyOfRange(arr2Ref.bytes, arr2Ref.offset, arr2Ref.offset + arr2Ref.length);
-        assertArrayEquals(arr, arr2);
+        assertArrayEquals(arr, BytesRef.deepCopyOf(arr2Ref).bytes);
       }
     }
     assertTrue(ir.numDocs() <= numDocs);
diff --git a/lucene/tools/forbiddenApis/lucene.txt b/lucene/tools/forbiddenApis/lucene.txt
index e02bd40ad0..a1801c4bfd 100644
--- a/lucene/tools/forbiddenApis/lucene.txt
+++ b/lucene/tools/forbiddenApis/lucene.txt
@@ -27,3 +27,15 @@ java.util.zip.ZipFile
 @defaultMessage Use home-grown methods instead
 java.lang.Math#toRadians(double)
 java.lang.Math#toDegrees(double)
+
+@defaultMessage Prefer using System#arraycopy as Arrays#copyOfRange fills zeros for bad bounds
+java.util.Arrays#copyOfRange(byte[],int,int)
+java.util.Arrays#copyOfRange(char[],int,int)
+java.util.Arrays#copyOfRange(short[],int,int)
+java.util.Arrays#copyOfRange(int[],int,int)
+java.util.Arrays#copyOfRange(long[],int,int)
+java.util.Arrays#copyOfRange(float[],int,int)
+java.util.Arrays#copyOfRange(double[],int,int)
+java.util.Arrays#copyOfRange(boolean[],int,int)
+java.util.Arrays#copyOfRange(java.lang.Object[],int,int)
+java.util.Arrays#copyOfRange(java.lang.Object[],int,int,java.lang.Class)
\ No newline at end of file
