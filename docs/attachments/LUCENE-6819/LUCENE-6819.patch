diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index 7d8e363..0159e3c 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -37,6 +37,10 @@ API Changes
   to be less trappy. See IndexReader.getReaderCacheHelper and
   LeafReader.getCoreCacheHelper. (Adrien Grand)
 
+* LUCENE-6819: Index-time boosts are not supported anymore. As a replacement,
+  index-time scoring factors should be indexed into a doc value field and
+  combined at query time using eg. FunctionScoreQuery. (Adrien Grand)
+
 Bug Fixes
 
 * LUCENE-7626: IndexWriter will no longer accept broken token offsets
diff --git a/lucene/MIGRATE.txt b/lucene/MIGRATE.txt
index 51f6435..1ccf56f 100644
--- a/lucene/MIGRATE.txt
+++ b/lucene/MIGRATE.txt
@@ -55,3 +55,9 @@ order to be less trappy. You should now use IndexReader.getReaderCacheHelper()
 to have manage caches that take deleted docs and doc values updates into
 account, and LeafReader.getCoreCacheHelper() to manage per-segment caches that
 do not take deleted docs and doc values updates into account.
+
+## Index-time boosts removal (LUCENE-6819)
+
+Index-time boosts are not supported anymore. As a replacement, index-time
+scoring factors should be indexed in a doc value field and combined with the
+score at query time using FunctionScoreQuery for instance.
diff --git a/lucene/backward-codecs/src/test/org/apache/lucene/legacy/TestLegacyField.java b/lucene/backward-codecs/src/test/org/apache/lucene/legacy/TestLegacyField.java
index 65ff096..92d1dd6 100644
--- a/lucene/backward-codecs/src/test/org/apache/lucene/legacy/TestLegacyField.java
+++ b/lucene/backward-codecs/src/test/org/apache/lucene/legacy/TestLegacyField.java
@@ -33,7 +33,6 @@ public class TestLegacyField extends LuceneTestCase {
     };
 
     for (Field field : fields) {
-      trySetBoost(field);
       trySetByteValue(field);
       trySetBytesValue(field);
       trySetBytesRefValue(field);
@@ -57,7 +56,6 @@ public class TestLegacyField extends LuceneTestCase {
     };
 
     for (Field field : fields) {
-      trySetBoost(field);
       trySetByteValue(field);
       trySetBytesValue(field);
       trySetBytesRefValue(field);
@@ -81,7 +79,6 @@ public class TestLegacyField extends LuceneTestCase {
     };
 
     for (Field field : fields) {
-      trySetBoost(field);
       trySetByteValue(field);
       trySetBytesValue(field);
       trySetBytesRefValue(field);
@@ -105,7 +102,6 @@ public class TestLegacyField extends LuceneTestCase {
     };
 
     for (Field field : fields) {
-      trySetBoost(field);
       trySetByteValue(field);
       trySetBytesValue(field);
       trySetBytesRefValue(field);
@@ -187,10 +183,4 @@ public class TestLegacyField extends LuceneTestCase {
       f.setTokenStream(new CannedTokenStream(new Token("foo", 0, 3)));
     });
   }
-  
-  private void trySetBoost(Field f) {
-    expectThrows(IllegalArgumentException.class, () -> {
-      f.setBoost(5.0f);
-    });
-  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter.java
index 0540f4f..39ade42 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter.java
@@ -249,11 +249,6 @@ public abstract class StoredFieldsWriter implements Closeable {
     public Reader readerValue() {
       return null;
     }
-    
-    @Override
-    public float boost() {
-      return 1F;
-    }
 
     @Override
     public TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) {
diff --git a/lucene/core/src/java/org/apache/lucene/document/Field.java b/lucene/core/src/java/org/apache/lucene/document/Field.java
index fa3f5a7..cbb559a 100644
--- a/lucene/core/src/java/org/apache/lucene/document/Field.java
+++ b/lucene/core/src/java/org/apache/lucene/document/Field.java
@@ -81,12 +81,6 @@ public class Field implements IndexableField {
   protected TokenStream tokenStream;
 
   /**
-   * Field's boost
-   * @see #boost()
-   */
-  protected float boost = 1.0f;
-
-  /**
    * Expert: creates a field with no initial value.
    * Intended only for custom Field subclasses.
    * @param name field name
@@ -432,32 +426,6 @@ public class Field implements IndexableField {
   public String name() {
     return name;
   }
-  
-  /** 
-   * {@inheritDoc}
-   * <p>
-   * The default value is <code>1.0f</code> (no boost).
-   * @see #setBoost(float)
-   */
-  @Override
-  public float boost() {
-    return boost;
-  }
-
-  /** 
-   * Sets the boost factor on this field.
-   * @throws IllegalArgumentException if this field is not indexed, 
-   *         or if it omits norms. 
-   * @see #boost()
-   */
-  public void setBoost(float boost) {
-    if (boost != 1.0f) {
-      if (type.indexOptions() == IndexOptions.NONE || type.omitNorms()) {
-        throw new IllegalArgumentException("You cannot set an index-time boost on an unindexed field, or one that omits norms");
-      }
-    }
-    this.boost = boost;
-  }
 
   @Override
   public Number numericValue() {
diff --git a/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java b/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
index b118c13..ba65629 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
@@ -426,12 +426,6 @@ final class DefaultIndexingChain extends DocConsumer {
 
     // Invert indexed fields:
     if (fieldType.indexOptions() != IndexOptions.NONE) {
-      
-      // if the field omits norms, the boost cannot be indexed.
-      if (fieldType.omitNorms() && field.boost() != 1.0f) {
-        throw new UnsupportedOperationException("You cannot set an index-time boost: norms are omitted for field '" + field.name() + "'");
-      }
-      
       fp = getOrAddField(fieldName, fieldType, true);
       boolean first = fp.fieldGen != fieldGen;
       fp.invert(field, first);
@@ -823,8 +817,6 @@ final class DefaultIndexingChain extends DocConsumer {
         invertState.position += docState.analyzer.getPositionIncrementGap(fieldInfo.name);
         invertState.offset += docState.analyzer.getOffsetGap(fieldInfo.name);
       }
-
-      invertState.boost *= field.boost();
     }
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/index/FieldInvertState.java b/lucene/core/src/java/org/apache/lucene/index/FieldInvertState.java
index f7eef96..1da02b2 100644
--- a/lucene/core/src/java/org/apache/lucene/index/FieldInvertState.java
+++ b/lucene/core/src/java/org/apache/lucene/index/FieldInvertState.java
@@ -38,7 +38,6 @@ public final class FieldInvertState {
   int offset;
   int maxTermFrequency;
   int uniqueTermCount;
-  float boost;
   // we must track these across field instances (multi-valued case)
   int lastStartOffset = 0;
   int lastPosition = 0;
@@ -57,13 +56,12 @@ public final class FieldInvertState {
   
   /** Creates {code FieldInvertState} for the specified
    *  field name and values for all fields. */
-  public FieldInvertState(String name, int position, int length, int numOverlap, int offset, float boost) {
+  public FieldInvertState(String name, int position, int length, int numOverlap, int offset) {
     this.name = name;
     this.position = position;
     this.length = length;
     this.numOverlap = numOverlap;
     this.offset = offset;
-    this.boost = boost;
   }
 
   /**
@@ -76,7 +74,6 @@ public final class FieldInvertState {
     offset = 0;
     maxTermFrequency = 0;
     uniqueTermCount = 0;
-    boost = 1.0f;
     lastStartOffset = 0;
     lastPosition = 0;
   }
@@ -139,21 +136,6 @@ public final class FieldInvertState {
   }
 
   /**
-   * Get boost value. This is the cumulative product of
-   * document boost and field boost for all field instances
-   * sharing the same field name.
-   * @return the boost
-   */
-  public float getBoost() {
-    return boost;
-  }
-
-  /** Set boost value. */
-  public void setBoost(float boost) {
-    this.boost = boost;
-  }
-
-  /**
    * Get the maximum term-frequency encountered for any term in the field.  A
    * field containing "the quick brown fox jumps over the lazy dog" would have
    * a value of 2, because "the" appears twice.
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexableField.java b/lucene/core/src/java/org/apache/lucene/index/IndexableField.java
index f6fc615..f08eab5 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexableField.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexableField.java
@@ -21,8 +21,6 @@ import java.io.Reader;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.search.similarities.ClassicSimilarity;
-import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.BytesRef;
 
 // TODO: how to handle versioning here...?
@@ -57,28 +55,6 @@ public interface IndexableField {
    */
   public TokenStream tokenStream(Analyzer analyzer, TokenStream reuse);
 
-  /** 
-   * Returns the field's index-time boost.
-   * <p>
-   * Only fields can have an index-time boost, if you want to simulate
-   * a "document boost", then you must pre-multiply it across all the
-   * relevant fields yourself. 
-   * <p>The boost is used to compute the norm factor for the field.  By
-   * default, in the {@link Similarity#computeNorm(FieldInvertState)} method, 
-   * the boost value is multiplied by the length normalization factor and then
-   * rounded by {@link ClassicSimilarity#encodeNormValue(float)} before it is stored in the
-   * index.  One should attempt to ensure that this product does not overflow
-   * the range of that encoding.
-   * <p>
-   * It is illegal to return a boost other than 1.0f for a field that is not
-   * indexed ({@link IndexableFieldType#indexOptions()} is IndexOptions.NONE) or
-   * omits normalization values ({@link IndexableFieldType#omitNorms()} returns true).
-   *
-   * @see Similarity#computeNorm(FieldInvertState)
-   * @see ClassicSimilarity#encodeNormValue(float)
-   */
-  public float boost();
-
   /** Non-null if this field has a binary value */
   public BytesRef binaryValue();
 
diff --git a/lucene/core/src/java/org/apache/lucene/index/SortingStoredFieldsConsumer.java b/lucene/core/src/java/org/apache/lucene/index/SortingStoredFieldsConsumer.java
index b3cc1f4..e5443b2 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SortingStoredFieldsConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SortingStoredFieldsConsumer.java
@@ -183,11 +183,6 @@ final class SortingStoredFieldsConsumer extends StoredFieldsConsumer {
     }
 
     @Override
-    public float boost() {
-      return 1F;
-    }
-
-    @Override
     public TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) {
       return null;
     }
diff --git a/lucene/core/src/java/org/apache/lucene/search/package-info.java b/lucene/core/src/java/org/apache/lucene/search/package-info.java
index fc0ab2e..c9d8e26 100644
--- a/lucene/core/src/java/org/apache/lucene/search/package-info.java
+++ b/lucene/core/src/java/org/apache/lucene/search/package-info.java
@@ -269,27 +269,8 @@
  *    Fields and the other in one Field may return different scores for the same query due to length
  *    normalization.
  * <h3>Score Boosting</h3>
- * <p>Lucene allows influencing search results by "boosting" at different times:
- *    <ul>                   
- *       <li><b>Index-time boost</b> by calling
- *        {@link org.apache.lucene.document.Field#setBoost(float) Field.setBoost()} before a document is 
- *        added to the index.</li>
- *       <li><b>Query-time boost</b> by applying a boost to a query by wrapping with
- *       {@link org.apache.lucene.search.BoostQuery}.</li>
- *    </ul>    
- * <p>Indexing time boosts are pre-processed for storage efficiency and written to
- *    storage for a field as follows:
- *    <ul>
- *        <li>All boosts of that field (i.e. all boosts under the same field name in that doc) are 
- *            multiplied.</li>
- *        <li>The boost is then encoded into a normalization value by the Similarity
- *            object at index-time: {@link org.apache.lucene.search.similarities.Similarity#computeNorm computeNorm()}.
- *            The actual encoding depends upon the Similarity implementation, but note that most
- *            use a lossy encoding (such as multiplying the boost with document length or similar, packed
- *            into a single byte!).</li>
- *        <li>Decoding of any index-time normalization values and integration into the document's score is also performed 
- *            at search time by the Similarity.</li>
- *     </ul>
+ * <p>Lucene allows influencing the score contribution of various parts of the query by wrapping with
+ *    {@link org.apache.lucene.search.BoostQuery}.</p>
  * 
  * <a name="changingScoring"></a>
  * <h2>Changing Scoring &mdash; Similarity</h2>
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
index 6763118..74978fd 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
@@ -96,12 +96,12 @@ public class BM25Similarity extends Similarity {
     }
   }
   
-  /** The default implementation encodes <code>boost / sqrt(length)</code>
+  /** The default implementation encodes <code>1 / sqrt(length)</code>
    * with {@link SmallFloat#floatToByte315(float)}.  This is compatible with 
-   * Lucene's default implementation.  If you change this, then you should 
-   * change {@link #decodeNormValue(byte)} to match. */
-  protected byte encodeNormValue(float boost, int fieldLength) {
-    return SmallFloat.floatToByte315(boost / (float) Math.sqrt(fieldLength));
+   * Lucene's historic implementation: {@link ClassicSimilarity}.  If you
+   * change this, then you should change {@link #decodeNormValue(byte)} to match. */
+  protected byte encodeNormValue(int fieldLength) {
+    return SmallFloat.floatToByte315((float) (1 / Math.sqrt(fieldLength)));
   }
 
   /** The default implementation returns <code>1 / f<sup>2</sup></code>
@@ -146,7 +146,7 @@ public class BM25Similarity extends Similarity {
   @Override
   public final long computeNorm(FieldInvertState state) {
     final int numTerms = discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength();
-    return encodeNormValue(state.getBoost(), numTerms);
+    return encodeNormValue(numTerms);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/ClassicSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/ClassicSimilarity.java
index 5a1e237..f56575f 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/ClassicSimilarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/ClassicSimilarity.java
@@ -69,8 +69,7 @@ public class ClassicSimilarity extends TFIDFSimilarity {
    * represent are rounded down to the largest representable value. Positive
    * values too small to represent are rounded up to the smallest positive
    * representable value.
-   * 
-   * @see org.apache.lucene.document.Field#setBoost(float)
+   *
    * @see org.apache.lucene.util.SmallFloat
    */
   @Override
@@ -103,7 +102,7 @@ public class ClassicSimilarity extends TFIDFSimilarity {
       numTerms = state.getLength() - state.getNumOverlap();
     else
       numTerms = state.getLength();
-    return state.getBoost() * ((float) (1.0 / Math.sqrt(numTerms)));
+    return (float) (1.0 / Math.sqrt(numTerms));
   }
 
   /** Implemented as <code>sqrt(freq)</code>. */
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/SimilarityBase.java b/lucene/core/src/java/org/apache/lucene/search/similarities/SimilarityBase.java
index 925dc59..dbf8d45 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/SimilarityBase.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/SimilarityBase.java
@@ -235,19 +235,19 @@ public abstract class SimilarityBase extends Similarity {
       numTerms = state.getLength() - state.getNumOverlap();
     else
       numTerms = state.getLength();
-    return encodeNormValue(state.getBoost(), numTerms);
+    return encodeNormValue(numTerms);
   }
   
   /** Decodes a normalization factor (document length) stored in an index.
-   * @see #encodeNormValue(float,float)
+   * @see #encodeNormValue(float)
    */
   protected float decodeNormValue(byte norm) {
     return NORM_TABLE[norm & 0xFF];  // & 0xFF maps negative bytes to positive above 127
   }
   
   /** Encodes the length to a byte via SmallFloat. */
-  protected byte encodeNormValue(float boost, float length) {
-    return SmallFloat.floatToByte315((boost / (float) Math.sqrt(length)));
+  protected byte encodeNormValue(float length) {
+    return SmallFloat.floatToByte315((float) (1 / Math.sqrt(length)));
   }
   
   // ----------------------------- Static methods ------------------------------
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
index 12ab1a2..2246561 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
@@ -369,49 +369,9 @@ import org.apache.lucene.util.BytesRef;
  *
  *    <li>
  *      <A NAME="formula_norm"></A>
- *      <b><i>norm(t,d)</i></b> encapsulates a few (indexing time) boost and length factors:
- *
- *      <ul>
- *        <li><b>Field boost</b> - set by calling
- *        {@link org.apache.lucene.document.Field#setBoost(float) field.setBoost()}
- *        before adding the field to a document.
- *        </li>
- *        <li><b>lengthNorm</b> - computed
- *        when the document is added to the index in accordance with the number of tokens
- *        of this field in the document, so that shorter fields contribute more to the score.
- *        LengthNorm is computed by the Similarity class in effect at indexing.
- *        </li>
- *      </ul>
- *      The {@link #computeNorm} method is responsible for
- *      combining all of these factors into a single float.
- *
- *      <p>
- *      When a document is added to the index, all the above factors are multiplied.
- *      If the document has multiple fields with the same name, all their boosts are multiplied together:
- *
- *      <br>&nbsp;<br>
- *      <table cellpadding="1" cellspacing="0" border="0" style="width:auto; margin-left:auto; margin-right:auto" summary="index-time normalization">
- *        <tr>
- *          <td valign="middle" align="right" rowspan="1">
- *            norm(t,d) &nbsp; = &nbsp;
- *            lengthNorm
- *            &nbsp;&middot;&nbsp;
- *          </td>
- *          <td valign="bottom" align="center" rowspan="1" style="text-align: center">
- *            <big><big><big>&prod;</big></big></big>
- *          </td>
- *          <td valign="middle" align="right" rowspan="1">
- *            {@link org.apache.lucene.index.IndexableField#boost() f.boost}()
- *          </td>
- *        </tr>
- *        <tr valign="top">
- *          <td></td>
- *          <td align="center" style="text-align: center"><small>field <i><b>f</b></i> in <i>d</i> named as <i><b>t</b></i></small></td>
- *          <td></td>
- *        </tr>
- *      </table>
- *      Note that search time is too late to modify this <i>norm</i> part of scoring, 
- *      e.g. by using a different {@link Similarity} for search.
+ *      <b><i>norm(t,d)</i></b> is an index-time boost factor that solely
+ *      depends on the number of tokens of this field in the document, so
+ *      that shorter fields contribute more to the score.
  *    </li>
  * </ol>
  *
diff --git a/lucene/core/src/test/org/apache/lucene/document/TestField.java b/lucene/core/src/test/org/apache/lucene/document/TestField.java
index 4ef7ffb..c087505 100644
--- a/lucene/core/src/test/org/apache/lucene/document/TestField.java
+++ b/lucene/core/src/test/org/apache/lucene/document/TestField.java
@@ -38,7 +38,6 @@ public class TestField extends LuceneTestCase {
   public void testDoublePoint() throws Exception {
     Field field = new DoublePoint("foo", 5d);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -58,7 +57,6 @@ public class TestField extends LuceneTestCase {
   public void testDoublePoint2D() throws Exception {
     DoublePoint field = new DoublePoint("foo", 5d, 4d);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -84,7 +82,6 @@ public class TestField extends LuceneTestCase {
   public void testDoubleDocValuesField() throws Exception {
     DoubleDocValuesField field = new DoubleDocValuesField("foo", 5d);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -103,7 +100,6 @@ public class TestField extends LuceneTestCase {
   public void testFloatDocValuesField() throws Exception {
     FloatDocValuesField field = new FloatDocValuesField("foo", 5f);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -122,7 +118,6 @@ public class TestField extends LuceneTestCase {
   public void testFloatPoint() throws Exception {
     Field field = new FloatPoint("foo", 5f);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -142,7 +137,6 @@ public class TestField extends LuceneTestCase {
   public void testFloatPoint2D() throws Exception {
     FloatPoint field = new FloatPoint("foo", 5f, 4f);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -166,7 +160,6 @@ public class TestField extends LuceneTestCase {
   public void testIntPoint() throws Exception {
     Field field = new IntPoint("foo", 5);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -186,7 +179,6 @@ public class TestField extends LuceneTestCase {
   public void testIntPoint2D() throws Exception {
     IntPoint field = new IntPoint("foo", 5, 4);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -210,7 +202,6 @@ public class TestField extends LuceneTestCase {
   public void testNumericDocValuesField() throws Exception {
     NumericDocValuesField field = new NumericDocValuesField("foo", 5L);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -229,7 +220,6 @@ public class TestField extends LuceneTestCase {
   public void testLongPoint() throws Exception {
     Field field = new LongPoint("foo", 5);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -249,7 +239,6 @@ public class TestField extends LuceneTestCase {
   public void testLongPoint2D() throws Exception {
     LongPoint field = new LongPoint("foo", 5, 4);
 
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -273,7 +262,6 @@ public class TestField extends LuceneTestCase {
   public void testSortedBytesDocValuesField() throws Exception {
     SortedDocValuesField field = new SortedDocValuesField("foo", new BytesRef("bar"));
 
-    trySetBoost(field);
     trySetByteValue(field);
     field.setBytesValue("fubar".getBytes(StandardCharsets.UTF_8));
     field.setBytesValue(new BytesRef("baz"));
@@ -292,7 +280,6 @@ public class TestField extends LuceneTestCase {
   public void testBinaryDocValuesField() throws Exception {
     BinaryDocValuesField field = new BinaryDocValuesField("foo", new BytesRef("bar"));
 
-    trySetBoost(field);
     trySetByteValue(field);
     field.setBytesValue("fubar".getBytes(StandardCharsets.UTF_8));
     field.setBytesValue(new BytesRef("baz"));
@@ -315,7 +302,6 @@ public class TestField extends LuceneTestCase {
     };
 
     for (Field field : fields) {
-      trySetBoost(field);
       trySetByteValue(field);
       trySetBytesValue(field);
       trySetBytesRefValue(field);
@@ -339,7 +325,6 @@ public class TestField extends LuceneTestCase {
     };
 
     for (Field field : fields) {
-      field.setBoost(5f);
       trySetByteValue(field);
       trySetBytesValue(field);
       trySetBytesRefValue(field);
@@ -353,14 +338,12 @@ public class TestField extends LuceneTestCase {
       field.setTokenStream(new CannedTokenStream(new Token("foo", 0, 3)));
       
       assertEquals("baz", field.stringValue());
-      assertEquals(5f, field.boost(), 0f);
     }
   }
   
   public void testTextFieldReader() throws Exception {
     Field field = new TextField("foo", new StringReader("bar"));
 
-    field.setBoost(5f);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -374,7 +357,6 @@ public class TestField extends LuceneTestCase {
     field.setTokenStream(new CannedTokenStream(new Token("foo", 0, 3)));
       
     assertNotNull(field.readerValue());
-    assertEquals(5f, field.boost(), 0f);
   }
   
   /* TODO: this is pretty expert and crazy
@@ -391,7 +373,6 @@ public class TestField extends LuceneTestCase {
     };
     
     for (Field field : fields) {
-      trySetBoost(field);
       trySetByteValue(field);
       field.setBytesValue("baz".getBytes(StandardCharsets.UTF_8));
       field.setBytesValue(new BytesRef("baz"));
@@ -410,7 +391,6 @@ public class TestField extends LuceneTestCase {
   
   public void testStoredFieldString() throws Exception {
     Field field = new StoredField("foo", "bar");
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -428,7 +408,6 @@ public class TestField extends LuceneTestCase {
   
   public void testStoredFieldInt() throws Exception {
     Field field = new StoredField("foo", 1);
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -446,7 +425,6 @@ public class TestField extends LuceneTestCase {
   
   public void testStoredFieldDouble() throws Exception {
     Field field = new StoredField("foo", 1D);
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -464,7 +442,6 @@ public class TestField extends LuceneTestCase {
   
   public void testStoredFieldFloat() throws Exception {
     Field field = new StoredField("foo", 1F);
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -482,7 +459,6 @@ public class TestField extends LuceneTestCase {
   
   public void testStoredFieldLong() throws Exception {
     Field field = new StoredField("foo", 1L);
-    trySetBoost(field);
     trySetByteValue(field);
     trySetBytesValue(field);
     trySetBytesRefValue(field);
@@ -586,10 +562,4 @@ public class TestField extends LuceneTestCase {
     });
   }
   
-  private void trySetBoost(Field f) {
-    expectThrows(IllegalArgumentException.class, () -> {
-      f.setBoost(5.0f);
-    });
-  }
-  
 }
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestCustomNorms.java b/lucene/core/src/test/org/apache/lucene/index/TestCustomNorms.java
index 65310cf..f193140 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestCustomNorms.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestCustomNorms.java
@@ -17,6 +17,8 @@
 package org.apache.lucene.index;
 
 import java.io.IOException;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -53,9 +55,9 @@ public class TestCustomNorms extends LuceneTestCase {
     int num = atLeast(100);
     for (int i = 0; i < num; i++) {
       Document doc = docs.nextDoc();
-      float nextFloat = random().nextFloat();
-      Field f = new TextField(floatTestField, "" + nextFloat, Field.Store.YES);
-      f.setBoost(nextFloat);
+      int boost = TestUtil.nextInt(random(), 1, 10);
+      String value = IntStream.range(0, boost).mapToObj(k -> Integer.toString(boost)).collect(Collectors.joining(" "));
+      Field f = new TextField(floatTestField, value, Field.Store.YES);
 
       doc.add(f);
       writer.addDocument(doc);
@@ -71,9 +73,9 @@ public class TestCustomNorms extends LuceneTestCase {
     assertNotNull(norms);
     for (int i = 0; i < open.maxDoc(); i++) {
       Document document = open.document(i);
-      float expected = Float.parseFloat(document.get(floatTestField));
+      int expected = Integer.parseInt(document.get(floatTestField).split(" ")[0]);
       assertEquals(i, norms.nextDoc());
-      assertEquals(expected, Float.intBitsToFloat((int)norms.longValue()), 0.0f);
+      assertEquals(expected, norms.longValue());
     }
     open.close();
     dir.close();
@@ -97,7 +99,7 @@ public class TestCustomNorms extends LuceneTestCase {
 
     @Override
     public long computeNorm(FieldInvertState state) {
-      return Float.floatToIntBits(state.getBoost());
+      return state.getLength();
     }
     
     @Override
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestFieldReuse.java b/lucene/core/src/test/org/apache/lucene/index/TestFieldReuse.java
index 977df3d..c5552a4 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestFieldReuse.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestFieldReuse.java
@@ -86,11 +86,6 @@ public class TestFieldReuse extends BaseTokenStreamTestCase {
       lastSeen = reuse;
       return lastReturned = new CannedTokenStream(new Token("unimportant", 0, 10));
     }
-    
-    @Override
-    public float boost() {
-      return 1;
-    } 
 
     @Override
     public BytesRef binaryValue() {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexSorting.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexSorting.java
index c2b180a..4275056 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexSorting.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexSorting.java
@@ -29,6 +29,8 @@ import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
@@ -1939,7 +1941,7 @@ public class TestIndexSorting extends LuceneTestCase {
     @Override
     public long computeNorm(FieldInvertState state) {
       if (state.getName().equals("norms")) {
-        return Float.floatToIntBits(state.getBoost());
+        return state.getLength();
       } else {
         return in.computeNorm(state);
       }
@@ -2021,8 +2023,8 @@ public class TestIndexSorting extends LuceneTestCase {
       positions.setId(id);
       doc.add(new Field("positions", positions, POSITIONS_TYPE));
       doc.add(new NumericDocValuesField("numeric", id));
-      TextField norms = new TextField("norms", Integer.toString(id), Store.NO);
-      norms.setBoost(Float.intBitsToFloat(id));
+      String value = IntStream.range(0, id).mapToObj(k -> Integer.toString(id)).collect(Collectors.joining(" "));
+      TextField norms = new TextField("norms", value, Store.NO);
       doc.add(norms);
       doc.add(new BinaryDocValuesField("binary", new BytesRef(Integer.toString(id))));
       doc.add(new SortedDocValuesField("sorted", new BytesRef(Integer.toString(id))));
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
index 6fdfca8..987852f 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
@@ -19,7 +19,6 @@ package org.apache.lucene.index;
 
 import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.io.Reader;
 import java.io.StringReader;
 import java.nio.file.NoSuchFileException;
 import java.util.ArrayList;
@@ -1687,71 +1686,6 @@ public class TestIndexWriterExceptions extends LuceneTestCase {
     uoe.doFail = false;
     d.close();
   }
-
-  public void testBoostOmitNorms() throws Exception {
-    Directory dir = newDirectory();
-    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));
-    iwc.setMergePolicy(newLogMergePolicy());
-    IndexWriter iw = new IndexWriter(dir, iwc);
-    Document doc = new Document();
-    doc.add(new StringField("field1", "sometext", Field.Store.YES));
-    doc.add(new TextField("field2", "sometext", Field.Store.NO));
-    doc.add(new StringField("foo", "bar", Field.Store.NO));
-    iw.addDocument(doc); // add an 'ok' document
-    expectThrows(UnsupportedOperationException.class, () -> {
-      // try to boost with norms omitted
-      List<IndexableField> list = new ArrayList<>();
-      list.add(new IndexableField() {
-        @Override
-        public String name() {
-          return "foo";
-        }
-
-        @Override
-        public IndexableFieldType fieldType() {
-          return StringField.TYPE_NOT_STORED;
-        }
-
-        @Override
-        public float boost() {
-          return 5f;
-        }
-
-        @Override
-        public BytesRef binaryValue() {
-          return null;
-        }
-
-        @Override
-        public String stringValue() {
-          return "baz";
-        }
-
-        @Override
-        public Reader readerValue() {
-          return null;
-        }
-
-        @Override
-        public Number numericValue() {
-          return null;
-        }
-
-        @Override
-        public TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) {
-          return null;
-        }
-      });
-      iw.addDocument(list);
-    });
-
-    DirectoryReader ir = DirectoryReader.open(iw);
-    assertEquals(1, ir.numDocs());
-    assertEquals("sometext", ir.document(0).get("field1"));
-    ir.close();
-    iw.close();
-    dir.close();
-  }
   
   // See LUCENE-4870 TooManyOpenFiles errors are thrown as
   // FNFExceptions which can trigger data loss.
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java
index 67edab9..e60a3e1 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java
@@ -111,11 +111,6 @@ public class TestIndexableField extends LuceneTestCase {
     }
 
     @Override
-    public float boost() {
-      return 1.0f + random().nextFloat();
-    }
-
-    @Override
     public BytesRef binaryValue() {
       if ((counter%10) == 3) {
         final byte[] bytes = new byte[10];
@@ -339,11 +334,6 @@ public class TestIndexableField extends LuceneTestCase {
     }
 
     @Override
-    public float boost() {
-      return 1.0f;
-    }
-
-    @Override
     public Number numericValue() {
       return null;
     }
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestNorms.java b/lucene/core/src/test/org/apache/lucene/index/TestNorms.java
index 52038bc..363f57e 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestNorms.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestNorms.java
@@ -19,6 +19,8 @@ package org.apache.lucene.index;
 
 import java.io.IOException;
 import java.util.Random;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -117,7 +119,7 @@ public class TestNorms extends LuceneTestCase {
     assertNotNull(normValues);
     for (int i = 0; i < open.maxDoc(); i++) {
       Document document = open.document(i);
-      int expected = Integer.parseInt(document.get(byteTestField));
+      int expected = Integer.parseInt(document.get(byteTestField).split(" ")[0]);
       assertEquals(i, normValues.nextDoc());
       assertEquals(expected, normValues.longValue());
     }
@@ -139,9 +141,9 @@ public class TestNorms extends LuceneTestCase {
     int num = atLeast(100);
     for (int i = 0; i < num; i++) {
       Document doc = docs.nextDoc();
-      int boost = random().nextInt(255);
-      Field f = new TextField(byteTestField, "" + boost, Field.Store.YES);
-      f.setBoost(boost);
+      int boost = TestUtil.nextInt(random, 1, 255);
+      String value = IntStream.range(0, boost).mapToObj(k -> Integer.toString(boost)).collect(Collectors.joining(" "));
+      Field f = new TextField(byteTestField, value, Field.Store.YES);
       doc.add(f);
       writer.addDocument(doc);
       doc.removeField(byteTestField);
@@ -173,8 +175,7 @@ public class TestNorms extends LuceneTestCase {
 
     @Override
     public long computeNorm(FieldInvertState state) {
-      int boost = (int) state.getBoost();
-      return (0xFF & boost);
+      return state.getLength();
     }
 
     @Override
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestOmitTf.java b/lucene/core/src/test/org/apache/lucene/index/TestOmitTf.java
index 3a13d9b..0deafdd 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestOmitTf.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestOmitTf.java
@@ -46,7 +46,7 @@ public class TestOmitTf extends LuceneTestCase {
   public static class SimpleSimilarity extends TFIDFSimilarity {
     @Override public float decodeNormValue(long norm) { return norm; }
     @Override public long encodeNormValue(float f) { return (long) f; }
-    @Override public float lengthNorm(FieldInvertState state) { return state.getBoost(); }
+    @Override public float lengthNorm(FieldInvertState state) { return 1; }
     @Override public float tf(float freq) { return freq; }
     @Override public float sloppyFreq(int distance) { return 2.0f; }
     @Override public float idf(long docFreq, long docCount) { return 1.0f; }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
index 87046c7..e20163a 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
@@ -74,7 +74,7 @@ public class TestDisjunctionMaxQuery extends LuceneTestCase {
     @Override
     public float lengthNorm(FieldInvertState state) {
       // Disable length norm
-      return state.getBoost();
+      return 1;
     }
     
     @Override
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDocBoost.java b/lucene/core/src/test/org/apache/lucene/search/TestDocBoost.java
deleted file mode 100644
index ecc4645..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/TestDocBoost.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.*;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-/** Document boost unit test.
- *
- *
- */
-public class TestDocBoost extends LuceneTestCase {
-
-  public void testDocBoost() throws Exception {
-    Directory store = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), store, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
-
-    Field f1 = newTextField("field", "word", Field.Store.YES);
-    Field f2 = newTextField("field", "word", Field.Store.YES);
-    f2.setBoost(2.0f);
-
-    Document d1 = new Document();
-    Document d2 = new Document();
-
-    d1.add(f1);                                 // boost = 1
-    d2.add(f2);                                 // boost = 2
-
-    writer.addDocument(d1);
-    writer.addDocument(d2);
-
-    IndexReader reader = writer.getReader();
-    writer.close();
-
-    final float[] scores = new float[4];
-
-    IndexSearcher searcher = newSearcher(reader);
-    searcher.search
-      (new TermQuery(new Term("field", "word")),
-       new SimpleCollector() {
-         private int base = 0;
-         private Scorer scorer;
-         @Override
-         public void setScorer(Scorer scorer) {
-          this.scorer = scorer;
-         }
-         @Override
-         public final void collect(int doc) throws IOException {
-           scores[doc + base] = scorer.score();
-         }
-         @Override
-         protected void doSetNextReader(LeafReaderContext context) throws IOException {
-           base = context.docBase;
-         }
-         @Override
-         public boolean needsScores() {
-           return true;
-         }
-       });
-
-    float lastScore = 0.0f;
-
-    for (int i = 0; i < 2; i++) {
-      if (VERBOSE) {
-        System.out.println(searcher.explain(new TermQuery(new Term("field", "word")), i));
-      }
-      if (scores[i] != 0.0) {
-        assertTrue("score: " + scores[i] + " should be > lastScore: " + lastScore, scores[i] > lastScore);
-      }
-      lastScore = scores[i];
-    }
-    
-    reader.close();
-    store.close();
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMatchAllDocsQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestMatchAllDocsQuery.java
index 8e9fb28..ee02eed 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMatchAllDocsQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMatchAllDocsQuery.java
@@ -45,9 +45,9 @@ public class TestMatchAllDocsQuery extends LuceneTestCase {
   public void testQuery() throws Exception {
     Directory dir = newDirectory();
     IndexWriter iw = new IndexWriter(dir, newIndexWriterConfig(analyzer).setMaxBufferedDocs(2).setMergePolicy(newLogMergePolicy()));
-    addDoc("one", iw, 1f);
-    addDoc("two", iw, 20f);
-    addDoc("three four", iw, 300f);
+    addDoc("one", iw);
+    addDoc("two", iw);
+    addDoc("three four", iw);
     IndexReader ir = DirectoryReader.open(iw);
 
     IndexSearcher is = newSearcher(ir);
@@ -92,10 +92,9 @@ public class TestMatchAllDocsQuery extends LuceneTestCase {
     assertTrue(q1.equals(q2));
   }
   
-  private void addDoc(String text, IndexWriter iw, float boost) throws IOException {
+  private void addDoc(String text, IndexWriter iw) throws IOException {
     Document doc = new Document();
     Field f = newTextField("key", text, Field.Store.YES);
-    f.setBoost(boost);
     doc.add(f);
     iw.addDocument(doc);
   }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSimilarity.java b/lucene/core/src/test/org/apache/lucene/search/TestSimilarity.java
index 966e5da..3faa5c2 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSimilarity.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSimilarity.java
@@ -39,7 +39,7 @@ import org.apache.lucene.document.Document;
 public class TestSimilarity extends LuceneTestCase {
   
   public static class SimpleSimilarity extends ClassicSimilarity {
-    @Override public float lengthNorm(FieldInvertState state) { return state.getBoost(); }
+    @Override public float lengthNorm(FieldInvertState state) { return 1; }
     @Override public float tf(float freq) { return freq; }
     @Override public float sloppyFreq(int distance) { return 2.0f; }
     @Override public float idf(long docFreq, long docCount) { return 1.0f; }
diff --git a/lucene/core/src/test/org/apache/lucene/search/similarities/TestBooleanSimilarity.java b/lucene/core/src/test/org/apache/lucene/search/similarities/TestBooleanSimilarity.java
index 15b1448..23f65d3 100644
--- a/lucene/core/src/test/org/apache/lucene/search/similarities/TestBooleanSimilarity.java
+++ b/lucene/core/src/test/org/apache/lucene/search/similarities/TestBooleanSimilarity.java
@@ -106,8 +106,7 @@ public class TestBooleanSimilarity extends LuceneTestCase {
       final int length = TestUtil.nextInt(random(), 1, 100);
       final int position = random().nextInt(length);
       final int numOverlaps = random().nextInt(50);
-      final float boost = random().nextFloat() * 10;
-      FieldInvertState state = new FieldInvertState("foo", position, length, numOverlaps, 100, boost);
+      FieldInvertState state = new FieldInvertState("foo", position, length, numOverlaps, 100);
       assertEquals(
           sim2.computeNorm(state),
           sim1.computeNorm(state),
diff --git a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java
index aec55de..373b9e6 100644
--- a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java
+++ b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java
@@ -593,7 +593,6 @@ public class TestSimilarityBase extends LuceneTestCase {
     FieldInvertState state = new FieldInvertState("foo");
     state.setLength(5);
     state.setNumOverlap(2);
-    state.setBoost(3);
     assertEquals(expected.computeNorm(state), actual.computeNorm(state));
     expected.setDiscountOverlaps(true);
     actual.setDiscountOverlaps(true);
diff --git a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
index dc4a666..533a60e 100644
--- a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
+++ b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
@@ -275,7 +275,7 @@ public class MemoryIndex {
       throw new IllegalArgumentException("analyzer must not be null");
     
     TokenStream stream = analyzer.tokenStream(fieldName, text);
-    storeTerms(getInfo(fieldName, defaultFieldType), stream, 1.0f,
+    storeTerms(getInfo(fieldName, defaultFieldType), stream,
         analyzer.getPositionIncrementGap(fieldName), analyzer.getOffsetGap(fieldName));
   }
 
@@ -358,31 +358,7 @@ public class MemoryIndex {
       }
     };
   }
-  
-  /**
-   * Equivalent to <code>addField(fieldName, stream, 1.0f)</code>.
-   *
-   * @param fieldName
-   *            a name to be associated with the text
-   * @param stream
-   *            the token stream to retrieve tokens from
-   */
-  public void addField(String fieldName, TokenStream stream) {
-    addField(fieldName, stream, 1.0f);
-  }
 
-  /**
-   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.
-   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.
-   *
-   * @param field the field to add
-   * @param analyzer the analyzer to use for term analysis
-   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these
-   *                                  structures are not supported by MemoryIndex
-   */
-  public void addField(IndexableField field, Analyzer analyzer) {
-    addField(field, analyzer, 1.0f);
-  }
 
   /**
    * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.
@@ -390,9 +366,8 @@ public class MemoryIndex {
    *
    * @param field the field to add
    * @param analyzer the analyzer to use for term analysis
-   * @param boost a field boost
    */
-  public void addField(IndexableField field, Analyzer analyzer, float boost) {
+  public void addField(IndexableField field, Analyzer analyzer) {
 
     Info info = getInfo(field.name(), field.fieldType());
 
@@ -409,7 +384,7 @@ public class MemoryIndex {
       positionIncrementGap = 0;
     }
     if (tokenStream != null) {
-      storeTerms(info, tokenStream, boost, positionIncrementGap, offsetGap);
+      storeTerms(info, tokenStream, positionIncrementGap, offsetGap);
     }
 
     DocValuesType docValuesType = field.fieldType().docValuesType();
@@ -451,13 +426,9 @@ public class MemoryIndex {
    *            a name to be associated with the text
    * @param stream
    *            the token stream to retrieve tokens from.
-   * @param boost
-   *            the boost factor for hits for this field
-   *  
-   * @see org.apache.lucene.document.Field#setBoost(float)
    */
-  public void addField(String fieldName, TokenStream stream, float boost) {
-    addField(fieldName, stream, boost, 0);
+  public void addField(String fieldName, TokenStream stream) {
+    addField(fieldName, stream, 0);
   }
 
 
@@ -472,17 +443,13 @@ public class MemoryIndex {
    *            a name to be associated with the text
    * @param stream
    *            the token stream to retrieve tokens from.
-   * @param boost
-   *            the boost factor for hits for this field
    *
    * @param positionIncrementGap
    *            the position increment gap if fields with the same name are added more than once
    *
-   *
-   * @see org.apache.lucene.document.Field#setBoost(float)
    */
-  public void addField(String fieldName, TokenStream stream, float boost, int positionIncrementGap) {
-    addField(fieldName, stream, boost, positionIncrementGap, 1);
+  public void addField(String fieldName, TokenStream stream, int positionIncrementGap) {
+    addField(fieldName, stream, positionIncrementGap, 1);
   }
 
   /**
@@ -497,17 +464,14 @@ public class MemoryIndex {
    *            a name to be associated with the text
    * @param tokenStream
    *            the token stream to retrieve tokens from. It's guaranteed to be closed no matter what.
-   * @param boost
-   *            the boost factor for hits for this field
    * @param positionIncrementGap
    *            the position increment gap if fields with the same name are added more than once
    * @param offsetGap
    *            the offset gap if fields with the same name are added more than once
-   * @see org.apache.lucene.document.Field#setBoost(float)
    */
-  public void addField(String fieldName, TokenStream tokenStream, float boost, int positionIncrementGap, int offsetGap) {
+  public void addField(String fieldName, TokenStream tokenStream, int positionIncrementGap, int offsetGap) {
     Info info = getInfo(fieldName, defaultFieldType);
-    storeTerms(info, tokenStream, boost, positionIncrementGap, offsetGap);
+    storeTerms(info, tokenStream, positionIncrementGap, offsetGap);
   }
 
   private Info getInfo(String fieldName, IndexableFieldType fieldType) {
@@ -600,20 +564,13 @@ public class MemoryIndex {
     }
   }
 
-  private void storeTerms(Info info, TokenStream tokenStream, float boost, int positionIncrementGap, int offsetGap) {
-
-    if (boost <= 0.0f) {
-      throw new IllegalArgumentException("boost factor must be greater than 0.0");
-    }
+  private void storeTerms(Info info, TokenStream tokenStream, int positionIncrementGap, int offsetGap) {
 
     int pos = -1;
     int offset = 0;
-    if (info.numTokens == 0) {
-      info.boost = boost;
-    } else if (info.numTokens > 0) {
+    if (info.numTokens > 0) {
       pos = info.lastPosition + positionIncrementGap;
       offset = info.lastOffset + offsetGap;
-      info.boost *= boost;
     }
 
     try (TokenStream stream = tokenStream) {
@@ -846,9 +803,6 @@ public class MemoryIndex {
     
     /** Number of overlapping tokens for this field */
     private int numOverlapTokens;
-    
-    /** Boost factor for hits for this field */
-    private float boost;
 
     private long sumTotalTermFreq;
 
@@ -939,7 +893,7 @@ public class MemoryIndex {
     NumericDocValues getNormDocValues() {
       if (norm == null) {
         FieldInvertState invertState = new FieldInvertState(fieldInfo.name, fieldInfo.number,
-            numTokens, numOverlapTokens, 0, boost);
+            numTokens, numOverlapTokens, 0);
         final long value = normSimilarity.computeNorm(invertState);
         if (DEBUG) System.err.println("MemoryIndexReader.norms: " + fieldInfo.name + ":" + value + ":" + numTokens);
 
diff --git a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java
index 4e2189c..f34f30c 100644
--- a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java
+++ b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java
@@ -422,11 +422,11 @@ public class TestMemoryIndex extends LuceneTestCase {
     }
   }
 
-  public void testPointValuesDoNotAffectBoostPositionsOrOffset() throws Exception {
+  public void testPointValuesDoNotAffectPositionsOrOffset() throws Exception {
     MemoryIndex mi = new MemoryIndex(true, true);
-    mi.addField(new TextField("text", "quick brown fox", Field.Store.NO), analyzer, 5f);
-    mi.addField(new BinaryPoint("text", "quick".getBytes(StandardCharsets.UTF_8)), analyzer, 5f);
-    mi.addField(new BinaryPoint("text", "brown".getBytes(StandardCharsets.UTF_8)), analyzer, 5f);
+    mi.addField(new TextField("text", "quick brown fox", Field.Store.NO), analyzer);
+    mi.addField(new BinaryPoint("text", "quick".getBytes(StandardCharsets.UTF_8)), analyzer);
+    mi.addField(new BinaryPoint("text", "brown".getBytes(StandardCharsets.UTF_8)), analyzer);
     LeafReader leafReader = mi.createSearcher().getIndexReader().leaves().get(0).reader();
     TermsEnum tenum = leafReader.terms("text").iterator();
 
diff --git a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java
index 03c17a5..8a751b1 100644
--- a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java
+++ b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java
@@ -536,14 +536,13 @@ public class TestMemoryIndexAgainstRAMDir extends BaseTokenStreamTestCase {
     MemoryIndex mi = new MemoryIndex(true, true);
     MockAnalyzer mockAnalyzer = new MockAnalyzer(random());
 
-    mi.addField(new BinaryDocValuesField("text", new BytesRef("quick brown fox")), mockAnalyzer, 5f);
-    mi.addField(new TextField("text", "quick brown fox", Field.Store.NO), mockAnalyzer, 5f);
+    mi.addField(new BinaryDocValuesField("text", new BytesRef("quick brown fox")), mockAnalyzer);
+    mi.addField(new TextField("text", "quick brown fox", Field.Store.NO), mockAnalyzer);
     LeafReader leafReader = mi.createSearcher().getIndexReader().leaves().get(0).reader();
 
     Document doc = new Document();
     doc.add(new BinaryDocValuesField("text", new BytesRef("quick brown fox")));
     Field field = new TextField("text", "quick brown fox", Field.Store.NO);
-    field.setBoost(5f);
     doc.add(field);
     Directory dir = newDirectory();
     IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), mockAnalyzer));
diff --git a/lucene/misc/src/java/org/apache/lucene/document/LazyDocument.java b/lucene/misc/src/java/org/apache/lucene/document/LazyDocument.java
index c1683a7..7fd8d98 100644
--- a/lucene/misc/src/java/org/apache/lucene/document/LazyDocument.java
+++ b/lucene/misc/src/java/org/apache/lucene/document/LazyDocument.java
@@ -162,11 +162,6 @@ public class LazyDocument {
     }
 
     @Override
-    public float boost() {
-      return 1.0f;
-    }
-
-    @Override
     public BytesRef binaryValue() {
       return getRealValue().binaryValue();
     }
diff --git a/lucene/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java b/lucene/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java
index 7eeeae0..9307b94 100644
--- a/lucene/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java
+++ b/lucene/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java
@@ -111,7 +111,7 @@ public class SweetSpotSimilarity extends ClassicSimilarity {
     else
       numTokens = state.getLength();
 
-    return state.getBoost() * computeLengthNorm(numTokens);
+    return computeLengthNorm(numTokens);
   }
 
   /**
diff --git a/lucene/misc/src/test/org/apache/lucene/misc/SweetSpotSimilarityTest.java b/lucene/misc/src/test/org/apache/lucene/misc/SweetSpotSimilarityTest.java
index b618654..cd6a819 100644
--- a/lucene/misc/src/test/org/apache/lucene/misc/SweetSpotSimilarityTest.java
+++ b/lucene/misc/src/test/org/apache/lucene/misc/SweetSpotSimilarityTest.java
@@ -47,7 +47,6 @@ public class SweetSpotSimilarityTest extends LuceneTestCase {
 
     // base case, should degrade
     FieldInvertState invertState = new FieldInvertState("bogus");
-    invertState.setBoost(1.0f);
     for (int i = 1; i < 1000; i++) {
       invertState.setLength(i);
       assertEquals("base case: i="+i,
@@ -108,7 +107,6 @@ public class SweetSpotSimilarityTest extends LuceneTestCase {
     };
 
     invertState = new FieldInvertState("foo");
-    invertState.setBoost(1.0f);
     for (int i = 3; i <=10; i++) {
       invertState.setLength(i);
       assertEquals("f: 3,10: spot i="+i,
@@ -129,7 +127,6 @@ public class SweetSpotSimilarityTest extends LuceneTestCase {
     }
     
     invertState = new FieldInvertState("bar");
-    invertState.setBoost(1.0f);
     for (int i = 8; i <=13; i++) {
       invertState.setLength(i);
       assertEquals("f: 8,13: spot i="+i,
@@ -139,7 +136,6 @@ public class SweetSpotSimilarityTest extends LuceneTestCase {
     }
     
     invertState = new FieldInvertState("yak");
-    invertState.setBoost(1.0f);
     for (int i = 6; i <=9; i++) {
       invertState.setLength(i);
       assertEquals("f: 6,9: spot i="+i,
@@ -149,7 +145,6 @@ public class SweetSpotSimilarityTest extends LuceneTestCase {
     }
     
     invertState = new FieldInvertState("bar");
-    invertState.setBoost(1.0f);
     for (int i = 13; i < 1000; i++) {
       invertState.setLength(i-12);
       final byte normD = computeAndGetNorm(d, invertState);
@@ -162,7 +157,6 @@ public class SweetSpotSimilarityTest extends LuceneTestCase {
     }
     
     invertState = new FieldInvertState("yak");
-    invertState.setBoost(1.0f);
     for (int i = 9; i < 1000; i++) {
       invertState.setLength(i-8);
       final byte normD = computeAndGetNorm(d, invertState);
@@ -179,11 +173,9 @@ public class SweetSpotSimilarityTest extends LuceneTestCase {
 
     for (int i = 9; i < 1000; i++) {
       invertState = new FieldInvertState("a");
-      invertState.setBoost(1.0f);
       invertState.setLength(i);
       final byte normSS = computeAndGetNorm(sp, invertState);
       invertState = new FieldInvertState("b");
-      invertState.setBoost(1.0f);
       invertState.setLength(i);
       final byte normS = computeAndGetNorm(sp, invertState);
       assertTrue("s: i="+i+" : a="+normSS+
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/function/TestLongNormValueSource.java b/lucene/queries/src/test/org/apache/lucene/queries/function/TestLongNormValueSource.java
index cfebc47..11060e5 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/function/TestLongNormValueSource.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/function/TestLongNormValueSource.java
@@ -135,7 +135,6 @@ class PreciseClassicSimilarity extends TFIDFSimilarity {
    * values too small to represent are rounded up to the smallest positive
    * representable value.
    *
-   * @see org.apache.lucene.document.Field#setBoost(float)
    * @see org.apache.lucene.util.SmallFloat
    */
   @Override
@@ -169,7 +168,7 @@ class PreciseClassicSimilarity extends TFIDFSimilarity {
     } else {
       numTerms = state.getLength();
     }
-    return state.getBoost() * ((float) (1.0 / Math.sqrt(numTerms)));
+    return (float) (1.0 / Math.sqrt(numTerms));
   }
 
   /** Implemented as <code>sqrt(freq)</code>. */
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadScoreQuery.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadScoreQuery.java
index 188ef61..2afec44 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadScoreQuery.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadScoreQuery.java
@@ -267,7 +267,7 @@ public class TestPayloadScoreQuery extends LuceneTestCase {
     //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     @Override
     public float lengthNorm(FieldInvertState state) {
-      return state.getBoost();
+      return 1;
     }
 
     @Override
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
index 9cc7067..da46a50 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
@@ -269,7 +269,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     @Override 
     public float lengthNorm(FieldInvertState state) {
-      return state.getBoost();
+      return 1;
     }
 
     @Override
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
index 2ea87f0..24e86e1 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
@@ -85,7 +85,6 @@ public abstract class BaseExplanationTestCase extends LuceneTestCase {
     doc.add(newStringField(KEY, ""+index, Field.Store.NO));
     doc.add(new SortedDocValuesField(KEY, new BytesRef(""+index)));
     Field f = newTextField(FIELD, docFields[index], Field.Store.NO);
-    f.setBoost(index);
     doc.add(f);
     doc.add(newTextField(ALTFIELD, docFields[index], Field.Store.NO));
     return doc;
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index db5e3e6..e22df91 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -45,6 +45,11 @@ Upgrading from Solr 6.x
 * Deprecated collection and configset methods on MiniSolrCloudCluster have been
   removed
 
+* Index-time boosts are not supported anymore. If any boosts are provided, they
+  will be ignored by the indexing chain. As a replacement, index-time scoring
+  factors should be indexed in a separate field and combined with the query
+  score using a function query.
+
 Bug Fixes
 ----------------------
 * SOLR-9262: Connection and read timeouts are being ignored by UpdateShardHandler after SOLR-4509.
diff --git a/solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java b/solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
index 5152768..7d9e1c7 100644
--- a/solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
+++ b/solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
@@ -284,10 +284,10 @@ public class ICUCollationField extends FieldType {
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object value, float boost) {
+  public List<IndexableField> createFields(SchemaField field, Object value) {
     if (field.hasDocValues()) {
       List<IndexableField> fields = new ArrayList<>();
-      fields.add(createField(field, value, boost));
+      fields.add(createField(field, value));
       final BytesRef bytes = getCollationKey(field.getName(), value.toString());
       if (field.multiValued()) {
         fields.add(new SortedSetDocValuesField(field.getName(), bytes));
@@ -296,7 +296,7 @@ public class ICUCollationField extends FieldType {
       }
       return fields;
     } else {
-      return Collections.singletonList(createField(field, value, boost));
+      return Collections.singletonList(createField(field, value));
     }
   }
 
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java
index c80d275..a3d4756 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java
@@ -51,6 +51,7 @@ import java.util.concurrent.atomic.AtomicLong;
 public class DocBuilder {
 
   private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+  private static final AtomicBoolean WARNED_ABOUT_INDEX_TIME_BOOSTS = new AtomicBoolean();
 
   private static final Date EPOCH = new Date(0);
   public static final String DELETE_DOC_BY_ID = "$deleteDocById";
@@ -617,13 +618,12 @@ public class DocBuilder {
     }
     value = arow.get(DOC_BOOST);
     if (value != null) {
-      float value1 = 1.0f;
-      if (value instanceof Number) {
-        value1 = ((Number) value).floatValue();
+      String message = "Ignoring document boost: " + value + " as index-time boosts are not supported anymore";
+      if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+        LOG.warn(message);
       } else {
-        value1 = Float.parseFloat(value.toString());
+        LOG.debug(message);
       }
-      doc.setDocumentBoost(value1);
     }
 
     value = arow.get(SKIP_DOC);
@@ -659,7 +659,7 @@ public class DocBuilder {
           sf = config.getSchemaField(key);
         }
         if (sf != null) {
-          addFieldToDoc(entry.getValue(), sf.getName(), 1.0f, sf.multiValued(), doc);
+          addFieldToDoc(entry.getValue(), sf.getName(), sf.multiValued(), doc);
         }
         //else do nothing. if we add it it may fail
       } else {
@@ -679,7 +679,7 @@ public class DocBuilder {
               }
             }
             if (toWrite) {
-              addFieldToDoc(entry.getValue(), name, f.getBoost(), multiValued, doc);
+              addFieldToDoc(entry.getValue(), name, multiValued, doc);
             }
           }
         }
@@ -687,30 +687,30 @@ public class DocBuilder {
     }
   }
 
-  private void addFieldToDoc(Object value, String name, float boost, boolean multiValued, DocWrapper doc) {
+  private void addFieldToDoc(Object value, String name, boolean multiValued, DocWrapper doc) {
     if (value instanceof Collection) {
       Collection collection = (Collection) value;
       if (multiValued) {
         for (Object o : collection) {
           if (o != null)
-            doc.addField(name, o, boost);
+            doc.addField(name, o);
         }
       } else {
         if (doc.getField(name) == null)
           for (Object o : collection) {
             if (o != null)  {
-              doc.addField(name, o, boost);
+              doc.addField(name, o);
               break;
             }
           }
       }
     } else if (multiValued) {
       if (value != null)  {
-        doc.addField(name, value, boost);
+        doc.addField(name, value);
       }
     } else {
       if (doc.getField(name) == null && value != null)
-        doc.addField(name, value, boost);
+        doc.addField(name, value);
     }
   }
 
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/config/EntityField.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/config/EntityField.java
index b61198d..2b28cb7 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/config/EntityField.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/config/EntityField.java
@@ -30,7 +30,6 @@ import org.w3c.dom.Element;
 public class EntityField {
   private final String column;
   private final String name;
-  private final float boost;
   private final boolean toWrite;
   private final boolean multiValued;
   private final boolean dynamicName;
@@ -40,7 +39,6 @@ public class EntityField {
   public EntityField(Builder b) {
     this.column = b.column;
     this.name = b.name;
-    this.boost = b.boost;
     this.toWrite = b.toWrite;
     this.multiValued = b.multiValued;
     this.dynamicName = b.dynamicName;
@@ -60,10 +58,6 @@ public class EntityField {
     return column;
   }
 
-  public float getBoost() {
-    return boost;
-  }
-
   public boolean isToWrite() {
     return toWrite;
   }
diff --git a/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/ExtractingParams.java b/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/ExtractingParams.java
index 6b587f1..f7917bb 100644
--- a/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/ExtractingParams.java
+++ b/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/ExtractingParams.java
@@ -47,19 +47,6 @@ public interface ExtractingParams {
   public static final String MAP_PREFIX = "fmap.";
 
   /**
-   * The boost value for the name of the field.  The boost can be specified by a name mapping.
-   * <p>
-   * For example
-   * <pre>
-   * map.title=solr.title
-   * boost.solr.title=2.5
-   * </pre>
-   * will boost the solr.title field for this document by 2.5
-   *
-   */
-  public static final String BOOST_PREFIX = "boost.";
-
-  /**
    * Pass in literal values to be added to the document, as in
    * <pre>
    *  literal.myField=Foo 
diff --git a/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/SolrContentHandler.java b/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/SolrContentHandler.java
index 7779451..9268f1c 100644
--- a/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/SolrContentHandler.java
+++ b/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/SolrContentHandler.java
@@ -252,15 +252,13 @@ public class SolrContentHandler extends DefaultHandler implements ExtractingPara
       vals=null;
     }
 
-    float boost = getBoost(name);
-
     if (fval != null) {
-      document.addField(name, transformValue(fval, sf), boost);
+      document.addField(name, transformValue(fval, sf));
     }
 
     if (vals != null) {
       for (String val : vals) {
-        document.addField(name, transformValue(val, sf), boost);
+        document.addField(name, transformValue(val, sf));
       }
     }
 
@@ -336,17 +334,6 @@ public class SolrContentHandler extends DefaultHandler implements ExtractingPara
     return result;
   }
 
-
-  /**
-   * Get the value of any boost factor for the mapped name.
-   *
-   * @param name The name of the field to see if there is a boost specified
-   * @return The boost value
-   */
-  protected float getBoost(String name) {
-    return params.getFloat(BOOST_PREFIX + name, 1.0f);
-  }
-
   /**
    * Get the name mapping
    *
diff --git a/solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor.java b/solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor.java
index ce81ae1..a8d6523 100644
--- a/solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor.java
+++ b/solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor.java
@@ -252,7 +252,7 @@ public abstract class LanguageIdentifierUpdateProcessor extends UpdateRequestPro
           if (mappedOutputField != null) {
             log.debug("Mapping field {} to {}", doc.getFieldValue(docIdField), fieldLang);
             SolrInputField inField = doc.getField(fieldName);
-            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());
+            doc.setField(mappedOutputField, inField.getValue());
             if(!mapKeepOrig) {
               log.debug("Removing old field {}", fieldName);
               doc.removeField(fieldName);
diff --git a/solr/contrib/morphlines-core/src/java/org/apache/solr/morphlines/solr/LoadSolrBuilder.java b/solr/contrib/morphlines-core/src/java/org/apache/solr/morphlines/solr/LoadSolrBuilder.java
index 2c2660b..a3af6e1 100644
--- a/solr/contrib/morphlines-core/src/java/org/apache/solr/morphlines/solr/LoadSolrBuilder.java
+++ b/solr/contrib/morphlines-core/src/java/org/apache/solr/morphlines/solr/LoadSolrBuilder.java
@@ -17,10 +17,12 @@
 package org.apache.solr.morphlines.solr;
 
 import java.io.IOException;
+import java.lang.invoke.MethodHandles;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.common.SolrInputDocument;
@@ -34,6 +36,9 @@ import org.kitesdk.morphline.base.AbstractCommand;
 import org.kitesdk.morphline.base.Configs;
 import org.kitesdk.morphline.base.Metrics;
 import org.kitesdk.morphline.base.Notifications;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import com.codahale.metrics.Timer;
 import com.typesafe.config.Config;
 import com.typesafe.config.ConfigFactory;
@@ -43,6 +48,9 @@ import com.typesafe.config.ConfigFactory;
  */
 public final class LoadSolrBuilder implements CommandBuilder {
 
+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+  private static final AtomicBoolean WARNED_ABOUT_INDEX_TIME_BOOSTS = new AtomicBoolean();
+
   @Override
   public Collection<String> getNames() {
     return Collections.singletonList("loadSolr");
@@ -60,7 +68,6 @@ public final class LoadSolrBuilder implements CommandBuilder {
   private static final class LoadSolr extends AbstractCommand {
     
     private final DocumentLoader loader;
-    private final Map<String, Float> boosts = new HashMap();
     private final Timer elapsedTime;    
     
     public LoadSolr(CommandBuilder builder, Config config, Command parent, Command child, MorphlineContext context) {
@@ -70,10 +77,13 @@ public final class LoadSolrBuilder implements CommandBuilder {
       LOG.debug("solrLocator: {}", locator);
       this.loader = locator.getLoader();
       Config boostsConfig = getConfigs().getConfig(config, "boosts", ConfigFactory.empty());
-      for (Map.Entry<String, Object> entry : new Configs().getEntrySet(boostsConfig)) {
-        String fieldName = entry.getKey();        
-        float boost = Float.parseFloat(entry.getValue().toString().trim());
-        boosts.put(fieldName, boost);
+      if (new Configs().getEntrySet(boostsConfig).isEmpty() == false) {
+        String message = "Ignoring field boosts: as index-time boosts are not supported anymore";
+        if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+          log.warn(message);
+        } else {
+          log.debug(message);
+        }
       }
       validateArguments();
       this.elapsedTime = getTimer(Metrics.ELAPSED_TIME);
@@ -134,20 +144,10 @@ public final class LoadSolrBuilder implements CommandBuilder {
       SolrInputDocument doc = new SolrInputDocument(new HashMap(2 * map.size()));
       for (Map.Entry<String, Collection<Object>> entry : map.entrySet()) {
         String key = entry.getKey();
-        doc.setField(key, entry.getValue(), getBoost(key));
+        doc.setField(key, entry.getValue());
       }
       return doc;
     }
-
-    private float getBoost(String key) {
-      if (boosts.size() > 0) {
-        Float boost = boosts.get(key);
-        if (boost != null) {
-          return boost.floatValue();
-        }
-      }
-      return 1.0f;
-    }
     
   }
 }
diff --git a/solr/contrib/uima/src/java/org/apache/solr/uima/processor/UIMAToSolrMapper.java b/solr/contrib/uima/src/java/org/apache/solr/uima/processor/UIMAToSolrMapper.java
index 024dc4e..ec08ee8 100644
--- a/solr/contrib/uima/src/java/org/apache/solr/uima/processor/UIMAToSolrMapper.java
+++ b/solr/contrib/uima/src/java/org/apache/solr/uima/processor/UIMAToSolrMapper.java
@@ -76,7 +76,7 @@ public class UIMAToSolrMapper {
           if (log.isDebugEnabled()) {
             log.debug("writing {} in {}", new Object[]{featureValue, fieldName});
           }
-          document.addField(fieldName, featureValue, 1.0f);
+          document.addField(fieldName, featureValue);
         }
       }
     } catch (Exception e) {
diff --git a/solr/core/src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler.java b/solr/core/src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler.java
index 4125aa9..fd568df 100644
--- a/solr/core/src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler.java
@@ -84,8 +84,6 @@ public class DocumentAnalysisRequestHandler extends AnalysisRequestHandlerBase {
   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
   private static final XMLErrorLogger xmllog = new XMLErrorLogger(log);
 
-  private static final float DEFAULT_BOOST = 1.0f;
-
   private XMLInputFactory inputFactory;
 
   @Override
@@ -298,7 +296,7 @@ public class DocumentAnalysisRequestHandler extends AnalysisRequestHandlerBase {
             }
             return doc;
           } else if ("field".equals(reader.getLocalName())) {
-            doc.addField(fieldName, text.toString(), DEFAULT_BOOST);
+            doc.addField(fieldName, text.toString());
             if (uniqueKeyField.equals(fieldName)) {
               hasId = true;
             }
diff --git a/solr/core/src/java/org/apache/solr/handler/ExportWriter.java b/solr/core/src/java/org/apache/solr/handler/ExportWriter.java
index 8bdd959..7602d9e 100644
--- a/solr/core/src/java/org/apache/solr/handler/ExportWriter.java
+++ b/solr/core/src/java/org/apache/solr/handler/ExportWriter.java
@@ -1377,7 +1377,7 @@ public class ExportWriter implements SolrCore.RawWriter, Closeable {
             while((o = vals.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {
               BytesRef ref = vals.lookupOrd(o);
               fieldType.indexedToReadable(ref, cref);
-              IndexableField f = fieldType.createField(schemaField, cref.toString(), 1.0f);
+              IndexableField f = fieldType.createField(schemaField, cref.toString());
               if (f == null) w.add(cref.toString());
               else w.add(fieldType.toObject(f));
             }
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java b/solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
index 7f08684..62a50e6 100644
--- a/solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
@@ -298,7 +298,6 @@ public class LukeRequestHandler extends RequestHandlerBase
       if (bytes != null) {
         f.add( "binary", Base64.byteArrayToBase64(bytes.bytes, bytes.offset, bytes.length));
       }
-      f.add( "boost", field.boost() );
       if (!ftype.isPointField()) {
         Term t = new Term(field.name(), ftype!=null ? ftype.storedToIndexed(field) : field.stringValue());
         f.add( "docFreq", t.text()==null ? 0 : reader.docFreq( t ) ); // this can be 0 for non-indexed fields
diff --git a/solr/core/src/java/org/apache/solr/handler/loader/CSVLoaderBase.java b/solr/core/src/java/org/apache/solr/handler/loader/CSVLoaderBase.java
index 84c82d7..b503fa3 100644
--- a/solr/core/src/java/org/apache/solr/handler/loader/CSVLoaderBase.java
+++ b/solr/core/src/java/org/apache/solr/handler/loader/CSVLoaderBase.java
@@ -83,7 +83,7 @@ abstract class CSVLoaderBase extends ContentStreamLoader {
   private class FieldAdder {
     void add(SolrInputDocument doc, int line, int column, String val) {
       if (val.length() > 0) {
-        doc.addField(fieldnames[column],val,1.0f);
+        doc.addField(fieldnames[column],val);
       }
     }
   }
@@ -92,7 +92,7 @@ abstract class CSVLoaderBase extends ContentStreamLoader {
   private class FieldAdderEmpty extends CSVLoaderBase.FieldAdder {
     @Override
     void add(SolrInputDocument doc, int line, int column, String val) {
-      doc.addField(fieldnames[column],val,1.0f);
+      doc.addField(fieldnames[column],val);
     }
   }
 
diff --git a/solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.java b/solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.java
index 2041d2f..8650ab8 100644
--- a/solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.java
+++ b/solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.java
@@ -28,6 +28,7 @@ import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.commons.io.IOUtils;
 import org.apache.solr.common.SolrException;
@@ -65,6 +66,7 @@ import static org.apache.solr.common.params.CommonParams.PATH;
  */
 public class JsonLoader extends ContentStreamLoader {
   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+  private static final AtomicBoolean WARNED_ABOUT_INDEX_TIME_BOOSTS = new AtomicBoolean();
   public static final String CHILD_DOC_KEY = "_childDocuments_";
 
   @Override
@@ -435,8 +437,6 @@ public class JsonLoader extends ContentStreamLoader {
       cmd.commitWithin = commitWithin;
       cmd.overwrite = overwrite;
 
-      float boost = 1.0f;
-
       while (true) {
         int ev = parser.nextEvent();
         if (ev == JSONParser.STRING) {
@@ -454,7 +454,13 @@ public class JsonLoader extends ContentStreamLoader {
             } else if (UpdateRequestHandler.COMMIT_WITHIN.equals(key)) {
               cmd.commitWithin = (int) parser.getLong();
             } else if ("boost".equals(key)) {
-              boost = Float.parseFloat(parser.getNumberChars().toString());
+              String boost = parser.getNumberChars().toString();
+              String message = "Ignoring document boost: " + boost + " as index-time boosts are not supported anymore";
+              if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+                log.warn(message);
+              } else {
+                log.debug(message);
+              }
             } else {
               throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Unknown key '" + key + "' at [" + parser.getPosition() + "]");
             }
@@ -467,7 +473,6 @@ public class JsonLoader extends ContentStreamLoader {
           if (cmd.solrDoc == null) {
             throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Missing solr document at [" + parser.getPosition() + "]");
           }
-          cmd.solrDoc.setDocumentBoost(boost);
           return cmd;
         } else {
           throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
@@ -536,7 +541,7 @@ public class JsonLoader extends ContentStreamLoader {
           // SolrInputDocument.addField will do the right thing
           // if the doc already has another value for this field
           // (ie: repeating fieldname keys)
-          sdoc.addField(sif.getName(), sif.getValue(), sif.getBoost());
+          sdoc.addField(sif.getName(), sif.getValue());
         }
 
       }
@@ -548,14 +553,13 @@ public class JsonLoader extends ContentStreamLoader {
         parseExtendedFieldValue(sif, ev);
       } else {
         Object val = parseNormalFieldValue(ev, sif.getName());
-        sif.setValue(val, 1.0f);
+        sif.setValue(val);
       }
     }
 
     private void parseExtendedFieldValue(SolrInputField sif, int ev) throws IOException {
       assert ev == JSONParser.OBJECT_START;
 
-      float boost = 1.0f;
       Object normalFieldValue = null;
       Map<String, Object> extendedInfo = null;
 
@@ -573,7 +577,12 @@ public class JsonLoader extends ContentStreamLoader {
                     + "Unexpected " + JSONParser.getEventString(ev) + " at [" + parser.getPosition() + "], field=" + sif.getName());
               }
 
-              boost = (float) parser.getDouble();
+              String message = "Ignoring field boost: " + parser.getDouble() + " as index-time boosts are not supported anymore";
+              if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+                log.warn(message);
+              } else {
+                log.debug(message);
+              }
             } else if ("value".equals(label)) {
               normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());
             } else {
@@ -593,9 +602,9 @@ public class JsonLoader extends ContentStreamLoader {
               if (normalFieldValue != null) {
                 extendedInfo.put("value", normalFieldValue);
               }
-              sif.setValue(extendedInfo, boost);
+              sif.setValue(extendedInfo);
             } else {
-              sif.setValue(normalFieldValue, boost);
+              sif.setValue(normalFieldValue);
             }
             return;
 
diff --git a/solr/core/src/java/org/apache/solr/handler/loader/XMLLoader.java b/solr/core/src/java/org/apache/solr/handler/loader/XMLLoader.java
index d6a5170..038ed9f 100644
--- a/solr/core/src/java/org/apache/solr/handler/loader/XMLLoader.java
+++ b/solr/core/src/java/org/apache/solr/handler/loader/XMLLoader.java
@@ -35,6 +35,7 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import com.google.common.collect.Lists;
 import org.apache.commons.io.IOUtils;
@@ -71,6 +72,7 @@ import static org.apache.solr.common.params.CommonParams.NAME;
 
 public class XMLLoader extends ContentStreamLoader {
   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+  private static final AtomicBoolean WARNED_ABOUT_INDEX_TIME_BOOSTS = new AtomicBoolean();
   static final XMLErrorLogger xmllog = new XMLErrorLogger(log);
   
   public static final String CONTEXT_TRANSFORMER_KEY = "xsltupdater.transformer";
@@ -379,7 +381,12 @@ public class XMLLoader extends ContentStreamLoader {
     for (int i = 0; i < parser.getAttributeCount(); i++) {
       attrName = parser.getAttributeLocalName(i);
       if ("boost".equals(attrName)) {
-        doc.setDocumentBoost(Float.parseFloat(parser.getAttributeValue(i)));
+        String message = "Ignoring document boost: " + parser.getAttributeValue(i) + " as index-time boosts are not supported anymore";
+        if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+          log.warn(message);
+        } else {
+          log.debug(message);
+        }
       } else {
         log.warn("XML element <doc> has invalid XML attr:" + attrName);
       }
@@ -387,7 +394,6 @@ public class XMLLoader extends ContentStreamLoader {
 
     StringBuilder text = new StringBuilder();
     String name = null;
-    float boost = 1.0f;
     boolean isNull = false;
     String update = null;
     Collection<SolrInputDocument> subDocs = null;
@@ -438,8 +444,7 @@ public class XMLLoader extends ContentStreamLoader {
               }
               break;
             }
-            doc.addField(name, v, boost);
-            boost = 1.0f;
+            doc.addField(name, v);
             // field is over
             name = null;
           }
@@ -460,7 +465,6 @@ public class XMLLoader extends ContentStreamLoader {
               throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
                                       msg);
             }
-            boost = 1.0f;
             update = null;
             isNull = false;
             String attrVal = "";
@@ -470,7 +474,12 @@ public class XMLLoader extends ContentStreamLoader {
               if (NAME.equals(attrName)) {
                 name = attrVal;
               } else if ("boost".equals(attrName)) {
-                boost = Float.parseFloat(attrVal);
+                String message = "Ignoring field boost: " + attrVal + " as index-time boosts are not supported anymore";
+                if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+                  log.warn(message);
+                } else {
+                  log.debug(message);
+                }
               } else if ("null".equals(attrName)) {
                 isNull = StrUtils.parseBoolean(attrVal);
               } else if ("update".equals(attrName)) {
@@ -488,7 +497,7 @@ public class XMLLoader extends ContentStreamLoader {
       for (Map.Entry<String, Map<String, Object>> entry : updateMap.entrySet()) {
         name = entry.getKey();
         Map<String, Object> value = entry.getValue();
-        doc.addField(name, value, 1.0f);
+        doc.addField(name, value);
       }
     }
 
diff --git a/solr/core/src/java/org/apache/solr/schema/AbstractSpatialFieldType.java b/solr/core/src/java/org/apache/solr/schema/AbstractSpatialFieldType.java
index 10756da..4e2829e 100644
--- a/solr/core/src/java/org/apache/solr/schema/AbstractSpatialFieldType.java
+++ b/solr/core/src/java/org/apache/solr/schema/AbstractSpatialFieldType.java
@@ -200,7 +200,7 @@ public abstract class AbstractSpatialFieldType<T extends SpatialStrategy> extend
   //--------------------------------------------------------------
 
   @Override
-  public final Field createField(SchemaField field, Object val, float boost) {
+  public final Field createField(SchemaField field, Object val) {
     throw new IllegalStateException("instead call createFields() because isPolyField() is true");
   }
 
@@ -210,7 +210,7 @@ public abstract class AbstractSpatialFieldType<T extends SpatialStrategy> extend
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object val, float boost) {
+  public List<IndexableField> createFields(SchemaField field, Object val) {
     String shapeStr = null;
     Shape shape;
     if (val instanceof Shape) {
@@ -237,7 +237,7 @@ public abstract class AbstractSpatialFieldType<T extends SpatialStrategy> extend
     return result;
   }
 
-  /** Called by {@link #createFields(SchemaField, Object, float)} to get the stored value. */
+  /** Called by {@link #createFields(SchemaField, Object)} to get the stored value. */
   protected String getStoredValue(Shape shape, String shapeStr) {
     return (shapeStr == null) ? shapeToString(shape) : shapeStr;
   }
diff --git a/solr/core/src/java/org/apache/solr/schema/BBoxField.java b/solr/core/src/java/org/apache/solr/schema/BBoxField.java
index d7fda7c..d69255b 100644
--- a/solr/core/src/java/org/apache/solr/schema/BBoxField.java
+++ b/solr/core/src/java/org/apache/solr/schema/BBoxField.java
@@ -137,7 +137,7 @@ public class BBoxField extends AbstractSpatialFieldType<BBoxStrategy> implements
     //Solr's FieldType ought to expose Lucene FieldType. Instead as a hack we create a Field with a dummy value.
     final SchemaField solrNumField = new SchemaField("_", numberType);//dummy temp
     org.apache.lucene.document.FieldType luceneType =
-        (org.apache.lucene.document.FieldType) solrNumField.createField(0.0, 1.0f).fieldType();
+        (org.apache.lucene.document.FieldType) solrNumField.createField(0.0).fieldType();
     luceneType.setStored(storeSubFields);
     
     //and annoyingly this Field isn't going to have a docValues format because Solr uses a separate Field for that
diff --git a/solr/core/src/java/org/apache/solr/schema/BinaryField.java b/solr/core/src/java/org/apache/solr/schema/BinaryField.java
index 889bd3c..d1882b1 100644
--- a/solr/core/src/java/org/apache/solr/schema/BinaryField.java
+++ b/solr/core/src/java/org/apache/solr/schema/BinaryField.java
@@ -20,7 +20,6 @@ import java.io.IOException;
 import java.lang.invoke.MethodHandles;
 import java.nio.ByteBuffer;
 
-import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
@@ -71,7 +70,7 @@ public class BinaryField extends FieldType  {
   }
 
   @Override
-  public IndexableField createField(SchemaField field, Object val, float boost) {
+  public IndexableField createField(SchemaField field, Object val) {
     if (val == null) return null;
     if (!field.stored()) {
       log.trace("Ignoring unstored binary field: " + field);
@@ -95,8 +94,6 @@ public class BinaryField extends FieldType  {
       len = buf.length;
     }
 
-    Field f = new org.apache.lucene.document.StoredField(field.getName(), buf, offset, len);
-    f.setBoost(boost);
-    return f;
+    return new org.apache.lucene.document.StoredField(field.getName(), buf, offset, len);
   }
 }
diff --git a/solr/core/src/java/org/apache/solr/schema/BoolField.java b/solr/core/src/java/org/apache/solr/schema/BoolField.java
index 1645ee6..7d5c0d7 100644
--- a/solr/core/src/java/org/apache/solr/schema/BoolField.java
+++ b/solr/core/src/java/org/apache/solr/schema/BoolField.java
@@ -182,8 +182,8 @@ public class BoolField extends PrimitiveFieldType {
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object value, float boost) {
-    IndexableField fval = createField(field, value, boost);
+  public List<IndexableField> createFields(SchemaField field, Object value) {
+    IndexableField fval = createField(field, value);
 
     if (field.hasDocValues()) {
       IndexableField docval;
diff --git a/solr/core/src/java/org/apache/solr/schema/CollationField.java b/solr/core/src/java/org/apache/solr/schema/CollationField.java
index 805e204..a498c01 100644
--- a/solr/core/src/java/org/apache/solr/schema/CollationField.java
+++ b/solr/core/src/java/org/apache/solr/schema/CollationField.java
@@ -254,10 +254,10 @@ public class CollationField extends FieldType {
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object value, float boost) {
+  public List<IndexableField> createFields(SchemaField field, Object value) {
     if (field.hasDocValues()) {
       List<IndexableField> fields = new ArrayList<>();
-      fields.add(createField(field, value, boost));
+      fields.add(createField(field, value));
       final BytesRef bytes = getCollationKey(field.getName(), value.toString());
       if (field.multiValued()) {
         fields.add(new SortedSetDocValuesField(field.getName(), bytes));
@@ -266,7 +266,7 @@ public class CollationField extends FieldType {
       }
       return fields;
     } else {
-      return Collections.singletonList(createField(field, value, boost));
+      return Collections.singletonList(createField(field, value));
     }
   }
 
diff --git a/solr/core/src/java/org/apache/solr/schema/CurrencyField.java b/solr/core/src/java/org/apache/solr/schema/CurrencyField.java
index 7ad285b..9e994cf 100644
--- a/solr/core/src/java/org/apache/solr/schema/CurrencyField.java
+++ b/solr/core/src/java/org/apache/solr/schema/CurrencyField.java
@@ -171,21 +171,21 @@ public class CurrencyField extends FieldType implements SchemaAware, ResourceLoa
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object externalVal, float boost) {
+  public List<IndexableField> createFields(SchemaField field, Object externalVal) {
     CurrencyValue value = CurrencyValue.parse(externalVal.toString(), defaultCurrency);
 
     List<IndexableField> f = new ArrayList<>();
     SchemaField amountField = getAmountField(field);
-    f.add(amountField.createField(String.valueOf(value.getAmount()), amountField.indexed() && !amountField.omitNorms() ? boost : 1F));
+    f.add(amountField.createField(String.valueOf(value.getAmount())));
     SchemaField currencyField = getCurrencyField(field);
-    f.add(currencyField.createField(value.getCurrencyCode(), currencyField.indexed() && !currencyField.omitNorms() ? boost : 1F));
+    f.add(currencyField.createField(value.getCurrencyCode()));
 
     if (field.stored()) {
       String storedValue = externalVal.toString().trim();
       if (storedValue.indexOf(",") < 0) {
         storedValue += "," + defaultCurrency;
       }
-      f.add(createField(field.getName(), storedValue, StoredField.TYPE, 1F));
+      f.add(createField(field.getName(), storedValue, StoredField.TYPE));
     }
 
     return f;
diff --git a/solr/core/src/java/org/apache/solr/schema/DateRangeField.java b/solr/core/src/java/org/apache/solr/schema/DateRangeField.java
index d51c1f1..8dde953 100644
--- a/solr/core/src/java/org/apache/solr/schema/DateRangeField.java
+++ b/solr/core/src/java/org/apache/solr/schema/DateRangeField.java
@@ -63,10 +63,10 @@ public class DateRangeField extends AbstractSpatialPrefixTreeFieldType<NumberRan
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object val, float boost) {
+  public List<IndexableField> createFields(SchemaField field, Object val) {
     if (val instanceof Date || val instanceof Calendar)//From URP?
       val = tree.toUnitShape(val);
-    return super.createFields(field, val, boost);
+    return super.createFields(field, val);
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/DoublePointField.java b/solr/core/src/java/org/apache/solr/schema/DoublePointField.java
index 3a90eec..e34ebec 100644
--- a/solr/core/src/java/org/apache/solr/schema/DoublePointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/DoublePointField.java
@@ -178,12 +178,9 @@ public class DoublePointField extends PointField implements DoubleValueFieldType
   }
 
   @Override
-  public IndexableField createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     if (!isFieldUsed(field)) return null;
 
-    if (boost != 1.0 && log.isTraceEnabled()) {
-      log.trace("Can't use document/field boost for PointField. Field: " + field.getName() + ", boost: " + boost);
-    }
     double doubleValue = (value instanceof Number) ? ((Number) value).doubleValue() : Double.parseDouble(value.toString());
     return new DoublePoint(field.getName(), doubleValue);
   }
diff --git a/solr/core/src/java/org/apache/solr/schema/EnumField.java b/solr/core/src/java/org/apache/solr/schema/EnumField.java
index 37cd24b..3e83db4 100644
--- a/solr/core/src/java/org/apache/solr/schema/EnumField.java
+++ b/solr/core/src/java/org/apache/solr/schema/EnumField.java
@@ -391,7 +391,7 @@ public class EnumField extends PrimitiveFieldType {
    * {@inheritDoc}
    */
   @Override
-  public IndexableField createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     final boolean indexed = field.indexed();
     final boolean stored = field.stored();
     final boolean docValues = field.hasDocValues();
@@ -418,21 +418,17 @@ public class EnumField extends PrimitiveFieldType {
     newType.setNumericType(LegacyNumericType.INT);
     newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);
 
-    final org.apache.lucene.document.Field f;
-    f = new LegacyIntField(field.getName(), intValue.intValue(), newType);
-
-    f.setBoost(boost);
-    return f;
+    return new LegacyIntField(field.getName(), intValue.intValue(), newType);
   }
 
   /**
    * {@inheritDoc}
    */
   @Override
-  public List<IndexableField> createFields(SchemaField sf, Object value, float boost) {
+  public List<IndexableField> createFields(SchemaField sf, Object value) {
     if (sf.hasDocValues()) {
       List<IndexableField> fields = new ArrayList<>();
-      final IndexableField field = createField(sf, value, boost);
+      final IndexableField field = createField(sf, value);
       fields.add(field);
 
       if (sf.multiValued()) {
@@ -445,7 +441,7 @@ public class EnumField extends PrimitiveFieldType {
       }
       return fields;
     } else {
-      return Collections.singletonList(createField(sf, value, boost));
+      return Collections.singletonList(createField(sf, value));
     }
   }
 
diff --git a/solr/core/src/java/org/apache/solr/schema/FieldType.java b/solr/core/src/java/org/apache/solr/schema/FieldType.java
index c21b23f..c542a95 100644
--- a/solr/core/src/java/org/apache/solr/schema/FieldType.java
+++ b/solr/core/src/java/org/apache/solr/schema/FieldType.java
@@ -86,7 +86,7 @@ public abstract class FieldType extends FieldProperties {
   /**
    * The default poly field separator.
    *
-   * @see #createFields(SchemaField, Object, float)
+   * @see #createFields(SchemaField, Object)
    * @see #isPolyField()
    */
   public static final String POLY_FIELD_SEPARATOR = "___";
@@ -119,9 +119,9 @@ public abstract class FieldType extends FieldProperties {
   }
 
   /**
-   * A "polyField" is a FieldType that can produce more than one IndexableField instance for a single value, via the {@link #createFields(org.apache.solr.schema.SchemaField, Object, float)} method.  This is useful
+   * A "polyField" is a FieldType that can produce more than one IndexableField instance for a single value, via the {@link #createFields(org.apache.solr.schema.SchemaField, Object)} method.  This is useful
    * when hiding the implementation details of a field from the Solr end user.  For instance, a spatial point may be represented by multiple different fields.
-   * @return true if the {@link #createFields(org.apache.solr.schema.SchemaField, Object, float)} method may return more than one field
+   * @return true if the {@link #createFields(org.apache.solr.schema.SchemaField, Object)} method may return more than one field
    */
   public boolean isPolyField(){
     return false;
@@ -263,7 +263,7 @@ public abstract class FieldType extends FieldProperties {
    *
    *
    */
-  public IndexableField createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     if (!field.indexed() && !field.stored()) {
       if (log.isTraceEnabled())
         log.trace("Ignoring unindexed/unstored field: " + field);
@@ -287,7 +287,7 @@ public abstract class FieldType extends FieldProperties {
       newType.setStoreTermVectorOffsets(field.storeTermOffsets());
       newType.setStoreTermVectorPositions(field.storeTermPositions());
       newType.setStoreTermVectorPayloads(field.storeTermPayloads());*/
-    return createField(field.getName(), val, field, boost);
+    return createField(field.getName(), val, field);
   }
 
   /**
@@ -296,27 +296,23 @@ public abstract class FieldType extends FieldProperties {
    * @param name The name of the field
    * @param val The _internal_ value to index
    * @param type {@link org.apache.lucene.document.FieldType}
-   * @param boost The boost value
    * @return the {@link org.apache.lucene.index.IndexableField}.
    */
-  protected IndexableField createField(String name, String val, org.apache.lucene.index.IndexableFieldType type, float boost){
-    Field f = new Field(name, val, type);
-    f.setBoost(boost);
-    return f;
+  protected IndexableField createField(String name, String val, org.apache.lucene.index.IndexableFieldType type){
+    return new Field(name, val, type);
   }
 
   /**
    * Given a {@link org.apache.solr.schema.SchemaField}, create one or more {@link org.apache.lucene.index.IndexableField} instances
    * @param field the {@link org.apache.solr.schema.SchemaField}
    * @param value The value to add to the field
-   * @param boost The boost to apply
    * @return An array of {@link org.apache.lucene.index.IndexableField}
    *
-   * @see #createField(SchemaField, Object, float)
+   * @see #createField(SchemaField, Object)
    * @see #isPolyField()
    */
-  public List<IndexableField> createFields(SchemaField field, Object value, float boost) {
-    IndexableField f = createField( field, value, boost);
+  public List<IndexableField> createFields(SchemaField field, Object value) {
+    IndexableField f = createField( field, value);
     if (field.hasDocValues() && f.fieldType().docValuesType() == null) {
       // field types that support doc values should either override createField
       // to return a field with doc values or extend createFields if this can't
@@ -366,7 +362,7 @@ public abstract class FieldType extends FieldProperties {
   public Object toObject(SchemaField sf, BytesRef term) {
     final CharsRefBuilder ref = new CharsRefBuilder();
     indexedToReadable(term, ref);
-    final IndexableField f = createField(sf, ref.toString(), 1.0f);
+    final IndexableField f = createField(sf, ref.toString());
     return toObject(f);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/schema/FloatPointField.java b/solr/core/src/java/org/apache/solr/schema/FloatPointField.java
index 6647286..39453e7 100644
--- a/solr/core/src/java/org/apache/solr/schema/FloatPointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/FloatPointField.java
@@ -179,12 +179,9 @@ public class FloatPointField extends PointField implements FloatValueFieldType {
   }
 
   @Override
-  public IndexableField createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     if (!isFieldUsed(field)) return null;
 
-    if (boost != 1.0 && log.isTraceEnabled()) {
-      log.trace("Can't use document/field boost for PointField. Field: " + field.getName() + ", boost: " + boost);
-    }
     float floatValue = (value instanceof Number) ? ((Number) value).floatValue() : Float.parseFloat(value.toString());
     return new FloatPoint(field.getName(), floatValue);
   }
diff --git a/solr/core/src/java/org/apache/solr/schema/IntPointField.java b/solr/core/src/java/org/apache/solr/schema/IntPointField.java
index b25bc9f..db26988 100644
--- a/solr/core/src/java/org/apache/solr/schema/IntPointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/IntPointField.java
@@ -169,12 +169,9 @@ public class IntPointField extends PointField implements IntValueFieldType {
   }
 
   @Override
-  public IndexableField createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     if (!isFieldUsed(field)) return null;
 
-    if (boost != 1.0 && log.isTraceEnabled()) {
-      log.trace("Can't use document/field boost for PointField. Field: " + field.getName() + ", boost: " + boost);
-    }
     int intValue = (value instanceof Number) ? ((Number) value).intValue() : Integer.parseInt(value.toString());
     return new IntPoint(field.getName(), intValue);
   }
diff --git a/solr/core/src/java/org/apache/solr/schema/LatLonType.java b/solr/core/src/java/org/apache/solr/schema/LatLonType.java
index 856c8bb..c484f3a 100644
--- a/solr/core/src/java/org/apache/solr/schema/LatLonType.java
+++ b/solr/core/src/java/org/apache/solr/schema/LatLonType.java
@@ -67,7 +67,7 @@ public class LatLonType extends AbstractSubTypeFieldType implements SpatialQuery
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object value, float boost) {
+  public List<IndexableField> createFields(SchemaField field, Object value) {
     String externalVal = value.toString();
     //we could have 3 fields (two for the lat & lon, one for storage)
     List<IndexableField> f = new ArrayList<>(3);
@@ -75,14 +75,14 @@ public class LatLonType extends AbstractSubTypeFieldType implements SpatialQuery
       Point point = SpatialUtils.parsePointSolrException(externalVal, SpatialContext.GEO);
       //latitude
       SchemaField subLatSF = subField(field, LAT, schema);
-      f.add(subLatSF.createField(String.valueOf(point.getY()), subLatSF.indexed() && !subLatSF.omitNorms() ? boost : 1f));
+      f.add(subLatSF.createField(String.valueOf(point.getY())));
       //longitude
       SchemaField subLonSF = subField(field, LON, schema);
-      f.add(subLonSF.createField(String.valueOf(point.getX()), subLonSF.indexed() && !subLonSF.omitNorms() ? boost : 1f));
+      f.add(subLonSF.createField(String.valueOf(point.getX())));
     }
 
     if (field.stored()) {
-      f.add(createField(field.getName(), externalVal, StoredField.TYPE, 1f));
+      f.add(createField(field.getName(), externalVal, StoredField.TYPE));
     }
     return f;
   }
@@ -245,7 +245,7 @@ public class LatLonType extends AbstractSubTypeFieldType implements SpatialQuery
   //It never makes sense to create a single field, so make it impossible to happen
 
   @Override
-  public IndexableField createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     throw new UnsupportedOperationException("LatLonType uses multiple fields.  field=" + field.getName());
   }
 
diff --git a/solr/core/src/java/org/apache/solr/schema/LongPointField.java b/solr/core/src/java/org/apache/solr/schema/LongPointField.java
index 5631938..f5d0948 100644
--- a/solr/core/src/java/org/apache/solr/schema/LongPointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/LongPointField.java
@@ -174,12 +174,9 @@ public class LongPointField extends PointField implements LongValueFieldType {
   }
 
   @Override
-  public IndexableField createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     if (!isFieldUsed(field)) return null;
 
-    if (boost != 1.0 && log.isTraceEnabled()) {
-      log.trace("Can't use document/field boost for PointField. Field: " + field.getName() + ", boost: " + boost);
-    }
     long longValue = (value instanceof Number) ? ((Number) value).longValue() : Long.parseLong(value.toString());
     return new LongPoint(field.getName(), longValue);
   }
diff --git a/solr/core/src/java/org/apache/solr/schema/PointField.java b/solr/core/src/java/org/apache/solr/schema/PointField.java
index 8746dac..6c75105 100644
--- a/solr/core/src/java/org/apache/solr/schema/PointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/PointField.java
@@ -203,12 +203,12 @@ public abstract class PointField extends NumericFieldType {
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField sf, Object value, float boost) {
+  public List<IndexableField> createFields(SchemaField sf, Object value) {
     if (!(sf.hasDocValues() || sf.stored())) {
-      return Collections.singletonList(createField(sf, value, boost));
+      return Collections.singletonList(createField(sf, value));
     }
     List<IndexableField> fields = new ArrayList<>();
-    final IndexableField field = createField(sf, value, boost);
+    final IndexableField field = createField(sf, value);
     fields.add(field);
     
     if (sf.hasDocValues()) {
diff --git a/solr/core/src/java/org/apache/solr/schema/PointType.java b/solr/core/src/java/org/apache/solr/schema/PointType.java
index 1c13097..4c022b8 100644
--- a/solr/core/src/java/org/apache/solr/schema/PointType.java
+++ b/solr/core/src/java/org/apache/solr/schema/PointType.java
@@ -66,7 +66,7 @@ public class PointType extends CoordinateFieldType implements SpatialQueryable {
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object value, float boost) {
+  public List<IndexableField> createFields(SchemaField field, Object value) {
     String externalVal = value.toString();
     String[] point = parseCommaSeparatedList(externalVal, dimension);
 
@@ -76,13 +76,13 @@ public class PointType extends CoordinateFieldType implements SpatialQueryable {
     if (field.indexed()) {
       for (int i=0; i<dimension; i++) {
         SchemaField sf = subField(field, i, schema);
-        f.add(sf.createField(point[i], sf.indexed() && !sf.omitNorms() ? boost : 1f));
+        f.add(sf.createField(point[i]));
       }
     }
 
     if (field.stored()) {
       String storedVal = externalVal;  // normalize or not?
-      f.add(createField(field.getName(), storedVal, StoredField.TYPE, 1f));
+      f.add(createField(field.getName(), storedVal, StoredField.TYPE));
     }
     
     return f;
@@ -105,7 +105,7 @@ public class PointType extends CoordinateFieldType implements SpatialQueryable {
    *
    */
   @Override
-  public IndexableField createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     throw new UnsupportedOperationException("PointType uses multiple fields.  field=" + field.getName());
   }
 
diff --git a/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java b/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java
index 5f125d9..d2dc811 100644
--- a/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java
+++ b/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java
@@ -119,11 +119,10 @@ public class PreAnalyzedField extends TextField implements HasImplicitIndexAnaly
   }
 
   @Override
-  public IndexableField createField(SchemaField field, Object value,
-          float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     IndexableField f = null;
     try {
-      f = fromString(field, String.valueOf(value), boost);
+      f = fromString(field, String.valueOf(value));
     } catch (Exception e) {
       LOG.warn("Error parsing pre-analyzed field '" + field.getName() + "'", e);
       return null;
@@ -225,7 +224,7 @@ public class PreAnalyzedField extends TextField implements HasImplicitIndexAnaly
   }
   
   
-  public IndexableField fromString(SchemaField field, String val, float boost) throws Exception {
+  public IndexableField fromString(SchemaField field, String val) throws Exception {
     if (val == null || val.trim().length() == 0) {
       return null;
     }
@@ -269,9 +268,6 @@ public class PreAnalyzedField extends TextField implements HasImplicitIndexAnaly
         }
       }
     }
-    if (f != null) {
-      f.setBoost(boost);
-    }
     return f;
   }
 
diff --git a/solr/core/src/java/org/apache/solr/schema/SchemaField.java b/solr/core/src/java/org/apache/solr/schema/SchemaField.java
index 009e5fc..e690a13 100644
--- a/solr/core/src/java/org/apache/solr/schema/SchemaField.java
+++ b/solr/core/src/java/org/apache/solr/schema/SchemaField.java
@@ -113,16 +113,16 @@ public final class SchemaField extends FieldProperties implements IndexableField
   boolean isTokenized() { return (properties & TOKENIZED)!=0; }
   boolean isBinary() { return (properties & BINARY)!=0; }
 
-  public IndexableField createField(Object val, float boost) {
-    return type.createField(this,val,boost);
+  public IndexableField createField(Object val) {
+    return type.createField(this,val);
   }
 
-  public List<IndexableField> createFields(Object val, float boost) {
-    return type.createFields(this,val,boost);
+  public List<IndexableField> createFields(Object val) {
+    return type.createFields(this,val);
   }
 
   /**
-   * If true, then use {@link #createFields(Object, float)}, else use {@link #createField} to save an extra allocation
+   * If true, then use {@link #createFields(Object)}, else use {@link #createField} to save an extra allocation
    * @return true if this field is a poly field
    */
   public boolean isPolyField(){
diff --git a/solr/core/src/java/org/apache/solr/schema/StrField.java b/solr/core/src/java/org/apache/solr/schema/StrField.java
index a00cfb7..0b1576b 100644
--- a/solr/core/src/java/org/apache/solr/schema/StrField.java
+++ b/solr/core/src/java/org/apache/solr/schema/StrField.java
@@ -40,8 +40,8 @@ public class StrField extends PrimitiveFieldType {
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object value, float boost) {
-    IndexableField fval = createField(field, value, boost);
+  public List<IndexableField> createFields(SchemaField field, Object value) {
+    IndexableField fval = createField(field, value);
 
     if (field.hasDocValues()) {
       IndexableField docval;
diff --git a/solr/core/src/java/org/apache/solr/schema/TrieField.java b/solr/core/src/java/org/apache/solr/schema/TrieField.java
index e470155..b70b2b0 100644
--- a/solr/core/src/java/org/apache/solr/schema/TrieField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TrieField.java
@@ -572,7 +572,7 @@ public class TrieField extends NumericFieldType {
   }
   
   @Override
-  public IndexableField createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value) {
     boolean indexed = field.indexed();
     boolean stored = field.stored();
     boolean docValues = field.hasDocValues();
@@ -647,15 +647,14 @@ public class TrieField extends NumericFieldType {
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + type);
     }
 
-    f.setBoost(boost);
     return f;
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField sf, Object value, float boost) {
+  public List<IndexableField> createFields(SchemaField sf, Object value) {
     if (sf.hasDocValues()) {
       List<IndexableField> fields = new ArrayList<>();
-      final IndexableField field = createField(sf, value, boost);
+      final IndexableField field = createField(sf, value);
       fields.add(field);
       
       if (sf.multiValued()) {
@@ -677,7 +676,7 @@ public class TrieField extends NumericFieldType {
       
       return fields;
     } else {
-      return Collections.singletonList(createField(sf, value, boost));
+      return Collections.singletonList(createField(sf, value));
     }
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/Grouping.java b/solr/core/src/java/org/apache/solr/search/Grouping.java
index 75011e7..327e5bb 100644
--- a/solr/core/src/java/org/apache/solr/search/Grouping.java
+++ b/solr/core/src/java/org/apache/solr/search/Grouping.java
@@ -819,7 +819,7 @@ public class Grouping {
           SchemaField schemaField = searcher.getSchema().getField(groupBy);
           FieldType fieldType = schemaField.getType();
           String readableValue = fieldType.indexedToReadable(group.groupValue.utf8ToString());
-          IndexableField field = schemaField.createField(readableValue, 1.0f);
+          IndexableField field = schemaField.createField(readableValue);
           nl.add("groupValue", fieldType.toObject(field));
         } else {
           nl.add("groupValue", null);
diff --git a/solr/core/src/java/org/apache/solr/search/grouping/endresulttransformer/GroupedEndResultTransformer.java b/solr/core/src/java/org/apache/solr/search/grouping/endresulttransformer/GroupedEndResultTransformer.java
index 47b5276..de2dee4 100644
--- a/solr/core/src/java/org/apache/solr/search/grouping/endresulttransformer/GroupedEndResultTransformer.java
+++ b/solr/core/src/java/org/apache/solr/search/grouping/endresulttransformer/GroupedEndResultTransformer.java
@@ -69,7 +69,7 @@ public class GroupedEndResultTransformer implements EndResultTransformer {
           SimpleOrderedMap<Object> groupResult = new SimpleOrderedMap<>();
           if (group.groupValue != null) {
             groupResult.add(
-                "groupValue", groupFieldType.toObject(groupField.createField(group.groupValue.utf8ToString(), 1.0f))
+                "groupValue", groupFieldType.toObject(groupField.createField(group.groupValue.utf8ToString()))
             );
           } else {
             groupResult.add("groupValue", null);
diff --git a/solr/core/src/java/org/apache/solr/update/DocumentBuilder.java b/solr/core/src/java/org/apache/solr/update/DocumentBuilder.java
index eb6612e..abf4a1f 100644
--- a/solr/core/src/java/org/apache/solr/update/DocumentBuilder.java
+++ b/solr/core/src/java/org/apache/solr/update/DocumentBuilder.java
@@ -43,25 +43,22 @@ public class DocumentBuilder {
    * @param doc Document that the field needs to be added to
    * @param field The schema field object for the field
    * @param val The value for the field to be added
-   * @param boost Boost value for the field
    * @param forInPlaceUpdate Whether the field is to be added for in-place update. If true,
    *        only numeric docValues based fields are added to the document. This can be true
    *        when constructing a Lucene document for writing an in-place update, and we don't need
    *        presence of non-updatable fields (non NDV) in such a document.
    */
-  private static void addField(Document doc, SchemaField field, Object val, float boost, 
+  private static void addField(Document doc, SchemaField field, Object val,
       boolean forInPlaceUpdate) {
     if (val instanceof IndexableField) {
       if (forInPlaceUpdate) {
         assert val instanceof NumericDocValuesField: "Expected in-place update to be done on"
             + " NDV fields only.";
       }
-      // set boost to the calculated compound boost
-      ((Field)val).setBoost(boost);
       doc.add((Field)val);
       return;
     }
-    for (IndexableField f : field.getType().createFields(field, val, boost)) {
+    for (IndexableField f : field.getType().createFields(field, val)) {
       if (f != null) { // null fields are not added
         // HACK: workaround for SOLR-9809
         // even though at this point in the code we know the field is single valued and DV only
@@ -126,7 +123,6 @@ public class DocumentBuilder {
     final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();
     
     Document out = new Document();
-    final float docBoost = doc.getDocumentBoost();
     Set<String> usedFields = Sets.newHashSet();
     
     // Load fields from SolrDocument to Document
@@ -141,19 +137,6 @@ public class DocumentBuilder {
             "ERROR: "+getID(doc, schema)+"multiple values encountered for non multiValued field " + 
               sfield.getName() + ": " +field.getValue() );
       }
-      
-      float fieldBoost = field.getBoost();
-      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();
-
-      if (applyBoost == false && fieldBoost != 1.0F) {
-        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-            "ERROR: "+getID(doc, schema)+"cannot set an index-time boost, unindexed or norms are omitted for field " + 
-              sfield.getName() + ": " +field.getValue() );
-      }
-
-      // Lucene no longer has a native docBoost, so we have to multiply 
-      // it ourselves 
-      float compoundBoost = fieldBoost * docBoost;
 
       List<CopyField> copyFields = schema.getCopyFieldsList(name);
       if( copyFields.size() == 0 ) copyFields = null;
@@ -168,7 +151,7 @@ public class DocumentBuilder {
           hasField = true;
           if (sfield != null) {
             used = true;
-            addField(out, sfield, v, applyBoost ? compoundBoost : 1f, 
+            addField(out, sfield, v,
                      name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);
             // record the field as having a value
             usedFields.add(sfield.getName());
@@ -200,27 +183,13 @@ public class DocumentBuilder {
                   val = cf.getLimitedValue((String)val);
                 }
 
-                // we can't copy any boost unless the dest field is 
-                // indexed & !omitNorms, but which boost we copy depends
-                // on whether the dest field already contains values (we
-                // don't want to apply the compounded docBoost more then once)
-                final float destBoost = 
-                    (destinationField.indexed() && !destinationField.omitNorms()) ?
-                        (destHasValues ? fieldBoost : compoundBoost) : 1.0F;
-
-                addField(out, destinationField, val, destBoost, 
+                addField(out, destinationField, val,
                          destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);
                 // record the field as having a value
                 usedFields.add(destinationField.getName());
               }
             }
           }
-
-          // The final boost for a given field named is the product of the 
-          // *all* boosts on values of that field. 
-          // For multi-valued fields, we only want to set the boost on the
-          // first field.
-          fieldBoost = compoundBoost = 1.0f;
         }
       }
       catch( SolrException ex ) {
@@ -250,7 +219,7 @@ public class DocumentBuilder {
       for (SchemaField field : schema.getRequiredFields()) {
         if (out.getField(field.getName() ) == null) {
           if (field.getDefaultValue() != null) {
-            addField(out, field, field.getDefaultValue(), 1.0f, false);
+            addField(out, field, field.getDefaultValue(), false);
           } 
           else {
             String msg = getID(doc, schema) + "missing required field: " + field.getName();
diff --git a/solr/core/src/java/org/apache/solr/update/processor/AllValuesOrNoneFieldMutatingUpdateProcessor.java b/solr/core/src/java/org/apache/solr/update/processor/AllValuesOrNoneFieldMutatingUpdateProcessor.java
index 52726ea..1d56a62 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/AllValuesOrNoneFieldMutatingUpdateProcessor.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/AllValuesOrNoneFieldMutatingUpdateProcessor.java
@@ -104,10 +104,9 @@ public abstract class AllValuesOrNoneFieldMutatingUpdateProcessor extends FieldM
                                      srcField.getName(), srcVal.getClass().getSimpleName(), srcVal, 
                                      destVal.getClass().getSimpleName(), destVal));
         }
-        result.addValue(destVal, 1.0F);
+        result.addValue(destVal);
       }
     }
-    result.setBoost(srcField.getBoost());
     
     if (null != messages && log.isDebugEnabled()) {
       for (String message : messages) {
diff --git a/solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger.java b/solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger.java
index 0c17758..093149a 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger.java
@@ -306,18 +306,18 @@ public class AtomicUpdateDocumentMerger {
 
   protected void doSet(SolrInputDocument toDoc, SolrInputField sif, Object fieldVal) {
     SchemaField sf = schema.getField(sif.getName());
-    toDoc.setField(sif.getName(), sf.getType().toNativeType(fieldVal), sif.getBoost());
+    toDoc.setField(sif.getName(), sf.getType().toNativeType(fieldVal));
   }
 
   protected void doAdd(SolrInputDocument toDoc, SolrInputField sif, Object fieldVal) {
     SchemaField sf = schema.getField(sif.getName());
-    toDoc.addField(sif.getName(), sf.getType().toNativeType(fieldVal), sif.getBoost());
+    toDoc.addField(sif.getName(), sf.getType().toNativeType(fieldVal));
   }
 
   protected void doInc(SolrInputDocument toDoc, SolrInputField sif, Object fieldVal) {
     SolrInputField numericField = toDoc.get(sif.getName());
     if (numericField == null) {
-      toDoc.setField(sif.getName(),  fieldVal, sif.getBoost());
+      toDoc.setField(sif.getName(),  fieldVal);
     } else {
       // TODO: fieldtype needs externalToObject?
       String oldValS = numericField.getFirstValue().toString();
@@ -339,7 +339,7 @@ public class AtomicUpdateDocumentMerger {
         result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);
       }
 
-      toDoc.setField(sif.getName(),  result, sif.getBoost());
+      toDoc.setField(sif.getName(),  result);
     }
   }
 
diff --git a/solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory.java
index ad5c772..2ffc5b9 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory.java
@@ -450,8 +450,7 @@ public class CloneFieldUpdateProcessorFactory
           }
 
           for (Object val : srcFieldValues) {
-            // preserve existing dest boost (multiplicitive), ignore src boost
-            destField.addValue(val, 1.0f);
+            destField.addValue(val);
           }
           // put it in map to avoid concurrent modification...
           destMap.put(resolvedDest, destField);
diff --git a/solr/core/src/java/org/apache/solr/update/processor/ConcatFieldUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/ConcatFieldUpdateProcessorFactory.java
index 65ca976..ae260e9 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/ConcatFieldUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/ConcatFieldUpdateProcessorFactory.java
@@ -81,8 +81,7 @@ public final class ConcatFieldUpdateProcessorFactory extends FieldMutatingUpdate
       if (src.getValueCount() <= 1) return src;
 
       SolrInputField result = new SolrInputField(src.getName());
-      result.setValue(StringUtils.join(src.getValues(), delimiter),
-          src.getBoost());
+      result.setValue(StringUtils.join(src.getValues(), delimiter));
       return result;
     });
   }
diff --git a/solr/core/src/java/org/apache/solr/update/processor/CountFieldValuesUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/CountFieldValuesUpdateProcessorFactory.java
index 5ffd0f6..1ed52c0 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/CountFieldValuesUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/CountFieldValuesUpdateProcessorFactory.java
@@ -72,8 +72,7 @@ public final class CountFieldValuesUpdateProcessorFactory extends FieldMutatingU
                                             UpdateRequestProcessor next) {
     return mutator(getSelector(), next, src -> {
       SolrInputField result = new SolrInputField(src.getName());
-      result.setValue(src.getValueCount(),
-          src.getBoost());
+      result.setValue(src.getValueCount());
       return result;
     });
   }
diff --git a/solr/core/src/java/org/apache/solr/update/processor/FieldValueMutatingUpdateProcessor.java b/solr/core/src/java/org/apache/solr/update/processor/FieldValueMutatingUpdateProcessor.java
index 51d99f1..b08ed9b 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/FieldValueMutatingUpdateProcessor.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/FieldValueMutatingUpdateProcessor.java
@@ -78,10 +78,9 @@ public abstract class FieldValueMutatingUpdateProcessor
           log.debug("replace value from field '{}': {} with {}", 
                     new Object[] { src.getName(), srcVal, destVal });
         }
-        result.addValue(destVal, 1.0F);
+        result.addValue(destVal);
       }
     }
-    result.setBoost(src.getBoost());
     return 0 == result.getValueCount() ? null : result;
   }
 
diff --git a/solr/core/src/java/org/apache/solr/update/processor/FieldValueSubsetUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/FieldValueSubsetUpdateProcessorFactory.java
index 1fda07d..89c94bb 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/FieldValueSubsetUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/FieldValueSubsetUpdateProcessorFactory.java
@@ -39,8 +39,7 @@ public abstract class FieldValueSubsetUpdateProcessorFactory extends FieldMutati
       if (src.getValueCount() <= 1) return src;
 
       SolrInputField result = new SolrInputField(src.getName());
-      result.setValue(pickSubset(src.getValues()),
-          src.getBoost());
+      result.setValue(pickSubset(src.getValues()));
       return result;
     });
   }
diff --git a/solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessorFactory.java
index 2b76fbf..690c0f0 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessorFactory.java
@@ -54,7 +54,7 @@ import org.slf4j.LoggerFactory;
  * <p>This update processor uses {@link PreAnalyzedParser}
  * to parse the original field content (interpreted as a string value), and thus
  * obtain the stored part and the token stream part. Then it creates the "template"
- * {@link Field}-s using the original {@link SchemaField#createFields(Object, float)}
+ * {@link Field}-s using the original {@link SchemaField#createFields(Object)}
  * as declared in the current schema. Finally it sets the pre-analyzed parts if
  * available (string value and the token
  * stream value) on the first field of these "template" fields. If the declared
@@ -155,17 +155,16 @@ class PreAnalyzedUpdateProcessor extends FieldMutatingUpdateProcessor {
       return null;
     }
     SolrInputField res = new SolrInputField(src.getName());
-    res.setBoost(src.getBoost());
     for (Object o : src) {
       if (o == null) {
         continue;
       }
-      Field pre = (Field)parser.createField(sf, o, 1.0f);
+      Field pre = (Field)parser.createField(sf, o);
       if (pre != null) {
-        res.addValue(pre, 1.0f);
+        res.addValue(pre);
       } else { // restore the original value
         log.warn("Could not parse field {} - using original value as is: {}", src.getName(), o);
-        res.addValue(o, 1.0f);
+        res.addValue(o);
       }
     }
     return res;
diff --git a/solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java b/solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java
index 579ccf0..f4a14db 100644
--- a/solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java
+++ b/solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java
@@ -506,32 +506,32 @@ public class BasicFunctionalityTest extends SolrTestCaseJ4 {
     IndexableField luf; // Lucene field
 
     f = ischema.getField("test_basictv");
-    luf = f.createField("test", 0f);
+    luf = f.createField("test");
     assertTrue(f.storeTermVector());
     assertTrue(luf.fieldType().storeTermVectors());
 
     f = ischema.getField("test_notv");
-    luf = f.createField("test", 0f);
+    luf = f.createField("test");
     assertTrue(!f.storeTermVector());
     assertTrue(!luf.fieldType().storeTermVectors());
 
     f = ischema.getField("test_postv");
-    luf = f.createField("test", 0f);
+    luf = f.createField("test");
     assertTrue(f.storeTermVector() && f.storeTermPositions());
     assertTrue(luf.fieldType().storeTermVectorPositions());
 
     f = ischema.getField("test_offtv");
-    luf = f.createField("test", 0f);
+    luf = f.createField("test");
     assertTrue(f.storeTermVector() && f.storeTermOffsets());
     assertTrue(luf.fieldType().storeTermVectorOffsets());
 
     f = ischema.getField("test_posofftv");
-    luf = f.createField("test", 0f);
+    luf = f.createField("test");
     assertTrue(f.storeTermVector() && f.storeTermPositions() && f.storeTermOffsets());
     assertTrue(luf.fieldType().storeTermVectorOffsets() && luf.fieldType().storeTermVectorPositions());
 
     f = ischema.getField("test_posoffpaytv");
-    luf = f.createField("test", 0f);
+    luf = f.createField("test");
     assertTrue(f.storeTermVector() && f.storeTermPositions() && f.storeTermOffsets() && f.storeTermPayloads());
     assertTrue(luf.fieldType().storeTermVectorOffsets() && luf.fieldType().storeTermVectorPositions() && luf.fieldType().storeTermVectorPayloads());
 
diff --git a/solr/core/src/test/org/apache/solr/TestDocumentBuilder.java b/solr/core/src/test/org/apache/solr/TestDocumentBuilder.java
index df8ef00..a3ca089 100644
--- a/solr/core/src/test/org/apache/solr/TestDocumentBuilder.java
+++ b/solr/core/src/test/org/apache/solr/TestDocumentBuilder.java
@@ -41,7 +41,6 @@ public class TestDocumentBuilder extends LuceneTestCase {
     list.add(33);
     list.add(20);
     doc.addField("field5", list);
-    doc.setDocumentBoost(5f);
     
     SolrInputDocument clone = doc.deepCopy();
     
diff --git a/solr/core/src/test/org/apache/solr/cloud/TestCloudDeleteByQuery.java b/solr/core/src/test/org/apache/solr/cloud/TestCloudDeleteByQuery.java
index 2f6c5e9..ec2dac6 100644
--- a/solr/core/src/test/org/apache/solr/cloud/TestCloudDeleteByQuery.java
+++ b/solr/core/src/test/org/apache/solr/cloud/TestCloudDeleteByQuery.java
@@ -244,7 +244,7 @@ public class TestCloudDeleteByQuery extends SolrCloudTestCase {
   
   public static SolrInputField f(String fieldName, Object... values) {
     SolrInputField f = new SolrInputField(fieldName);
-    f.setValue(values, 1.0F);
+    f.setValue(values);
     return f;
   }
 }
diff --git a/solr/core/src/test/org/apache/solr/cloud/TestStressCloudBlindAtomicUpdates.java b/solr/core/src/test/org/apache/solr/cloud/TestStressCloudBlindAtomicUpdates.java
index 9f29d3d..9c04f75 100644
--- a/solr/core/src/test/org/apache/solr/cloud/TestStressCloudBlindAtomicUpdates.java
+++ b/solr/core/src/test/org/apache/solr/cloud/TestStressCloudBlindAtomicUpdates.java
@@ -437,13 +437,13 @@ public class TestStressCloudBlindAtomicUpdates extends SolrCloudTestCase {
   
   public static SolrInputField f(String fieldName, Object... values) {
     SolrInputField f = new SolrInputField(fieldName);
-    f.setValue(values, 1.0F);
+    f.setValue(values);
     // TODO: soooooooooo stupid (but currently neccessary because atomic updates freak out
     // if the Map with the "inc" operation is inside of a collection - even if it's the only "value") ...
     if (1 == values.length) {
-      f.setValue(values[0], 1.0F);
+      f.setValue(values[0]);
     } else {
-      f.setValue(values, 1.0F);
+      f.setValue(values);
     }
     return f;
   }
diff --git a/solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud.java b/solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud.java
index f5dead9..f66f892 100644
--- a/solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud.java
+++ b/solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud.java
@@ -1036,7 +1036,7 @@ public class TestTolerantUpdateProcessorCloud extends SolrCloudTestCase {
   
   public static SolrInputField f(String fieldName, Object... values) {
     SolrInputField f = new SolrInputField(fieldName);
-    f.setValue(values, 1.0F);
+    f.setValue(values);
     return f;
   }
 
diff --git a/solr/core/src/test/org/apache/solr/handler/JsonLoaderTest.java b/solr/core/src/test/org/apache/solr/handler/JsonLoaderTest.java
index 5ca51c8..4f8b7da 100644
--- a/solr/core/src/test/org/apache/solr/handler/JsonLoaderTest.java
+++ b/solr/core/src/test/org/apache/solr/handler/JsonLoaderTest.java
@@ -52,7 +52,7 @@ public class JsonLoaderTest extends SolrTestCaseJ4 {
       "    },\n" +
       "    'array': [ 'aaa', 'bbb' ],\n" +
       "    'boosted': {\n" +
-      "      'boost': 6.7,\n" +
+      "      'boost': 6.7,\n" + // make sure we still accept boosts
       "      'value': [ 'aaa', 'bbb' ]\n" +
       "    }\n" +
       "  }\n" +
@@ -94,7 +94,6 @@ public class JsonLoaderTest extends SolrTestCaseJ4 {
     AddUpdateCommand add = p.addCommands.get(0);
     SolrInputDocument d = add.solrDoc;
     SolrInputField f = d.getField( "boosted" );
-    assertEquals(6.7f, f.getBoost(), 0.1);
     assertEquals(2, f.getValues().size());
 
     // 
@@ -102,7 +101,6 @@ public class JsonLoaderTest extends SolrTestCaseJ4 {
     d = add.solrDoc;
     f = d.getField( "f1" );
     assertEquals(2, f.getValues().size());
-    assertEquals(3.45f, d.getDocumentBoost(), 0.001);
     assertEquals(false, add.overwrite);
 
     assertEquals(0, d.getField("f2").getValueCount());
@@ -262,7 +260,6 @@ public class JsonLoaderTest extends SolrTestCaseJ4 {
     assertEquals(2, d.getFieldNames().size());
     assertEquals("1", d.getFieldValue("id"));
     assertEquals(new Object[] {45L, 67L, 89L} , d.getFieldValues("f").toArray());
-    assertEquals(0.0F, fBoost, d.getField("f").getBoost());
 
     d = p.addCommands.get(1).solrDoc;
     assertEquals(1, d.getFieldNames().size());
diff --git a/solr/core/src/test/org/apache/solr/handler/XmlUpdateRequestHandlerTest.java b/solr/core/src/test/org/apache/solr/handler/XmlUpdateRequestHandlerTest.java
index 7282e19..6d46722 100644
--- a/solr/core/src/test/org/apache/solr/handler/XmlUpdateRequestHandlerTest.java
+++ b/solr/core/src/test/org/apache/solr/handler/XmlUpdateRequestHandlerTest.java
@@ -76,13 +76,6 @@ public class XmlUpdateRequestHandlerTest extends SolrTestCaseJ4 {
     XMLLoader loader = new XMLLoader();
     SolrInputDocument doc = loader.readDoc( parser );
     
-    // Read boosts
-    assertEquals( 5.5f, doc.getDocumentBoost(), 0.1);
-    assertEquals( 1.0f, doc.getField( "name" ).getBoost(), 0.1);
-    assertEquals( 2.2f, doc.getField( "id" ).getBoost(), 0.1);
-    // Boost is the product of each value
-    assertEquals( (3*4*5.0f), doc.getField( "cat" ).getBoost(), 0.1);
-    
     // Read values
     assertEquals( "12345", doc.getField( "id" ).getValue() );
     assertEquals( "kitten", doc.getField( "name").getValue() );
diff --git a/solr/core/src/test/org/apache/solr/schema/AbstractCurrencyFieldTest.java b/solr/core/src/test/org/apache/solr/schema/AbstractCurrencyFieldTest.java
index e633a13..a195794 100644
--- a/solr/core/src/test/org/apache/solr/schema/AbstractCurrencyFieldTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/AbstractCurrencyFieldTest.java
@@ -98,7 +98,7 @@ public abstract class AbstractCurrencyFieldTest extends SolrTestCaseJ4 {
     FieldType tmp = amount.getType();
     assertTrue(tmp instanceof CurrencyField);
     String currencyValue = "1.50,EUR";
-    List<IndexableField> fields = amount.createFields(currencyValue, 2);
+    List<IndexableField> fields = amount.createFields(currencyValue);
     assertEquals(fields.size(), 3);
 
     // First field is currency code, second is value, third is stored.
diff --git a/solr/core/src/test/org/apache/solr/schema/DateFieldTest.java b/solr/core/src/test/org/apache/solr/schema/DateFieldTest.java
index 9e88b6e..ac451bf 100644
--- a/solr/core/src/test/org/apache/solr/schema/DateFieldTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/DateFieldTest.java
@@ -50,13 +50,13 @@ public class DateFieldTest extends SolrTestCaseJ4 {
     int props = FieldProperties.INDEXED ^ FieldProperties.STORED;
     SchemaField sf = new SchemaField( "test", f, props, null );
     // String
-    IndexableField out = f.createField(sf, "1995-12-31T23:59:59Z", 1.0f );
+    IndexableField out = f.createField(sf, "1995-12-31T23:59:59Z" );
     assertEquals(820454399000L, f.toObject( out ).getTime() );
     // Date obj
-    out = f.createField(sf, new Date(820454399000L), 1.0f );
+    out = f.createField(sf, new Date(820454399000L) );
     assertEquals(820454399000L, f.toObject( out ).getTime() );
     // Date math
-    out = f.createField(sf, "1995-12-31T23:59:59.99Z+5MINUTES", 1.0f);
+    out = f.createField(sf, "1995-12-31T23:59:59.99Z+5MINUTES");
     assertEquals(820454699990L, f.toObject( out ).getTime() );
   }
 
diff --git a/solr/core/src/test/org/apache/solr/schema/DocValuesTest.java b/solr/core/src/test/org/apache/solr/schema/DocValuesTest.java
index cc3486e..cf43a68 100644
--- a/solr/core/src/test/org/apache/solr/schema/DocValuesTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/DocValuesTest.java
@@ -152,7 +152,7 @@ public class DocValuesTest extends SolrTestCaseJ4 {
   }
 
   private void tstToObj(SchemaField sf, Object o) {
-    List<IndexableField> fields = sf.createFields(o, 1.0f);
+    List<IndexableField> fields = sf.createFields(o);
     for (IndexableField field : fields) {
       assertEquals( sf.getType().toObject(field), o);
     }
diff --git a/solr/core/src/test/org/apache/solr/schema/PolyFieldTest.java b/solr/core/src/test/org/apache/solr/schema/PolyFieldTest.java
index f788ba0..6839c70 100644
--- a/solr/core/src/test/org/apache/solr/schema/PolyFieldTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/PolyFieldTest.java
@@ -83,7 +83,7 @@ public class PolyFieldTest extends SolrTestCaseJ4 {
     assertEquals(pt.getDimension(), 2);
     double[] xy = new double[]{35.0, -79.34};
     String point = xy[0] + "," + xy[1];
-    List<IndexableField> fields = home.createFields(point, 2);
+    List<IndexableField> fields = home.createFields(point);
     assertEquals(fields.size(), 3);//should be 3, we have a stored field
     //first two fields contain the values, third is just stored and contains the original
     for (int i = 0; i < 3; i++) {
@@ -99,13 +99,13 @@ public class PolyFieldTest extends SolrTestCaseJ4 {
 
     home = schema.getField("home_ns");
     assertNotNull(home);
-    fields = home.createFields(point, 2);
+    fields = home.createFields(point);
     assertEquals(fields.size(), 2);//should be 2, since we aren't storing
 
     home = schema.getField("home_ns");
     assertNotNull(home);
     try {
-      fields = home.createFields("35.0,foo", 2);
+      fields = home.createFields("35.0,foo");
       assertTrue(false);
     } catch (Exception e) {
       //
@@ -115,7 +115,7 @@ public class PolyFieldTest extends SolrTestCaseJ4 {
     SchemaField s1 = schema.getField("test_p");
     SchemaField s2 = schema.getField("test_p");
     // If we use [Int/Double/Long/Float]PointField, we can't get the valueSource, since docValues is false
-    if (s1.createFields("1,2", 0).get(0).fieldType().pointDimensionCount() == 0) {
+    if (s1.createFields("1,2").get(0).fieldType().pointDimensionCount() == 0) {
       assertFalse(s2.getType().isPointField());
       ValueSource v1 = s1.getType().getValueSource(s1, null);
       ValueSource v2 = s2.getType().getValueSource(s2, null);
diff --git a/solr/core/src/test/org/apache/solr/schema/PreAnalyzedFieldTest.java b/solr/core/src/test/org/apache/solr/schema/PreAnalyzedFieldTest.java
index 622a634..a494654 100644
--- a/solr/core/src/test/org/apache/solr/schema/PreAnalyzedFieldTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/PreAnalyzedFieldTest.java
@@ -105,7 +105,7 @@ public class PreAnalyzedFieldTest extends SolrTestCaseJ4 {
     for (int i = 0; i < valid.length; i++) {
       String s = valid[i];
       try {
-        Field f = (Field)paf.fromString(field, s, 1.0f);
+        Field f = (Field)paf.fromString(field, s);
         //System.out.println(" - toString: '" + sb.toString() + "'");
         assertEquals(validParsed[i], parser.toFormattedString(f));
       } catch (Exception e) {
@@ -179,7 +179,7 @@ public class PreAnalyzedFieldTest extends SolrTestCaseJ4 {
     paf.init(h.getCore().getLatestSchema(), Collections.<String,String>emptyMap());
     for (String s : invalidSimple) {
       try {
-        paf.fromString(field, s, 1.0f);
+        paf.fromString(field, s);
         fail("should fail: '" + s + "'");
       } catch (Exception e) {
         //
@@ -232,7 +232,7 @@ public class PreAnalyzedFieldTest extends SolrTestCaseJ4 {
     args.put(PreAnalyzedField.PARSER_IMPL, SimplePreAnalyzedParser.class.getName());
     paf.init(h.getCore().getLatestSchema(), args);
     try {
-      Field f = (Field)paf.fromString(field, valid[0], 1.0f);
+      Field f = (Field)paf.fromString(field, valid[0]);
     } catch (Exception e) {
       fail("Should pass: '" + valid[0] + "', exception: " + e);
     }
@@ -240,14 +240,14 @@ public class PreAnalyzedFieldTest extends SolrTestCaseJ4 {
     args.put(PreAnalyzedField.PARSER_IMPL, JsonPreAnalyzedParser.class.getName());
     paf.init(h.getCore().getLatestSchema(), args);
     try {
-      Field f = (Field)paf.fromString(field, valid[0], 1.0f);
+      Field f = (Field)paf.fromString(field, valid[0]);
       fail("Should fail JSON parsing: '" + valid[0] + "'");
     } catch (Exception e) {
     }
     byte[] deadbeef = new byte[]{(byte)0xd, (byte)0xe, (byte)0xa, (byte)0xd, (byte)0xb, (byte)0xe, (byte)0xe, (byte)0xf};
     PreAnalyzedParser parser = new JsonPreAnalyzedParser();
     try {
-      Field f = (Field)paf.fromString(field, jsonValid, 1.0f);
+      Field f = (Field)paf.fromString(field, jsonValid);
       assertEquals(jsonValid, parser.toFormattedString(f));
     } catch (Exception e) {
       fail("Should pass: '" + jsonValid + "', exception: " + e);
diff --git a/solr/core/src/test/org/apache/solr/schema/SortableBinaryField.java b/solr/core/src/test/org/apache/solr/schema/SortableBinaryField.java
index 1ebf4cc..b8ed296 100644
--- a/solr/core/src/test/org/apache/solr/schema/SortableBinaryField.java
+++ b/solr/core/src/test/org/apache/solr/schema/SortableBinaryField.java
@@ -40,10 +40,10 @@ public class SortableBinaryField extends BinaryField {
   }
 
   @Override
-  public List<IndexableField> createFields(SchemaField field, Object value, float boost) {
+  public List<IndexableField> createFields(SchemaField field, Object value) {
     if (field.hasDocValues()) {
       List<IndexableField> fields = new ArrayList<>();
-      IndexableField storedField = createField(field, value, boost);
+      IndexableField storedField = createField(field, value);
       fields.add(storedField);
       ByteBuffer byteBuffer = toObject(storedField);
       BytesRef bytes = new BytesRef
@@ -55,7 +55,7 @@ public class SortableBinaryField extends BinaryField {
       }
       return fields;
     } else {
-      return Collections.singletonList(createField(field, value, boost));
+      return Collections.singletonList(createField(field, value));
     }
   }
 
diff --git a/solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates.java b/solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates.java
index c2e8b2e..ca48f78 100644
--- a/solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates.java
+++ b/solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates.java
@@ -149,7 +149,7 @@ public class TestSchemalessBufferedUpdates extends SolrTestCaseJ4 {
         // Non-JSON types (Date in this case) aren't handled properly in noggit-0.6.  Although this is fixed in 
         // https://github.com/yonik/noggit/commit/ec3e732af7c9425e8f40297463cbe294154682b1 to call obj.toString(), 
         // Date::toString produces a Date representation that Solr doesn't like, so we convert using Instant::toString
-        cmd.solrDoc.get("f_dt").setValue(((Date) cmd.solrDoc.get("f_dt").getValue()).toInstant().toString(), 1.0f);
+        cmd.solrDoc.get("f_dt").setValue(((Date) cmd.solrDoc.get("f_dt").getValue()).toInstant().toString());
       }
       return cmd.solrDoc;
     } finally {
diff --git a/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java b/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java
index 8c65b58..92f2863 100644
--- a/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java
+++ b/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java
@@ -432,7 +432,6 @@ public class TestFunctionQuery extends SolrTestCaseJ4 {
             "//float[@name='score']='" + similarity.tf(5)  + "'");
     
     FieldInvertState state = new FieldInvertState("a_tfidf");
-    state.setBoost(1.0f);
     state.setLength(4);
     long norm = similarity.computeNorm(state);
     float nrm = similarity.decodeNormValue((byte) norm);
diff --git a/solr/core/src/test/org/apache/solr/update/DocumentBuilderTest.java b/solr/core/src/test/org/apache/solr/update/DocumentBuilderTest.java
index 2c0b634..2a78d6b 100644
--- a/solr/core/src/test/org/apache/solr/update/DocumentBuilderTest.java
+++ b/solr/core/src/test/org/apache/solr/update/DocumentBuilderTest.java
@@ -16,30 +16,15 @@
  */
 package org.apache.solr.update;
 
-import java.util.List;
-
 import org.apache.lucene.document.Document;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.LeafReader;
-import org.apache.lucene.index.NumericDocValues;
-import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.util.TestUtil;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.SolrInputField;
-import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.index.SlowCompositeReaderWrapper;
-import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.response.ResultContext;
-import org.apache.solr.response.SolrQueryResponse;
-import org.apache.solr.schema.CopyField;
 import org.apache.solr.schema.FieldType;
-import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.search.DocList;
-import org.apache.solr.search.SolrIndexSearcher;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -62,7 +47,7 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
     // undefined field
     try {
       SolrInputDocument doc = new SolrInputDocument();
-      doc.setField( "unknown field", 12345, 1.0f );
+      doc.setField( "unknown field", 12345 );
       DocumentBuilder.toDocument( doc, core.getLatestSchema() );
       fail( "should throw an error" );
     }
@@ -78,7 +63,7 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
     
     // make sure a null value is not indexed
     SolrInputDocument doc = new SolrInputDocument();
-    doc.addField( "name", null, 1.0f );
+    doc.addField( "name", null );
     Document out = DocumentBuilder.toDocument( doc, core.getLatestSchema() );
     assertNull( out.get( "name" ) );
   }
@@ -90,8 +75,8 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
     
     // make sure a null value is not indexed
     SolrInputDocument doc = new SolrInputDocument();
-    doc.addField( "id", "123", 1.0f );
-    doc.addField( "unknown", "something", 1.0f );
+    doc.addField( "id", "123" );
+    doc.addField( "unknown", "something" );
     try {
       DocumentBuilder.toDocument( doc, core.getLatestSchema() );
       fail( "added an unknown field" );
@@ -102,7 +87,7 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
     doc.remove( "unknown" );
     
 
-    doc.addField( "weight", "not a number", 1.0f );
+    doc.addField( "weight", "not a number" );
     try {
       DocumentBuilder.toDocument( doc, core.getLatestSchema() );
       fail( "invalid 'float' field value" );
@@ -113,7 +98,7 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
     }
     
     // now make sure it is OK
-    doc.setField( "weight", "1.34", 1.0f );
+    doc.setField( "weight", "1.34" );
     DocumentBuilder.toDocument( doc, core.getLatestSchema() );
   }
 
@@ -123,95 +108,15 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
 
     // make sure a null value is not indexed
     SolrInputDocument doc = new SolrInputDocument();
-    doc.addField( "home", "2.2,3.3", 1.0f );
+    doc.addField( "home", "2.2,3.3" );
     Document out = DocumentBuilder.toDocument( doc, core.getLatestSchema() );
     assertNotNull( out.get( "home" ) );//contains the stored value and term vector, if there is one
     assertNotNull( out.getField( "home_0" + FieldType.POLY_FIELD_SEPARATOR + "double" ) );
     assertNotNull( out.getField( "home_1" + FieldType.POLY_FIELD_SEPARATOR + "double" ) );
   }
   
-  @Test
-  public void testCopyFieldWithDocumentBoost() {
-    SolrCore core = h.getCore();
-    IndexSchema schema = core.getLatestSchema();
-    assertFalse(schema.getField("title").omitNorms());
-    assertTrue(schema.getField("title_stringNoNorms").omitNorms());
-    SolrInputDocument doc = new SolrInputDocument();
-    doc.setDocumentBoost(3f);
-    doc.addField( "title", "mytitle");
-    Document out = DocumentBuilder.toDocument( doc, schema );
-    assertNotNull( out.get( "title_stringNoNorms" ) );
-    assertTrue("title_stringNoNorms has the omitNorms attribute set to true, if the boost is different than 1.0, it will fail",1.0f == out.getField( "title_stringNoNorms" ).boost() );
-    assertTrue("It is OK that title has a boost of 3",3.0f == out.getField( "title" ).boost() );
-  }
-  
-  
-  @Test
-  public void testCopyFieldWithFieldBoost() {
-    SolrCore core = h.getCore();
-    IndexSchema schema = core.getLatestSchema();
-    assertFalse(schema.getField("title").omitNorms());
-    assertTrue(schema.getField("title_stringNoNorms").omitNorms());
-    SolrInputDocument doc = new SolrInputDocument();
-    doc.addField( "title", "mytitle", 3.0f );
-    Document out = DocumentBuilder.toDocument( doc, schema );
-    assertNotNull( out.get( "title_stringNoNorms" ) );
-    assertTrue("title_stringNoNorms has the omitNorms attribute set to true, if the boost is different than 1.0, it will fail",1.0f == out.getField( "title_stringNoNorms" ).boost() );
-    assertTrue("It is OK that title has a boost of 3",3.0f == out.getField( "title" ).boost() );
-  }
-  
-  @Test
-  public void testWithPolyFieldsAndFieldBoost() {
-    SolrCore core = h.getCore();
-    IndexSchema schema = core.getLatestSchema();
-    assertFalse(schema.getField("store").omitNorms());
-    assertTrue(schema.getField("store_0_coordinate").omitNorms());
-    assertTrue(schema.getField("store_1_coordinate").omitNorms());
-    assertFalse(schema.getField("amount").omitNorms());
-    assertTrue(schema.getField("amount" + FieldType.POLY_FIELD_SEPARATOR + "_currency").omitNorms());
-    assertTrue(schema.getField("amount" + FieldType.POLY_FIELD_SEPARATOR + "_amount_raw").omitNorms());
-    
-    SolrInputDocument doc = new SolrInputDocument();
-    doc.addField( "store", "40.7143,-74.006", 3.0f );
-    doc.addField( "amount", "10.5", 3.0f );
-    Document out = DocumentBuilder.toDocument( doc, schema );
-    assertNotNull( out.get( "store" ) );
-    assertNotNull( out.get( "amount" ) );
-    assertNotNull(out.getField("store_0_coordinate"));
-    //NOTE: As the subtypes have omitNorm=true, they must have boost=1F, otherwise this is going to fail when adding the doc to Lucene.
-    assertTrue(1f == out.getField("store_0_coordinate").boost());
-    assertTrue(1f == out.getField("store_1_coordinate").boost());
-    assertTrue(1f == out.getField("amount" + FieldType.POLY_FIELD_SEPARATOR + "_currency").boost());
-    assertTrue(1f == out.getField("amount" + FieldType.POLY_FIELD_SEPARATOR + "_amount_raw").boost());
-  }
-  
-  @Test
-  public void testWithPolyFieldsAndDocumentBoost() {
-    SolrCore core = h.getCore();
-    IndexSchema schema = core.getLatestSchema();
-    assertFalse(schema.getField("store").omitNorms());
-    assertTrue(schema.getField("store_0_coordinate").omitNorms());
-    assertTrue(schema.getField("store_1_coordinate").omitNorms());
-    assertFalse(schema.getField("amount").omitNorms());
-    assertTrue(schema.getField("amount" + FieldType.POLY_FIELD_SEPARATOR + "_currency").omitNorms());
-    assertTrue(schema.getField("amount" + FieldType.POLY_FIELD_SEPARATOR + "_amount_raw").omitNorms());
-    
-    SolrInputDocument doc = new SolrInputDocument();
-    doc.setDocumentBoost(3.0f);
-    doc.addField( "store", "40.7143,-74.006");
-    doc.addField( "amount", "10.5");
-    Document out = DocumentBuilder.toDocument( doc, schema );
-    assertNotNull( out.get( "store" ) );
-    assertNotNull(out.getField("store_0_coordinate"));
-    //NOTE: As the subtypes have omitNorm=true, they must have boost=1F, otherwise this is going to fail when adding the doc to Lucene.
-    assertTrue(1f == out.getField("store_0_coordinate").boost());
-    assertTrue(1f == out.getField("store_1_coordinate").boost());
-    assertTrue(1f == out.getField("amount" + FieldType.POLY_FIELD_SEPARATOR + "_currency").boost());
-    assertTrue(1f == out.getField("amount" + FieldType.POLY_FIELD_SEPARATOR + "_amount_raw").boost());
-  }
-  
   /**
-   * It's ok to boost a field if it has norms
+   * Even though boosts have been removed, we still support them for bw compat.
    */
   public void testBoost() throws Exception {
     XmlDoc xml = new XmlDoc();
@@ -222,192 +127,6 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
     assertNull(h.validateUpdate(add(xml, new String[0])));
   }
   
-  private void assertMultiValuedFieldAndDocBoosts(SolrInputField field) throws Exception {
-    SolrCore core = h.getCore();
-    IndexSchema schema = core.getLatestSchema();
-    SolrInputDocument doc = new SolrInputDocument();
-    doc.setDocumentBoost(3.0f);
-    field.addValue( "summer time" , 1.0f );
-    field.addValue( "in the city" , 5.0f ); // using boost
-    field.addValue( "living is easy" , 1.0f );
-    doc.put( field.getName(), field );
-
-    Document out = DocumentBuilder.toDocument( doc, schema );
-    IndexableField[] outF = out.getFields( field.getName() );
-    assertEquals("wrong number of field values",
-                 3, outF.length);
-
-    // since Lucene no longer has native documnt boosts, we should find
-    // the doc boost multiplied into the boost o nthe first field value
-    // all other field values should be 1.0f
-    // (lucene will multiply all of the field boosts later)
-    assertEquals(15.0f, outF[0].boost(), 0.0f);
-    assertEquals(1.0f, outF[1].boost(), 0.0f);
-    assertEquals(1.0f, outF[2].boost(), 0.0f);
-    
-  }
-
-  public void testMultiValuedFieldAndDocBoostsWithCopy() throws Exception {
-    SolrCore core = h.getCore();
-    IndexSchema schema = core.getLatestSchema();
-    SolrInputField field = new SolrInputField( "foo_t" );
-    List<CopyField> copyFields = schema.getCopyFieldsList(field.getName());
-    
-    assertNotNull( copyFields );
-    assertFalse( copyFields.isEmpty() );
-    assertMultiValuedFieldAndDocBoosts( field );
-  }
-  
-  public void testMultiValuedFieldAndDocBoostsNoCopy() throws Exception {
-    SolrCore core = h.getCore();
-    IndexSchema schema = core.getLatestSchema();
-    SolrInputField field = new SolrInputField( "t_foo" );
-    List<CopyField> copyFields = schema.getCopyFieldsList(field.getName());
-
-    assertTrue( copyFields == null || copyFields.isEmpty() );
-    assertMultiValuedFieldAndDocBoosts( field );
-  }
-
-  public void testCopyFieldsAndFieldBoostsAndDocBoosts() throws Exception {
-    SolrCore core = h.getCore();
-    IndexSchema schema = core.getLatestSchema();
-    SolrInputDocument doc = new SolrInputDocument();
-
-    final float DOC_BOOST = 3.0F;
-    doc.setDocumentBoost(DOC_BOOST);
-    doc.addField("id", "42");
-
-    SolrInputField inTitle = new SolrInputField( "title" );
-    inTitle.addValue( "titleA" , 2.0F ); 
-    inTitle.addValue( "titleB" , 7.0F ); 
-    final float TITLE_BOOST = 2.0F * 7.0F;
-    assertEquals(TITLE_BOOST, inTitle.getBoost(), 0.0F);
-    doc.put( inTitle.getName(), inTitle );
-    
-    SolrInputField inFoo = new SolrInputField( "foo_t" );
-    inFoo.addValue( "summer time" , 1.0F );
-    inFoo.addValue( "in the city" , 5.0F ); 
-    inFoo.addValue( "living is easy" , 11.0F );
-    final float FOO_BOOST = 1.0F * 5.0F * 11.0F;
-    assertEquals(FOO_BOOST, inFoo.getBoost(), 0.0F);
-    doc.put( inFoo.getName(), inFoo );
-
-    Document out = DocumentBuilder.toDocument( doc, schema );
-
-    IndexableField[] outTitle = out.getFields( inTitle.getName() );
-    assertEquals("wrong number of title values",
-                 2, outTitle.length);
-
-    IndexableField[] outNoNorms = out.getFields( "title_stringNoNorms" );
-    assertEquals("wrong number of nonorms values",
-                 2, outNoNorms.length);
-
-    IndexableField[] outFoo = out.getFields( inFoo.getName() );
-    assertEquals("wrong number of foo values",
-                 3, outFoo.length);
-
-    IndexableField[] outText = out.getFields( "text" );
-    assertEquals("wrong number of text values",
-                 5, outText.length);
-
-    // since Lucene no longer has native document boosts, we should find
-    // the doc boost multiplied into the boost on the first field value
-    // of each field.  All other field values should be 1.0f
-    // (lucene will multiply all of the field value boosts later)
-    assertEquals(TITLE_BOOST * DOC_BOOST, outTitle[0].boost(), 0.0F);
-    assertEquals(1.0F,                    outTitle[1].boost(), 0.0F);
-    //
-    assertEquals(FOO_BOOST * DOC_BOOST,   outFoo[0].boost(), 0.0F);
-    assertEquals(1.0F,                    outFoo[1].boost(), 0.0F);
-    assertEquals(1.0F,                    outFoo[2].boost(), 0.0F);
-    //
-    assertEquals(TITLE_BOOST * DOC_BOOST, outText[0].boost(), 0.0F);
-    assertEquals(1.0F,                    outText[1].boost(), 0.0F);
-    assertEquals(FOO_BOOST,               outText[2].boost(), 0.0F);
-    assertEquals(1.0F,                    outText[3].boost(), 0.0F);
-    assertEquals(1.0F,                    outText[4].boost(), 0.0F);
-    
-    // copyField dest with no norms should not have received any boost
-    assertEquals(1.0F, outNoNorms[0].boost(), 0.0F);
-    assertEquals(1.0F, outNoNorms[1].boost(), 0.0F);
-    
-    // now index that SolrInputDocument to check the computed norms
-
-    assertU(adoc(doc));
-    assertU(commit());
-
-    SolrQueryRequest req = req("q", "id:42");
-    try {
-      // very hack-ish
-
-      SolrQueryResponse rsp = new SolrQueryResponse();
-      core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);
-
-      DocList dl = ((ResultContext) rsp.getResponse()).getDocList();
-      assertTrue("can't find the doc we just added", 1 == dl.size());
-      int docid = dl.iterator().nextDoc();
-
-      SolrIndexSearcher searcher = req.getSearcher();
-      LeafReader reader = SlowCompositeReaderWrapper.wrap(searcher.getTopReaderContext().reader());
-
-      assertTrue("similarity doesn't extend ClassicSimilarity, " + 
-                 "config or defaults have changed since test was written",
-                 searcher.getSimilarity(true) instanceof ClassicSimilarity);
-
-      ClassicSimilarity sim = (ClassicSimilarity) searcher.getSimilarity(true);
-      
-      NumericDocValues titleNorms = reader.getNormValues("title");
-      NumericDocValues fooNorms = reader.getNormValues("foo_t");
-      NumericDocValues textNorms =  reader.getNormValues("text");
-
-      assertEquals(docid, titleNorms.advance(docid));
-      assertEquals(expectedNorm(sim, 2, TITLE_BOOST * DOC_BOOST),
-                   titleNorms.longValue());
-
-      assertEquals(docid, fooNorms.advance(docid));
-      assertEquals(expectedNorm(sim, 8-3, FOO_BOOST * DOC_BOOST),
-                   fooNorms.longValue());
-
-      assertEquals(docid, textNorms.advance(docid));
-      assertEquals(expectedNorm(sim, 2 + 8-3, 
-                                TITLE_BOOST * FOO_BOOST * DOC_BOOST),
-                   textNorms.longValue());
-
-    } finally {
-      req.close();
-    }
-  }
-
-  /**
-   * Given a length, and boost returns the expected encoded norm 
-   */
-  private static byte expectedNorm(final ClassicSimilarity sim,
-                                   final int length, final float boost) {
-    return (byte) sim.encodeNormValue(boost / ((float) Math.sqrt(length)));
-  }
-    
-
-  public void testBoostOmitNorms() throws Exception {
-    XmlDoc xml = new XmlDoc();
-    // explicitly boosting a field if that omits norms is not ok
-    xml.xml = "<doc>"
-        + "<field name=\"id\">ignore_exception</field>"
-        + "<field name=\"title_stringNoNorms\" boost=\"3.0\">mytitle</field>"
-        + "</doc>";
-    try {
-      assertNull(h.validateUpdate(add(xml, new String[0])));
-      fail("didn't get expected exception for boosting omit norms field");
-    } catch (SolrException expected) {
-      // expected exception
-    }
-    // boosting a field that is copied to another field that omits norms is ok
-    xml.xml = "<doc>"
-      + "<field name=\"id\">42</field>"
-      + "<field name=\"title\" boost=\"3.0\">mytitle</field>"
-      + "</doc>";
-    assertNull(h.validateUpdate(add(xml, new String[0])));
-  }
-  
   /**
    * It's ok to supply a document boost even if a field omits norms
    */
@@ -467,15 +186,6 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
 
     assertTrue(compareSolrInputDocument(doc1, doc2));
 
-    doc1.setDocumentBoost(1.1f);
-    assertFalse(compareSolrInputDocument(doc1, doc2));
-
-    doc2.setDocumentBoost(1.1f);
-    assertTrue(compareSolrInputDocument(doc1, doc2));
-
-    doc2.setDocumentBoost(20f);
-    assertFalse(compareSolrInputDocument(doc1, doc2));
-
 
     doc1 = new SolrInputDocument();
     doc1.addField("foo", randomString);
@@ -503,19 +213,12 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
 
     int val = random().nextInt();
     SolrInputField sif1 = new SolrInputField(randomString);
-    sif1.setValue(val, 1.0f);
+    sif1.setValue(val);
     SolrInputField sif2 = new SolrInputField(randomString);
-    sif2.setValue(val, 1.0f);
-
-    assertTrue(assertSolrInputFieldEquals(sif1, sif2));
+    sif2.setValue(val);
 
-    sif1.setBoost(2.1f);
-    sif2.setBoost(2.1f);
     assertTrue(assertSolrInputFieldEquals(sif1, sif2));
 
-    sif2.setBoost(2.0f);
-    assertFalse(assertSolrInputFieldEquals(sif1, sif2));
-
     sif2.setName("foo");
     assertFalse(assertSolrInputFieldEquals(sif1, sif2));
 
diff --git a/solr/core/src/test/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactoryTest.java b/solr/core/src/test/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactoryTest.java
index c01c319..051cad1 100644
--- a/solr/core/src/test/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactoryTest.java
+++ b/solr/core/src/test/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactoryTest.java
@@ -177,7 +177,7 @@ public class CloneFieldUpdateProcessorFactoryTest extends UpdateProcessorTestBas
       // append to existing values, preserve boost
       d = processAdd(chain,
                      doc(f("id", "1111"),
-                         field("dest_s", 2.3f, "orig1", "orig2"),
+                         field("dest_s", "orig1", "orig2"),
                          f("source0_s", "NOT COPIED"),
                          f("source1_s", "123456789", "", 42, "abcd")));
       assertNotNull(chain, d);
@@ -187,8 +187,6 @@ public class CloneFieldUpdateProcessorFactoryTest extends UpdateProcessorTestBas
       assertEquals(chain,
                    Arrays.asList("orig1", "orig2", "123456789", "", 42, "abcd"),
                    d.getFieldValues("dest_s"));
-      assertEquals(chain + ": dest boost changed",
-                   2.3f, d.getField("dest_s").getBoost(), 0.0f);
     }
 
     // should be equivalent for any chain matching source1_s and source2_s (but not source0_s)
@@ -213,10 +211,10 @@ public class CloneFieldUpdateProcessorFactoryTest extends UpdateProcessorTestBas
                    Arrays.asList("123456789", "", 42, "abcd", "xxx", 999),
                    d.getFieldValues("dest_s"));
 
-      // append to existing values, preserve boost
+      // append to existing values
       d = processAdd(chain,
                      doc(f("id", "1111"),
-                         field("dest_s", 2.3f, "orig1", "orig2"),
+                         field("dest_s", "orig1", "orig2"),
                          f("source0_s", "NOT COPIED"),
                          f("source1_s", "123456789", "", 42, "abcd"),
                          f("source2_s", "xxx", 999)));
@@ -232,8 +230,6 @@ public class CloneFieldUpdateProcessorFactoryTest extends UpdateProcessorTestBas
                                  "123456789", "", 42, "abcd",
                                  "xxx", 999),
                    d.getFieldValues("dest_s"));
-      assertEquals(chain + ": dest boost changed",
-                   2.3f, d.getField("dest_s").getBoost(), 0.0f);
     }
     
     // any chain that copies source1_s to dest_s should be equivalent for these assertions
@@ -258,7 +254,7 @@ public class CloneFieldUpdateProcessorFactoryTest extends UpdateProcessorTestBas
       // append to existing values, preserve boost
       d = processAdd(chain,
                      doc(f("id", "1111"),
-                         field("dest_s", 2.3f, "orig1", "orig2"),
+                         field("dest_s", "orig1", "orig2"),
                          f("source1_s", "123456789", "", 42, "abcd")));
       assertNotNull(chain, d);
       assertEquals(chain,
@@ -267,8 +263,6 @@ public class CloneFieldUpdateProcessorFactoryTest extends UpdateProcessorTestBas
       assertEquals(chain,
                    Arrays.asList("orig1", "orig2", "123456789", "", 42, "abcd"),
                    d.getFieldValues("dest_s"));
-      assertEquals(chain + ": dest boost changed",
-                   2.3f, d.getField("dest_s").getBoost(), 0.0f);
     }
   }
 
diff --git a/solr/core/src/test/org/apache/solr/update/processor/DefaultValueUpdateProcessorTest.java b/solr/core/src/test/org/apache/solr/update/processor/DefaultValueUpdateProcessorTest.java
index c90a727..e328267 100644
--- a/solr/core/src/test/org/apache/solr/update/processor/DefaultValueUpdateProcessorTest.java
+++ b/solr/core/src/test/org/apache/solr/update/processor/DefaultValueUpdateProcessorTest.java
@@ -104,12 +104,11 @@ public class DefaultValueUpdateProcessorTest extends SolrTestCaseJ4 {
   /** 
    * Convenience method for building up SolrInputFields
    */
-  SolrInputField field(String name, float boost, Object... values) {
+  SolrInputField field(String name, Object... values) {
     SolrInputField f = new SolrInputField(name);
     for (Object v : values) {
-      f.addValue(v, 1.0F);
+      f.addValue(v);
     }
-    f.setBoost(boost);
     return f;
   }
 
@@ -117,7 +116,7 @@ public class DefaultValueUpdateProcessorTest extends SolrTestCaseJ4 {
    * Convenience method for building up SolrInputFields with default boost
    */
   SolrInputField f(String name, Object... values) {
-    return field(name, 1.0F, values);
+    return field(name, values);
   }
 
 
diff --git a/solr/core/src/test/org/apache/solr/update/processor/FieldMutatingUpdateProcessorTest.java b/solr/core/src/test/org/apache/solr/update/processor/FieldMutatingUpdateProcessorTest.java
index ecfe772..55fa5bd 100644
--- a/solr/core/src/test/org/apache/solr/update/processor/FieldMutatingUpdateProcessorTest.java
+++ b/solr/core/src/test/org/apache/solr/update/processor/FieldMutatingUpdateProcessorTest.java
@@ -75,7 +75,7 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
                        f("name", " Hoss ", new StringBuilder(" Man")),
                        f("foo_t", " some text ", "other Text\t"),
                        f("foo_d", new Integer(42)),
-                       field("foo_s", 5.0F, " string ")));
+                       field("foo_s", " string ")));
 
     assertNotNull(d);
 
@@ -89,8 +89,6 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
     // slightly more interesting
     assertEquals("processor borked non string value", 
                  new Integer(42), d.getFieldValue("foo_d"));
-    assertEquals("wrong boost", 
-                 5.0F, d.getField("foo_s").getBoost(), 0.0F);
   }
 
   public void testUniqValues() throws Exception {
@@ -448,7 +446,7 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
 
     special = new SolrInputField("foo_s");
     special.setValue(new TreeSet<>
-                     (Arrays.asList("ggg", "first", "last", "hhh")), 1.2F);
+                     (Arrays.asList("ggg", "first", "last", "hhh")));
     
     d = processAdd("last-value", 
                    doc(f("id", "1111"),
@@ -461,7 +459,7 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
     // test something that's definitely a List
     
     special = new SolrInputField("foo_s");
-    special.setValue(Arrays.asList("first", "ggg", "hhh", "last"), 1.2F);
+    special.setValue(Arrays.asList("first", "ggg", "hhh", "last"));
     
     d = processAdd("last-value", 
                    doc(f("id", "1111"),
@@ -476,7 +474,7 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
 
     special = new SolrInputField("foo_s");
     special.setValue(new LinkedHashSet<>
-                     (Arrays.asList("first", "ggg", "hhh", "last")), 1.2F);
+                     (Arrays.asList("first", "ggg", "hhh", "last")));
     
     d = processAdd("last-value", 
                    doc(f("id", "1111"),
@@ -819,7 +817,7 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
                    doc(f("id", "1111"),
                        f("foo_t", "string1", "string2"),
                        f("foo_d", new Integer(42)),
-                       field("foo_s", 3.0F, "string3", "string4")));
+                       field("foo_s", "string3", "string4")));
 
     assertNotNull(d);
 
@@ -830,8 +828,6 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
     // slightly more interesting
     assertEquals("processor borked non string value", 
                  new Integer(42), d.getFieldValue("foo_d"));
-    assertEquals("wrong boost", 
-                 3.0F, d.getField("foo_s").getBoost(), 0.0F);
   }
 
 }
diff --git a/solr/core/src/test/org/apache/solr/update/processor/TolerantUpdateProcessorTest.java b/solr/core/src/test/org/apache/solr/update/processor/TolerantUpdateProcessorTest.java
index f4ab1fa..6e7584f 100644
--- a/solr/core/src/test/org/apache/solr/update/processor/TolerantUpdateProcessorTest.java
+++ b/solr/core/src/test/org/apache/solr/update/processor/TolerantUpdateProcessorTest.java
@@ -81,9 +81,9 @@ public class TolerantUpdateProcessorTest extends UpdateProcessorTestBase {
       badIds = new String[10];
       for(int i = 0; i < 10;i++) {
         // a valid document
-        docs.add(doc(field("id", 1f, String.valueOf(2*i)), field("weight", 1f, i)));
+        docs.add(doc(field("id", String.valueOf(2*i)), field("weight", i)));
         // ... and an invalid one
-        docs.add(doc(field("id", 1f, String.valueOf(2*i+1)), field("weight", 1f, "b")));
+        docs.add(doc(field("id", String.valueOf(2*i+1)), field("weight", "b")));
         badIds[i] = String.valueOf(2*i+1);
       }
     }
@@ -119,10 +119,10 @@ public class TolerantUpdateProcessorTest extends UpdateProcessorTestBase {
   
   @Test
   public void testValidAdds() throws IOException {
-    SolrInputDocument validDoc = doc(field("id", 1f, "1"), field("text", 1f, "the quick brown fox"));
+    SolrInputDocument validDoc = doc(field("id", "1"), field("text", "the quick brown fox"));
     add("tolerant-chain-max-errors-10", null, validDoc);
     
-    validDoc = doc(field("id", 1f, "2"), field("text", 1f, "the quick brown fox"));
+    validDoc = doc(field("id", "2"), field("text", "the quick brown fox"));
     add("tolerant-chain-max-errors-not-set", null, validDoc);
     
     assertU(commit());
@@ -136,7 +136,7 @@ public class TolerantUpdateProcessorTest extends UpdateProcessorTestBase {
   
   @Test
   public void testInvalidAdds() throws IOException {
-    SolrInputDocument invalidDoc = doc(field("text", 1f, "the quick brown fox")); //no id
+    SolrInputDocument invalidDoc = doc(field("text", "the quick brown fox")); //no id
     try {
       // This doc should fail without being tolerant
       add("not-tolerant", null, invalidDoc);
@@ -148,7 +148,7 @@ public class TolerantUpdateProcessorTest extends UpdateProcessorTestBase {
     assertAddsSucceedWithErrors("tolerant-chain-max-errors-10", Arrays.asList(new SolrInputDocument[]{invalidDoc}), null, "(unknown)");
     
     //a valid doc
-    SolrInputDocument validDoc = doc(field("id", 1f, "1"), field("text", 1f, "the quick brown fox"));
+    SolrInputDocument validDoc = doc(field("id", "1"), field("text", "the quick brown fox"));
     
     try {
       // This batch should fail without being tolerant
@@ -171,8 +171,8 @@ public class TolerantUpdateProcessorTest extends UpdateProcessorTestBase {
     assertQ(req("q","id:1")
         ,"//result[@numFound='1']");
     
-    invalidDoc = doc(field("id", 1f, "2"), field("weight", 1f, "aaa"));
-    validDoc = doc(field("id", 1f, "3"), field("weight", 1f, "3"));
+    invalidDoc = doc(field("id", "2"), field("weight", "aaa"));
+    validDoc = doc(field("id", "3"), field("weight", "3"));
     
     try {
       // This batch should fail without being tolerant
diff --git a/solr/core/src/test/org/apache/solr/update/processor/UUIDUpdateProcessorFallbackTest.java b/solr/core/src/test/org/apache/solr/update/processor/UUIDUpdateProcessorFallbackTest.java
index bca2d30..2b10953 100644
--- a/solr/core/src/test/org/apache/solr/update/processor/UUIDUpdateProcessorFallbackTest.java
+++ b/solr/core/src/test/org/apache/solr/update/processor/UUIDUpdateProcessorFallbackTest.java
@@ -106,9 +106,8 @@ public class UUIDUpdateProcessorFallbackTest extends SolrTestCaseJ4 {
   SolrInputField field(String name, float boost, Object... values) {
     SolrInputField f = new SolrInputField(name);
     for (Object v : values) {
-      f.addValue(v, 1.0F);
+      f.addValue(v);
     }
-    f.setBoost(boost);
     return f;
   }
 
diff --git a/solr/core/src/test/org/apache/solr/update/processor/UpdateProcessorTestBase.java b/solr/core/src/test/org/apache/solr/update/processor/UpdateProcessorTestBase.java
index e069ee2..d3aa979 100644
--- a/solr/core/src/test/org/apache/solr/update/processor/UpdateProcessorTestBase.java
+++ b/solr/core/src/test/org/apache/solr/update/processor/UpdateProcessorTestBase.java
@@ -151,12 +151,11 @@ public class UpdateProcessorTestBase extends SolrTestCaseJ4 {
   /**
    * Convenience method for building up SolrInputFields
    */
-  final SolrInputField field(String name, float boost, Object... values) {
+  final SolrInputField field(String name, Object... values) {
     SolrInputField f = new SolrInputField(name);
     for (Object v : values) {
-      f.addValue(v, 1.0F);
+      f.addValue(v);
     }
-    f.setBoost(boost);
     return f;
   }
 
@@ -164,6 +163,6 @@ public class UpdateProcessorTestBase extends SolrTestCaseJ4 {
    * Convenience method for building up SolrInputFields with default boost
    */
   final SolrInputField f(String name, Object... values) {
-    return field(name, 1.0F, values);
+    return field(name, values);
   }
 }
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java b/solr/solrj/src/java/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java
index 9550a41..e2e65bb 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java
@@ -86,13 +86,13 @@ public class DocumentObjectBinder {
         Map<String, Object> mapValue = (Map<String, Object>) field.get(obj);
 
         for (Map.Entry<String, Object> e : mapValue.entrySet()) {
-          doc.setField(e.getKey(), e.getValue(), 1.0f);
+          doc.setField(e.getKey(), e.getValue());
         }
       } else {
         if (field.child != null) {
           addChild(obj, field, doc);
         } else {
-          doc.setField(field.name, field.get(obj), 1.0f);
+          doc.setField(field.name, field.get(obj));
         }
       }
     }
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.java
index 47521de..7776a13 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.java
@@ -19,12 +19,14 @@ package org.apache.solr.client.solrj.request;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.lang.invoke.MethodHandles;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.params.ModifiableSolrParams;
@@ -32,6 +34,8 @@ import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.DataInputInputStream;
 import org.apache.solr.common.util.JavaBinCodec;
 import org.apache.solr.common.util.NamedList;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Provides methods for marshalling an UpdateRequest to a NamedList which can be serialized in the javabin format and
@@ -43,6 +47,9 @@ import org.apache.solr.common.util.NamedList;
  */
 public class JavaBinUpdateRequestCodec {
 
+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+  private static final AtomicBoolean WARNED_ABOUT_INDEX_TIME_BOOSTS = new AtomicBoolean();
+
   /**
    * Converts an UpdateRequest to a NamedList which can be serialized to the given OutputStream in the javabin format
    *
@@ -243,11 +250,27 @@ public class JavaBinUpdateRequestCodec {
     for (int i = 0; i < namedList.size(); i++) {
       NamedList nl = namedList.get(i);
       if (i == 0) {
-        doc.setDocumentBoost(nl.getVal(0) == null ? 1.0f : (Float) nl.getVal(0));
+        Float boost = (Float) nl.getVal(0);
+        if (boost != null && boost.floatValue() != 1f) {
+          String message = "Ignoring document boost: " + boost + " as index-time boosts are not supported anymore";
+          if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+            log.warn(message);
+          } else {
+            log.debug(message);
+          }
+        }
       } else {
+        Float boost = (Float) nl.getVal(2);
+        if (boost != null && boost.floatValue() != 1f) {
+          String message = "Ignoring field boost: " + boost + " as index-time boosts are not supported anymore";
+          if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+            log.warn(message);
+          } else {
+            log.debug(message);
+          }
+        }
         doc.addField((String) nl.getVal(0),
-                nl.getVal(1),
-                nl.getVal(2) == null ? 1.0f : (Float) nl.getVal(2));
+                nl.getVal(1));
       }
     }
     return doc;
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/util/ClientUtils.java b/solr/solrj/src/java/org/apache/solr/client/solrj/util/ClientUtils.java
index beed40e..c5595b1 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/util/ClientUtils.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/util/ClientUtils.java
@@ -64,10 +64,9 @@ public class ClientUtils
 
   public static void writeXML( SolrInputDocument doc, Writer writer ) throws IOException
   {
-    writer.write("<doc boost=\""+doc.getDocumentBoost()+"\">");
+    writer.write("<doc>");
 
     for( SolrInputField field : doc ) {
-      float boost = field.getBoost();
       String name = field.getName();
 
       for( Object v : field ) {
@@ -81,19 +80,14 @@ public class ClientUtils
             if (v instanceof Collection) {
               Collection values = (Collection) v;
               for (Object value : values) {
-                writeVal(writer, boost, name, value, update);
-                boost = 1.0f;
+                writeVal(writer, name, value, update);
               }
             } else  {
-              writeVal(writer, boost, name, v, update);
-              boost = 1.0f;
+              writeVal(writer, name, v, update);
             }
           }
         } else  {
-          writeVal(writer, boost, name, v, update);
-          // only write the boost for the first multi-valued field
-          // otherwise, the used boost is the product of all the boost values
-          boost = 1.0f;
+          writeVal(writer, name, v, update);
         }
       }
     }
@@ -107,7 +101,7 @@ public class ClientUtils
     writer.write("</doc>");
   }
 
-  private static void writeVal(Writer writer, float boost, String name, Object v, String update) throws IOException {
+  private static void writeVal(Writer writer, String name, Object v, String update) throws IOException {
     if (v instanceof Date) {
       v = ((Date)v).toInstant().toString();
     } else if (v instanceof byte[]) {
@@ -119,20 +113,14 @@ public class ClientUtils
     }
 
     if (update == null) {
-      if( boost != 1.0f ) {
-        XML.writeXML(writer, "field", v.toString(), "name", name, "boost", boost);
-      } else if (v != null) {
+      if (v != null) {
         XML.writeXML(writer, "field", v.toString(), "name", name );
       }
     } else {
-      if( boost != 1.0f ) {
-        XML.writeXML(writer, "field", v.toString(), "name", name, "boost", boost, "update", update);
-      } else {
-        if (v == null)  {
-          XML.writeXML(writer, "field", null, "name", name, "update", update, "null", true);
-        } else  {
-          XML.writeXML(writer, "field", v.toString(), "name", name, "update", update);
-        }
+      if (v == null)  {
+        XML.writeXML(writer, "field", null, "name", name, "update", update, "null", true);
+      } else  {
+        XML.writeXML(writer, "field", v.toString(), "name", name, "update", update);
       }
     }
   }
diff --git a/solr/solrj/src/java/org/apache/solr/common/SolrInputDocument.java b/solr/solrj/src/java/org/apache/solr/common/SolrInputDocument.java
index 3d3c060..c8451aa 100644
--- a/solr/solrj/src/java/org/apache/solr/common/SolrInputDocument.java
+++ b/solr/solrj/src/java/org/apache/solr/common/SolrInputDocument.java
@@ -35,7 +35,6 @@ import java.util.Set;
 public class SolrInputDocument extends SolrDocumentBase<SolrInputField, SolrInputDocument> implements Iterable<SolrInputField>
 {
   private final Map<String,SolrInputField> _fields;
-  private float _documentBoost = 1.0f;
   private List<SolrInputDocument> _childDocuments;
   
   public SolrInputDocument(String... fields) {
@@ -74,11 +73,16 @@ public class SolrInputDocument extends SolrDocumentBase<SolrInputField, SolrInpu
    * 
    * @param name Name of the field, should match one of the field names defined under "fields" tag in schema.xml.
    * @param value Value of the field, should be of same class type as defined by "type" attribute of the corresponding field in schema.xml. 
-   * @see #addField(String, Object, float)
    */
   public void addField(String name, Object value) 
   {
-    addField(name, value, 1.0f );
+    SolrInputField field = _fields.get( name );
+    if( field == null || field.value == null ) {
+      setField(name, value);
+    }
+    else {
+      field.addValue( value );
+    }
   }
   
   /** Get the first value for a field.
@@ -122,44 +126,14 @@ public class SolrInputDocument extends SolrDocumentBase<SolrInputField, SolrInpu
   
   /** Set a field with implied null value for boost.
    * 
-   * @see #setField(String, Object, float)
    * @param name name of the field to set
    * @param value value of the field
    */
-  public void setField(String name, Object value) 
-  {
-    setField(name, value, 1.0f );
-  }
-  
-  public void setField(String name, Object value, float boost ) 
+  public void setField(String name, Object value ) 
   {
     SolrInputField field = new SolrInputField( name );
     _fields.put( name, field );
-    field.setValue( value, boost );
-  }
-
-  /**
-   * Adds a field with the given name, value and boost.  If a field with the
-   * name already exists, then the given value is appended to the value of that
-   * field, with the new boost. If the value is a collection, then each of its
-   * values will be added to the field.
-   *
-   * The class type of value and the name parameter should match schema.xml. 
-   * schema.xml can be found in conf directory under the solr home by default.
-   * 
-   * @param name Name of the field, should match one of the field names defined under "fields" tag in schema.xml.
-   * @param value Value of the field, should be of same class type as defined by "type" attribute of the corresponding field in schema.xml. 
-   * @param boost Boost value for the field
-   */
-  public void addField(String name, Object value, float boost ) 
-  {
-    SolrInputField field = _fields.get( name );
-    if( field == null || field.value == null ) {
-      setField(name, value, boost);
-    }
-    else {
-      field.addValue( value, boost );
-    }
+    field.setValue( value );
   }
 
   /**
@@ -187,14 +161,6 @@ public class SolrInputDocument extends SolrDocumentBase<SolrInputField, SolrInpu
     return _fields.values().iterator();
   }
   
-  public float getDocumentBoost() {
-    return _documentBoost;
-  }
-
-  public void setDocumentBoost(float documentBoost) {
-    _documentBoost = documentBoost;
-  }
-  
   @Override
   public String toString()
   {
@@ -209,7 +175,6 @@ public class SolrInputDocument extends SolrDocumentBase<SolrInputField, SolrInpu
     for (Map.Entry<String,SolrInputField> fieldEntry : entries) {
       clone._fields.put(fieldEntry.getKey(), fieldEntry.getValue().deepCopy());
     }
-    clone._documentBoost = _documentBoost;
 
     if (_childDocuments != null) {
       clone._childDocuments = new ArrayList<>(_childDocuments.size());
diff --git a/solr/solrj/src/java/org/apache/solr/common/SolrInputField.java b/solr/solrj/src/java/org/apache/solr/common/SolrInputField.java
index 261b326..94e98de 100644
--- a/solr/solrj/src/java/org/apache/solr/common/SolrInputField.java
+++ b/solr/solrj/src/java/org/apache/solr/common/SolrInputField.java
@@ -29,7 +29,6 @@ public class SolrInputField implements Iterable<Object>, Serializable
 {
   String name;
   Object value = null; 
-  float boost = 1.0f;
   
   public SolrInputField( String n )
   {
@@ -44,9 +43,7 @@ public class SolrInputField implements Iterable<Object>, Serializable
    * a collection is given, then that collection will be used as the backing
    * collection for the values.
    */
-  public void setValue(Object v, float b) {
-    boost = b;
-
+  public void setValue(Object v) {
     if( v instanceof Object[] ) {
       Object[] arr = (Object[])v;
       Collection<Object> c = new ArrayList<>( arr.length );
@@ -65,27 +62,21 @@ public class SolrInputField implements Iterable<Object>, Serializable
    * will be added individually.
    */
   @SuppressWarnings("unchecked")
-  public void addValue(Object v, float b) {
+  public void addValue(Object v) {
     if( value == null ) {
       if ( v instanceof Collection ) {
         Collection<Object> c = new ArrayList<>( 3 );
         for ( Object o : (Collection<Object>)v ) {
           c.add( o );
         }
-        setValue(c, b);
+        setValue(c);
       } else {
-        setValue(v, b);
+        setValue(v);
       }
 
       return;
     }
     
-    // The lucene API and solr XML field specification make it possible to set boosts
-    // on multi-value fields even though lucene indexing does not support this.
-    // To keep behavior consistent with what happens in the lucene index, we accumulate
-    // the product of all boosts specified for this field.
-    boost *= b;
-    
     Collection<Object> vals = null;
     if( value instanceof Collection ) {
       vals = (Collection<Object>)value;
@@ -164,14 +155,6 @@ public class SolrInputField implements Iterable<Object>, Serializable
   
   //---------------------------------------------------------------
   //---------------------------------------------------------------
-  
-  public float getBoost() {
-    return boost;
-  }
-
-  public void setBoost(float boost) {
-    this.boost = boost;
-  }
 
   public String getName() {
     return name;
@@ -211,12 +194,11 @@ public class SolrInputField implements Iterable<Object>, Serializable
   @Override
   public String toString()
   {
-    return name + ((boost == 1.0) ? "=" : ("("+boost+")=")) + value;
+    return name + "=" + value;
   }
 
   public SolrInputField deepCopy() {
     SolrInputField clone = new SolrInputField(name);
-    clone.boost = boost;
     // We can't clone here, so we rely on simple primitives
     if (value instanceof Collection) {
       Collection<Object> values = (Collection<Object>) value;
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/JavaBinCodec.java b/solr/solrj/src/java/org/apache/solr/common/util/JavaBinCodec.java
index 7e0cac6..def3571 100644
--- a/solr/solrj/src/java/org/apache/solr/common/util/JavaBinCodec.java
+++ b/solr/solrj/src/java/org/apache/solr/common/util/JavaBinCodec.java
@@ -19,6 +19,7 @@ package org.apache.solr.common.util;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.lang.invoke.MethodHandles;
 import java.nio.ByteBuffer;
 import java.nio.file.Path;
 import java.util.ArrayList;
@@ -31,6 +32,7 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.solr.common.EnumFieldValue;
 import org.apache.solr.common.IteratorWriter;
@@ -43,6 +45,8 @@ import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.SolrInputField;
 import org.noggit.CharArr;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Defines a space-efficient serialization/deserialization format for transferring data.
@@ -61,6 +65,9 @@ import org.noggit.CharArr;
  */
 public class JavaBinCodec implements PushWriter {
 
+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+  private static final AtomicBoolean WARNED_ABOUT_INDEX_TIME_BOOSTS = new AtomicBoolean();
+
   public static final byte
           NULL = 0,
           BOOL_TRUE = 1,
@@ -555,14 +562,28 @@ public class JavaBinCodec implements PushWriter {
   public SolrInputDocument readSolrInputDocument(DataInputInputStream dis) throws IOException {
     int sz = readVInt(dis);
     float docBoost = (Float)readVal(dis);
+    if (docBoost != 1f) {
+      String message = "Ignoring document boost: " + docBoost + " as index-time boosts are not supported anymore";
+      if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+        log.warn(message);
+      } else {
+        log.debug(message);
+      }
+    }
     SolrInputDocument sdoc = new SolrInputDocument(new LinkedHashMap<>(sz));
-    sdoc.setDocumentBoost(docBoost);
     for (int i = 0; i < sz; i++) {
-      float boost = 1.0f;
       String fieldName;
       Object obj = readVal(dis); // could be a boost, a field name, or a child document
       if (obj instanceof Float) {
-        boost = (Float)obj;
+        float boost = (Float)obj;
+        if (boost != 1f) {
+          String message = "Ignoring field boost: " + boost + " as index-time boosts are not supported anymore";
+          if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {
+            log.warn(message);
+          } else {
+            log.debug(message);
+          }
+        }
         fieldName = (String)readVal(dis);
       } else if (obj instanceof SolrInputDocument) {
         sdoc.addChildDocument((SolrInputDocument)obj);
@@ -571,7 +592,7 @@ public class JavaBinCodec implements PushWriter {
         fieldName = (String)obj;
       }
       Object fieldVal = readVal(dis);
-      sdoc.setField(fieldName, fieldVal, boost);
+      sdoc.setField(fieldName, fieldVal);
     }
     return sdoc;
   }
@@ -580,11 +601,8 @@ public class JavaBinCodec implements PushWriter {
     List<SolrInputDocument> children = sdoc.getChildDocuments();
     int sz = sdoc.size() + (children==null ? 0 : children.size());
     writeTag(SOLRINPUTDOC, sz);
-    writeFloat(sdoc.getDocumentBoost());
+    writeFloat(1f); // document boost
     for (SolrInputField inputField : sdoc.values()) {
-      if (inputField.getBoost() != 1.0f) {
-        writeFloat(inputField.getBoost());
-      }
       writeExternString(inputField.getName());
       writeVal(inputField.getValue());
     }
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests.java b/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests.java
index d25280d..b1e7285 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests.java
@@ -100,8 +100,8 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
     // Now add something...
     SolrInputDocument doc = new SolrInputDocument();
     String docID = "1112211111";
-    doc.addField( "id", docID, 1.0f );
-    doc.addField( "name", "my name!", 1.0f );
+    doc.addField( "id", docID );
+    doc.addField( "name", "my name!" );
     
     Assert.assertEquals( null, doc.getField("foo") );
     Assert.assertTrue(doc.getField("name").getValue() != null );
@@ -127,28 +127,28 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
     // Now add a few docs for facet testing...
     List<SolrInputDocument> docs = new ArrayList<>();
     SolrInputDocument doc2 = new SolrInputDocument();
-    doc2.addField( "id", "2", 1.0f );
-    doc2.addField( "inStock", true, 1.0f );
-    doc2.addField( "price", 2, 1.0f );
-    doc2.addField( "timestamp_dt", new java.util.Date(), 1.0f );
+    doc2.addField( "id", "2" );
+    doc2.addField( "inStock", true );
+    doc2.addField( "price", 2 );
+    doc2.addField( "timestamp_dt", new java.util.Date() );
     docs.add(doc2);
     SolrInputDocument doc3 = new SolrInputDocument();
-    doc3.addField( "id", "3", 1.0f );
-    doc3.addField( "inStock", false, 1.0f );
-    doc3.addField( "price", 3, 1.0f );
-    doc3.addField( "timestamp_dt", new java.util.Date(), 1.0f );
+    doc3.addField( "id", "3" );
+    doc3.addField( "inStock", false );
+    doc3.addField( "price", 3 );
+    doc3.addField( "timestamp_dt", new java.util.Date() );
     docs.add(doc3);
     SolrInputDocument doc4 = new SolrInputDocument();
-    doc4.addField( "id", "4", 1.0f );
-    doc4.addField( "inStock", true, 1.0f );
-    doc4.addField( "price", 4, 1.0f );
-    doc4.addField( "timestamp_dt", new java.util.Date(), 1.0f );
+    doc4.addField( "id", "4" );
+    doc4.addField( "inStock", true );
+    doc4.addField( "price", 4 );
+    doc4.addField( "timestamp_dt", new java.util.Date() );
     docs.add(doc4);
     SolrInputDocument doc5 = new SolrInputDocument();
-    doc5.addField( "id", "5", 1.0f );
-    doc5.addField( "inStock", false, 1.0f );
-    doc5.addField( "price", 5, 1.0f );
-    doc5.addField( "timestamp_dt", new java.util.Date(), 1.0f );
+    doc5.addField( "id", "5" );
+    doc5.addField( "inStock", false );
+    doc5.addField( "price", 5 );
+    doc5.addField( "timestamp_dt", new java.util.Date() );
     docs.add(doc5);
     
     upres = client.add( docs );
@@ -247,13 +247,13 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
     
     // Now add something...
     SolrInputDocument doc1 = new SolrInputDocument();
-    doc1.addField( "id", "id1", 1.0f );
-    doc1.addField( "name", "doc1", 1.0f );
+    doc1.addField( "id", "id1" );
+    doc1.addField( "name", "doc1" );
     doc1.addField( "price", 10 );
 
     SolrInputDocument doc2 = new SolrInputDocument();
-    doc2.addField( "id", "id2", 1.0f );
-    doc2.addField( "name", "h\uD866\uDF05llo", 1.0f );
+    doc2.addField( "id", "id2" );
+    doc2.addField( "name", "h\uD866\uDF05llo" );
     doc2.addField( "price", 20 );
     
     Collection<SolrInputDocument> docs = new ArrayList<>();
@@ -302,13 +302,13 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
      
     // Add two docs
     SolrInputDocument doc = new SolrInputDocument();
-    doc.addField( "id", "id1", 1.0f );
-    doc.addField( "name", "doc1", 1.0f );
+    doc.addField( "id", "id1" );
+    doc.addField( "name", "doc1" );
     doc.addField( "price", 10 );
     client.add(doc);
     
     doc = new SolrInputDocument();
-    doc.addField( "id", "id2", 1.0f );
+    doc.addField( "id", "id2" );
     client.add(doc);
     client.commit();
     
@@ -443,9 +443,9 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
 
     }
     SolrInputDocument doc = new SolrInputDocument();
-    doc.addField("id", "DOCID", 1.0f);
-    doc.addField("id", "DOCID2", 1.0f);
-    doc.addField("name", "hello", 1.0f);
+    doc.addField("id", "DOCID");
+    doc.addField("id", "DOCID2");
+    doc.addField("name", "hello");
 
     if (client instanceof HttpSolrClient) {
       try {
@@ -484,15 +484,15 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
     
     // Now add something...
     SolrInputDocument doc = new SolrInputDocument();
-    doc.addField( "id", "111", 1.0f );
-    doc.addField( "name", "doc1", 1.0f );
+    doc.addField( "id", "111" );
+    doc.addField( "name", "doc1" );
     doc.addField( "price", 11 );
     client.add(doc);
     client.commit(); // make sure this gets in first
     
     doc = new SolrInputDocument();
-    doc.addField( "id", "222", 1.0f );
-    doc.addField( "name", "doc2", 1.0f );
+    doc.addField( "id", "222" );
+    doc.addField( "name", "doc2" );
     doc.addField( "price", 22 );
     client.add(doc);
     client.commit();
@@ -539,8 +539,8 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
     
     // Now add something...
     SolrInputDocument doc = new SolrInputDocument();
-    doc.addField( "id", "111", 1.0f );
-    doc.addField( "name", "doc1", 1.0f );
+    doc.addField( "id", "111" );
+    doc.addField( "name", "doc1" );
     doc.addField( "json_s", rawJson );
     doc.addField( "xml_s", rawXml );
     client.add(doc);
@@ -689,7 +689,7 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
     SolrInputDocument[] doc = new SolrInputDocument[5];
     for( int i=0; i<doc.length; i++ ) {
       doc[i] = new SolrInputDocument();
-      doc[i].setField( "id", "ID"+i, 1.0f );
+      doc[i].setField( "id", "ID"+i );
       client.add(doc[i]);
     }
     client.commit();
@@ -844,7 +844,7 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
     ArrayList<SolrInputDocument> docs = new ArrayList<>(10);
     for( int i=1; i<=10; i++ ) {
       SolrInputDocument doc = new SolrInputDocument();
-      doc.setField( "id", i+"", 1.0f );
+      doc.setField( "id", i+"" );
       if( (i%2)==0 ) {
         doc.addField( "features", "two" );
       }
@@ -1576,8 +1576,8 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
     
     // Now add something...
     SolrInputDocument doc = new SolrInputDocument();
-    doc.addField( "id", "DOCID", 1.0f );
-    doc.addField( "name", "hello", 1.0f );
+    doc.addField( "id", "DOCID" );
+    doc.addField( "name", "hello" );
     client.add(doc);
     client.commit();  // Since the transaction log is disabled in the example, we need to commit
     
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTestsBase.java b/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTestsBase.java
index dc964cb..cda9961 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTestsBase.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTestsBase.java
@@ -50,8 +50,8 @@ abstract public class SolrExampleTestsBase extends SolrJettyTestBase {
     
     // Now try a timed commit...
     SolrInputDocument doc3 = new SolrInputDocument();
-    doc3.addField("id", "id3", 1.0f);
-    doc3.addField("name", "doc3", 1.0f);
+    doc3.addField("id", "id3");
+    doc3.addField("name", "doc3");
     doc3.addField("price", 10);
     UpdateRequest up = new UpdateRequest();
     up.add(doc3);
@@ -87,8 +87,8 @@ abstract public class SolrExampleTestsBase extends SolrJettyTestBase {
     
     // Now test the new convenience parameter on the add() for commitWithin
     SolrInputDocument doc4 = new SolrInputDocument();
-    doc4.addField("id", "id4", 1.0f);
-    doc4.addField("name", "doc4", 1.0f);
+    doc4.addField("id", "id4");
+    doc4.addField("name", "doc4");
     doc4.addField("price", 10);
     client.add(doc4, 500);
     
@@ -125,8 +125,8 @@ abstract public class SolrExampleTestsBase extends SolrJettyTestBase {
     
     // Now add one document...
     SolrInputDocument doc3 = new SolrInputDocument();
-    doc3.addField("id", "id3", 1.0f);
-    doc3.addField("name", "doc3", 1.0f);
+    doc3.addField("id", "id3");
+    doc3.addField("name", "doc3");
     doc3.addField("price", 10);
     client.add(doc3);
     client.commit();
@@ -169,7 +169,7 @@ abstract public class SolrExampleTestsBase extends SolrJettyTestBase {
     SolrInputDocument[] doc = new SolrInputDocument[3];
     for (int i = 0; i < 3; i++) {
       doc[i] = new SolrInputDocument();
-      doc[i].setField("id", i + " & 222", 1.0f);
+      doc[i].setField("id", i + " & 222");
     }
     String id = (String) doc[0].getField("id").getFirstValue();
     
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestUpdateRequestCodec.java b/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestUpdateRequestCodec.java
index 53ad2eb..df7beea 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestUpdateRequestCodec.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestUpdateRequestCodec.java
@@ -53,20 +53,19 @@ public class TestUpdateRequestCodec extends LuceneTestCase {
     updateRequest.setParam("a", "b");
     SolrInputDocument doc = new SolrInputDocument();
     doc.addField("id", 1);
-    doc.addField("desc", "one", 2.0f);
+    doc.addField("desc", "one");
     doc.addField("desc", "1");
     updateRequest.add(doc);
 
     doc = new SolrInputDocument();
     doc.addField("id", 2);
-    doc.setDocumentBoost(10.0f);
-    doc.addField("desc", "two", 3.0f);
+    doc.addField("desc", "two");
     doc.addField("desc", "2");
     updateRequest.add(doc);
 
     doc = new SolrInputDocument();
     doc.addField("id", 3);
-    doc.addField("desc", "three", 3.0f);
+    doc.addField("desc", "three");
     doc.addField("desc", "3");
     updateRequest.add(doc);
 
@@ -121,7 +120,7 @@ public class TestUpdateRequestCodec extends LuceneTestCase {
 
     SolrInputDocument doc = new SolrInputDocument();
     doc.addField("id", 1);
-    doc.addField("desc", "one", 2.0f);
+    doc.addField("desc", "one");
     // imagine someone adding a custom Bean that implements Iterable 
     // but is not a Collection
     doc.addField("iter", new Iterable<String>() { 
@@ -171,20 +170,19 @@ public class TestUpdateRequestCodec extends LuceneTestCase {
     updateRequest.setParam("a", "b");
     SolrInputDocument doc = new SolrInputDocument();
     doc.addField("id", 1);
-    doc.addField("desc", "one", 2.0f);
+    doc.addField("desc", "one");
     doc.addField("desc", "1");
     updateRequest.add(doc);
 
     doc = new SolrInputDocument();
     doc.addField("id", 2);
-    doc.setDocumentBoost(10.0f);
-    doc.addField("desc", "two", 3.0f);
+    doc.addField("desc", "two");
     doc.addField("desc", "2");
     updateRequest.add(doc);
 
     doc = new SolrInputDocument();
     doc.addField("id", 3);
-    doc.addField("desc", "three", 3.0f);
+    doc.addField("desc", "three");
     doc.addField("desc", "3");
     updateRequest.add(doc);
 
@@ -234,14 +232,10 @@ public class TestUpdateRequestCodec extends LuceneTestCase {
   private void compareDocs(String m, 
                            SolrInputDocument expectedDoc, 
                            SolrInputDocument actualDoc) {
-    Assert.assertEquals(expectedDoc.getDocumentBoost(), 
-                        actualDoc.getDocumentBoost());
 
     for (String s : expectedDoc.getFieldNames()) {
       SolrInputField expectedField = expectedDoc.getField(s);
       SolrInputField actualField = actualDoc.getField(s);
-      Assert.assertEquals(m + ": diff boosts for field: " + s,
-                          expectedField.getBoost(), actualField.getBoost());
       Object expectedVal = expectedField.getValue();
       Object actualVal = actualField.getValue();
       if (expectedVal instanceof Set &&
diff --git a/solr/solrj/src/test/org/apache/solr/common/SolrDocumentTest.java b/solr/solrj/src/test/org/apache/solr/common/SolrDocumentTest.java
index 6b3318d..0234ce0 100644
--- a/solr/solrj/src/test/org/apache/solr/common/SolrDocumentTest.java
+++ b/solr/solrj/src/test/org/apache/solr/common/SolrDocumentTest.java
@@ -191,9 +191,9 @@ public class SolrDocumentTest extends LuceneTestCase
     // Set up a simple document
     SolrInputDocument doc = new SolrInputDocument();
     for( int i=0; i<5; i++ ) {
-      doc.addField( "f", fval0, 1.0f );
-      doc.addField( "f", fval1, 1.0f );
-      doc.addField( "f", fval2, 1.0f );
+      doc.addField( "f", fval0 );
+      doc.addField( "f", fval1 );
+      doc.addField( "f", fval2 );
     }
     assertEquals( (3*5), doc.getField("f").getValueCount() );
   }
diff --git a/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java b/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java
index e5bd384..c3c269c 100644
--- a/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java
+++ b/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java
@@ -2161,9 +2161,6 @@ public abstract class SolrTestCaseJ4 extends LuceneTestCase {
 
     SolrInputDocument sdoc1 = (SolrInputDocument) expected;
     SolrInputDocument sdoc2 = (SolrInputDocument) actual;
-    if (Float.compare(sdoc1.getDocumentBoost(), sdoc2.getDocumentBoost()) != 0) {
-      return false;
-    }
 
     if(sdoc1.getFieldNames().size() != sdoc2.getFieldNames().size()) {
       return false;
@@ -2222,10 +2219,6 @@ public abstract class SolrTestCaseJ4 extends LuceneTestCase {
       return false;
     }
 
-    if (Float.compare(sif1.getBoost(), sif2.getBoost()) != 0) {
-      return false;
-    }
-
     return true;
   }
 
