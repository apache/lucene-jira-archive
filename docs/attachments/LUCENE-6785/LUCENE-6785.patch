Index: lucene/core/src/java/org/apache/lucene/search/BlendedTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BlendedTermQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/BlendedTermQuery.java	(working copy)
@@ -263,7 +263,8 @@
   }
 
   @Override
-  public final Query rewrite(IndexReader reader) throws IOException {
+  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    final IndexReader reader = searcher.getIndexReader();
     final TermContext[] contexts = Arrays.copyOf(this.contexts, this.contexts.length);
     for (int i = 0; i < contexts.length; ++i) {
       if (contexts[i] == null || contexts[i].topReaderContext != reader.getContext()) {
@@ -296,7 +297,7 @@
         termQueries[i] = new BoostQuery(termQueries[i], boosts[i]);
       }
     }
-    return rewriteMethod.rewrite(termQueries);
+    return rewriteMethod.rewrite(termQueries).createWeight(searcher, needsScores);
   }
 
   private static TermContext adjustFrequencies(TermContext ctx, int artificialDf, long artificialTtf) {
Index: lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java	(working copy)
@@ -25,7 +25,6 @@
 import java.util.List;
 import java.util.Objects;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.similarities.Similarity;
 
@@ -189,15 +188,7 @@
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    BooleanQuery query = this;
-    if (needsScores == false) {
-      query = rewriteNoScoring();
-    }
-    return new BooleanWeight(query, searcher, needsScores, disableCoord);
-  }
 
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
     if (minimumNumberShouldMatch == 0 && clauses.size() == 1) {// optimize 1-clause queries
       BooleanClause c = clauses.get(0);
       if (!c.isProhibited()) {  // just return clause
@@ -209,26 +200,26 @@
           query = new BoostQuery(new ConstantScoreQuery(query), 0);
         }
 
-        return query;
+        return searcher.createWeight(query, needsScores);
       }
     }
 
-    BooleanQuery.Builder builder = new BooleanQuery.Builder();
-    builder.setDisableCoord(isCoordDisabled());
-    builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());
-    boolean actuallyRewritten = false;
-    for (BooleanClause clause : this) {
-      Query query = clause.getQuery();
-      Query rewritten = query.rewrite(reader);
-      if (rewritten != query) {
-        actuallyRewritten = true;
-      }
-      builder.add(rewritten, clause.getOccur());
+    BooleanQuery query = this;
+    if (needsScores == false) {
+      query = rewriteNoScoring();
     }
-    if (actuallyRewritten) {
-      return builder.build();
+
+    List<Weight> subweights = new ArrayList<>();
+    Builder builder = new Builder();
+    for (BooleanClause clause : query) {
+      Weight w = searcher.createWeight(clause.getQuery(), needsScores && clause.isScoring());
+      subweights.add(w);
+      builder.add(w.getQuery(), clause.getOccur());
     }
-    return super.rewrite(reader);
+    builder.setMinimumNumberShouldMatch(minimumNumberShouldMatch);
+    builder.setDisableCoord(disableCoord);
+
+    return new BooleanWeight(builder.build(), subweights, searcher, needsScores, disableCoord);
   }
 
   /** Prints a user-readable version of this query. */
Index: lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java	(working copy)
@@ -38,23 +38,21 @@
   final Similarity similarity;
   final BooleanQuery query;
   
-  final ArrayList<Weight> weights;
+  final List<Weight> weights;
   final int maxCoord;  // num optional + num required
   final boolean disableCoord;
   final boolean needsScores;
   final float coords[];
 
-  BooleanWeight(BooleanQuery query, IndexSearcher searcher, boolean needsScores, boolean disableCoord) throws IOException {
+  BooleanWeight(BooleanQuery query, List<Weight> subweights, IndexSearcher searcher, boolean needsScores, boolean disableCoord) throws IOException {
     super(query);
     this.query = query;
     this.needsScores = needsScores;
     this.similarity = searcher.getSimilarity(needsScores);
-    weights = new ArrayList<>();
+    this.weights = subweights;
     int i = 0;
     int maxCoord = 0;
     for (BooleanClause c : query) {
-      Weight w = searcher.createWeight(c.getQuery(), needsScores && c.isScoring());
-      weights.add(w);
       if (c.isScoring()) {
         maxCoord++;
       }
Index: lucene/core/src/java/org/apache/lucene/search/BoostQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BoostQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/BoostQuery.java	(working copy)
@@ -24,7 +24,6 @@
 import java.util.Objects;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 
@@ -96,31 +95,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final Query rewritten = query.rewrite(reader);
-
-    if (boost == 1f) {
-      return rewritten;
-    }
-
-    if (rewritten.getClass() == BoostQuery.class) {
-      BoostQuery in = (BoostQuery) rewritten;
-      return new BoostQuery(in.query, boost * in.boost);
-    }
-
-    if (boost == 0f && rewritten.getClass() != ConstantScoreQuery.class) {
-      // so that we pass needScores=false
-      return new BoostQuery(new ConstantScoreQuery(rewritten), 0f);
-    }
-
-    if (query != rewritten) {
-      return new BoostQuery(rewritten, boost);
-    }
-
-    return super.rewrite(reader);
-  }
-
-  @Override
   public String toString(String field) {
     boolean needsParens = NO_PARENS_REQUIRED_QUERIES.contains(query.getClass()) == false;
     StringBuilder builder = new StringBuilder();
@@ -138,14 +112,27 @@
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+
+    if (query instanceof BoostQuery) {
+      BoostQuery innerQuery = (BoostQuery) query;
+      return new BoostQuery(innerQuery.getQuery(), innerQuery.getBoost() * boost).createWeight(searcher, needsScores);
+    }
+
+    if (boost == 0 && query.getClass() != ConstantScoreQuery.class) {
+      return new BoostQuery(new ConstantScoreQuery(query), 0).createWeight(searcher, needsScores);
+    }
+
     final Weight weight = query.createWeight(searcher, needsScores);
-    if (needsScores == false) {
+    if (needsScores == false || boost == 1f) {
       return weight;
     }
     // Apply the query boost, this may impact the return value of getValueForNormalization()
     weight.normalize(1f, boost);
-    return new Weight(this) {
 
+    // Pass a new BoostQuery with the rewritten weight to Weight constructor, for use in
+    // query cacheing
+    return new Weight(new BoostQuery(weight.getQuery(), boost)) {
+
       @Override
       public void extractTerms(Set<Term> terms) {
         weight.extractTerms(terms);
Index: lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java	(working copy)
@@ -28,7 +28,6 @@
 import java.util.WeakHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
@@ -77,23 +76,6 @@
     return new RoaringDocIdSet.Builder(reader.maxDoc()).add(iterator).build();
   }
 
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final Query rewritten = query.rewrite(reader);
-    if (query == rewritten) {
-      return super.rewrite(reader);
-    } else {
-      CachingWrapperQuery clone;
-      try {
-        clone = (CachingWrapperQuery) clone();
-        clone.query = rewritten;
-        return clone;
-      } catch (CloneNotSupportedException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-
   // for testing
   int hitCount, missCount;
 
Index: lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java	(working copy)
@@ -22,7 +22,6 @@
 import java.util.Collections;
 import java.util.Objects;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.util.Bits;
 
@@ -45,25 +44,6 @@
     return query;
   }
 
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    Query rewritten = query.rewrite(reader);
-
-    if (rewritten != query) {
-      return new ConstantScoreQuery(rewritten);
-    }
-
-    if (rewritten.getClass() == ConstantScoreQuery.class) {
-      return rewritten;
-    }
-
-    if (rewritten.getClass() == BoostQuery.class) {
-      return new ConstantScoreQuery(((BoostQuery) rewritten).getQuery());
-    }
-
-    return super.rewrite(reader);
-  }
-
   /** We return this as our {@link BulkScorer} so that if the CSQ
    *  wraps a query with its own optimized top-level
    *  scorer (e.g. BooleanScorer) we can use that
Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(working copy)
@@ -25,7 +25,6 @@
 import java.util.Set;
 
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 
 /**
@@ -116,15 +115,13 @@
   protected class DisjunctionMaxWeight extends Weight {
 
     /** The Weights for our subqueries, in 1-1 correspondence with disjuncts */
-    protected final ArrayList<Weight> weights = new ArrayList<>();  // The Weight's for our subqueries, in 1-1 correspondence with disjuncts
+    protected final List<Weight> weights;  // The Weight's for our subqueries, in 1-1 correspondence with disjuncts
     private final boolean needsScores;
 
     /** Construct the Weight for this Query searched by searcher.  Recursively construct subquery weights. */
-    public DisjunctionMaxWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-      super(DisjunctionMaxQuery.this);
-      for (Query disjunctQuery : disjuncts) {
-        weights.add(searcher.createWeight(disjunctQuery, needsScores));
-      }
+    public DisjunctionMaxWeight(Query query, List<Weight> weights, boolean needsScores) throws IOException {
+      super(query);
+      this.weights = weights;
       this.needsScores = needsScores;
     }
 
@@ -207,30 +204,16 @@
   /** Create the Weight used to score us */
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    return new DisjunctionMaxWeight(searcher, needsScores);
-  }
-
-  /** Optimize our representation and our subqueries representations
-   * @param reader the IndexReader we query
-   * @return an optimized copy of us (which may not be a copy if there is nothing to optimize) */
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    int numDisjunctions = disjuncts.size();
-    if (numDisjunctions == 1) {
-      return disjuncts.get(0);
-    }
-    DisjunctionMaxQuery rewritten = new DisjunctionMaxQuery(tieBreakerMultiplier);
-    boolean actuallyRewritten = false;
+    if (disjuncts.size() == 1)
+      return searcher.createWeight(disjuncts.get(0), needsScores);
+    List<Weight> subWeights = new ArrayList<>(disjuncts.size());
+    List<Query> rewrittenQueries = new ArrayList<>(disjuncts.size());
     for (Query sub : disjuncts) {
-      Query rewrittenSub = sub.rewrite(reader);
-      actuallyRewritten |= rewrittenSub != sub;
-      rewritten.add(rewrittenSub);
+      Weight w = searcher.createWeight(sub, needsScores);
+      subWeights.add(w);
+      rewrittenQueries.add(w.getQuery());
     }
-
-    if (actuallyRewritten) {
-      return rewritten;
-    }
-    return super.rewrite(reader);
+    return new DisjunctionMaxWeight(new DisjunctionMaxQuery(rewrittenQueries, tieBreakerMultiplier), subWeights, needsScores);
   }
 
   /** Prettyprint us.
Index: lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java	(working copy)
@@ -344,7 +344,6 @@
    * Count how many documents match the given query.
    */
   public int count(Query query) throws IOException {
-    query = rewrite(query);
     while (true) {
       // remove wrappers that don't matter for counts
       if (query instanceof ConstantScoreQuery) {
@@ -655,19 +654,6 @@
     }
   }
 
-  /** Expert: called to re-write queries into primitive queries.
-   * @throws BooleanQuery.TooManyClauses If a query would exceed 
-   *         {@link BooleanQuery#getMaxClauseCount()} clauses.
-   */
-  public Query rewrite(Query original) throws IOException {
-    Query query = original;
-    for (Query rewrittenQuery = query.rewrite(reader); rewrittenQuery != query;
-         rewrittenQuery = query.rewrite(reader)) {
-      query = rewrittenQuery;
-    }
-    return query;
-  }
-
   /** Returns an Explanation that describes how <code>doc</code> scored against
    * <code>query</code>.
    *
@@ -711,7 +697,6 @@
    * @lucene.internal
    */
   public Weight createNormalizedWeight(Query query, boolean needsScores) throws IOException {
-    query = rewrite(query);
     Weight weight = createWeight(query, needsScores);
     float v = weight.getValueForNormalization();
     float norm = getSimilarity(needsScores).queryNorm(v);
Index: lucene/core/src/java/org/apache/lucene/search/MatchNoDocsQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MatchNoDocsQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/MatchNoDocsQuery.java	(working copy)
@@ -19,8 +19,6 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
-
 /**
  * A query that matches no documents.
  */
@@ -27,13 +25,12 @@
 public class MatchNoDocsQuery extends Query {
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
-        // Rewrite to an empty BooleanQuery so no Scorer or Weight is required
-        return new BooleanQuery.Builder().build();
+    public String toString(String field) {
+        return "";
     }
 
     @Override
-    public String toString(String field) {
-        return "";
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+        return new BooleanQuery.Builder().build().createWeight(searcher, needsScores);
     }
 }
Index: lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -18,20 +18,29 @@
  */
 
 import java.io.IOException;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
 
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
-import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.PriorityQueue;
@@ -250,10 +259,10 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    if (termArrays.isEmpty()) {
-      return new MatchNoDocsQuery();
-    } else if (termArrays.size() == 1) {                 // optimize one-term case
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    if (termArrays.isEmpty())
+      return new MatchNoDocsQuery().createWeight(searcher, needsScores);
+    if (termArrays.size() == 1) {
       Term[] terms = termArrays.get(0);
       BooleanQuery.Builder builder = new BooleanQuery.Builder();
       builder.setDisableCoord(true);
@@ -260,14 +269,8 @@
       for (int i=0; i<terms.length; i++) {
         builder.add(new TermQuery(terms[i]), BooleanClause.Occur.SHOULD);
       }
-      return builder.build();
-    } else {
-      return super.rewrite(reader);
+      return builder.build().createWeight(searcher, needsScores);
     }
-  }
-
-  @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     return new MultiPhraseWeight(searcher, needsScores);
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java	(working copy)
@@ -20,9 +20,8 @@
 import java.io.IOException;
 import java.util.Objects;
 
-import org.apache.lucene.index.FilteredTermsEnum; // javadocs
+import org.apache.lucene.index.FilteredTermsEnum;
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.SingleTermsEnum;   // javadocs
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
@@ -304,14 +303,9 @@
     return getTermsEnum(terms, new AttributeSource());
   }
 
-  /**
-   * To rewrite to a simpler form, instead return a simpler
-   * enum from {@link #getTermsEnum(Terms, AttributeSource)}.  For example,
-   * to rewrite to a single term, return a {@link SingleTermsEnum}
-   */
   @Override
-  public final Query rewrite(IndexReader reader) throws IOException {
-    return rewriteMethod.rewrite(reader, this);
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return rewriteMethod.rewrite(searcher.getIndexReader(), this).createWeight(searcher, needsScores);
   }
 
   /**
Index: lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java	(working copy)
@@ -157,7 +157,7 @@
             bq.add(new TermQuery(new Term(query.field, t.term), termContext), Occur.SHOULD);
           }
           Query q = new ConstantScoreQuery(bq.build());
-          final Weight weight = searcher.rewrite(q).createWeight(searcher, needsScores);
+          final Weight weight = searcher.createWeight(q, needsScores);
           weight.normalize(1f, score());
           return new WeightOrDocIdSet(weight);
         }
Index: lucene/core/src/java/org/apache/lucene/search/NGramPhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/NGramPhraseQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/NGramPhraseQuery.java	(working copy)
@@ -20,7 +20,6 @@
 import java.io.IOException;
 import java.util.Objects;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 
 /**
@@ -27,7 +26,7 @@
  * This is a {@link PhraseQuery} which is optimized for n-gram phrase query.
  * For example, when you query "ABCD" on a 2-gram field, you may want to use
  * NGramPhraseQuery rather than {@link PhraseQuery}, because NGramPhraseQuery
- * will {@link #rewrite(IndexReader)} the query to "AB/0 CD/2", while {@link PhraseQuery}
+ * will rewrite the query to "AB/0 CD/2", while {@link PhraseQuery}
  * will query "AB/0 BC/1 CD/2" (where term/position).
  *
  */
@@ -47,7 +46,7 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     final Term[] terms = phraseQuery.getTerms();
     final int[] positions = phraseQuery.getPositions();
 
@@ -65,7 +64,7 @@
     }
     
     if (isOptimizable == false) {
-      return phraseQuery.rewrite(reader);
+      return phraseQuery.createWeight(searcher, needsScores);
     }
 
     PhraseQuery.Builder builder = new PhraseQuery.Builder();
@@ -74,7 +73,7 @@
         builder.add(terms[i], i);
       }
     }
-    return builder.build();
+    return builder.build().createWeight(searcher, needsScores);
   }
 
   @Override
@@ -108,4 +107,5 @@
   public String toString(String field) {
     return phraseQuery.toString(field);
   }
+
 }
Index: lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java	(working copy)
@@ -24,7 +24,6 @@
 import java.util.List;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
@@ -261,23 +260,6 @@
       return positions;
   }
 
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    if (terms.length == 0) {
-      return new MatchNoDocsQuery();
-    } else if (terms.length == 1) {
-      return new TermQuery(terms[0]);
-    } else if (positions[0] != 0) {
-      int[] newPositions = new int[positions.length];
-      for (int i = 0; i < positions.length; ++i) {
-        newPositions[i] = positions[i] - positions[0];
-      }
-      return new PhraseQuery(slop, terms, newPositions);
-    } else {
-      return super.rewrite(reader);
-    }
-  }
-
   static class PostingsAndFreq implements Comparable<PostingsAndFreq> {
     final PostingsEnum postings;
     final int position;
@@ -459,6 +441,17 @@
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    if (terms.length == 0)
+      return new MatchNoDocsQuery().createWeight(searcher, needsScores);
+    if (terms.length == 1)
+      return new TermQuery(terms[0]).createWeight(searcher, needsScores);
+    if (positions[0] != 0) {
+      int[] newPositions = new int[positions.length];
+      for (int i = 0; i < positions.length; ++i) {
+        newPositions[i] = positions[i] - positions[0];
+      }
+      return new PhraseQuery(slop, terms, newPositions).createWeight(searcher, needsScores);
+    }
     return new PhraseWeight(searcher, needsScores);
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/Query.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/Query.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/Query.java	(working copy)
@@ -19,8 +19,6 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
-
 /** The abstract base class for queries.
     <p>Instantiable subclasses are:
     <ul>
@@ -56,24 +54,12 @@
 
   /**
    * Expert: Constructs an appropriate Weight implementation for this query.
-   * <p>
-   * Only implemented by primitive queries, which re-write to themselves.
    *
    * @param needsScores   True if document scores ({@link Scorer#score}) or match
    *                      frequencies ({@link Scorer#freq}) are needed.
    */
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    throw new UnsupportedOperationException("Query " + this + " does not implement createWeight");
-  }
+  public abstract Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException;
 
-  /** Expert: called to re-write queries into primitive queries. For example,
-   * a PrefixQuery will be rewritten into a BooleanQuery that consists
-   * of TermQuerys.
-   */
-  public Query rewrite(IndexReader reader) throws IOException {
-    return this;
-  }
-
   @Override
   public int hashCode() {
     return getClass().hashCode();
Index: lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.util.Bits;
 
@@ -43,12 +42,12 @@
       throw new NullPointerException("Query may not be null");
     this.query = query;
   }
-  
+
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    return new BoostQuery(new ConstantScoreQuery(query), 0f);
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return new BoostQuery(new ConstantScoreQuery(query), 0f).createWeight(searcher, needsScores);
   }
-  
+
   /** returns the inner Query */
   public final Query getQuery() {
     return query;
Index: lucene/core/src/java/org/apache/lucene/search/package-info.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/package-info.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/package-info.java	(working copy)
@@ -353,9 +353,8 @@
  *         class is where it all begins. Without a Query, there would be
  *         nothing to score. Furthermore, the Query class is the catalyst for the other scoring classes as it
  *         is often responsible
- *         for creating them or coordinating the functionality between them. The
- *         {@link org.apache.lucene.search.Query Query} class has several methods that are important for
- *         derived classes:
+ *         for creating them or coordinating the functionality between them. Derived classes must implement the
+ *         following method:
  *         <ol>
  *             <li>{@link org.apache.lucene.search.Query#createWeight(IndexSearcher,boolean) createWeight(IndexSearcher searcher,boolean)} &mdash; A
  *                 {@link org.apache.lucene.search.Weight Weight} is the internal representation of the
@@ -363,19 +362,16 @@
  *                 provide an implementation of Weight. See the subsection on <a
  *                     href="#weightClass">The Weight Interface</a> below for details on implementing the Weight
  *                 interface.</li>
- *             <li>{@link org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) rewrite(IndexReader reader)} &mdash; Rewrites queries into primitive queries. Primitive queries are:
- *                 {@link org.apache.lucene.search.TermQuery TermQuery},
- *                 {@link org.apache.lucene.search.BooleanQuery BooleanQuery}, <span
- *                     >and other queries that implement {@link org.apache.lucene.search.Query#createWeight(IndexSearcher,boolean) createWeight(IndexSearcher searcher,boolean,float)}</span></li>
+ *
  *         </ol>
  * <a name="weightClass"></a>
  * <h3>The Weight Interface</h3>
  *     <p>The
  *         {@link org.apache.lucene.search.Weight Weight}
- *         interface provides an internal representation of the Query so that it can be reused. Any
+ *         class provides an internal representation of the Query so that it can be reused. Any
  *         {@link org.apache.lucene.search.IndexSearcher IndexSearcher}
  *         dependent state should be stored in the Weight implementation,
- *         not in the Query class. The interface defines five methods that must be implemented:
+ *         not in the Query class. The abstract base class defines five methods that must be implemented:
  *         <ol>
  *             <li>
  *                 {@link org.apache.lucene.search.Weight#getQuery getQuery()} &mdash; Pointer to the
Index: lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java	(working copy)
@@ -17,13 +17,11 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-
 import java.io.IOException;
 import java.util.Objects;
 
+import org.apache.lucene.search.IndexSearcher;
+
 /**
  * <p>Wrapper to allow {@link SpanQuery} objects participate in composite 
  * single-field SpanQueries by 'lying' about their search field. That is, 
@@ -94,18 +92,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    FieldMaskingSpanQuery clone = null;
-
-    SpanQuery rewritten = (SpanQuery) maskedQuery.rewrite(reader);
-    if (rewritten != maskedQuery) {
-      return new FieldMaskingSpanQuery(rewritten, field);
-    }
-
-    return super.rewrite(reader);
-  }
-
-  @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("mask(");
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java	(working copy)
@@ -26,7 +26,6 @@
 import java.util.Set;
 import java.util.TreeMap;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
@@ -33,7 +32,6 @@
 import org.apache.lucene.search.BoostQuery;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 
 /**
@@ -99,25 +97,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    if (boost == 1f) {
-      return query;
-    }
-
-    final SpanQuery rewritten = (SpanQuery) query.rewrite(reader);
-    if (query != rewritten) {
-      return new SpanBoostQuery(rewritten, boost);
-    }
-
-    if (query.getClass() == SpanBoostQuery.class) {
-      SpanBoostQuery in = (SpanBoostQuery) query;
-      return new SpanBoostQuery(in.query, boost * in.boost);
-    }
-
-    return super.rewrite(reader);
-  }
-
-  @Override
   public String toString(String field) {
     boolean needsParens = NO_PARENS_REQUIRED_QUERIES.contains(query.getClass()) == false;
     StringBuilder builder = new StringBuilder();
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java	(working copy)
@@ -17,13 +17,6 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Map;
@@ -30,6 +23,11 @@
 import java.util.Objects;
 import java.util.Set;
 
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.IndexSearcher;
+
 abstract class SpanContainQuery extends SpanQuery implements Cloneable {
 
   SpanQuery big;
@@ -104,23 +102,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    SpanQuery rewrittenBig = (SpanQuery) big.rewrite(reader);
-    SpanQuery rewrittenLittle = (SpanQuery) little.rewrite(reader);
-    if (big != rewrittenBig || little != rewrittenLittle) {
-      try {
-        SpanContainQuery clone = (SpanContainQuery) super.clone();
-        clone.big = rewrittenBig;
-        clone.little = rewrittenLittle;
-        return clone;
-      } catch (CloneNotSupportedException e) {
-        throw new AssertionError(e);
-      }
-    }
-    return super.rewrite(reader);
-  }
-
-  @Override
   public boolean equals(Object o) {
     if (! super.equals(o)) {
       return false;
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java	(working copy)
@@ -17,6 +17,9 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Objects;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
@@ -27,9 +30,6 @@
 import org.apache.lucene.search.ScoringRewrite;
 import org.apache.lucene.search.TopTermsRewrite;
 
-import java.io.IOException;
-import java.util.Objects;
-
 /**
  * Wraps any {@link MultiTermQuery} as a {@link SpanQuery}, 
  * so it can be nested within other SpanQuery classes.
@@ -97,7 +97,7 @@
 
   @Override
   public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    throw new IllegalArgumentException("Rewrite first!");
+    return (SpanWeight) query.createWeight(searcher, needsScores);
   }
 
   /** Returns the wrapped query */
@@ -116,14 +116,6 @@
     builder.append(")");
     return builder.toString();
   }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final Query q = query.rewrite(reader);
-    if (!(q instanceof SpanQuery))
-      throw new UnsupportedOperationException("You can only use SpanMultiTermQueryWrapper with a suitable SpanRewriteMethod.");
-    return q;
-  }
   
   @Override
   public int hashCode() {
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(working copy)
@@ -26,14 +26,11 @@
 import java.util.Objects;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.util.ToStringUtils;
 
 /** Matches spans which are near one another.  One can specify <i>slop</i>, the
  * maximum number of intervening unmatched positions, as well as whether
@@ -232,28 +229,6 @@
     }
   }
 
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    boolean actuallyRewritten = false;
-    List<SpanQuery> rewrittenClauses = new ArrayList<>();
-    for (int i = 0 ; i < clauses.size(); i++) {
-      SpanQuery c = clauses.get(i);
-      SpanQuery query = (SpanQuery) c.rewrite(reader);
-      actuallyRewritten |= query != c;
-      rewrittenClauses.add(query);
-    }
-    if (actuallyRewritten) {
-      try {
-        SpanNearQuery rewritten = (SpanNearQuery) clone();
-        rewritten.clauses = rewrittenClauses;
-        return rewritten;
-      } catch (CloneNotSupportedException e) {
-        throw new AssertionError(e);
-      }
-    }
-    return super.rewrite(reader);
-  }
-
   /** Returns true iff <code>o</code> is equal to this. */
   @Override
   public boolean equals(Object o) {
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(working copy)
@@ -17,21 +17,18 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.index.IndexReader;
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.util.ToStringUtils;
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-
 /** Removes matches which overlap with another SpanQuery or which are
  * within x tokens before or y tokens after another SpanQuery.
  */
@@ -191,17 +188,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    SpanQuery rewrittenInclude = (SpanQuery) include.rewrite(reader);
-    SpanQuery rewrittenExclude = (SpanQuery) exclude.rewrite(reader);
-    if (rewrittenInclude != include || rewrittenExclude != exclude) {
-      return new SpanNotQuery(rewrittenInclude, rewrittenExclude);
-    }
-    return super.rewrite(reader);
-  }
-
-    /** Returns true iff <code>o</code> is equal to this. */
-  @Override
   public boolean equals(Object o) {
     if (!super.equals(o))
       return false;
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(working copy)
@@ -17,7 +17,13 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.index.IndexReader;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
@@ -25,17 +31,9 @@
 import org.apache.lucene.search.DisiWrapper;
 import org.apache.lucene.search.DisjunctionDISIApproximation;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TwoPhaseIterator;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
 
-
 /** Matches the union of its clauses.
  */
 public final class SpanOrQuery extends SpanQuery {
@@ -71,22 +69,6 @@
   public String getField() { return field; }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    SpanOrQuery rewritten = new SpanOrQuery();
-    boolean actuallyRewritten = false;
-    for (int i = 0 ; i < clauses.size(); i++) {
-      SpanQuery c = clauses.get(i);
-      SpanQuery query = (SpanQuery) c.rewrite(reader);
-      actuallyRewritten |= query != c;
-      rewritten.addClause(query);
-    }
-    if (actuallyRewritten) {
-      return rewritten;
-    }
-    return super.rewrite(reader);
-  }
-
-  @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("spanOr([");
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(revision 1702789)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(working copy)
@@ -17,20 +17,18 @@
  */
 
 
-import org.apache.lucene.index.IndexReader;
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
 
-
 /**
  * Base class for filtering a SpanQuery based on the position of a match.
  **/
@@ -105,23 +103,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    SpanQuery rewritten = (SpanQuery) match.rewrite(reader);
-    if (rewritten != match) {
-      try {
-        SpanPositionCheckQuery clone = (SpanPositionCheckQuery) this.clone();
-        clone.match = rewritten;
-        return clone;
-      } catch (CloneNotSupportedException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    return super.rewrite(reader);
-  }
-
-  /** Returns true iff <code>o</code> is equal to this. */
-  @Override
   public boolean equals(Object o) {
     if (! super.equals(o)) {
       return false;
Index: lucene/core/src/test/org/apache/lucene/search/JustCompileSearch.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/JustCompileSearch.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/JustCompileSearch.java	(working copy)
@@ -181,7 +181,12 @@
     public String toString(String field) {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
-    
+
+    @Override
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
   }
   
   static final class JustCompileScorer extends Scorer {
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(working copy)
@@ -175,8 +175,6 @@
 
     final ExecutorService es = Executors.newCachedThreadPool(new NamedThreadFactory("NRT search threads"));
     searcher = new IndexSearcher(multireader, es);
-    if (VERBOSE)
-      System.out.println("rewritten form: " + searcher.rewrite(query.build()));
     assertEquals(0, searcher.search(query.build(), 10).totalHits);
     es.shutdown();
     es.awaitTermination(1, TimeUnit.SECONDS);
@@ -337,8 +335,9 @@
     Directory dir = newDirectory();
     (new RandomIndexWriter(random(), dir)).close();
     IndexReader r = DirectoryReader.open(dir);
+    IndexSearcher s = new IndexSearcher(r);
 
-    TermQuery expected = new TermQuery(new Term(FIELD, VALUE));
+    Query expected = new TermQuery(new Term(FIELD, VALUE));
 
     final int numLayers = atLeast(3);
     Query actual = new TermQuery(new Term(FIELD, VALUE));
@@ -352,7 +351,7 @@
     }
 
     assertEquals(numLayers + ": " + actual.toString(),
-                 expected, new IndexSearcher(r).rewrite(actual));
+                 expected, actual.createWeight(s, true).getQuery());
 
     r.close();
     dir.close();
@@ -564,9 +563,9 @@
     query1.add(new TermQuery(new Term("field", "a")), Occur.FILTER);
 
     // Single clauses rewrite to a term query
-    final Query rewritten1 = query1.build().rewrite(reader);
-    assertTrue(rewritten1 instanceof BoostQuery);
-    assertEquals(0f, ((BoostQuery) rewritten1).getBoost(), 0f);
+    final Weight rewritten1 = query1.build().createWeight(searcher, true);
+    assertTrue(rewritten1.getQuery() instanceof BoostQuery);
+    assertEquals(0f, ((BoostQuery) rewritten1.getQuery()).getBoost(), 0f);
 
     // When there are two clauses, we cannot rewrite, but if one of them creates
     // a null scorer we will end up with a single filter scorer and will need to
Index: lucene/core/src/test/org/apache/lucene/search/TestBoostQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBoostQuery.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestBoostQuery.java	(working copy)
@@ -56,15 +56,15 @@
 
     // inner queries are rewritten
     Query q = new BoostQuery(new MatchNoDocsQuery(), 2);
-    assertEquals(new BoostQuery(new BooleanQuery.Builder().build(), 2), searcher.rewrite(q));
+    assertEquals(new BoostQuery(new BooleanQuery.Builder().build(), 2), searcher.createWeight(q, true).getQuery());
 
     // boosts are merged
     q = new BoostQuery(new BoostQuery(new MatchAllDocsQuery(), 3), 2);
-    assertEquals(new BoostQuery(new MatchAllDocsQuery(), 6), searcher.rewrite(q));
+    assertEquals(new BoostQuery(new MatchAllDocsQuery(), 6), searcher.createWeight(q, true).getQuery());
 
     // scores are not computed when the boost is 0
     q = new BoostQuery(new MatchAllDocsQuery(), 0);
-    assertEquals(new BoostQuery(new ConstantScoreQuery(new MatchAllDocsQuery()), 0), searcher.rewrite(q));
+    assertEquals(new BoostQuery(new ConstantScoreQuery(new MatchAllDocsQuery()), 0), searcher.createWeight(q, true).getQuery());
   }
 
 }
Index: lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java	(working copy)
@@ -217,10 +217,7 @@
     s.search(new ConstantScoreQuery(filter), new TotalHitCountCollector());
     
     // check the rewrite
-    Query rewritten = filter;
-    for (Query q = rewritten.rewrite(r); q != rewritten; q = rewritten.rewrite(r)) {
-      rewritten = q;
-    }
+    Query rewritten = s.createWeight(filter, true).getQuery();
     assertEquals(new BoostQuery(new ConstantScoreQuery(wrapped), 0), rewritten);
     
     r.close();
Index: lucene/core/src/test/org/apache/lucene/search/TestMatchNoDocsQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestMatchNoDocsQuery.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestMatchNoDocsQuery.java	(working copy)
@@ -23,11 +23,9 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.store.Directory;
-
 import org.apache.lucene.util.LuceneTestCase;
 
 /**
@@ -58,7 +56,7 @@
 
     // A MatchNoDocsQuery rewrites to an empty BooleanQuery
     MatchNoDocsQuery mndq = new MatchNoDocsQuery();
-    Query rewritten = mndq.rewrite(ir);
+    Query rewritten = mndq.createWeight(is, true).getQuery();
     assertTrue(rewritten instanceof BooleanQuery);
     assertEquals(0, ((BooleanQuery) rewritten).clauses().size());
     hits = is.search(mndq, 1000).scoreDocs;
Index: lucene/core/src/test/org/apache/lucene/search/TestMultiTermQueryRewrites.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestMultiTermQueryRewrites.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestMultiTermQueryRewrites.java	(working copy)
@@ -89,8 +89,11 @@
   private Query extractInnerQuery(Query q) {
     if (q instanceof ConstantScoreQuery) {
       // wrapped as ConstantScoreQuery
-      q = ((ConstantScoreQuery) q).getQuery();
+      return extractInnerQuery(((ConstantScoreQuery) q).getQuery());
     }
+    if (q instanceof BoostQuery) {
+      return extractInnerQuery(((BoostQuery)q).getQuery());
+    }
     return q;
   }
   
@@ -115,9 +118,9 @@
   private void checkDuplicateTerms(MultiTermQuery.RewriteMethod method) throws Exception {
     final MultiTermQuery mtq = TermRangeQuery.newStringRange("data", "2", "7", true, true);
     mtq.setRewriteMethod(method);
-    final Query q1 = searcher.rewrite(mtq);
-    final Query q2 = multiSearcher.rewrite(mtq);
-    final Query q3 = multiSearcherDupls.rewrite(mtq);
+    final Query q1 = searcher.createWeight(mtq, true).getQuery();
+    final Query q2 = multiSearcher.createWeight(mtq, true).getQuery();
+    final Query q3 = multiSearcherDupls.createWeight(mtq, true).getQuery();
     if (VERBOSE) {
       System.out.println();
       System.out.println("single segment: " + q1);
@@ -185,9 +188,9 @@
       }
     };
     mtq.setRewriteMethod(method);
-    final Query q1 = searcher.rewrite(mtq);
-    final Query q2 = multiSearcher.rewrite(mtq);
-    final Query q3 = multiSearcherDupls.rewrite(mtq);
+    final Query q1 = searcher.createWeight(mtq, true).getQuery();
+    final Query q2 = multiSearcher.createWeight(mtq, true).getQuery();
+    final Query q3 = multiSearcherDupls.createWeight(mtq, true).getQuery();
     if (VERBOSE) {
       System.out.println();
       System.out.println("single segment: " + q1);
@@ -215,7 +218,7 @@
     final MultiTermQuery mtq = TermRangeQuery.newStringRange("data", "2", "7", true, true);
     mtq.setRewriteMethod(method);
     try {
-      multiSearcherDupls.rewrite(mtq);
+      multiSearcherDupls.createWeight(mtq, true);
       fail("Should throw BooleanQuery.TooManyClauses");
     } catch (BooleanQuery.TooManyClauses e) {
       //  Maybe remove this assert in later versions, when internal API changes:
@@ -233,7 +236,7 @@
     final MultiTermQuery mtq = TermRangeQuery.newStringRange("data", "2", "7", true, true);
     mtq.setRewriteMethod(method);
     try {
-      multiSearcherDupls.rewrite(mtq);
+      multiSearcherDupls.createWeight(mtq, true);
     } finally {
       BooleanQuery.setMaxClauseCount(savedMaxClauseCount);
     }
Index: lucene/core/src/test/org/apache/lucene/search/TestNGramPhraseQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestNGramPhraseQuery.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestNGramPhraseQuery.java	(working copy)
@@ -48,11 +48,14 @@
   }
   
   public void testRewrite() throws Exception {
+
+    IndexSearcher searcher = new IndexSearcher(reader);
+
     // bi-gram test ABC => AB/BC => AB/BC
     NGramPhraseQuery pq1 = new NGramPhraseQuery(2, new PhraseQuery("f", "AB", "BC"));
     
-    Query q = pq1.rewrite(reader);
-    assertSame(q.rewrite(reader), q);
+    Query q = pq1.createWeight(searcher, true).getQuery();
+    assertSame(q.createWeight(searcher, true).getQuery(), q);
     PhraseQuery rewritten1 = (PhraseQuery) q;
     assertArrayEquals(new Term[]{new Term("f", "AB"), new Term("f", "BC")}, rewritten1.getTerms());
     assertArrayEquals(new int[]{0, 1}, rewritten1.getPositions());
@@ -60,7 +63,7 @@
     // bi-gram test ABCD => AB/BC/CD => AB//CD
     NGramPhraseQuery pq2 = new NGramPhraseQuery(2, new PhraseQuery("f", "AB", "BC", "CD"));
     
-    q = pq2.rewrite(reader);
+    q = pq2.createWeight(searcher, true).getQuery();
     assertTrue(q instanceof PhraseQuery);
     assertNotSame(pq2, q);
     PhraseQuery rewritten2 = (PhraseQuery) q;
@@ -70,7 +73,7 @@
     // tri-gram test ABCDEFGH => ABC/BCD/CDE/DEF/EFG/FGH => ABC///DEF//FGH
     NGramPhraseQuery pq3 = new NGramPhraseQuery(3, new PhraseQuery("f", "ABC", "BCD", "CDE", "DEF", "EFG", "FGH"));
     
-    q = pq3.rewrite(reader);
+    q = pq3.createWeight(searcher, true).getQuery();
     assertTrue(q instanceof PhraseQuery);
     assertNotSame(pq3, q);
     PhraseQuery rewritten3 = (PhraseQuery) q;
Index: lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java	(working copy)
@@ -139,16 +139,6 @@
     }
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
-      Query in2 = in.rewrite(reader);
-      if (in2 == in) {
-        return super.rewrite(reader);
-      } else {
-        return new AssertNeedsScores(in2, value);
-      }
-    }
-
-    @Override
     public int hashCode() {
       final int prime = 31;
       int result = super.hashCode();
Index: lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java	(working copy)
@@ -545,7 +545,7 @@
   /* test that a single term is rewritten to a term query */
   public void testRewrite() throws IOException {
     PhraseQuery pq = new PhraseQuery("foo", "bar");
-    Query rewritten = pq.rewrite(searcher.getIndexReader());
+    Query rewritten = pq.createWeight(searcher, true).getQuery();
     assertTrue(rewritten instanceof TermQuery);
   }
 
Index: lucene/core/src/test/org/apache/lucene/search/TestQueryCacheKeys.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestQueryCacheKeys.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/search/TestQueryCacheKeys.java	(working copy)
@@ -0,0 +1,171 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestQueryCacheKeys extends LuceneTestCase {
+
+  static class AssertingCachingPolicy implements QueryCachingPolicy {
+
+    final Query expectedKey;
+
+    AssertingCachingPolicy(Query expectedKey) {
+      this.expectedKey = expectedKey;
+    }
+
+    @Override
+    public void onUse(Query query) {
+      assertEquals(expectedKey, query);
+    }
+
+    @Override
+    public boolean shouldCache(Query query, LeafReaderContext context) throws IOException {
+      assertEquals(expectedKey, query);
+      return true;
+    }
+  }
+
+  public void testSingleTermBooleansAreCached() throws IOException {
+    final Query expectedCacheKey = new TermQuery(new Term("foo", "bar"));
+    final BooleanQuery.Builder query = new BooleanQuery.Builder();
+    query.add(new BoostQuery(expectedCacheKey, 42f), BooleanClause.Occur.MUST);
+
+    final LRUQueryCache queryCache = new LRUQueryCache(1000000, 10000000);
+    Directory dir = newDirectory();
+    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new StringField("foo", "bar", Field.Store.YES));
+    w.addDocument(doc);
+    w.commit();
+    final IndexReader reader = w.getReader();
+    final IndexSearcher searcher = newSearcher(reader);
+    w.close();
+
+    searcher.setQueryCache(queryCache);
+    searcher.setQueryCachingPolicy(new AssertingCachingPolicy(expectedCacheKey));
+    searcher.search(query.build(), new TotalHitCountCollector());
+
+    reader.close();
+    dir.close();
+  }
+
+  public void testEquivalentDismaxesYieldEquivalentCacheKeys() throws Exception {
+    Directory dir = newDirectory();
+    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));
+    Document doc = new Document();
+    doc.add(newTextField("field", "word2 word3 word10 word11", Field.Store.NO));
+    w.addDocument(doc);
+    IndexReader r = DirectoryReader.open(w, true);
+    IndexSearcher s = newSearcher(r);
+
+    BooleanQuery orquery = new BooleanQuery.Builder()
+        .add(new TermQuery(new Term("field", "word10")), BooleanClause.Occur.SHOULD)
+        .add(new TermQuery(new Term("field", "word11")), BooleanClause.Occur.SHOULD)
+        .setDisableCoord(true)
+        .build();
+
+    PrefixQuery regexq = new PrefixQuery(new Term("field", "word1"));
+    regexq.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);
+
+    Query expected = new DisjunctionMaxQuery(Arrays.asList(new TermQuery(new Term("field", "word2")), orquery), 0.1f);
+    Query multiterm = new DisjunctionMaxQuery(Arrays.asList(new TermQuery(new Term("field", "word2")), regexq), 0.1f);
+
+    final LRUQueryCache queryCache = new LRUQueryCache(1000000, 10000000);
+    s.setQueryCache(queryCache);
+    s.setQueryCachingPolicy(QueryCachingPolicy.ALWAYS_CACHE);
+    s.search(multiterm, new TotalHitCountCollector());
+
+    s.search(expected, new TotalHitCountCollector());
+    assertEquals(1, queryCache.getHitCount());
+
+    s.search(multiterm, new TotalHitCountCollector());
+    assertEquals(2, queryCache.getHitCount());
+
+    r.close();
+    w.close();
+    dir.close();
+  }
+
+  public void testEquivalentBooleansYieldEquivalentCacheKeys() throws IOException {
+    Directory dir = newDirectory();
+    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));
+    Document doc = new Document();
+    doc.add(newTextField("field", "word2 word3 word10 word11", Field.Store.NO));
+    w.addDocument(doc);
+    IndexReader r = DirectoryReader.open(w, true);
+    IndexSearcher s = newSearcher(r);
+
+    BooleanQuery orquery = new BooleanQuery.Builder()
+        .add(new TermQuery(new Term("field", "word10")), BooleanClause.Occur.SHOULD)
+        .add(new TermQuery(new Term("field", "word11")), BooleanClause.Occur.SHOULD)
+        .setDisableCoord(true)
+        .build();
+
+    PrefixQuery regexq = new PrefixQuery(new Term("field", "word1"));
+    regexq.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);
+
+    BooleanQuery expected = new BooleanQuery.Builder()
+        .add(new TermQuery(new Term("field", "word2")), BooleanClause.Occur.FILTER)
+        .add(orquery, BooleanClause.Occur.FILTER)
+        .build();
+
+    BooleanQuery must = new BooleanQuery.Builder()
+        .add(new TermQuery(new Term("field", "word2")), BooleanClause.Occur.MUST)
+        .add(orquery, BooleanClause.Occur.MUST)
+        .build();
+
+    BooleanQuery multiterm = new BooleanQuery.Builder()
+        .add(new TermQuery(new Term("field", "word2")), BooleanClause.Occur.MUST)
+        .add(regexq, BooleanClause.Occur.MUST)
+        .build();
+
+    final LRUQueryCache queryCache = new LRUQueryCache(1000000, 10000000);
+    s.setQueryCache(queryCache);
+    s.setQueryCachingPolicy(QueryCachingPolicy.ALWAYS_CACHE);
+    s.search(multiterm, new TotalHitCountCollector());
+
+    s.search(expected, new TotalHitCountCollector());
+    assertEquals(1, queryCache.getHitCount());
+
+    s.search(multiterm, new TotalHitCountCollector());
+    assertEquals(2, queryCache.getHitCount());
+
+    s.search(must, new TotalHitCountCollector());
+    assertEquals(3, queryCache.getHitCount());
+
+    r.close();
+    w.close();
+    dir.close();
+  }
+
+}

Property changes on: lucene/core/src/test/org/apache/lucene/search/TestQueryCacheKeys.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery.java	(working copy)
@@ -142,13 +142,13 @@
   }
   
   private void checkBooleanTerms(IndexSearcher searcher, TermRangeQuery query, String... terms) throws IOException {
-    query.setRewriteMethod(new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(50));
-    final BooleanQuery bq = (BooleanQuery) searcher.rewrite(query);
+    MultiTermQuery.RewriteMethod rewriteMethod = new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(50);
+    final BooleanQuery bq = (BooleanQuery) rewriteMethod.rewrite(searcher.getIndexReader(), query);
     final Set<String> allowedTerms = asSet(terms);
     assertEquals(allowedTerms.size(), bq.clauses().size());
     for (BooleanClause c : bq.clauses()) {
-      assertTrue(c.getQuery() instanceof TermQuery);
-      final TermQuery tq = (TermQuery) c.getQuery();
+      assertTrue(c.getQuery() instanceof BoostQuery);
+      final TermQuery tq = (TermQuery) ((BoostQuery)c.getQuery()).getQuery();
       final String term = tq.getTerm().text();
       assertTrue("invalid term: "+ term, allowedTerms.contains(term));
       allowedTerms.remove(term); // remove to fail on double terms
Index: lucene/core/src/test/org/apache/lucene/search/TestWildcard.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestWildcard.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/TestWildcard.java	(working copy)
@@ -17,11 +17,11 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.document.Field;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
+import java.io.IOException;
+
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
@@ -28,9 +28,9 @@
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.Terms;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
 
-import java.io.IOException;
-
 /**
  * TestWildcard tests the '*' and '?' wildcard characters.
  */
@@ -70,16 +70,16 @@
       assertMatches(searcher, wq, 1);
 
       wq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);
-      Query q = searcher.rewrite(wq);
-      assertTrue(q instanceof TermQuery);
+      Weight w = wq.createWeight(searcher, true);
+      assertTrue(w.getQuery() instanceof TermQuery);
       
       wq.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_REWRITE);
-      q = searcher.rewrite(wq);
-      assertTrue(q instanceof MultiTermQueryConstantScoreWrapper);
+      w = wq.createWeight(searcher, true);
+      assertTrue(w.getQuery() instanceof MultiTermQueryConstantScoreWrapper);
       
       wq.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);
-      q = searcher.rewrite(wq);
-      assertTrue(q instanceof ConstantScoreQuery);
+      w = wq.createWeight(searcher, true);
+      assertTrue(w.getQuery() instanceof ConstantScoreQuery);
       reader.close();
       indexStore.close();
   }
@@ -95,9 +95,9 @@
     MultiTermQuery wq = new WildcardQuery(new Term("field", ""));
     wq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);
     assertMatches(searcher, wq, 0);
-    Query q = searcher.rewrite(wq);
-    assertTrue(q instanceof BooleanQuery);
-    assertEquals(0, ((BooleanQuery) q).clauses().size());
+    Weight w = wq.createWeight(searcher, true);
+    assertTrue(w.getQuery() instanceof BooleanQuery);
+    assertEquals(0, ((BooleanQuery) w.getQuery()).clauses().size());
     reader.close();
     indexStore.close();
   }
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java	(revision 1702789)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java	(working copy)
@@ -25,7 +25,6 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.similarities.TFIDFSimilarity;
 import org.apache.lucene.store.Directory;
@@ -33,9 +32,6 @@
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
-import java.util.HashSet;
-import java.util.Set;
-
 import static org.apache.lucene.search.spans.SpanTestUtil.assertFinished;
 import static org.apache.lucene.search.spans.SpanTestUtil.assertNext;
 
@@ -132,53 +128,7 @@
   protected void check(SpanQuery q, int[] docs) throws Exception {
     CheckHits.checkHitCollector(random(), q, null, searcher, docs);
   }
-
-  public void testRewrite0() throws Exception {
-    SpanQuery q = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "first");
-    SpanQuery qr = (SpanQuery) searcher.rewrite(q);
-
-    QueryUtils.checkEqual(q, qr);
-
-    Set<Term> terms = new HashSet<>();
-    qr.createWeight(searcher, false).extractTerms(terms);
-    assertEquals(1, terms.size());
-  }
   
-  public void testRewrite1() throws Exception {
-    // mask an anon SpanQuery class that rewrites to something else.
-    SpanQuery q = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) {
-          @Override
-          public Query rewrite(IndexReader reader) {
-            return new SpanOrQuery(new SpanTermQuery(new Term("first", "sally")),
-                new SpanTermQuery(new Term("first", "james")));
-          }
-        }, "first");
-
-    SpanQuery qr = (SpanQuery) searcher.rewrite(q);
-
-    QueryUtils.checkUnequal(q, qr);
-
-    Set<Term> terms = new HashSet<>();
-    qr.createWeight(searcher, false).extractTerms(terms);
-    assertEquals(2, terms.size());
-  }
-  
-  public void testRewrite2() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("last", "smith"));
-    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
-    SpanQuery q = new SpanNearQuery(new SpanQuery[]
-      { q1, new FieldMaskingSpanQuery(q2, "last")}, 1, true );
-    Query qr = searcher.rewrite(q);
-
-    QueryUtils.checkEqual(q, qr);
-
-    HashSet<Term> set = new HashSet<>();
-    qr.createWeight(searcher, true).extractTerms(set);
-    assertEquals(2, set.size());
-  }
-  
   public void testEquality1() {
     SpanQuery q1 = new FieldMaskingSpanQuery
       (new SpanTermQuery(new Term("last", "sally")) , "first");
Index: lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery.java	(revision 1702789)
+++ lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery.java	(working copy)
@@ -24,14 +24,15 @@
 import java.util.Map;
 import java.util.Objects;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.Weight;
 
 /**
  * A {@link Query} for drill-down over facet categories. You
@@ -84,8 +85,8 @@
   }
   
   /** Creates a new {@code DrillDownQuery} over the given base query. Can be
-   *  {@code null}, in which case the result {@link Query} from
-   *  {@link #rewrite(IndexReader)} will be a pure browsing query, filtering on
+   *  {@code null}, in which case the result {@link Weight} from
+   *  {@link #createWeight(IndexSearcher,boolean)} will be a pure browsing query, filtering on
    *  the added categories only. */
   public DrillDownQuery(FacetsConfig config, Query baseQuery) {
     this.baseQuery = baseQuery;
@@ -135,14 +136,14 @@
     return Objects.equals(baseQuery, other.baseQuery)
         && dimQueries.equals(other.dimQueries);
   }
-  
+
   @Override
-  public Query rewrite(IndexReader r) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     BooleanQuery rewritten = getBooleanQuery();
     if (rewritten.clauses().isEmpty()) {
-      return new MatchAllDocsQuery();
+      return searcher.createWeight(new MatchAllDocsQuery(), needsScores);
     }
-    return rewritten;
+    return searcher.createWeight(rewritten, needsScores);
   }
 
   @Override
Index: lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysQuery.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysQuery.java	(revision 1702789)
+++ lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysQuery.java	(working copy)
@@ -23,7 +23,6 @@
 import java.util.Set;
 
 import org.apache.lucene.facet.DrillSidewaysScorer.DocsAndCost;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BulkScorer;
@@ -60,23 +59,6 @@
   public String toString(String field) {
     return "DrillSidewaysQuery";
   }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    Query newQuery = baseQuery;
-    while(true) {
-      Query rewrittenQuery = newQuery.rewrite(reader);
-      if (rewrittenQuery == newQuery) {
-        break;
-      }
-      newQuery = rewrittenQuery;
-    }
-    if (newQuery == baseQuery) {
-      return super.rewrite(reader);
-    } else {
-      return new DrillSidewaysQuery(newQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce);
-    }
-  }
   
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
Index: lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRange.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRange.java	(revision 1702789)
+++ lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRange.java	(working copy)
@@ -21,7 +21,6 @@
 import java.util.Collections;
 import java.util.Objects;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
@@ -139,17 +138,6 @@
     }
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
-      if (fastMatchQuery != null) {
-        final Query fastMatchRewritten = fastMatchQuery.rewrite(reader);
-        if (fastMatchRewritten != fastMatchQuery) {
-          return new ValueSourceQuery(range, fastMatchRewritten, valueSource);
-        }
-      }
-      return super.rewrite(reader);
-    }
-
-    @Override
     public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
       final Weight fastMatchWeight = fastMatchQuery == null
           ? null
Index: lucene/facet/src/java/org/apache/lucene/facet/range/LongRange.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/range/LongRange.java	(revision 1702789)
+++ lucene/facet/src/java/org/apache/lucene/facet/range/LongRange.java	(working copy)
@@ -21,7 +21,6 @@
 import java.util.Collections;
 import java.util.Objects;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
@@ -131,17 +130,6 @@
     }
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
-      if (fastMatchQuery != null) {
-        final Query fastMatchRewritten = fastMatchQuery.rewrite(reader);
-        if (fastMatchRewritten != fastMatchQuery) {
-          return new ValueSourceQuery(range, fastMatchRewritten, valueSource);
-        }
-      }
-      return super.rewrite(reader);
-    }
-
-    @Override
     public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
       final Weight fastMatchWeight = fastMatchQuery == null
           ? null
Index: lucene/facet/src/test/org/apache/lucene/facet/TestDrillDownQuery.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/TestDrillDownQuery.java	(revision 1702789)
+++ lucene/facet/src/test/org/apache/lucene/facet/TestDrillDownQuery.java	(working copy)
@@ -239,7 +239,7 @@
   public void testNoDrillDown() throws Exception {
     Query base = new MatchAllDocsQuery();
     DrillDownQuery q = new DrillDownQuery(config, base);
-    Query rewrite = q.rewrite(reader).rewrite(reader);
+    Query rewrite = new IndexSearcher(reader).createWeight(q, true).getQuery();
     assertEquals(base, rewrite);
   }
 }
Index: lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java	(revision 1702789)
+++ lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java	(working copy)
@@ -870,15 +870,6 @@
     }
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
-      final Query inRewritten = in.rewrite(reader);
-      if (in != inRewritten) {
-        return new UsedQuery(inRewritten, used);
-      }
-      return super.rewrite(reader);
-    }
-
-    @Override
     public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
       final Weight in = this.in.createWeight(searcher, needsScores);
       return new Weight(in.getQuery()) {
Index: lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermScorer.java
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermScorer.java	(revision 1702789)
+++ lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermScorer.java	(working copy)
@@ -64,8 +64,7 @@
 
   /**
    * 
-   * @param query a Lucene query (ideally rewritten using query.rewrite before
-   *        being passed to this class and the searcher)
+   * @param query a Lucene query
    * @param reader used to compute IDF which can be used to a) score selected
    *        fragments better b) use graded highlights eg set font color
    *        intensity
Index: lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(revision 1702789)
+++ lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(working copy)
@@ -208,22 +208,23 @@
     } else if (query instanceof CustomScoreQuery){
       extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);
     } else {
-      Query origQuery = query;
       final IndexReader reader = getLeafContext().reader();
-      Query rewritten;
       if (query instanceof MultiTermQuery) {
         if (!expandMultiTermQuery) {
           return;
         }
-        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);
-      } else {
-        rewritten = origQuery.rewrite(reader);
+        Query rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);
+        extract(rewritten, boost, terms);
       }
-      if (rewritten != origQuery) {
-        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment
-        // if this method is overwritten in a subclass or above in the next recursion
-        extract(rewritten, boost, terms);
-      } 
+      else {
+        IndexSearcher searcher = new IndexSearcher(reader);
+        Query rewritten = query.createWeight(searcher, true).getQuery();
+        if (query.equals(rewritten) == false) {
+          // only rewrite once and then flatten again - the rewritten query could have a speacial treatment
+          // if this method is overwritten in a subclass or above in the next recursion
+          extract(rewritten, boost, terms);
+        }
+      }
     }
     extractUnknownQuery(query, terms);
   }
@@ -261,45 +262,29 @@
     Map<String, SpanQuery> queries = new HashMap<>();
  
     Set<Term> nonWeightedTerms = new HashSet<>();
-    final boolean mustRewriteQuery = mustRewriteQuery(spanQuery);
     final IndexSearcher searcher = new IndexSearcher(getLeafContext());
     searcher.setQueryCache(null);
-    if (mustRewriteQuery) {
-      for (final String field : fieldNames) {
-        final SpanQuery rewrittenQuery = (SpanQuery) spanQuery.rewrite(getLeafContext().reader());
-        queries.put(field, rewrittenQuery);
-        rewrittenQuery.createWeight(searcher, false).extractTerms(nonWeightedTerms);
-      }
-    } else {
-      spanQuery.createWeight(searcher, false).extractTerms(nonWeightedTerms);
-    }
+    spanQuery.createWeight(searcher, false).extractTerms(nonWeightedTerms);
 
     List<PositionSpan> spanPositions = new ArrayList<>();
 
-    for (final String field : fieldNames) {
-      final SpanQuery q;
-      if (mustRewriteQuery) {
-        q = queries.get(field);
-      } else {
-        q = spanQuery;
+    final SpanQuery q = spanQuery;
+    LeafReaderContext context = getLeafContext();
+    SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(q, false);
+    Bits acceptDocs = context.reader().getLiveDocs();
+    final Spans spans = w.getSpans(context, SpanWeight.Postings.POSITIONS);
+    if (spans == null) {
+      return;
+    }
+
+    // collect span positions
+    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+      if (acceptDocs != null && acceptDocs.get(spans.docID()) == false) {
+        continue;
       }
-      LeafReaderContext context = getLeafContext();
-      SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(q, false);
-      Bits acceptDocs = context.reader().getLiveDocs();
-      final Spans spans = w.getSpans(context, SpanWeight.Postings.POSITIONS);
-      if (spans == null) {
-        return;
+      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+        spanPositions.add(new PositionSpan(spans.startPosition(), spans.endPosition() - 1));
       }
-
-      // collect span positions
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        if (acceptDocs != null && acceptDocs.get(spans.docID()) == false) {
-          continue;
-        }
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-          spanPositions.add(new PositionSpan(spans.startPosition(), spans.endPosition() - 1));
-        }
-      }
     }
 
     if (spanPositions.size() == 0) {
Index: lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java	(revision 1702789)
+++ lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java	(working copy)
@@ -34,6 +34,7 @@
 import org.apache.lucene.search.BoostQuery;
 import org.apache.lucene.search.ConstantScoreQuery;
 import org.apache.lucene.search.DisjunctionMaxQuery;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
@@ -138,21 +139,18 @@
       if (q != null) {
         flatten( q, reader, flatQueries, boost);
       }
-    } else if (reader != null) {
-      Query query = sourceQuery;
-      Query rewritten;
-      if (sourceQuery instanceof MultiTermQuery) {
-        rewritten = new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(MAX_MTQ_TERMS).rewrite(reader, (MultiTermQuery) query);
-      } else {
-        rewritten = query.rewrite(reader);
-      }
-      if (rewritten != query) {
+    } else if (sourceQuery instanceof MultiTermQuery && reader != null) {
+      Query rewritten = new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(MAX_MTQ_TERMS).rewrite(reader, (MultiTermQuery) sourceQuery);
+      flatten(rewritten, reader, flatQueries, boost);
+    }
+    if (reader != null) {
+      IndexSearcher searcher = new IndexSearcher(reader);
+      Query rewritten = sourceQuery.createWeight(searcher, true).getQuery();
+      if (rewritten.equals(sourceQuery) == false) {
         // only rewrite once and then flatten again - the rewritten query could have a speacial treatment
         // if this method is overwritten in a subclass.
         flatten(rewritten, reader, flatQueries, boost);
-        
-      } 
-      // if the query is already rewritten we discard it
+      }
     }
     // else discard queries
   }
@@ -322,7 +320,8 @@
           termSet.add( term.text() );
       }
       else if (query instanceof MultiTermQuery && reader != null) {
-        BooleanQuery mtqTerms = (BooleanQuery) query.rewrite(reader);
+        Query rewritten = new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(MAX_MTQ_TERMS).rewrite(reader, (MultiTermQuery) query);
+        BooleanQuery mtqTerms = (BooleanQuery) rewritten;
         for (BooleanClause clause : mtqTerms) {
           termSet.add (((TermQuery) clause.getQuery()).getTerm().text());
         }
Index: lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
===================================================================
--- lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(revision 1702789)
+++ lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(working copy)
@@ -17,6 +17,8 @@
  * limitations under the License.
  */
 
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
@@ -29,9 +31,6 @@
 import java.util.Map;
 import java.util.StringTokenizer;
 
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.BaseTokenStreamTestCase;
 import org.apache.lucene.analysis.CachingTokenFilter;
@@ -56,11 +55,9 @@
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
-import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.StoredDocument;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queries.CommonTermsQuery;
-import org.apache.lucene.queries.CustomScoreProvider;
 import org.apache.lucene.queries.CustomScoreQuery;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
@@ -79,10 +76,11 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.search.highlight.SynonymTokenizer.TestHighlightRunner;
+import org.apache.lucene.search.join.BitSetProducer;
 import org.apache.lucene.search.join.QueryBitSetProducer;
-import org.apache.lucene.search.join.BitSetProducer;
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.lucene.search.join.ToChildBlockJoinQuery;
 import org.apache.lucene.search.join.ToParentBlockJoinQuery;
@@ -228,14 +226,14 @@
   
   public void testHighlightUnknowQueryAfterRewrite() throws IOException, InvalidTokenOffsetsException {
     Query query = new Query() {
-      
+
       @Override
-      public Query rewrite(IndexReader reader) throws IOException {
+      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
         CommonTermsQuery query = new CommonTermsQuery(Occur.MUST, Occur.SHOULD, 3);
         query.add(new Term(FIELD_NAME, "this"));//stop-word
         query.add(new Term(FIELD_NAME, "long"));
         query.add(new Term(FIELD_NAME, "very"));
-        return query;
+        return query.createWeight(searcher, needsScores);
       }
 
       @Override
@@ -723,7 +721,7 @@
 
     phraseQuery = new PhraseQuery(FIELD_NAME, "been", "shot");
 
-    doSearching(query);
+    doSearching(phraseQuery);
 
     maxNumFragmentsRequired = 2;
     
@@ -2009,11 +2007,9 @@
     return "<B>" + originalText + "</B>";
   }
 
-  public void doSearching(Query unReWrittenQuery) throws Exception {
+  public void doSearching(Query query) throws Exception {
+    this.query = query;
     searcher = newSearcher(reader);
-    // for any multi-term queries to work (prefix, wildcard, range,fuzzy etc)
-    // you must use a rewritten query!
-    query = unReWrittenQuery.rewrite(reader);
     if (VERBOSE) System.out.println("Searching for: " + query.toString(FIELD_NAME));
     hits = searcher.search(query, 1000);
   }
@@ -2290,7 +2286,8 @@
         if (mode == QUERY) {
           scorer = new QueryScorer(query);
         } else if (mode == QUERY_TERM) {
-          scorer = new QueryTermScorer(query);
+          Query rewritten = query.createWeight(searcher, true).getQuery();
+          scorer = new QueryTermScorer(rewritten);
         }
         Highlighter highlighter = new Highlighter(formatter, scorer);
         highlighter.setTextFragmenter(frag);
Index: lucene/highlighter/src/test/org/apache/lucene/search/highlight/custom/HighlightCustomQueryTest.java
===================================================================
--- lucene/highlighter/src/test/org/apache/lucene/search/highlight/custom/HighlightCustomQueryTest.java	(revision 1702789)
+++ lucene/highlighter/src/test/org/apache/lucene/search/highlight/custom/HighlightCustomQueryTest.java	(working copy)
@@ -16,15 +16,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+import java.io.IOException;
+import java.util.Map;
+
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenFilter;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.highlight.Highlighter;
 import org.apache.lucene.search.highlight.InvalidTokenOffsetsException;
 import org.apache.lucene.search.highlight.QueryScorer;
@@ -34,9 +38,6 @@
 import org.apache.lucene.search.highlight.WeightedSpanTermExtractor;
 import org.apache.lucene.util.LuceneTestCase;
 
-import java.io.IOException;
-import java.util.Map;
-
 /**
  * Tests the extensibility of {@link WeightedSpanTermExtractor} and
  * {@link QueryScorer} in a user defined package
@@ -156,8 +157,8 @@
     }
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
-      return new TermQuery(term);
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      return searcher.createWeight(new TermQuery(term), needsScores);
     }
 
     @Override
Index: lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldQueryTest.java
===================================================================
--- lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldQueryTest.java	(revision 1702789)
+++ lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldQueryTest.java	(working copy)
@@ -31,11 +31,13 @@
 import org.apache.lucene.search.ConstantScoreQuery;
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.Filter;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.RegexpQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.search.vectorhighlight.FieldQuery.QueryPhraseMap;
 import org.apache.lucene.search.vectorhighlight.FieldTermStack.TermInfo;
@@ -931,7 +933,12 @@
       public String toString(String field) {
         return "DummyQuery";
       }
-      
+
+      @Override
+      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+        return new BooleanQuery.Builder().build().createWeight(searcher, needsScores);
+      }
+
     };
     make1d1fIndex( "a" );
     assertNotNull(reader);
Index: lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java	(revision 1702789)
+++ lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java	(working copy)
@@ -17,6 +17,9 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Locale;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.MultiDocValues;
@@ -25,9 +28,6 @@
 import org.apache.lucene.search.MatchNoDocsQuery;
 import org.apache.lucene.search.Query;
 
-import java.io.IOException;
-import java.util.Locale;
-
 /**
  * Utility for query time joining.
  *
@@ -179,8 +179,6 @@
       valueCount = ordinalMap.getValueCount();
     }
 
-    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);
-    final Query rewrittenToQuery = searcher.rewrite(toQuery);
     GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;
     switch (scoreMode) {
       case Total:
@@ -198,8 +196,8 @@
       case None:
         if (min <= 0 && max == Integer.MAX_VALUE) {
           GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);
-          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);
-          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, indexReader);
+          searcher.search(fromQuery, globalOrdinalsCollector);
+          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, toQuery, fromQuery, indexReader);
         } else {
           globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);
           break;
@@ -207,8 +205,8 @@
       default:
         throw new IllegalArgumentException(String.format(Locale.ROOT, "Score mode %s isn't supported.", scoreMode));
     }
-    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);
-    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, indexReader);
+    searcher.search(fromQuery, globalOrdinalsWithScoreCollector);
+    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, fromQuery, min, max, indexReader);
   }
 
 }
Index: lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.java	(revision 1702789)
+++ lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.java	(working copy)
@@ -21,7 +21,6 @@
 import java.util.Locale;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
@@ -74,17 +73,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final Query originalQueryRewrite = originalQuery.rewrite(reader);
-    if (originalQueryRewrite != originalQuery) {
-      return new TermsIncludingScoreQuery(field, multipleValuesPerDocument, terms, scores,
-          ords, originalQueryRewrite, originalQuery);
-    } else {
-      return super.rewrite(reader);
-    }
-  }
-
-  @Override
   public boolean equals(Object obj) {
     if (this == obj) {
       return true;
Index: lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java	(revision 1702789)
+++ lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java	(working copy)
@@ -23,7 +23,6 @@
 import java.util.Locale;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Explanation;
@@ -312,18 +311,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final Query parentRewrite = parentQuery.rewrite(reader);
-    if (parentRewrite != parentQuery) {
-      return new ToChildBlockJoinQuery(parentQuery,
-                                parentRewrite,
-                                parentsFilter);
-    } else {
-      return super.rewrite(reader);
-    }
-  }
-
-  @Override
   public String toString(String field) {
     return "ToChildBlockJoinQuery ("+parentQuery.toString()+")";
   }
Index: lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java	(revision 1702789)
+++ lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java	(working copy)
@@ -23,7 +23,6 @@
 import java.util.Locale;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
@@ -410,19 +409,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final Query childRewrite = childQuery.rewrite(reader);
-    if (childRewrite != childQuery) {
-      return new ToParentBlockJoinQuery(origChildQuery,
-                                childRewrite,
-                                parentsFilter,
-                                scoreMode);
-    } else {
-      return super.rewrite(reader);
-    }
-  }
-
-  @Override
   public String toString(String field) {
     return "ToParentBlockJoinQuery ("+childQuery.toString()+")";
   }
Index: lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
===================================================================
--- lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java	(revision 1702789)
+++ lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java	(working copy)
@@ -278,16 +278,6 @@
     BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("docType", "resume")));
     CheckJoinIndex.check(r, parentsFilter);
 
-    int h1 = qc.hashCode();
-    Query qw1 = qc.rewrite(r);
-    int h2 = qw1.hashCode();
-    Query qw2 = qw1.rewrite(r);
-    int h3 = qw2.hashCode();
-
-    assertTrue(h1 != h2);
-    assertTrue(h2 != h3);
-    assertTrue(h3 != h1);
-
     ToParentBlockJoinQuery qp = new ToParentBlockJoinQuery(qc, parentsFilter, ScoreMode.Max);
     ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(Sort.RELEVANCE, 10, true, true);
 
Index: lucene/queries/src/java/org/apache/lucene/queries/BoostingQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/BoostingQuery.java	(revision 1702789)
+++ lucene/queries/src/java/org/apache/lucene/queries/BoostingQuery.java	(working copy)
@@ -21,10 +21,16 @@
 import java.util.Objects;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.*;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.FilterScorer;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.Weight;
 
 /**
  * The BoostingQuery class can be used to effectively demote results that match a given query. 
@@ -54,16 +60,6 @@
     }
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
-      Query matchRewritten = match.rewrite(reader);
-      Query contextRewritten = context.rewrite(reader);
-      if (match != matchRewritten || context != contextRewritten) {
-        return new BoostingQuery(matchRewritten, contextRewritten, boost);
-      }
-      return super.rewrite(reader);
-    }
-
-    @Override
     public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
       if (needsScores == false) {
         return match.createWeight(searcher, needsScores);
Index: lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery.java	(revision 1702789)
+++ lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery.java	(working copy)
@@ -30,9 +30,11 @@
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BoostQuery;
-import org.apache.lucene.search.MatchNoDocsQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.similarities.Similarity;
 
 /**
@@ -142,20 +144,21 @@
     }
     this.terms.add(term);
   }
-  
+
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    if (this.terms.isEmpty()) {
-      return new MatchNoDocsQuery();
-    } else if (this.terms.size() == 1) {
-      return newTermQuery(this.terms.get(0), null);
-    }
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    if (this.terms.isEmpty())
+      return searcher.createWeight(new MatchAllDocsQuery(), needsScores);
+    if (this.terms.size() == 1)
+      return searcher.createWeight(new TermQuery(this.terms.get(0)), needsScores);
+
+    final IndexReader reader = searcher.getIndexReader();
     final List<LeafReaderContext> leaves = reader.leaves();
     final int maxDoc = reader.maxDoc();
     final TermContext[] contextArray = new TermContext[terms.size()];
-    final Term[] queryTerms = this.terms.toArray(new Term[0]);
+    final Term[] queryTerms = this.terms.toArray(new Term[terms.size()]);
     collectTermContext(reader, leaves, contextArray, queryTerms);
-    return buildQuery(maxDoc, contextArray, queryTerms);
+    return searcher.createWeight(buildQuery(maxDoc, contextArray, queryTerms), needsScores);
   }
   
   protected int calcLowFreqMinimumNumberShouldMatch(int numOptional) {
Index: lucene/queries/src/java/org/apache/lucene/queries/CustomScoreQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/CustomScoreQuery.java	(revision 1702789)
+++ lucene/queries/src/java/org/apache/lucene/queries/CustomScoreQuery.java	(working copy)
@@ -83,28 +83,6 @@
     if (subQuery == null) throw new IllegalArgumentException("<subquery> must not be null!");
   }
 
-  /*(non-Javadoc) @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) */
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    CustomScoreQuery clone = null;
-    
-    final Query sq = subQuery.rewrite(reader);
-    if (sq != subQuery) {
-      clone = clone();
-      clone.subQuery = sq;
-    }
-
-    for(int i = 0; i < scoringQueries.length; i++) {
-      final Query v = scoringQueries[i].rewrite(reader);
-      if (v != scoringQueries[i]) {
-        if (clone == null) clone = clone();
-        clone.scoringQueries[i] = v;
-      }
-    }
-    
-    return (clone == null) ? this : clone;
-  }
-
   /*(non-Javadoc) @see org.apache.lucene.search.Query#clone() */
   @Override
   public CustomScoreQuery clone() {
Index: lucene/queries/src/java/org/apache/lucene/queries/TermsQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/TermsQuery.java	(revision 1702789)
+++ lucene/queries/src/java/org/apache/lucene/queries/TermsQuery.java	(working copy)
@@ -27,7 +27,6 @@
 import java.util.Set;
 
 import org.apache.lucene.index.Fields;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PostingsEnum;
@@ -140,20 +139,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());
-    if (termData.size() <= threshold) {
-      BooleanQuery.Builder bq = new BooleanQuery.Builder();
-      TermIterator iterator = termData.iterator();
-      for (BytesRef term = iterator.next(); term != null; term = iterator.next()) {
-        bq.add(new TermQuery(new Term(iterator.field(), BytesRef.deepCopyOf(term))), Occur.SHOULD);
-      }
-      return new ConstantScoreQuery(bq.build());
-    }
-    return super.rewrite(reader);
-  }
-
-  @Override
   public boolean equals(Object obj) {
     if (this == obj) {
       return true;
@@ -233,6 +218,17 @@
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+
+    final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());
+    if (termData.size() <= threshold) {
+      BooleanQuery.Builder bq = new BooleanQuery.Builder();
+      TermIterator iterator = termData.iterator();
+      for (BytesRef term = iterator.next(); term != null; term = iterator.next()) {
+        bq.add(new TermQuery(new Term(iterator.field(), BytesRef.deepCopyOf(term))), Occur.SHOULD);
+      }
+      return searcher.createWeight(new ConstantScoreQuery(bq.build()), needsScores);
+    }
+
     return new ConstantScoreWeight(this) {
 
       @Override
@@ -304,7 +300,7 @@
             bq.add(new TermQuery(new Term(t.field, t.term), termContext), Occur.SHOULD);
           }
           Query q = new ConstantScoreQuery(bq.build());
-          final Weight weight = searcher.rewrite(q).createWeight(searcher, needsScores);
+          final Weight weight = searcher.createWeight(q, needsScores);
           weight.normalize(1f, score());
           return new WeightOrDocIdSet(weight);
         } else {
Index: lucene/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java	(revision 1702789)
+++ lucene/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java	(working copy)
@@ -23,7 +23,6 @@
 import java.util.Map;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Explanation;
@@ -32,7 +31,6 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Weight;
-import org.apache.lucene.util.ToStringUtils;
 
 /**
  * Query that is boosted by a ValueSource
@@ -52,15 +50,6 @@
   public ValueSource getValueSource() { return boostVal; }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    Query newQ = q.rewrite(reader);
-    if (newQ != q) {
-      return new BoostedQuery(newQ, boostVal);
-    }
-    return super.rewrite(reader);
-  }
-
-  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     return new BoostedQuery.BoostedWeight(searcher, needsScores);
   }
Index: lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThisQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThisQuery.java	(revision 1702789)
+++ lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThisQuery.java	(working copy)
@@ -20,17 +20,19 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.Arrays;
+import java.util.Set;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Weight;
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.util.Arrays;
-import java.util.Set;
-
 /**
  * A simple wrapper for MoreLikeThis for use in scenarios where a Query object is required eg
  * in custom QueryParser extensions. At query.rewrite() time the reader is used to construct the
@@ -59,7 +61,8 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    final IndexReader reader = searcher.getIndexReader();
     MoreLikeThis mlt = new MoreLikeThis(reader);
 
     mlt.setFieldNames(moreLikeFields);
@@ -78,7 +81,7 @@
     }
     //make at least half the terms match
     newBq.setMinimumNumberShouldMatch((int) (bq.clauses().size() * percentTermsToMatch));
-    return newBq.build();
+    return searcher.createWeight(newBq.build(), needsScores);
   }
 
   /* (non-Javadoc)
Index: lucene/queries/src/test/org/apache/lucene/queries/BoostingQueryTest.java
===================================================================
--- lucene/queries/src/test/org/apache/lucene/queries/BoostingQueryTest.java	(revision 1702789)
+++ lucene/queries/src/test/org/apache/lucene/queries/BoostingQueryTest.java	(working copy)
@@ -17,16 +17,7 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.MultiReader;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.MatchNoDocsQuery;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.util.LuceneTestCase;
@@ -45,13 +36,4 @@
     assertEquals("BoostingQuery with same attributes is not equal", bq1, bq2);
   }
 
-  public void testRewrite() throws IOException {
-    IndexReader reader = new MultiReader();
-    BoostingQuery q = new BoostingQuery(new MatchNoDocsQuery(), new MatchAllDocsQuery(), 3);
-    Query rewritten = new IndexSearcher(reader).rewrite(q);
-    Query expectedRewritten = new BoostingQuery(new BooleanQuery.Builder().build(), new MatchAllDocsQuery(), 3);
-    assertEquals(expectedRewritten, rewritten);
-    assertSame(rewritten, rewritten.rewrite(reader));
-  }
-
 }
Index: lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java
===================================================================
--- lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java	(revision 1702789)
+++ lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java	(working copy)
@@ -41,7 +41,6 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TopDocs;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -195,29 +194,6 @@
     r.close();
   }
   
-  @Test
-  public void testRewrite() throws Exception {
-    IndexReader r = DirectoryReader.open(dir);
-    final IndexSearcher s = newSearcher(r);
-
-    Query q = new TermQuery(new Term(TEXT_FIELD, "first"));
-    CustomScoreQuery original = new CustomScoreQuery(q);
-    CustomScoreQuery rewritten = (CustomScoreQuery) original.rewrite(s.getIndexReader());
-    assertTrue("rewritten query should be identical, as TermQuery does not rewrite", original == rewritten);
-    assertTrue("no hits for query", s.search(rewritten,1).totalHits > 0);
-    assertEquals(s.search(q,1).totalHits, s.search(rewritten,1).totalHits);
-
-    q = new TermRangeQuery(TEXT_FIELD, null, null, true, true); // everything
-    original = new CustomScoreQuery(q);
-    rewritten = (CustomScoreQuery) original.rewrite(s.getIndexReader());
-    assertTrue("rewritten query should not be identical, as TermRangeQuery rewrites", original != rewritten);
-    assertTrue("no hits for query", s.search(rewritten,1).totalHits > 0);
-    assertEquals(s.search(q,1).totalHits, s.search(original,1).totalHits);
-    assertEquals(s.search(q,1).totalHits, s.search(rewritten,1).totalHits);
-    
-    r.close();
-  }
-  
   // Test that FieldScoreQuery returns docs with expected score.
   private void doTestCustomScore(ValueSource valueSource, double dboost) throws Exception {
     float boost = (float) dboost;
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java	(revision 1702789)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java	(working copy)
@@ -35,7 +35,9 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.spans.SpanBoostQuery;
+import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
@@ -251,7 +253,11 @@
     }
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      return searcher.createWeight(rewrite(searcher.getIndexReader()), needsScores);
+    }
+
+    private Query rewrite(IndexReader reader) throws IOException {
       final Query contents = this.contents[0];
       // ArrayList spanClauses = new ArrayList();
       if (contents instanceof TermQuery) {
@@ -274,8 +280,7 @@
       for (BooleanClause clause : bq) {
         // HashSet bclauseterms=new HashSet();
         Query qc = clause.getQuery();
-        // Rewrite this clause e.g one* becomes (one OR onerous)
-        qc = new IndexSearcher(reader).rewrite(qc);
+
         if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {
           numNegatives++;
         }
@@ -300,11 +305,13 @@
           if (qc instanceof TermQuery) {
             TermQuery tq = (TermQuery) qc;
             allSpanClauses[i] = new SpanTermQuery(tq.getTerm());
+          } else if (qc instanceof MultiTermQuery) {
+            allSpanClauses[i] = new SpanMultiTermQueryWrapper<>((MultiTermQuery)qc);
           } else {
-            throw new IllegalArgumentException("Unknown query type \""
-                + qc.getClass().getName()
-                + "\" found in phrase query string \""
-                + phrasedQueryStringContents + "\"");
+              throw new IllegalArgumentException("Unknown query type \""
+                  + qc.getClass().getName()
+                  + "\" found in phrase query string \""
+                  + phrasedQueryStringContents + "\"");
           }
 
         }
@@ -376,6 +383,8 @@
         } else if (childQuery instanceof BooleanQuery) {
           BooleanQuery cbq = (BooleanQuery) childQuery;
           addComplexPhraseClause(chosenList, cbq);
+        } else if (childQuery instanceof MultiTermQuery) {
+          chosenList.add(new SpanMultiTermQueryWrapper<>((MultiTermQuery)childQuery));
         } else {
           // TODO alternatively could call extract terms here?
           throw new IllegalArgumentException("Unknown query type:"
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceRewriteQuery.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceRewriteQuery.java	(revision 1702789)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceRewriteQuery.java	(working copy)
@@ -18,8 +18,8 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.Query;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Weight;
 
 class DistanceRewriteQuery extends RewriteQuery<DistanceQuery> {
 
@@ -31,8 +31,9 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    return srndQuery.getSpanNearQuery(reader, fieldName, qf);
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return searcher.createWeight(srndQuery.getSpanNearQuery(searcher.getIndexReader(), fieldName, qf), needsScores);
   }
+
 }
 
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java	(revision 1702789)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java	(working copy)
@@ -15,9 +15,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import java.io.IOException;
-
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.Query;
 
 abstract class RewriteQuery<SQ extends SrndQuery> extends Query {
@@ -35,9 +32,6 @@
   }
 
   @Override
-  abstract public Query rewrite(IndexReader reader) throws IOException;
-
-  @Override
   public String toString(String field) {
     return getClass().getName()
     + (field.isEmpty() ? "" : "(unused: " + field + ")")
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTermRewriteQuery.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTermRewriteQuery.java	(revision 1702789)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTermRewriteQuery.java	(working copy)
@@ -16,14 +16,16 @@
  * limitations under the License.
  */
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.List;
-import java.util.ArrayList;
 
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchNoDocsQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Weight;
 
 class SimpleTermRewriteQuery extends RewriteQuery<SimpleTerm> {
 
@@ -35,8 +37,9 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     final List<Query> luceneSubQueries = new ArrayList<>();
+    final IndexReader reader = searcher.getIndexReader();
     srndQuery.visitMatchingTerms(reader, fieldName,
     new SimpleTerm.MatchingTermVisitor() {
       @Override
@@ -44,11 +47,15 @@
         luceneSubQueries.add(qf.newTermQuery(term));
       }
     });
-    return  (luceneSubQueries.size() == 0) ? new MatchNoDocsQuery()
-    : (luceneSubQueries.size() == 1) ? luceneSubQueries.get(0)
-    : SrndBooleanQuery.makeBooleanQuery(
-      /* luceneSubQueries all have default weight */
-      luceneSubQueries, BooleanClause.Occur.SHOULD); /* OR the subquery terms */
+
+    if (luceneSubQueries.size() == 0) {
+      return searcher.createWeight(new MatchNoDocsQuery(), needsScores);
+    }
+    if (luceneSubQueries.size() == 1) {
+      return searcher.createWeight(luceneSubQueries.get(0), needsScores);
+    }
+    return searcher.createWeight(SrndBooleanQuery.makeBooleanQuery(luceneSubQueries, BooleanClause.Occur.SHOULD), needsScores);
+
   }
 }
 
Index: lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiAnalyzer.java
===================================================================
--- lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiAnalyzer.java	(revision 1702789)
+++ lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiAnalyzer.java	(working copy)
@@ -18,15 +18,20 @@
  */
 
 import java.io.IOException;
-import java.io.Reader;
 
-import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.BaseTokenStreamTestCase;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.TypeAttribute;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.util.Version;
+import org.apache.lucene.search.Weight;
 
 /**
  * Test QueryParser's ability to deal with Analyzers that return more
@@ -265,6 +270,11 @@
         public String toString(String f) {
             return q.toString(f);
         }
+
+      @Override
+      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+        return q.createWeight(searcher, needsScores);
+      }
     }
     
 }
Index: lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/TestParser.java
===================================================================
--- lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/TestParser.java	(revision 1702789)
+++ lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/TestParser.java	(working copy)
@@ -17,6 +17,12 @@
  * limitations under the License.
  */
 
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenFilter;
@@ -24,7 +30,6 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.IntField;
-import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
@@ -37,17 +42,9 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.junit.AfterClass;
-import org.junit.Assume;
 import org.junit.BeforeClass;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.nio.charset.StandardCharsets;
-import java.util.List;
 
-
 public class TestParser extends LuceneTestCase {
 
   private static CoreParser builder;
@@ -149,10 +146,6 @@
 
   public void testFuzzyLikeThisQueryXML() throws Exception {
     Query q = parse("FuzzyLikeThisQuery.xml");
-    //show rewritten fuzzyLikeThisQuery - see what is being matched on
-    if (VERBOSE) {
-      System.out.println(q.rewrite(reader));
-    }
     dumpResults("FuzzyLikeThis", q, 5);
   }
 
Index: lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDPointInBBoxQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDPointInBBoxQuery.java	(revision 1702789)
+++ lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDPointInBBoxQuery.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.SortedNumericDocValues;
@@ -74,6 +73,20 @@
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
 
+    if (maxLon < minLon) {
+
+      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:
+      BooleanQuery.Builder q = new BooleanQuery.Builder();
+      q.setDisableCoord(true);
+
+      // E.g.: maxLon = -179, minLon = 179
+      BKDPointInBBoxQuery left = new BKDPointInBBoxQuery(field, minLat, maxLat, BKDTreeWriter.MIN_LON_INCL, maxLon);
+      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
+      BKDPointInBBoxQuery right = new BKDPointInBBoxQuery(field, minLat, maxLat, minLon, BKDTreeWriter.MAX_LON_INCL);
+      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
+      return searcher.createWeight(new ConstantScoreQuery(q.build()), needsScores);
+    }
+
     // I don't use RandomAccessWeight here: it's no good to approximate with "match all docs"; this is an inverted structure and should be
     // used in the first pass:
 
@@ -104,26 +117,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    // Crosses date line: we just rewrite into OR of two bboxes:
-    if (maxLon < minLon) {
-
-      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:
-      BooleanQuery.Builder q = new BooleanQuery.Builder();
-      q.setDisableCoord(true);
-
-      // E.g.: maxLon = -179, minLon = 179
-      BKDPointInBBoxQuery left = new BKDPointInBBoxQuery(field, minLat, maxLat, BKDTreeWriter.MIN_LON_INCL, maxLon);
-      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
-      BKDPointInBBoxQuery right = new BKDPointInBBoxQuery(field, minLat, maxLat, minLon, BKDTreeWriter.MAX_LON_INCL);
-      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
-      return new ConstantScoreQuery(q.build());
-    } else {
-      return super.rewrite(reader);
-    }
-  }
-
-  @Override
   public int hashCode() {
     int hash = super.hashCode();
     hash += Double.hashCode(minLat)^0x14fa55fb;
Index: lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java	(revision 1702789)
+++ lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java	(working copy)
@@ -38,9 +38,11 @@
 import org.apache.lucene.search.BoostAttribute;
 import org.apache.lucene.search.BoostQuery;
 import org.apache.lucene.search.ConstantScoreQuery;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MaxNonCompetitiveBoostAttribute;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.TFIDFSimilarity;
 import org.apache.lucene.util.AttributeSource;
@@ -285,8 +287,9 @@
   }
 
   @Override
-    public Query rewrite(IndexReader reader) throws IOException
-    {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+
+    final IndexReader reader = searcher.getIndexReader();
         ScoreTermQueue q = new ScoreTermQueue(maxNumTerms);
         //load up the list of possible terms
         for (FieldVals f : fieldVals) {
@@ -341,7 +344,7 @@
         }
         //TODO possible alternative step 3 - organize above booleans into a new layer of field-based
         // booleans with a minimum-should-match of NumFields-1?
-        return bq.build();
+        return searcher.createWeight(bq.build(), needsScores);
     }
     
     //Holds info for a fuzzy term variant - initially score is set to edit distance (for ranking best
Index: lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery.java	(revision 1702789)
+++ lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery.java	(working copy)
@@ -22,7 +22,6 @@
 
 import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.DocValuesType;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.SortedNumericDocValues;
 import org.apache.lucene.index.SortedSetDocValues;
@@ -112,17 +111,9 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    if (lowerVal == null && upperVal == null) {
-      return new FieldValueQuery(field);
-    }
-    return super.rewrite(reader);
-  }
-
-  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     if (lowerVal == null && upperVal == null) {
-      throw new IllegalStateException("Both min and max values cannot be null, call rewrite first");
+      return searcher.createWeight(new FieldValueQuery(field), needsScores);
     }
     return new RandomAccessWeight(DocValuesRangeQuery.this) {
       
Index: lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQuery.java	(revision 1702789)
+++ lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQuery.java	(working copy)
@@ -17,7 +17,8 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.index.IndexReader;
+import java.io.IOException;
+
 import org.apache.lucene.util.GeoProjectionUtils;
 import org.apache.lucene.util.GeoUtils;
 
@@ -67,7 +68,7 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     if (maxLon < minLon) {
       BooleanQuery.Builder bqb = new BooleanQuery.Builder();
 
@@ -77,9 +78,10 @@
       GeoPointDistanceQueryImpl right = new GeoPointDistanceQueryImpl(field, this, new GeoBoundingBox(minLon, 180.0D,
           minLat, maxLat));
       bqb.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
-      return bqb.build();
+      return searcher.createWeight(bqb.build(), needsScores);
     }
-    return new GeoPointDistanceQueryImpl(field, this, new GeoBoundingBox(this.minLon, this.maxLon, this.minLat, this.maxLat));
+    return searcher.createWeight(new GeoPointDistanceQueryImpl(field, this,
+        new GeoBoundingBox(this.minLon, this.maxLon, this.minLat, this.maxLat)), needsScores);
   }
 
   static GeoBoundingBox computeBBox(final double centerLon, final double centerLat, final double radius) {
Index: lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInBBoxQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInBBoxQuery.java	(revision 1702789)
+++ lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInBBoxQuery.java	(working copy)
@@ -17,7 +17,7 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.index.IndexReader;
+import java.io.IOException;
 
 /** Implements a simple bounding box query on a GeoPoint field. This is inspired by
  * {@link org.apache.lucene.search.NumericRangeQuery} and is implemented using a
@@ -54,7 +54,7 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     if (maxLon < minLon) {
       BooleanQuery.Builder bqb = new BooleanQuery.Builder();
 
@@ -62,9 +62,9 @@
       bqb.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
       GeoPointInBBoxQueryImpl right = new GeoPointInBBoxQueryImpl(field, minLon, minLat, 180.0D, maxLat);
       bqb.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
-      return bqb.build();
+      return searcher.createWeight(bqb.build(), needsScores);
     }
-    return new GeoPointInBBoxQueryImpl(field, minLon, minLat, maxLon, maxLat);
+    return searcher.createWeight(new GeoPointInBBoxQueryImpl(field, minLon, minLat, maxLon, maxLat), needsScores);
   }
 
   @Override
Index: lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/FuzzyLikeThisQueryTest.java
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/FuzzyLikeThisQueryTest.java	(revision 1702789)
+++ lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/FuzzyLikeThisQueryTest.java	(working copy)
@@ -17,6 +17,9 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.HashSet;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -26,7 +29,6 @@
 import org.apache.lucene.index.StoredDocument;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.Directory;
@@ -33,9 +35,6 @@
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
 
-import java.io.IOException;
-import java.util.HashSet;
-
 public class FuzzyLikeThisQueryTest extends LuceneTestCase {
   private Directory directory;
   private IndexSearcher searcher;
@@ -80,9 +79,8 @@
   public void testClosestEditDistanceMatchComesFirst() throws Throwable {
     FuzzyLikeThisQuery flt = new FuzzyLikeThisQuery(10, analyzer);
     flt.addTerms("smith", "name", 0.3f, 1);
-    Query q = flt.rewrite(searcher.getIndexReader());
     HashSet<Term> queryTerms = new HashSet<>();
-    searcher.createWeight(q, true).extractTerms(queryTerms);
+    searcher.createWeight(flt, true).extractTerms(queryTerms);
     assertTrue("Should have variant smythe", queryTerms.contains(new Term("name", "smythe")));
     assertTrue("Should have variant smith", queryTerms.contains(new Term("name", "smith")));
     assertTrue("Should have variant smyth", queryTerms.contains(new Term("name", "smyth")));
@@ -97,9 +95,8 @@
   public void testMultiWord() throws Throwable {
     FuzzyLikeThisQuery flt = new FuzzyLikeThisQuery(10, analyzer);
     flt.addTerms("jonathin smoth", "name", 0.3f, 1);
-    Query q = flt.rewrite(searcher.getIndexReader());
     HashSet<Term> queryTerms = new HashSet<>();
-    searcher.createWeight(q, true).extractTerms(queryTerms);
+    searcher.createWeight(flt, true).extractTerms(queryTerms);
     assertTrue("Should have variant jonathan", queryTerms.contains(new Term("name", "jonathan")));
     assertTrue("Should have variant smith", queryTerms.contains(new Term("name", "smith")));
     TopDocs topDocs = searcher.search(flt, 1);
@@ -115,9 +112,8 @@
     flt.addTerms("jonathin smoth", "name", 0.3f, 1);
     flt.addTerms("jonathin smoth", "this field does not exist", 0.3f, 1);
     // don't fail here just because the field doesn't exits
-    Query q = flt.rewrite(searcher.getIndexReader());
     HashSet<Term> queryTerms = new HashSet<>();
-    searcher.createWeight(q, true).extractTerms(queryTerms);
+    searcher.createWeight(flt, true).extractTerms(queryTerms);
     assertTrue("Should have variant jonathan", queryTerms.contains(new Term("name", "jonathan")));
     assertTrue("Should have variant smith", queryTerms.contains(new Term("name", "smith")));
     TopDocs topDocs = searcher.search(flt, 1);
@@ -132,9 +128,8 @@
   public void testNoMatchFirstWordBug() throws Throwable {
     FuzzyLikeThisQuery flt = new FuzzyLikeThisQuery(10, analyzer);
     flt.addTerms("fernando smith", "name", 0.3f, 1);
-    Query q = flt.rewrite(searcher.getIndexReader());
     HashSet<Term> queryTerms = new HashSet<>();
-    searcher.createWeight(q, true).extractTerms(queryTerms);
+    searcher.createWeight(flt, true).extractTerms(queryTerms);
     assertTrue("Should have variant smith", queryTerms.contains(new Term("name", "smith")));
     TopDocs topDocs = searcher.search(flt, 1);
     ScoreDoc[] sd = topDocs.scoreDocs;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/composite/CompositeVerifyQuery.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/composite/CompositeVerifyQuery.java	(revision 1702789)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/composite/CompositeVerifyQuery.java	(working copy)
@@ -20,7 +20,6 @@
 import java.io.IOException;
 import java.util.Map;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
@@ -31,7 +30,6 @@
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.TwoPhaseIterator;
 import org.apache.lucene.search.Weight;
-import org.apache.lucene.util.Bits;
 
 /**
  * A Query that considers an "indexQuery" to have approximate results, and a follow-on
@@ -50,15 +48,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final Query rewritten = indexQuery.rewrite(reader);
-    if (rewritten != indexQuery) {
-      return new CompositeVerifyQuery(rewritten, predicateValueSource);
-    }
-    return super.rewrite(reader);
-  }
-
-  @Override
   public boolean equals(Object o) {
     if (this == o) return true;
     if (o == null || getClass() != o.getClass()) return false;
Index: lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionQuery.java
===================================================================
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionQuery.java	(revision 1702789)
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionQuery.java	(working copy)
@@ -93,18 +93,20 @@
     return term;
   }
 
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
+  /**
+   * Rewrite this query into a {@link ContextQuery} or concrete {@link CompletionQuery}
+   * implementation, depending on the type of field to run against.
+   * @param reader an IndexReader to query over
+   * @return the rewritten query
+   * @throws IOException if a low-level IO exception occurs
+   */
+  public CompletionQuery rewrite(IndexReader reader) throws IOException {
     byte type = 0;
     boolean first = true;
     Terms terms;
     for (LeafReaderContext context : reader.leaves()) {
       LeafReader leafReader = context.reader();
-      try {
-        if ((terms = leafReader.terms(getField())) == null) {
-          continue;
-        }
-      } catch (IOException e) {
+      if ((terms = leafReader.terms(getField())) == null) {
         continue;
       }
       if (terms instanceof CompletionTerms) {
@@ -132,7 +134,7 @@
         }
       }
     }
-    return super.rewrite(reader);
+    return this;
   }
 
   @Override
Index: lucene/suggest/src/java/org/apache/lucene/search/suggest/document/SuggestIndexSearcher.java
===================================================================
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/document/SuggestIndexSearcher.java	(revision 1702789)
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/document/SuggestIndexSearcher.java	(working copy)
@@ -65,9 +65,7 @@
    * is called for every matching completion hit.
    */
   public void suggest(CompletionQuery query, TopSuggestDocsCollector collector) throws IOException {
-    // TODO use IndexSearcher.rewrite instead
-    // have to implement equals() and hashCode() in CompletionQuerys and co
-    query = (CompletionQuery) query.rewrite(getIndexReader());
+    query = query.rewrite(getIndexReader());
     Weight weight = query.createWeight(this, collector.needsScores());
     for (LeafReaderContext context : getIndexReader().leaves()) {
       BulkScorer scorer = weight.bulkScorer(context);
Index: lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java	(revision 1702789)
+++ lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java	(working copy)
@@ -74,19 +74,11 @@
   @Override
   public Weight createWeight(Query query, boolean needsScores) throws IOException {
     // this adds assertions to the inner weights/scorers too
+    QueryUtils.check(query);
     return new AssertingWeight(random, super.createWeight(query, needsScores), needsScores);
   }
 
   @Override
-  public Query rewrite(Query original) throws IOException {
-    // TODO: use the more sophisticated QueryUtils.check sometimes!
-    QueryUtils.check(original);
-    Query rewritten = super.rewrite(original);
-    QueryUtils.check(rewritten);
-    return rewritten;
-  }
-
-  @Override
   protected void search(List<LeafReaderContext> leaves, Weight weight, Collector collector) throws IOException {
     assert weight instanceof AssertingWeight;
     super.search(leaves, weight, AssertingCollector.wrap(random, collector));
Index: lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java	(revision 1702789)
+++ lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java	(working copy)
@@ -20,8 +20,6 @@
 import java.io.IOException;
 import java.util.Random;
 
-import org.apache.lucene.index.IndexReader;
-
 /** Assertion-enabled query. */
 public final class AssertingQuery extends Query {
 
@@ -63,14 +61,4 @@
     return -in.hashCode();
   }
 
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final Query rewritten = in.rewrite(reader);
-    if (rewritten == in) {
-      return super.rewrite(reader);
-    } else {
-      return wrap(new Random(random.nextLong()), rewritten);
-    }
-  }
-
 }
Index: lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(revision 1702789)
+++ lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(working copy)
@@ -67,6 +67,11 @@
       public String toString(String field) {
         return "My Whacky Query";
       }
+
+      @Override
+      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+        return null;
+      }
     };
     checkUnequal(q, whacky);
     
Index: lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java	(revision 1702789)
+++ lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java	(working copy)
@@ -5,11 +5,8 @@
 import java.util.Set;
 
 import com.carrotsearch.randomizedtesting.generators.RandomInts;
-
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.util.Bits;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -42,15 +39,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final Query rewritten = query.rewrite(reader);
-    if (rewritten != query) {
-      return new RandomApproximationQuery(rewritten, random);
-    }
-    return super.rewrite(reader);
-  }
-
-  @Override
   public boolean equals(Object obj) {
     if (super.equals(obj) == false) {
       return false;
Index: lucene/test-framework/src/java/org/apache/lucene/search/ShardSearchingTestBase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/ShardSearchingTestBase.java	(revision 1702789)
+++ lucene/test-framework/src/java/org/apache/lucene/search/ShardSearchingTestBase.java	(working copy)
@@ -227,9 +227,10 @@
       }
 
       @Override
-      public Query rewrite(Query original) throws IOException {
-        final IndexSearcher localSearcher = new IndexSearcher(getIndexReader());
-        final Weight weight = localSearcher.createNormalizedWeight(original, true);
+      public Weight createNormalizedWeight(Query query, boolean needsScores) throws IOException {
+
+        IndexSearcher localSearcher = new IndexSearcher(getIndexReader());
+        final Weight weight = query.createWeight(localSearcher, true);
         final Set<Term> terms = new HashSet<>();
         weight.extractTerms(terms);
 
@@ -255,7 +256,14 @@
           }
         }
 
-        return weight.getQuery();
+        Weight dweight = createWeight(query, needsScores);
+        float v = dweight.getValueForNormalization();
+        float norm = getSimilarity(needsScores).queryNorm(v);
+        if (Float.isInfinite(norm) || Float.isNaN(norm)) {
+          norm = 1.0f;
+        }
+        dweight.normalize(norm, 1.0f);
+        return dweight;
       }
 
       @Override
Index: lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java	(revision 1702789)
+++ lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java	(working copy)
@@ -17,12 +17,11 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.index.IndexReader;
+import java.io.IOException;
+
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 
-import java.io.IOException;
-
 /** Wraps a span query with asserts */
 public class AssertingSpanQuery extends SpanQuery {
   private final SpanQuery in;
@@ -48,18 +47,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    Query q = in.rewrite(reader);
-    if (q == in) {
-      return super.rewrite(reader);
-    } else if (q instanceof SpanQuery) {
-      return new AssertingSpanQuery((SpanQuery) q);
-    } else {
-      return q;
-    }
-  }
-
-  @Override
   public Query clone() {
     return new AssertingSpanQuery((SpanQuery) in);
   }
Index: solr/core/src/java/org/apache/solr/handler/component/HighlightComponent.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/component/HighlightComponent.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/handler/component/HighlightComponent.java	(working copy)
@@ -17,6 +17,11 @@
 
 package org.apache.solr.handler.component;
 
+import java.io.IOException;
+import java.net.URL;
+import java.util.List;
+import java.util.Map;
+
 import com.google.common.base.Objects;
 import org.apache.lucene.search.Query;
 import org.apache.solr.common.SolrException;
@@ -28,7 +33,6 @@
 import org.apache.solr.core.PluginInfo;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.highlight.DefaultSolrHighlighter;
-import org.apache.solr.highlight.PostingsSolrHighlighter;
 import org.apache.solr.highlight.SolrHighlighter;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.search.QParser;
@@ -39,11 +43,6 @@
 import org.apache.solr.util.plugin.PluginInfoInitialized;
 import org.apache.solr.util.plugin.SolrCoreAware;
 
-import java.io.IOException;
-import java.net.URL;
-import java.util.List;
-import java.util.Map;
-
 /**
  * TODO!
  *
@@ -131,12 +130,14 @@
           rb.setHighlightQuery( highlightQuery );
         }
       }
-      
+
+      /*
       if(highlightQuery != null) {
         boolean rewrite = (highlighter instanceof PostingsSolrHighlighter == false) && !(Boolean.valueOf(params.get(HighlightParams.USE_PHRASE_HIGHLIGHTER, "true")) &&
             Boolean.valueOf(params.get(HighlightParams.HIGHLIGHT_MULTI_TERM, "true")));
         highlightQuery = rewrite ?  highlightQuery.rewrite(req.getSearcher().getIndexReader()) : highlightQuery;
       }
+      */
 
       // No highlighting if there is no query -- consider q.alt="*:*
       if( highlightQuery != null ) {
Index: solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter.java
===================================================================
--- solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter.java	(working copy)
@@ -192,7 +192,7 @@
    * @param fieldName The name of the field
    * @param request The current SolrQueryRequest
    */
-  protected Highlighter getHighlighter(Query query, String fieldName, SolrQueryRequest request) {
+  protected Highlighter getHighlighter(Query query, String fieldName, SolrQueryRequest request) throws IOException {
     SolrParams params = request.getParams();
     Highlighter highlighter = new Highlighter(
         getFormatter(fieldName, params),
@@ -236,11 +236,12 @@
    * @param fieldName The name of the field
    * @param request The SolrQueryRequest
    */
-  protected Scorer getQueryScorer(Query query, String fieldName, SolrQueryRequest request) {
+  protected Scorer getQueryScorer(Query query, String fieldName, SolrQueryRequest request) throws IOException {
     boolean reqFieldMatch = request.getParams().getFieldBool(fieldName, HighlightParams.FIELD_MATCH, false);
     if (reqFieldMatch) {
       return new QueryTermScorer(query, request.getSearcher().getIndexReader(), fieldName);
     } else {
+      query = request.getSearcher().createWeight(query, true).getQuery();
       return new QueryTermScorer(query);
     }
   }
Index: solr/core/src/java/org/apache/solr/query/FilterQuery.java
===================================================================
--- solr/core/src/java/org/apache/solr/query/FilterQuery.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/query/FilterQuery.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.BoostQuery;
 import org.apache.lucene.search.ConstantScoreQuery;
 import org.apache.lucene.search.IndexSearcher;
@@ -62,18 +61,7 @@
     return sb.toString();
   }
 
-
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    Query newQ = q.rewrite(reader);
-    if (newQ != q) {
-      return new FilterQuery(newQ);
-    } else {
-      return this;
-    }
-  }
-
-  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needScores) throws IOException {
     // SolrRequestInfo reqInfo = SolrRequestInfo.getRequestInfo();
 
Index: solr/core/src/java/org/apache/solr/query/SolrRangeQuery.java
===================================================================
--- solr/core/src/java/org/apache/solr/query/SolrRangeQuery.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/query/SolrRangeQuery.java	(working copy)
@@ -21,7 +21,6 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
@@ -44,7 +43,6 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.util.AttributeSource;
-import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.DocIdSetBuilder;
 import org.apache.lucene.util.FixedBitSet;
@@ -53,7 +51,6 @@
 import org.apache.solr.search.DocSetBuilder;
 import org.apache.solr.search.DocSetProducer;
 import org.apache.solr.search.ExtendedQueryBase;
-import org.apache.solr.search.SolrConstantScoreQuery;
 import org.apache.solr.search.SolrIndexSearcher;
 
 /** @lucene.experimental */
@@ -136,11 +133,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    return this;
-  }
-
-  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needScores) throws IOException {
     return new ConstWeight(searcher, needScores);
     /*
@@ -404,7 +396,7 @@
           bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);
         }
         Query q = new ConstantScoreQuery(bq.build());
-        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);
+        final Weight weight = searcher.createWeight(q, needScores);
         weight.normalize(1f, score());
         return segStates[context.ord] = new SegState(weight);
       }
Index: solr/core/src/java/org/apache/solr/schema/LatLonType.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/LatLonType.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/schema/LatLonType.java	(working copy)
@@ -301,12 +301,6 @@
   double dist;
   double planetRadius;
 
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    return bboxQuery != null ? bboxQuery.rewrite(reader) : this;
-  }
-
   protected class SpatialWeight extends ConstantScoreWeight {
     protected IndexSearcher searcher;
     protected Map latContext;
@@ -515,8 +509,8 @@
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    // if we were supposed to use bboxQuery, then we should have been rewritten using that query
-    assert bboxQuery == null;
+    if (bboxQuery != null)
+      return searcher.createWeight(bboxQuery, needsScores);
     return new SpatialWeight(searcher);
   }
 
Index: solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java	(working copy)
@@ -48,6 +48,7 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.uninverting.UninvertingReader;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BitSetIterator;
@@ -201,6 +202,11 @@
       return s;
     }
 
+    @Override
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
     public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {
       this.collapseField = localParams.get("field");
       if (this.collapseField == null) {
Index: solr/core/src/java/org/apache/solr/search/ExportQParserPlugin.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/ExportQParserPlugin.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/search/ExportQParserPlugin.java	(working copy)
@@ -17,21 +17,27 @@
 
 package org.apache.solr.search;
 
+import java.io.IOException;
+import java.util.Map;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.LeafCollector;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.search.TopDocsCollector;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.util.FixedBitSet;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.handler.component.MergeStrategy;
+import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestInfo;
-import org.apache.lucene.search.*;
-import org.apache.lucene.index.*;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.common.params.SolrParams;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.Set;
-
 public class ExportQParserPlugin extends QParserPlugin {
 
   public static final String NAME = "xport";
@@ -84,15 +90,6 @@
       return mainQuery.createWeight(searcher, true);
     }
 
-    public Query rewrite(IndexReader reader) throws IOException {
-      Query q = mainQuery.rewrite(reader);
-      if(q == mainQuery) {
-        return super.rewrite(reader);
-      } else {
-        return clone().wrap(q);
-      }
-    }
-
     public TopDocsCollector getTopDocsCollector(int len,
                                                 SolrIndexSearcher.QueryCommand cmd,
                                                 IndexSearcher searcher) throws IOException {
Index: solr/core/src/java/org/apache/solr/search/ExtendedQueryBase.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/ExtendedQueryBase.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/search/ExtendedQueryBase.java	(working copy)
@@ -19,7 +19,8 @@
 
 import org.apache.lucene.search.Query;
 
-public class ExtendedQueryBase extends Query implements ExtendedQuery {
+public abstract class ExtendedQueryBase extends Query implements ExtendedQuery {
+
   private int cost;
   private boolean cache = true;
   private boolean cacheSep;
Index: solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java	(working copy)
@@ -18,50 +18,36 @@
 package org.apache.solr.search;
 
 import java.io.IOException;
-import java.io.Serializable;
 import java.util.List;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.Future;
+
 import com.google.common.primitives.Longs;
-
+import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.NumericDocValues;
+import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.search.BitsFilteredDocIdSet;
+import org.apache.lucene.search.ConstantScoreQuery;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.LeafCollector;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.util.BitDocIdSet;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.CharsRefBuilder;
 import org.apache.lucene.util.FixedBitSet;
-
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.search.BitsFilteredDocIdSet;
 import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.SolrjNamedThreadFactory;
-import org.apache.solr.core.CloseHook;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.StrField;
-import org.apache.solr.schema.TrieField;
-import org.apache.solr.core.SolrCore;
 
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.ConstantScoreQuery;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.Weight;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.index.SortedDocValues;
-import org.apache.lucene.index.NumericDocValues;
-import org.apache.lucene.util.BytesRef;
-
-import org.apache.solr.common.util.NamedList;
-
 /**
 * syntax fq={!hash workers=11 worker=4 keys=field1,field2}
 * */
@@ -145,7 +131,7 @@
       }
 
       ConstantScoreQuery constantScoreQuery = new ConstantScoreQuery(new BitsFilter(fixedBitSets));
-      return searcher.rewrite(constantScoreQuery).createWeight(searcher, false);
+      return searcher.createWeight(constantScoreQuery, false);
     }
 
     public class BitsFilter extends Filter {
Index: solr/core/src/java/org/apache/solr/search/JoinQParserPlugin.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/JoinQParserPlugin.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/search/JoinQParserPlugin.java	(working copy)
@@ -23,7 +23,6 @@
 import java.util.List;
 
 import org.apache.lucene.index.Fields;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.MultiPostingsEnum;
 import org.apache.lucene.index.PostingsEnum;
@@ -145,12 +144,6 @@
   public Query getQuery() { return q; }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    // don't rewrite the subQuery
-    return super.rewrite(reader);
-  }
-
-  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     return new JoinQueryWeight((SolrIndexSearcher)searcher);
   }
Index: solr/core/src/java/org/apache/solr/search/ReRankQParserPlugin.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/ReRankQParserPlugin.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/search/ReRankQParserPlugin.java	(working copy)
@@ -25,8 +25,6 @@
 
 import com.carrotsearch.hppc.IntFloatHashMap;
 import com.carrotsearch.hppc.IntIntHashMap;
-
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Explanation;
@@ -159,14 +157,6 @@
              " reRankWeight="+reRankWeight+"}";
     }
 
-    public Query rewrite(IndexReader reader) throws IOException {
-      Query q = mainQuery.rewrite(reader);
-      if (q != mainQuery) {
-        return new ReRankQuery(reRankQuery, reRankDocs, reRankWeight, length).wrap(q);
-      }
-      return super.rewrite(reader);
-    }
-
     public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException{
       return new ReRankWeight(mainQuery, reRankQuery, reRankWeight, searcher, needsScores);
     }
Index: solr/core/src/java/org/apache/solr/search/WrappedQuery.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/WrappedQuery.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/search/WrappedQuery.java	(working copy)
@@ -17,13 +17,12 @@
 
 package org.apache.solr.search;
 
-import org.apache.lucene.index.IndexReader;
+import java.io.IOException;
+
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Weight;
 
-import java.io.IOException;
-
 /** A simple query that wraps another query and implements ExtendedQuery. */
 public final class WrappedQuery extends ExtendedQueryBase {
   private Query q;
@@ -46,12 +45,6 @@
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    // currently no need to continue wrapping at this point.
-    return q.rewrite(reader);
-  }
-
-  @Override
   public int hashCode() {
     return q.hashCode();
   }
Index: solr/core/src/java/org/apache/solr/search/join/ScoreJoinQParserPlugin.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/join/ScoreJoinQParserPlugin.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/search/join/ScoreJoinQParserPlugin.java	(working copy)
@@ -21,8 +21,9 @@
 import java.util.Map;
 
 import org.apache.lucene.index.DocValuesType;
-import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.join.JoinUtil;
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.lucene.uninverting.UninvertingReader;
@@ -87,27 +88,27 @@
     }
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+
       SolrRequestInfo info = SolrRequestInfo.getRequestInfo();
 
       CoreContainer container = info.getReq().getCore().getCoreDescriptor().getCoreContainer();
 
-      final SolrCore fromCore = container.getCore(fromIndex);
-
-      if (fromCore == null) {
-        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Cross-core join: no such core " + fromIndex);
-      }
       RefCounted<SolrIndexSearcher> fromHolder = null;
-      fromHolder = fromCore.getRegisteredSearcher();
       final Query joinQuery;
-      try {
-        joinQuery = JoinUtil.createJoinQuery(fromField, true,
-            toField, fromQuery, fromHolder.get(), scoreMode);
-      } finally {
-        fromCore.close();
-        fromHolder.decref();
+      try (SolrCore fromCore = container.getCore(fromIndex)) {
+        if (fromCore == null) {
+          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Cross-core join: no such core " + fromIndex);
+        }
+        fromHolder = fromCore.getRegisteredSearcher();
+        joinQuery = JoinUtil.createJoinQuery(fromField, true, toField, fromQuery, fromHolder.get(), scoreMode);
+        return searcher.createWeight(joinQuery, needsScores);
       }
-      return joinQuery.rewrite(reader);
+      finally {
+        if (fromHolder != null)
+          fromHolder.decref();
+      }
+
     }
 
     @Override
@@ -157,15 +158,6 @@
     }
 
     @Override
-    public Query rewrite(IndexReader reader) throws IOException {
-      SolrRequestInfo info = SolrRequestInfo.getRequestInfo();
-      final Query jq = JoinUtil.createJoinQuery(fromField, true,
-          toField, fromQuery, info.getReq().getSearcher(), scoreMode);
-      return jq.rewrite(reader);
-    }
-
-
-    @Override
     public String toString(String field) {
       return "SameCoreJoinQuery [fromQuery=" + fromQuery + ", fromField="
           + fromField + ", toField=" + toField + ", scoreMode=" + scoreMode
@@ -173,6 +165,14 @@
     }
 
     @Override
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      SolrRequestInfo info = SolrRequestInfo.getRequestInfo();
+      final Query jq = JoinUtil.createJoinQuery(fromField, true,
+          toField, fromQuery, info.getReq().getSearcher(), scoreMode);
+      return searcher.createWeight(jq, needsScores);
+    }
+
+    @Override
     public int hashCode() {
       final int prime = 31;
       int result = super.hashCode();
Index: solr/core/src/java/org/apache/solr/update/DeleteByQueryWrapper.java
===================================================================
--- solr/core/src/java/org/apache/solr/update/DeleteByQueryWrapper.java	(revision 1702789)
+++ solr/core/src/java/org/apache/solr/update/DeleteByQueryWrapper.java	(working copy)
@@ -20,7 +20,6 @@
 import java.io.IOException;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
@@ -30,7 +29,6 @@
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.uninverting.UninvertingReader;
-import org.apache.lucene.util.Bits;
 import org.apache.solr.schema.IndexSchema;
 
 /** 
@@ -56,16 +54,6 @@
   // we try to be well-behaved, but we are not (and IW's applyQueryDeletes isn't much better...)
   
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    Query rewritten = in.rewrite(reader);
-    if (rewritten != in) {
-      return new DeleteByQueryWrapper(rewritten, schema);
-    } else {
-      return super.rewrite(reader);
-    }
-  }
-  
-  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     final LeafReader wrapped = wrap((LeafReader) searcher.getIndexReader());
     final IndexSearcher privateContext = new IndexSearcher(wrapped);
Index: solr/core/src/test/org/apache/solr/search/TestAnalyticsQParserPlugin.java
===================================================================
--- solr/core/src/test/org/apache/solr/search/TestAnalyticsQParserPlugin.java	(revision 1702789)
+++ solr/core/src/test/org/apache/solr/search/TestAnalyticsQParserPlugin.java	(working copy)
@@ -17,19 +17,19 @@
 
 package org.apache.solr.search;
 
-import org.apache.lucene.search.LeafCollector;
+import java.io.IOException;
+
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Weight;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.handler.component.MergeStrategy;
 import org.apache.solr.handler.component.ResponseBuilder;
 import org.apache.solr.handler.component.ShardRequest;
+import org.apache.solr.handler.component.ShardResponse;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.handler.component.MergeStrategy;
-import org.apache.solr.handler.component.ShardResponse;
-
 import org.junit.Ignore;
-import java.io.IOException;
 
 @Ignore
 public class TestAnalyticsQParserPlugin extends QParserPlugin {
@@ -63,6 +63,11 @@
     public DelegatingCollector getAnalyticsCollector(ResponseBuilder rb, IndexSearcher searcher) {
       return new TestAnalyticsCollector(rb);
     }
+
+    @Override
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      throw new UnsupportedOperationException();
+    }
   }
 
   class TestAnalyticsCollector extends DelegatingCollector {
Index: solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPNoScore.java
===================================================================
--- solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPNoScore.java	(revision 1702789)
+++ solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPNoScore.java	(working copy)
@@ -17,7 +17,6 @@
 
 package org.apache.solr.search.join;
 
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -28,17 +27,11 @@
 import java.util.Map;
 import java.util.Set;
 
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.solr.JSONTestUtil;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrRequestInfo;
-import org.apache.solr.response.SolrQueryResponse;
-import org.apache.solr.search.JoinQParserPlugin;
-import org.apache.solr.search.QParser;
-import org.apache.solr.search.SyntaxError;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.noggit.JSONUtil;
@@ -154,40 +147,6 @@
 
   }
 
-  public void testJoinQueryType() throws SyntaxError, IOException{
-    SolrQueryRequest req = null;
-    try{
-      final String score = whateverScore();
-      
-      req = req("{!join from=dept_id_s to=dept_ss"+score+"}text_t:develop");
-      SolrQueryResponse rsp = new SolrQueryResponse();
-      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));
-      
-      {
-        final Query query = QParser.getParser(req.getParams().get("q"), null, req).getQuery();
-        final Query rewrittenQuery = query.rewrite(req.getSearcher().getIndexReader());
-        assertTrue(
-            rewrittenQuery+" should be Lucene's",
-            rewrittenQuery.getClass().getPackage().getName()
-            .startsWith("org.apache.lucene"));
-      }
-      {
-        final Query query = QParser.getParser(
-            "{!join from=dept_id_s to=dept_ss}text_t:develop"
-            , null, req).getQuery();
-        final Query rewrittenQuery = query.rewrite(req.getSearcher().getIndexReader());
-        assertEquals(rewrittenQuery+" is expected to be from Solr",
-              JoinQParserPlugin.class.getPackage().getName(), 
-              rewrittenQuery.getClass().getPackage().getName());
-      }
-    }finally{
-      if(req!=null){
-        req.close();
-      }
-      SolrRequestInfo.clearRequestInfo();
-    }
-  }
-
   public static String whateverScore() {
       final ScoreMode[] vals = ScoreMode.values();
       return " score="+vals[random().nextInt(vals.length)]+" ";
Index: solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore.java
===================================================================
--- solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore.java	(revision 1702789)
+++ solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore.java	(working copy)
@@ -191,7 +191,7 @@
 
     final SolrQueryRequest req = req("q", "{!join from=movieId_s to=id score=" + score + " b=200}title:movie", "fl", "id,score", "omitHeader", "true");
     SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse()));
-    final Query luceneQ = QParser.getParser(req.getParams().get("q"), null, req).getQuery().rewrite(req.getSearcher().getLeafReader());
+    final Query luceneQ = QParser.getParser(req.getParams().get("q"), null, req).getQuery();
     assertTrue(luceneQ instanceof BoostQuery);
     float boost = ((BoostQuery) luceneQ).getBoost();
     assertEquals("" + luceneQ, Float.floatToIntBits(200), Float.floatToIntBits(boost));
