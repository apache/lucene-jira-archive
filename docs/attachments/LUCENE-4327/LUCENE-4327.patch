Index: lucene/core/src/java/org/apache/lucene/search/ConjunctionTermScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ConjunctionTermScorer.java	(revision 1376891)
+++ lucene/core/src/java/org/apache/lucene/search/ConjunctionTermScorer.java	(working copy)
@@ -90,6 +90,7 @@
 
   @Override
   public float score() throws IOException {
+    // TODO: sum into a double and cast to float if we ever send required clauses to BS1
     float sum = 0.0f;
     for (DocsAndFreqs docs : docsAndFreqs) {
       sum += docs.scorer.score();
Index: lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java	(revision 1376891)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java	(working copy)
@@ -23,7 +23,6 @@
 import java.util.List;
 
 import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery.BooleanWeight;
 
 /* Description from Doug Cutting (excerpted from
@@ -115,7 +114,7 @@
   // Therefore the only methods that are implemented are score() and doc().
   private static final class BucketScorer extends Scorer {
 
-    float score;
+    double score;
     int doc = NO_MORE_DOCS;
     int freq;
     
@@ -134,13 +133,13 @@
     public int nextDoc() { return NO_MORE_DOCS; }
     
     @Override
-    public float score() { return score; }
+    public float score() { return (float)score; }
     
   }
 
   static final class Bucket {
     int doc = -1;            // tells if bucket is valid
-    float score;             // incremental score
+    double score;             // incremental score
     // TODO: break out bool anyProhibited, int
     // numRequiredMatched; then we can remove 32 limit on
     // required clauses
Index: lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java	(revision 1376891)
+++ lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java	(working copy)
@@ -69,6 +69,7 @@
    */
   @Override
   public float score() throws IOException {
+    // TODO: sum into a double and cast to float if we ever send required clauses to BS1
     int curDoc = reqScorer.docID();
     float reqScore = reqScorer.score();
     if (optScorer == null) {
Index: lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java	(revision 1376891)
+++ lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java	(working copy)
@@ -129,6 +129,7 @@
   
   @Override
   public float score() throws IOException {
+    // TODO: sum into a double and cast to float if we ever send required clauses to BS1
     float sum = 0.0f;
     for (int i = 0; i < scorers.length; i++) {
       sum += scorers[i].score();
Index: lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(revision 1376891)
+++ lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(working copy)
@@ -83,9 +83,7 @@
       
       @Override
       public boolean scoresDocsOutOfOrder() {
-        // TODO: Support out-of-order scoring!
-        // For now we return false here, as we always get the scorer in order
-        return false;
+        return true;
       }
 
       @Override
@@ -148,9 +146,7 @@
 
         if (useRandomAccess) {
           // if we are using random access, we return the inner scorer, just with other acceptDocs
-          // TODO, replace this by when BooleanWeight is fixed to be consistent with its scorer implementations:
-          // return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);
-          return weight.scorer(context, true, topScorer, filterAcceptDocs);
+          return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);
         } else {
           assert firstFilterDoc > -1;
           // we are gonna advance() this scorer, so we set inorder=true/toplevel=false
