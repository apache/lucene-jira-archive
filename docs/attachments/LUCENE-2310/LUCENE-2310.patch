Index: lucene/src/java/org/apache/lucene/document/NumericField.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/NumericField.java	(revision 1069343)
+++ lucene/src/java/org/apache/lucene/document/NumericField.java	Wed Mar 23 14:41:53 NZDT 2011
@@ -136,10 +136,8 @@
  *
  * @since 2.9
  */
-public final class NumericField extends AbstractField {
+public final class NumericField extends Field {
 
-  private final NumericTokenStream numericTS;
-
   /**
    * Creates a field for numeric values using the default <code>precisionStep</code>
    * {@link NumericUtils#PRECISION_STEP_DEFAULT} (4). The instance is not yet initialized with
@@ -191,16 +189,11 @@
    * @param index if the field should be indexed using {@link NumericTokenStream}
    */
   public NumericField(String name, int precisionStep, Field.Store store, boolean index) {
-    super(name, store, index ? Field.Index.ANALYZED_NO_NORMS : Field.Index.NO, Field.TermVector.NO);
+    super(name, null, store, index ? Field.Index.ANALYZED_NO_NORMS : Field.Index.NO, Field.TermVector.NO);
     setOmitTermFreqAndPositions(true);
-    numericTS = new NumericTokenStream(precisionStep);
+    tokenStream = new NumericTokenStream(precisionStep);
   }
-
+  
-  /** Returns a {@link NumericTokenStream} for indexing the numeric value. */
-  public TokenStream tokenStreamValue()   {
-    return isIndexed() ? numericTS : null;
-  }
-  
   /** Returns always <code>null</code> for numeric fields */
   @Override
   public byte[] getBinaryValue(byte[] result){
@@ -224,7 +217,7 @@
   
   /** Returns the precision step. */
   public int getPrecisionStep() {
-    return numericTS.getPrecisionStep();
+    return ((NumericTokenStream)tokenStream).getPrecisionStep();
   }
   
   /**
@@ -234,7 +227,7 @@
    * <code>document.add(new NumericField(name, precisionStep).setLongValue(value))</code>
    */
   public NumericField setLongValue(final long value) {
-    numericTS.setLongValue(value);
+    ((NumericTokenStream)tokenStream).setLongValue(value);
     fieldsData = Long.valueOf(value);
     return this;
   }
@@ -246,7 +239,7 @@
    * <code>document.add(new NumericField(name, precisionStep).setIntValue(value))</code>
    */
   public NumericField setIntValue(final int value) {
-    numericTS.setIntValue(value);
+    ((NumericTokenStream)tokenStream).setIntValue(value);
     fieldsData = Integer.valueOf(value);
     return this;
   }
@@ -258,7 +251,7 @@
    * <code>document.add(new NumericField(name, precisionStep).setDoubleValue(value))</code>
    */
   public NumericField setDoubleValue(final double value) {
-    numericTS.setDoubleValue(value);
+    ((NumericTokenStream)tokenStream).setDoubleValue(value);
     fieldsData = Double.valueOf(value);
     return this;
   }
@@ -270,9 +263,33 @@
    * <code>document.add(new NumericField(name, precisionStep).setFloatValue(value))</code>
    */
   public NumericField setFloatValue(final float value) {
-    numericTS.setFloatValue(value);
+    ((NumericTokenStream)tokenStream).setFloatValue(value);
     fieldsData = Float.valueOf(value);
     return this;
   }
 
+  @Override
+  public void setValue(String value) {
+    throw new UnsupportedOperationException("Cannot set String values in NumericFields");
-}
+  }
+
+  @Override
+  public void setValue(Reader value) {
+    throw new UnsupportedOperationException("Cannot set value through Readers in NumericFields");
+  }
+
+  @Override
+  public void setValue(byte[] value) {
+    throw new UnsupportedOperationException("Cannot set byte[] values in NumericFields");
+  }
+
+  @Override
+  public void setValue(byte[] value, int offset, int length) {
+    throw new UnsupportedOperationException("Cannot set byte[] values in NumericFields");
+  }
+
+  @Override
+  public void setTokenStream(TokenStream tokenStream) {
+    throw new UnsupportedOperationException("Cannot set new TokenStreams in NumericFields");
+  }
+}
Index: lucene/src/java/org/apache/lucene/document/Fieldable.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/Fieldable.java	(revision 883852)
+++ lucene/src/java/org/apache/lucene/document/Fieldable.java	Wed Mar 23 14:38:27 NZDT 2011
@@ -33,7 +33,10 @@
  * read and write indices created within the same major version.
  * </p>
  *
+ * @deprecated Use or extend {@link org.apache.lucene.document.Field}
+ *
  **/
+@Deprecated
 public interface Fieldable extends Serializable {
   /** Sets the boost factor hits on this field.  This value will be
    * multiplied into the score of all hits on this this field of this
Index: lucene/src/test/org/apache/lucene/document/TestDocument.java
===================================================================
--- lucene/src/test/org/apache/lucene/document/TestDocument.java	(revision 1066722)
+++ lucene/src/test/org/apache/lucene/document/TestDocument.java	Wed Mar 23 16:41:07 NZDT 2011
@@ -279,4 +279,14 @@
       // expected
     }
   }
+
+  /**
+   * Tests that the cast done inside getAllFields does not result in a ClassCastException
+   */
+  public void testGetAllFieldsCast() {
+    Document document = new Document();
+    Field field = new Field("field1", new byte[0]);
+    document.add(field);
+    assertEquals(1, document.getAllFields().size());
-}
+  }
+}
Index: lucene/src/java/org/apache/lucene/document/Field.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/Field.java	(revision 893177)
+++ lucene/src/java/org/apache/lucene/document/Field.java	Wed Mar 23 14:49:04 NZDT 2011
@@ -32,7 +32,7 @@
   index, so that they may be returned with hits on the document.
   */
 
-public final class Field extends AbstractField implements Fieldable, Serializable {
+public class Field extends AbstractField implements Fieldable, Serializable {
   
   /** Specifies whether and how a field should be stored. */
   public static enum Store {
@@ -44,13 +44,17 @@
      */
     YES {
       @Override
-      public boolean isStored() { return true; }
+      public boolean isStored() {
+        return true;
+      }
     },
 
     /** Do not store the field value in the index. */
     NO {
       @Override
-      public boolean isStored() { return false; }
+      public boolean isStored() {
+        return false;
+      }
     };
 
     public abstract boolean isStored();
@@ -64,11 +68,19 @@
      * {@link Field.Store stored}. */
     NO {
       @Override
-      public boolean isIndexed()  { return false; }
+      public boolean isIndexed() {
+        return false;
+      }
+
       @Override
-      public boolean isAnalyzed() { return false; }
+      public boolean isAnalyzed() {
+        return false;
+      }
+
       @Override
-      public boolean omitNorms()  { return true;  }   
+      public boolean omitNorms() {
+        return true;
+      }   
     },
 
     /** Index the tokens produced by running the field's
@@ -76,11 +88,18 @@
      * common text. */
     ANALYZED {
       @Override
-      public boolean isIndexed()  { return true;  }
+      public boolean isIndexed() {
+        return true;
+      }
+
       @Override
-      public boolean isAnalyzed() { return true;  }
+      public boolean isAnalyzed() {
+        return true; }
+
       @Override
-      public boolean omitNorms()  { return false; }   	
+      public boolean omitNorms() {
+        return false;
+      }   	
     },
 
     /** Index the field's value without using an Analyzer, so it can be searched.
@@ -89,11 +108,19 @@
      */
     NOT_ANALYZED {
       @Override
-      public boolean isIndexed()  { return true;  }
+      public boolean isIndexed() {
+        return true;
+      }
+
       @Override
-      public boolean isAnalyzed() { return false; }
+      public boolean isAnalyzed() {
+        return false;
+      }
+
       @Override
-      public boolean omitNorms()  { return false; }   	
+      public boolean omitNorms() {
+        return false;
+      }   	
     },
 
     /** Expert: Index the field's value without an Analyzer,
@@ -112,11 +139,19 @@
      * from the beginning. */
     NOT_ANALYZED_NO_NORMS {
       @Override
-      public boolean isIndexed()  { return true;  }
+      public boolean isIndexed() {
+        return true;
+      }
+
       @Override
-      public boolean isAnalyzed() { return false; }
+      public boolean isAnalyzed() {
+        return false;
+      }
+
       @Override
-      public boolean omitNorms()  { return true;  }   	
+      public boolean omitNorms() {
+        return true;
+      }   	
     },
 
     /** Expert: Index the tokens produced by running the
@@ -126,11 +161,19 @@
      *  and why you may want to disable them. */
     ANALYZED_NO_NORMS {
       @Override
-      public boolean isIndexed()  { return true;  }
+      public boolean isIndexed() {
+        return true;
+      }
+
       @Override
-      public boolean isAnalyzed() { return true;  }
+      public boolean isAnalyzed() {
+        return true;
+      }
+
       @Override
-      public boolean omitNorms()  { return true;  }   	
+      public boolean omitNorms() {
+        return true;
+      }   	
     };
 
     /** Get the best representation of the index given the flags. */
@@ -155,11 +198,8 @@
       }
 
       // Expert: Norms omitted
-      if (analyzed) {
-        return Index.ANALYZED_NO_NORMS;
+      return analyzed ? Index.ANALYZED_NO_NORMS : Index.NOT_ANALYZED_NO_NORMS;
-      }
+    }
-      return Index.NOT_ANALYZED_NO_NORMS;
-    }
 
     public abstract boolean isIndexed();
     public abstract boolean isAnalyzed();
@@ -173,22 +213,38 @@
      */
     NO {
       @Override
-      public boolean isStored()      { return false; }
+      public boolean isStored() {
+        return false;
+      }
+
       @Override
-      public boolean withPositions() { return false; }
+      public boolean withPositions() {
+        return false;
+      }
+
       @Override
-      public boolean withOffsets()   { return false; }
+      public boolean withOffsets() {
+        return false;
+      }
     },
     
     /** Store the term vectors of each document. A term vector is a list
      * of the document's terms and their number of occurrences in that document. */
     YES {
       @Override
-      public boolean isStored()      { return true;  }
+      public boolean isStored() {
+        return true;
+      }
+
       @Override
-      public boolean withPositions() { return false; }
+      public boolean withPositions() {
+        return false;
+      }
+
       @Override
-      public boolean withOffsets()   { return false; }
+      public boolean withOffsets() {
+        return false;
+      }
     },
     
     /**
@@ -198,11 +254,19 @@
      */ 
     WITH_POSITIONS {
       @Override
-      public boolean isStored()      { return true;  }
+      public boolean isStored() {
+        return true;
+      }
+
       @Override
-      public boolean withPositions() { return true;  }
+      public boolean withPositions() {
+        return true;
+      }
+
       @Override
-      public boolean withOffsets()   { return false; }
+      public boolean withOffsets() {
+        return false;
+      }
     },
     
     /**
@@ -212,11 +276,19 @@
      */ 
     WITH_OFFSETS {
       @Override
-      public boolean isStored()      { return true;  }
+      public boolean isStored() {
+        return true;
+      }
+
       @Override
-      public boolean withPositions() { return false; }
+      public boolean withPositions() {
+        return false;
+      }
+
       @Override
-      public boolean withOffsets()   { return true;  }
+      public boolean withOffsets() {
+        return true;
+      }
     },
     
     /**
@@ -228,11 +300,19 @@
      */ 
     WITH_POSITIONS_OFFSETS {
       @Override
-      public boolean isStored()      { return true;  }
+      public boolean isStored() {
+        return true;
+      }
+
       @Override
-      public boolean withPositions() { return true;  }
+      public boolean withPositions() {
+        return true;
+      }
+
       @Override
-      public boolean withOffsets()   { return true;  }
+      public boolean withOffsets() {
+        return true;
+      }
     };
 
     /** Get the best representation of a TermVector given the flags. */
@@ -260,168 +340,115 @@
     public abstract boolean withPositions();
     public abstract boolean withOffsets();
   }
-  
+
+  protected String name = "body";
+  protected boolean storeTermVector;
+  protected boolean storeOffsetWithTermVector;
+  protected boolean storePositionWithTermVector;
+  protected boolean omitNorms;
+  protected boolean isStored;
+  protected boolean isIndexed = true;
+  protected boolean isTokenized = true;
+  protected boolean isBinary;
+  protected boolean lazy;
+  protected boolean omitTermFreqAndPositions;
+  protected float boost = 1.0f;
+  // the data object for all different kind of field values
+  protected Object fieldsData = null;
+  // pre-analyzed tokenStream for indexed fields
+  protected TokenStream tokenStream;
+  // length/offset for all primitive types
+  protected int binaryLength;
+  protected int binaryOffset;
-  
+
-  /** The value of the field as a String, or null.  If null, the Reader value or
-   * binary value is used.  Exactly one of stringValue(),
-   * readerValue(), and getBinaryValue() must be set. */
-  public String stringValue()   { return fieldsData instanceof String ? (String)fieldsData : null; }
-  
-  /** The value of the field as a Reader, or null.  If null, the String value or
-   * binary value is used.  Exactly one of stringValue(),
-   * readerValue(), and getBinaryValue() must be set. */
-  public Reader readerValue()   { return fieldsData instanceof Reader ? (Reader)fieldsData : null; }
-    
-  /** The TokesStream for this field to be used when indexing, or null.  If null, the Reader value
-   * or String value is analyzed to produce the indexed tokens. */
-  public TokenStream tokenStreamValue()   { return tokenStream; }
-  
-
-  /** <p>Expert: change the value of this field.  This can
-   *  be used during indexing to re-use a single Field
-   *  instance to improve indexing speed by avoiding GC cost
-   *  of new'ing and reclaiming Field instances.  Typically
-   *  a single {@link Document} instance is re-used as
-   *  well.  This helps most on small documents.</p>
-   * 
-   *  <p>Each Field instance should only be used once
-   *  within a single {@link Document} instance.  See <a
-   *  href="http://wiki.apache.org/lucene-java/ImproveIndexingSpeed">ImproveIndexingSpeed</a>
-   *  for details.</p> */
-  public void setValue(String value) {
-    if (isBinary) {
-      throw new IllegalArgumentException("cannot set a String value on a binary field");
-    }
-    fieldsData = value;
-  }
-
-  /** Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. */
-  public void setValue(Reader value) {
-    if (isBinary) {
-      throw new IllegalArgumentException("cannot set a Reader value on a binary field");
-    }
-    if (isStored) {
-      throw new IllegalArgumentException("cannot set a Reader value on a stored field");
-    }
-    fieldsData = value;
-  }
-
-  /** Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. */
-  public void setValue(byte[] value) {
-    if (!isBinary) {
-      throw new IllegalArgumentException("cannot set a byte[] value on a non-binary field");
-    }
-    fieldsData = value;
-    binaryLength = value.length;
-    binaryOffset = 0;
-  }
-
-  /** Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. */
-  public void setValue(byte[] value, int offset, int length) {
-    if (!isBinary) {
-      throw new IllegalArgumentException("cannot set a byte[] value on a non-binary field");
-    }
-    fieldsData = value;
-    binaryLength = length;
-    binaryOffset = offset;
-  }
-  
-  /** Expert: sets the token stream to be used for indexing and causes isIndexed() and isTokenized() to return true.
-   *  May be combined with stored values from stringValue() or getBinaryValue() */
-  public void setTokenStream(TokenStream tokenStream) {
-    this.isIndexed = true;
-    this.isTokenized = true;
-    this.tokenStream = tokenStream;
-  }
-
   /**
    * Create a field by specifying its name, value and how it will
    * be saved in the index. Term vectors will not be stored in the index.
-   * 
+   *
    * @param name The name of the field
    * @param value The string to process
    * @param store Whether <code>value</code> should be stored in the index
    * @param index Whether the field should be indexed, and if so, if it should
-   *  be tokenized before indexing 
+   *  be tokenized before indexing
    * @throws NullPointerException if name or value is <code>null</code>
-   * @throws IllegalArgumentException if the field is neither stored nor indexed 
+   * @throws IllegalArgumentException if the field is neither stored nor indexed
    */
   public Field(String name, String value, Store store, Index index) {
     this(name, value, store, index, TermVector.NO);
   }
-  
+
   /**
    * Create a field by specifying its name, value and how it will
    * be saved in the index.
-   * 
+   *
    * @param name The name of the field
    * @param value The string to process
    * @param store Whether <code>value</code> should be stored in the index
    * @param index Whether the field should be indexed, and if so, if it should
-   *  be tokenized before indexing 
+   *  be tokenized before indexing
    * @param termVector Whether term vector should be stored
    * @throws NullPointerException if name or value is <code>null</code>
    * @throws IllegalArgumentException in any of the following situations:
-   * <ul> 
-   *  <li>the field is neither stored nor indexed</li> 
+   * <ul>
+   *  <li>the field is neither stored nor indexed</li>
    *  <li>the field is not indexed but termVector is <code>TermVector.YES</code></li>
-   * </ul> 
-   */ 
+   * </ul>
+   */
   public Field(String name, String value, Store store, Index index, TermVector termVector) {
     this(name, true, value, store, index, termVector);
   }
-  
+
   /**
    * Create a field by specifying its name, value and how it will
    * be saved in the index.
-   * 
+   *
    * @param name The name of the field
    * @param internName Whether to .intern() name or not
    * @param value The string to process
    * @param store Whether <code>value</code> should be stored in the index
    * @param index Whether the field should be indexed, and if so, if it should
-   *  be tokenized before indexing 
+   *  be tokenized before indexing
    * @param termVector Whether term vector should be stored
    * @throws NullPointerException if name or value is <code>null</code>
    * @throws IllegalArgumentException in any of the following situations:
-   * <ul> 
-   *  <li>the field is neither stored nor indexed</li> 
+   * <ul>
+   *  <li>the field is neither stored nor indexed</li>
    *  <li>the field is not indexed but termVector is <code>TermVector.YES</code></li>
-   * </ul> 
-   */ 
+   * </ul>
+   */
   public Field(String name, boolean internName, String value, Store store, Index index, TermVector termVector) {
-    if (name == null)
+    if (name == null) {
       throw new NullPointerException("name cannot be null");
-    if (value == null)
-      throw new NullPointerException("value cannot be null");
-    if (name.length() == 0 && value.length() == 0)
+    }
+    if (name.length() == 0 && value.length() == 0) {
       throw new IllegalArgumentException("name and value cannot both be empty");
-    if (index == Index.NO && store == Store.NO)
+    }
+    if (index == Index.NO && store == Store.NO) {
       throw new IllegalArgumentException("it doesn't make sense to have a field that "
          + "is neither indexed nor stored");
-    if (index == Index.NO && termVector != TermVector.NO)
+    }
+    if (index == Index.NO && termVector != TermVector.NO) {
       throw new IllegalArgumentException("cannot store term vector information "
          + "for a field that is not indexed");
+    }
-          
+
-    if (internName) // field names are optionally interned
+    if (internName) { // field names are optionally interned
       name = StringHelper.intern(name);
+    }
-    
-    this.name = name; 
+
+    this.name = name;
-    
     this.fieldsData = value;
 
     this.isStored = store.isStored();
-   
     this.isIndexed = index.isIndexed();
     this.isTokenized = index.isAnalyzed();
     this.omitNorms = index.omitNorms();
     if (index == Index.NO) {
       this.omitTermFreqAndPositions = false;
-    }    
+    }
+    setStoreTermVector(termVector);
 
     this.isBinary = false;
-
-    setStoreTermVector(termVector);
   }
 
   /**
@@ -429,7 +456,7 @@
    * not be stored.  The Reader is read only when the Document is added to the index,
    * i.e. you may not close the Reader until {@link IndexWriter#addDocument(Document)}
    * has been called.
-   * 
+   *
    * @param name The name of the field
    * @param reader The reader with the content
    * @throws NullPointerException if name or reader is <code>null</code>
@@ -439,33 +466,33 @@
   }
 
   /**
-   * Create a tokenized and indexed field that is not stored, optionally with 
+   * Create a tokenized and indexed field that is not stored, optionally with
    * storing term vectors.  The Reader is read only when the Document is added to the index,
    * i.e. you may not close the Reader until {@link IndexWriter#addDocument(Document)}
    * has been called.
-   * 
+   *
    * @param name The name of the field
    * @param reader The reader with the content
    * @param termVector Whether term vector should be stored
    * @throws NullPointerException if name or reader is <code>null</code>
-   */ 
+   */
   public Field(String name, Reader reader, TermVector termVector) {
-    if (name == null)
+    if (name == null) {
       throw new NullPointerException("name cannot be null");
-    if (reader == null)
+    }
+    if (reader == null) {
       throw new NullPointerException("reader cannot be null");
+    }
-    
+
     this.name = StringHelper.intern(name);        // field names are interned
     this.fieldsData = reader;
-    
+
     this.isStored = false;
-    
     this.isIndexed = true;
     this.isTokenized = true;
+    setStoreTermVector(termVector);
-    
+
     this.isBinary = false;
-    
-    setStoreTermVector(termVector);
   }
 
   /**
@@ -474,55 +501,55 @@
    * The TokenStream is read only when the Document is added to the index,
    * i.e. you may not close the TokenStream until {@link IndexWriter#addDocument(Document)}
    * has been called.
-   * 
+   *
    * @param name The name of the field
    * @param tokenStream The TokenStream with the content
    * @throws NullPointerException if name or tokenStream is <code>null</code>
-   */ 
+   */
   public Field(String name, TokenStream tokenStream) {
     this(name, tokenStream, TermVector.NO);
   }
-  
+
   /**
-   * Create a tokenized and indexed field that is not stored, optionally with 
+   * Create a tokenized and indexed field that is not stored, optionally with
    * storing term vectors.  This is useful for pre-analyzed fields.
    * The TokenStream is read only when the Document is added to the index,
    * i.e. you may not close the TokenStream until {@link IndexWriter#addDocument(Document)}
    * has been called.
-   * 
+   *
    * @param name The name of the field
    * @param tokenStream The TokenStream with the content
    * @param termVector Whether term vector should be stored
    * @throws NullPointerException if name or tokenStream is <code>null</code>
-   */ 
+   */
   public Field(String name, TokenStream tokenStream, TermVector termVector) {
-    if (name == null)
+    if (name == null) {
       throw new NullPointerException("name cannot be null");
-    if (tokenStream == null)
+    }
+    if (tokenStream == null) {
       throw new NullPointerException("tokenStream cannot be null");
+    }
-    
+
-    this.name = StringHelper.intern(name);        // field names are interned
+    this.name = StringHelper.intern(name); // field names are interned
     this.fieldsData = null;
     this.tokenStream = tokenStream;
 
     this.isStored = false;
-    
     this.isIndexed = true;
     this.isTokenized = true;
+    setStoreTermVector(termVector);
-    
+
     this.isBinary = false;
-    
-    setStoreTermVector(termVector);
   }
 
-  
+
   /**
    * Create a stored field with binary value. Optionally the value may be compressed.
-   * 
+   *
    * @param name The name of the field
    * @param value The binary value
    * @param store Must be Store.YES
-   * @throws IllegalArgumentException if store is <code>Store.NO</code> 
+   * @throws IllegalArgumentException if store is <code>Store.NO</code>
    * @deprecated Use {@link #Field(String, byte[]) instead}
    */
   @Deprecated
@@ -536,7 +563,7 @@
 
   /**
    * Create a stored field with binary value. Optionally the value may be compressed.
-   * 
+   *
    * @param name The name of the field
    * @param value The binary value
    */
@@ -546,13 +573,13 @@
 
   /**
    * Create a stored field with binary value. Optionally the value may be compressed.
-   * 
+   *
    * @param name The name of the field
    * @param value The binary value
    * @param offset Starting offset in value where this Field's bytes are
    * @param length Number of bytes to use for this Field, starting at offset
    * @param store How <code>value</code> should be stored (compressed or not)
-   * @throws IllegalArgumentException if store is <code>Store.NO</code> 
+   * @throws IllegalArgumentException if store is <code>Store.NO</code>
    * @deprecated Use {@link #Field(String, byte[], int, int) instead}
    */
   @Deprecated
@@ -566,32 +593,361 @@
 
   /**
    * Create a stored field with binary value. Optionally the value may be compressed.
-   * 
+   *
    * @param name The name of the field
    * @param value The binary value
    * @param offset Starting offset in value where this Field's bytes are
    * @param length Number of bytes to use for this Field, starting at offset
    */
   public Field(String name, byte[] value, int offset, int length) {
-
-    if (name == null)
+    if (name == null) {
       throw new IllegalArgumentException("name cannot be null");
-    if (value == null)
+    }
+    if (value == null) {
       throw new IllegalArgumentException("value cannot be null");
+    }
-    
+
-    this.name = StringHelper.intern(name);        // field names are interned
+    this.name = StringHelper.intern(name); // field names are interned
+    this.fieldsData = value;
+
+    this.isStored = true;
+    this.isIndexed = false;
+    this.isTokenized = false;
+    this.omitTermFreqAndPositions = false;
+    this.omitNorms = true;
+    setStoreTermVector(TermVector.NO);
+
+    this.isBinary = true;
+    this.binaryLength = length;
+    this.binaryOffset = offset;
+  }
+
+  protected void setStoreTermVector(Field.TermVector termVector) {
+    this.storeTermVector = termVector.isStored();
+    this.storePositionWithTermVector = termVector.withPositions();
+    this.storeOffsetWithTermVector = termVector.withOffsets();
+  }
+  
+  /** The value of the field as a String, or null.  If null, the Reader value or
+   * binary value is used.  Exactly one of stringValue(),
+   * readerValue(), and getBinaryValue() must be set. */
+  public String stringValue() {
+    return fieldsData instanceof String ? (String) fieldsData : null;
+  }
+  
+  /** The value of the field as a Reader, or null.  If null, the String value or
+   * binary value is used.  Exactly one of stringValue(),
+   * readerValue(), and getBinaryValue() must be set. */
+  public Reader readerValue() {
+    return fieldsData instanceof Reader ? (Reader) fieldsData : null;
+  }
+    
+  /** The TokesStream for this field to be used when indexing, or null.  If null, the Reader value
+   * or String value is analyzed to produce the indexed tokens. */
+  public TokenStream tokenStreamValue() {
+    return tokenStream;
+  }
+
+  /** <p>Expert: change the value of this field.  This can
+   *  be used during indexing to re-use a single Field
+   *  instance to improve indexing speed by avoiding GC cost
+   *  of new'ing and reclaiming Field instances.  Typically
+   *  a single {@link Document} instance is re-used as
+   *  well.  This helps most on small documents.</p>
+   * 
+   *  <p>Each Field instance should only be used once
+   *  within a single {@link Document} instance.  See <a
+   *  href="http://wiki.apache.org/lucene-java/ImproveIndexingSpeed">ImproveIndexingSpeed</a>
+   *  for details.</p> */
+  public void setValue(String value) {
+    if (isBinary) {
+      throw new IllegalArgumentException("cannot set a String value on a binary field");
+    }
     fieldsData = value;
+  }
-    
+
-    isStored = true;
-    isIndexed   = false;
-    isTokenized = false;
-    omitTermFreqAndPositions = false;
-    omitNorms = true;
+  /** Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. */
+  public void setValue(Reader value) {
+    if (isBinary) {
+      throw new IllegalArgumentException("cannot set a Reader value on a binary field");
+    }
+    if (isStored) {
+      throw new IllegalArgumentException("cannot set a Reader value on a stored field");
+    }
+    fieldsData = value;
+  }
-    
+
-    isBinary    = true;
+  /** Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. */
+  public void setValue(byte[] value) {
+    if (!isBinary) {
+      throw new IllegalArgumentException("cannot set a byte[] value on a non-binary field");
+    }
+    fieldsData = value;
+    binaryLength = value.length;
+    binaryOffset = 0;
+  }
+
+  /** Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. */
+  public void setValue(byte[] value, int offset, int length) {
+    if (!isBinary) {
+      throw new IllegalArgumentException("cannot set a byte[] value on a non-binary field");
+    }
+    fieldsData = value;
     binaryLength = length;
     binaryOffset = offset;
+  }
-    
+  
-    setStoreTermVector(TermVector.NO);
+  /** Expert: sets the token stream to be used for indexing and causes isIndexed() and isTokenized() to return true.
+   *  May be combined with stored values from stringValue() or getBinaryValue() */
+  public void setTokenStream(TokenStream tokenStream) {
+    this.isIndexed = true;
+    this.isTokenized = true;
+    this.tokenStream = tokenStream;
   }
+
+    /** Sets the boost factor hits on this field.  This value will be
+   * multiplied into the score of all hits on this this field of this
+   * document.
+   *
+   * <p>The boost is multiplied by {@link org.apache.lucene.document.Document#getBoost()} of the document
+   * containing this field.  If a document has multiple fields with the same
+   * name, all such values are multiplied together.  This product is then
+   * used to compute the norm factor for the field.  By
+   * default, in the {@link
+   * org.apache.lucene.search.Similarity#computeNorm(String,
+   * org.apache.lucene.index.FieldInvertState)} method, the boost value is multiplied
+   * by the {@link
+   * org.apache.lucene.search.Similarity#lengthNorm(String,
+   * int)} and then
+   * rounded by {@link org.apache.lucene.search.Similarity#encodeNormValue(float)} before it is stored in the
+   * index.  One should attempt to ensure that this product does not overflow
+   * the range of that encoding.
+   *
+   * @see org.apache.lucene.document.Document#setBoost(float)
+   * @see org.apache.lucene.search.Similarity#computeNorm(String, org.apache.lucene.index.FieldInvertState)
+   * @see org.apache.lucene.search.Similarity#encodeNormValue(float)
+   */
+  public void setBoost(float boost) {
+    this.boost = boost;
-}
+  }
+
+  /** Returns the boost factor for hits for this field.
+   *
+   * <p>The default value is 1.0.
+   *
+   * <p>Note: this value is not stored directly with the document in the index.
+   * Documents returned from {@link org.apache.lucene.index.IndexReader#document(int)} and
+   * {@link org.apache.lucene.search.Searcher#doc(int)} may thus not have the same value present as when
+   * this field was indexed.
+   *
+   * @see #setBoost(float)
+   */
+  public float getBoost() {
+    return boost;
+  }
+
+  /** Returns the name of the field as an interned string.
+   * For example "date", "title", "body", ...
+   */
+  public String name() {
+    return name;
+  }
+
+  /** True iff the value of the field is to be stored in the index for return
+    with search hits.  It is an error for this to be true if a field is
+    Reader-valued. */
+  public boolean isStored() {
+    return isStored;
+  }
+
+  /** True iff the value of the field is to be indexed, so that it may be
+    searched on. */
+  public boolean isIndexed() {
+    return isIndexed;
+  }
+
+  /** True iff the value of the field should be tokenized as text prior to
+    indexing.  Un-tokenized fields are indexed as a single word and may not be
+    Reader-valued. */
+  public boolean isTokenized() {
+    return isTokenized;
+  }
+
+  /** True iff the term or terms used to index this field are stored as a term
+   *  vector, available from {@link org.apache.lucene.index.IndexReader#getTermFreqVector(int,String)}.
+   *  These methods do not provide access to the original content of the field,
+   *  only to terms used to index it. If the original content must be
+   *  preserved, use the <code>stored</code> attribute instead.
+   *
+   * @see org.apache.lucene.index.IndexReader#getTermFreqVector(int, String)
+   */
+  public boolean isTermVectorStored() {
+    return storeTermVector;
+  }
+
+  /**
+   * True iff terms are stored as term vector together with their offsets
+   * (start and end position in source text).
+   */
+  public boolean isStoreOffsetWithTermVector() {
+    return storeOffsetWithTermVector;
+  }
+
+  /**
+   * True iff terms are stored as term vector together with their token positions.
+   */
+  public boolean isStorePositionWithTermVector() {
+    return storePositionWithTermVector;
+  }
+
+  /** True iff the value of the filed is stored as binary */
+  public boolean isBinary() {
+    return isBinary;
+  }
+
+
+  /**
+   * Return the raw byte[] for the binary field.  Note that
+   * you must also call {@link #getBinaryLength} and {@link
+   * #getBinaryOffset} to know which range of bytes in this
+   * returned array belong to the field.
+   * @return reference to the Field value as byte[].
+   */
+  public byte[] getBinaryValue() {
+    return getBinaryValue(null);
+  }
+
+  public byte[] getBinaryValue(byte[] result) {
+    if (isBinary || fieldsData instanceof byte[]) {
+      return (byte[]) fieldsData;
+    }
+    
+    return null;
+  }
+
+  /**
+   * Returns length of byte[] segment that is used as value, if Field is not binary
+   * returned value is undefined
+   * @return length of byte[] segment that represents this Field value
+   */
+  public int getBinaryLength() {
+    if (isBinary) {
+      return binaryLength;
+    } else if (fieldsData instanceof byte[]) {
+      return ((byte[]) fieldsData).length;
+    }
+    
+    return 0;
+  }
+
+  /**
+   * Returns offset into byte[] segment that is used as value, if Field is not binary
+   * returned value is undefined
+   * @return index of the first character in byte[] segment that represents this Field value
+   */
+  public int getBinaryOffset() {
+    return binaryOffset;
+  }
+
+  /** True if norms are omitted for this indexed field */
+  public boolean getOmitNorms() {
+    return omitNorms;
+  }
+
+  /** @see #setOmitTermFreqAndPositions */
+  public boolean getOmitTermFreqAndPositions() {
+    return omitTermFreqAndPositions;
+  }
+
+  /** Expert:
+   *
+   * If set, omit normalization factors associated with this indexed field.
+   * This effectively disables indexing boosts and length normalization for this field.
+   */
+  public void setOmitNorms(boolean omitNorms) {
+    this.omitNorms = omitNorms;
+  }
+
+  /** Expert:
+   *
+   * If set, omit term freq, positions and payloads from
+   * postings for this field.
+   *
+   * <p><b>NOTE</b>: While this option reduces storage space
+   * required in the index, it also means any query
+   * requiring positional information, such as {@link
+   * org.apache.lucene.search.PhraseQuery} or {@link org.apache.lucene.search.spans.SpanQuery} subclasses will
+   * silently fail to find results.
+   */
+  public void setOmitTermFreqAndPositions(boolean omitTermFreqAndPositions) {
+    this.omitTermFreqAndPositions = omitTermFreqAndPositions;
+  }
+
+  public boolean isLazy() {
+    return lazy;
+  }
+
+  /** Prints a Field for human consumption. */
+  @Override
+  public String toString() {
+    StringBuilder result = new StringBuilder();
+    if (isStored) {
+      result.append("stored");
+    }
+    if (isIndexed) {
+      if (result.length() > 0) {
+        result.append(",");
+      }
+      result.append("indexed");
+    }
+    if (isTokenized) {
+      if (result.length() > 0) {
+        result.append(",");
+      }
+      result.append("tokenized");
+    }
+    if (storeTermVector) {
+      if (result.length() > 0) {
+        result.append(",");
+      }
+      result.append("termVector");
+    }
+    if (storeOffsetWithTermVector) {
+      if (result.length() > 0) {
+        result.append(",");
+      }
+      result.append("termVectorOffsets");
+    }
+    if (storePositionWithTermVector) {
+      if (result.length() > 0) {
+        result.append(",");
+      }
+      result.append("termVectorPosition");
+    }
+    if (isBinary) {
+      if (result.length() > 0) {
+        result.append(",");
+      }
+      result.append("binary");
+    }
+    if (omitNorms) {
+      result.append(",omitNorms");
+    }
+    if (omitTermFreqAndPositions) {
+      result.append(",omitTermFreqAndPositions");
+    }
+    if (lazy){
+      result.append(",lazy");
+    }
+    result.append('<');
+    result.append(name);
+    result.append(':');
+
+    if (fieldsData != null && !lazy) {
+      result.append(fieldsData);
+    }
+
+    result.append('>');
+    return result.toString();
+  }
+}
Index: lucene/src/java/org/apache/lucene/document/AbstractField.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/AbstractField.java	(revision 1065413)
+++ lucene/src/java/org/apache/lucene/document/AbstractField.java	Wed Mar 23 14:34:46 NZDT 2011
@@ -24,8 +24,9 @@
 
 /**
  *
- *
+ * @deprecated Use {@link org.apache.lucene.document.Field} instead
  **/
+@Deprecated
 public abstract class AbstractField implements Fieldable {
 
   protected String name = "body";
@@ -122,16 +123,16 @@
   /** True iff the value of the field is to be stored in the index for return
     with search hits.  It is an error for this to be true if a field is
     Reader-valued. */
-  public final boolean  isStored()  { return isStored; }
+  public boolean  isStored()  { return isStored; }
 
   /** True iff the value of the field is to be indexed, so that it may be
     searched on. */
-  public final boolean  isIndexed()   { return isIndexed; }
+  public boolean  isIndexed()   { return isIndexed; }
 
   /** True iff the value of the field should be tokenized as text prior to
     indexing.  Un-tokenized fields are indexed as a single word and may not be
     Reader-valued. */
-  public final boolean  isTokenized()   { return isTokenized; }
+  public boolean  isTokenized()   { return isTokenized; }
 
   /** True iff the term or terms used to index this field are stored as a term
    *  vector, available from {@link org.apache.lucene.index.IndexReader#getTermFreqVector(int,String)}.
@@ -141,7 +142,7 @@
    *
    * @see org.apache.lucene.index.IndexReader#getTermFreqVector(int, String)
    */
-  public final boolean isTermVectorStored() { return storeTermVector; }
+  public boolean isTermVectorStored() { return storeTermVector; }
 
   /**
    * True iff terms are stored as term vector together with their offsets 
@@ -159,7 +160,7 @@
   }
 
   /** True iff the value of the filed is stored as binary */
-  public final boolean  isBinary() {
+  public boolean  isBinary() {
     return isBinary;
   }
 
@@ -237,7 +238,7 @@
 
   /** Prints a Field for human consumption. */
   @Override
-  public final String toString() {
+  public String toString() {
     StringBuilder result = new StringBuilder();
     if (isStored) {
       result.append("stored");
Index: lucene/src/java/org/apache/lucene/document/Document.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/Document.java	(revision 830661)
+++ lucene/src/java/org/apache/lucene/document/Document.java	Wed Mar 23 16:38:46 NZDT 2011
@@ -25,18 +25,24 @@
 /** Documents are the unit of indexing and search.
  *
  * A Document is a set of fields.  Each field has a name and a textual value.
- * A field may be {@link Fieldable#isStored() stored} with the document, in which
+ * A field may be {@link Field#isStored() stored} with the document, in which
  * case it is returned with search hits on the document.  Thus each document
  * should typically contain one or more stored fields which uniquely identify
  * it.
  *
- * <p>Note that fields which are <i>not</i> {@link Fieldable#isStored() stored} are
+ * <p>Note that fields which are <i>not</i> {@link Field#isStored() stored} are
  * <i>not</i> available in documents retrieved from the index, e.g. with {@link
  * ScoreDoc#doc}, {@link Searcher#doc(int)} or {@link
  * IndexReader#document(int)}.
  */
 
 public final class Document implements java.io.Serializable {
+
+  private final static Field[] NO_FIELDS = new Field[0];
+  private final static Fieldable[] NO_FIELDABLES = new Fieldable[0];
+  private final static String[] NO_STRINGS = new String[0];
+  private final static byte[][] NO_BYTES = new byte[0][];
+
   List<Fieldable> fields = new ArrayList<Fieldable>();
   private float boost = 1.0f;
 
@@ -49,11 +55,11 @@
    *
    * <p>The default value is 1.0.
    * 
-   * <p>Values are multiplied into the value of {@link Fieldable#getBoost()} of
+   * <p>Values are multiplied into the value of {@link Field#getBoost()} of
    * each field in this document.  Thus, this method in effect sets a default
    * boost for the fields of this document.
    *
-   * @see Fieldable#setBoost(float)
+   * @see Field#setBoost(float)
    */
   public void setBoost(float boost) {
     this.boost = boost;
@@ -76,16 +82,25 @@
   }
 
   /**
+   * @deprecated Convert to instances of {@link org.apache.lucene.document.Field}
+   * and use {@link #add(Field)}
+   */
+  @Deprecated
+  public final void add(Fieldable field) {
+    fields.add(field);
+  }
+
+  /**
    * <p>Adds a field to a document.  Several fields may be added with
    * the same name.  In this case, if the fields are indexed, their text is
    * treated as though appended for the purposes of search.</p>
-   * <p> Note that add like the removeField(s) methods only makes sense 
+   * <p> Note that add like the removeField(s) methods only makes sense
    * prior to adding a document to an index. These methods cannot
    * be used to change the content of an existing index! In order to achieve this,
    * a document has to be deleted from an index and a new changed version of that
    * document has to be added.</p>
    */
-  public final void add(Fieldable field) {
+  public final void add(Field field) {
     fields.add(field);
   }
   
@@ -142,12 +157,17 @@
  /** Returns a field with the given name if any exist in this document, or
    * null.  If multiple fields exists with this name, this method returns the
    * first value added.
+  *
+  * @deprecated Convert to instances of {@link org.apache.lucene.document.Field}
+  * and use {@link #getField(String)}
    */
+ @Deprecated
  public Fieldable getFieldable(String name) {
    for (Fieldable field : fields) {
-     if (field.name().equals(name))
+     if (field.name().equals(name)) {
        return field;
-   }
+     }
+   }
    return null;
  }
 
@@ -158,24 +178,37 @@
    */
   public final String get(String name) {
    for (Fieldable field : fields) {
-      if (field.name().equals(name) && (!field.isBinary()))
+      if (field.name().equals(name) && (!field.isBinary())) {
         return field.stringValue();
-    }
+      }
+    }
     return null;
   }
 
-  /** Returns a List of all the fields in a document.
-   * <p>Note that fields which are <i>not</i> {@link Fieldable#isStored() stored} are
+  /**
+   * @deprecated Convert to instances of {@link org.apache.lucene.document.Field}
+   * and use {@link #getAllFields()}
+   */
+  @Deprecated
+  public final List<Fieldable> getFields() {
+    return fields;
+  }
+
+  /**
+   * Returns a List of all the fields in a document.
+   * <p>Note that fields which are <i>not</i> {@link Field#isStored() stored} are
    * <i>not</i> available in documents retrieved from the
    * index, e.g. {@link Searcher#doc(int)} or {@link
    * IndexReader#document(int)}.
+   *
+   * Note, this method assumes that all fields contained in this Document are an
+   * instance of {@link org.apache.lucene.document.Field}.
    */
-  public final List<Fieldable> getFields() {
-    return fields;
+  @SuppressWarnings("unchecked")
+  public final List<? extends Field> getAllFields() {
+    return (List) fields;
   }
-
+  
-  private final static Field[] NO_FIELDS = new Field[0];
-  
   /**
    * Returns an array of {@link Field}s with the given name.
    * Do not use with lazy loaded fields.
@@ -193,15 +226,13 @@
        }
      }
 
-     if (result.size() == 0)
+     if (result.size() == 0) {
        return NO_FIELDS;
+     }
 
      return result.toArray(new Field[result.size()]);
    }
 
-
-   private final static Fieldable[] NO_FIELDABLES = new Fieldable[0];
-
    /**
    * Returns an array of {@link Fieldable}s with the given name.
    * This method returns an empty array when there are no
@@ -209,7 +240,10 @@
    *
    * @param name the name of the field
    * @return a <code>Fieldable[]</code> array
+   * @deprecated Convert to instances of {@link org.apache.lucene.document.Field}
+   * and use {@link #getFields(String)}
    */
+   @Deprecated
    public Fieldable[] getFieldables(String name) {
      List<Fieldable> result = new ArrayList<Fieldable>();
      for (Fieldable field : fields) {
@@ -218,15 +252,13 @@
        }
      }
 
-     if (result.size() == 0)
+     if (result.size() == 0) {
        return NO_FIELDABLES;
+     }
 
      return result.toArray(new Fieldable[result.size()]);
    }
 
-
-   private final static String[] NO_STRINGS = new String[0];
-
   /**
    * Returns an array of values of the field specified as the method parameter.
    * This method returns an empty array when there are no
@@ -241,14 +273,13 @@
         result.add(field.stringValue());
     }
     
-    if (result.size() == 0)
+    if (result.size() == 0) {
       return NO_STRINGS;
+    }
     
     return result.toArray(new String[result.size()]);
   }
 
-  private final static byte[][] NO_BYTES = new byte[0][];
-
   /**
   * Returns an array of byte arrays for of the fields that have the name specified
   * as the method parameter.  This method returns an empty
