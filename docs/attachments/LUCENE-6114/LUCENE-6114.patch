Index: lucene/core/src/java/org/apache/lucene/util/packed/Direct16.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/Direct16.java	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/Direct16.java	(working copy)
@@ -42,11 +42,6 @@
     for (int i = 0; i < valueCount; ++i) {
       values[i] = in.readShort();
     }
-    // because packed ints have not always been byte-aligned
-    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, 16) - 2L * valueCount);
-    for (int i = 0; i < remaining; ++i) {
-      in.readByte();
-    }
   }
 
   @Override
Index: lucene/core/src/java/org/apache/lucene/util/packed/Direct32.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/Direct32.java	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/Direct32.java	(working copy)
@@ -42,11 +42,6 @@
     for (int i = 0; i < valueCount; ++i) {
       values[i] = in.readInt();
     }
-    // because packed ints have not always been byte-aligned
-    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, 32) - 4L * valueCount);
-    for (int i = 0; i < remaining; ++i) {
-      in.readByte();
-    }
   }
 
   @Override
Index: lucene/core/src/java/org/apache/lucene/util/packed/Direct8.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/Direct8.java	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/Direct8.java	(working copy)
@@ -40,11 +40,6 @@
   Direct8(int packedIntsVersion, DataInput in, int valueCount) throws IOException {
     this(valueCount);
     in.readBytes(values, 0, valueCount);
-    // because packed ints have not always been byte-aligned
-    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, 8) - 1L * valueCount);
-    for (int i = 0; i < remaining; ++i) {
-      in.readByte();
-    }
   }
 
   @Override
Index: lucene/core/src/java/org/apache/lucene/util/packed/MonotonicBlockPackedReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/MonotonicBlockPackedReader.java	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/MonotonicBlockPackedReader.java	(working copy)
@@ -17,7 +17,6 @@
  * limitations under the License.
  */
 
-import static org.apache.lucene.util.BitUtil.zigZagDecode;
 import static org.apache.lucene.util.packed.AbstractBlockPackedWriter.MAX_BLOCK_SIZE;
 import static org.apache.lucene.util.packed.AbstractBlockPackedWriter.MIN_BLOCK_SIZE;
 import static org.apache.lucene.util.packed.PackedInts.checkBlockSize;
@@ -50,14 +49,6 @@
 
   /** Sole constructor. */
   public static MonotonicBlockPackedReader of(IndexInput in, int packedIntsVersion, int blockSize, long valueCount, boolean direct) throws IOException {
-    if (packedIntsVersion < PackedInts.VERSION_MONOTONIC_WITHOUT_ZIGZAG) {
-      return new MonotonicBlockPackedReader(in, packedIntsVersion, blockSize, valueCount, direct) {
-        @Override
-        protected long decodeDelta(long delta) {
-          return zigZagDecode(delta);
-        }
-      };
-    }
     return new MonotonicBlockPackedReader(in, packedIntsVersion, blockSize, valueCount, direct);
   }
 
@@ -71,11 +62,7 @@
     subReaders = new PackedInts.Reader[numBlocks];
     long sumBPV = 0;
     for (int i = 0; i < numBlocks; ++i) {
-      if (packedIntsVersion < PackedInts.VERSION_MONOTONIC_WITHOUT_ZIGZAG) {
-        minValues[i] = in.readVLong();
-      } else {
-        minValues[i] = in.readZLong();
-      }
+      minValues[i] = in.readZLong();
       averages[i] = Float.intBitsToFloat(in.readInt());
       final int bitsPerValue = in.readVInt();
       sumBPV += bitsPerValue;
@@ -103,13 +90,9 @@
     assert index >= 0 && index < valueCount;
     final int block = (int) (index >>> blockShift);
     final int idx = (int) (index & blockMask);
-    return expected(minValues[block], averages[block], idx) + decodeDelta(subReaders[block].get(idx));
+    return expected(minValues[block], averages[block], idx) + subReaders[block].get(idx);
   }
 
-  protected long decodeDelta(long delta) {
-    return delta;
-  }
-
   /** Returns the number of values */
   public long size() {
     return valueCount;
Index: lucene/core/src/java/org/apache/lucene/util/packed/Packed16ThreeBlocks.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/Packed16ThreeBlocks.java	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/Packed16ThreeBlocks.java	(working copy)
@@ -47,11 +47,6 @@
     for (int i = 0; i < 3 * valueCount; ++i) {
       blocks[i] = in.readShort();
     }
-    // because packed ints have not always been byte-aligned
-    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, 48) - 3L * valueCount * 2);
-    for (int i = 0; i < remaining; ++i) {
-       in.readByte();
-    }
   }
 
   @Override
Index: lucene/core/src/java/org/apache/lucene/util/packed/Packed64.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/Packed64.java	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/Packed64.java	(working copy)
@@ -27,7 +27,7 @@
  * Space optimized random access capable array of values with a fixed number of
  * bits/value. Values are packed contiguously.
  * </p><p>
- * The implementation strives to perform af fast as possible under the
+ * The implementation strives to perform as fast as possible under the
  * constraint of contiguous bits, by avoiding expensive operations. This comes
  * at the cost of code clarity.
  * </p><p>
Index: lucene/core/src/java/org/apache/lucene/util/packed/Packed8ThreeBlocks.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/Packed8ThreeBlocks.java	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/Packed8ThreeBlocks.java	(working copy)
@@ -45,11 +45,6 @@
   Packed8ThreeBlocks(int packedIntsVersion, DataInput in, int valueCount) throws IOException {
     this(valueCount);
     in.readBytes(blocks, 0, 3 * valueCount);
-    // because packed ints have not always been byte-aligned
-    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, 24) - 3L * valueCount * 1);
-    for (int i = 0; i < remaining; ++i) {
-       in.readByte();
-    }
   }
 
   @Override
Index: lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java	(working copy)
@@ -65,9 +65,8 @@
   public static final int DEFAULT_BUFFER_SIZE = 1024; // 1K
 
   public final static String CODEC_NAME = "PackedInts";
-  public final static int VERSION_START = 0; // PackedInts were long-aligned
-  public final static int VERSION_BYTE_ALIGNED = 1;
   public static final int VERSION_MONOTONIC_WITHOUT_ZIGZAG = 2;
+  public final static int VERSION_START = VERSION_MONOTONIC_WITHOUT_ZIGZAG;
   public final static int VERSION_CURRENT = VERSION_MONOTONIC_WITHOUT_ZIGZAG;
 
   /**
@@ -94,11 +93,7 @@
 
       @Override
       public long byteCount(int packedIntsVersion, int valueCount, int bitsPerValue) {
-        if (packedIntsVersion < VERSION_BYTE_ALIGNED) {
-          return 8L *  (long) Math.ceil((double) valueCount * bitsPerValue / 64);
-        } else {
-          return (long) Math.ceil((double) valueCount * bitsPerValue / 8);
-        }
+        return (long) Math.ceil((double) valueCount * bitsPerValue / 8);      
       }
 
     },
@@ -889,32 +884,7 @@
     checkVersion(version);
     switch (format) {
       case PACKED:
-        final long byteCount = format.byteCount(version, valueCount, bitsPerValue);
-        if (byteCount != format.byteCount(VERSION_CURRENT, valueCount, bitsPerValue)) {
-          assert version == VERSION_START;
-          final long endPointer = in.getFilePointer() + byteCount;
-          // Some consumers of direct readers assume that reading the last value
-          // will make the underlying IndexInput go to the end of the packed
-          // stream, but this is not true because packed ints storage used to be
-          // long-aligned and is now byte-aligned, hence this additional
-          // condition when reading the last value
-          return new DirectPackedReader(bitsPerValue, valueCount, in) {
-            @Override
-            public long get(int index) {
-              final long result = super.get(index);
-              if (index == valueCount - 1) {
-                try {
-                  in.seek(endPointer);
-                } catch (IOException e) {
-                  throw new IllegalStateException("failed", e);
-                }
-              }
-              return result;
-            }
-          };
-        } else {
-          return new DirectPackedReader(bitsPerValue, valueCount, in);
-        }
+        return new DirectPackedReader(bitsPerValue, valueCount, in);
       case PACKED_SINGLE_BLOCK:
         return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);
       default:
Index: lucene/core/src/java/org/apache/lucene/util/packed/PackedReaderIterator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/PackedReaderIterator.java	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/PackedReaderIterator.java	(working copy)
@@ -39,7 +39,7 @@
     this.format = format;
     this.packedIntsVersion = packedIntsVersion;
     bulkOperation = BulkOperation.of(format, bitsPerValue);
-    iterations = iterations(mem);
+    iterations = bulkOperation.computeIterations(valueCount, mem);
     assert valueCount == 0 || iterations > 0;
     nextBlocks = new byte[iterations * bulkOperation.byteBlockCount()];
     nextValues = new LongsRef(new long[iterations * bulkOperation.byteValueCount()], 0, 0);
@@ -47,15 +47,6 @@
     position = -1;
   }
 
-  private int iterations(int mem) {
-    int iterations = bulkOperation.computeIterations(valueCount, mem);
-    if (packedIntsVersion < PackedInts.VERSION_BYTE_ALIGNED) {
-      // make sure iterations is a multiple of 8
-      iterations = (iterations + 7) & 0xFFFFFFF8;
-    }
-    return iterations;
-  }
-
   @Override
   public LongsRef next(int count) throws IOException {
     assert nextValues.length >= 0;
Index: lucene/core/src/java/org/apache/lucene/util/packed/gen_PackedThreeBlocks.py
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/gen_PackedThreeBlocks.py	(revision 1645839)
+++ lucene/core/src/java/org/apache/lucene/util/packed/gen_PackedThreeBlocks.py	(working copy)
@@ -78,11 +78,6 @@
       f.write("    for (int i = 0; i < 3 * valueCount; ++i) {\n")
       f.write("      blocks[i] = in.read%s();\n" %TYPES[bpv].title())
       f.write("    }\n")
-    f.write("    // because packed ints have not always been byte-aligned\n")
-    f.write("    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, %d) - 3L * valueCount * %d);\n" %(3 * bpv, bpv / 8))
-    f.write("    for (int i = 0; i < remaining; ++i) {\n")
-    f.write("       in.readByte();\n")
-    f.write("    }\n")
     f.write("  }\n")
 
     f.write("""
