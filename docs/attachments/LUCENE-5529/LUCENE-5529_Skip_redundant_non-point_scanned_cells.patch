Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/Cell.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/Cell.java	(revision 4d4d7c2ca7cccc3ee7e72cadf5563bd3aed3c6bc)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/Cell.java	(revision )
@@ -33,6 +33,7 @@
  * @lucene.experimental
  */
 public abstract class Cell implements Comparable<Cell> {
+  //TODO refactor to be non-constant; add getter
   public static final byte LEAF_BYTE = '+';//NOTE: must sort before letters & numbers
 
   /*
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree.java	(revision 4d4d7c2ca7cccc3ee7e72cadf5563bd3aed3c6bc)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree.java	(revision )
@@ -228,7 +228,7 @@
     assert endToken.length() == detailLevel;
     List<Cell> cells = new ArrayList<>(detailLevel);
     for (int i = 1; i < detailLevel; i++) {
-      cells.add(getCell(endToken.substring(0, i)));
+      cells.add(getCell(endToken.substring(0, i)));//TODO refactor: add a cell.getParent()
     }
     cells.add(cell);
     return cells;
@@ -236,6 +236,7 @@
 
   /**
    * Will add the trailing leaf byte for leaves. This isn't particularly efficient.
+   * @deprecated TODO remove; not used and not interesting, don't need collection in & out
    */
   public static List<String> cellsToTokenStrings(Collection<Cell> cells) {
     List<String> tokens = new ArrayList<>((cells.size()));
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy.java	(revision 4d4d7c2ca7cccc3ee7e72cadf5563bd3aed3c6bc)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy.java	(revision )
@@ -61,7 +61,7 @@
     BytesRef[] terms = new BytesRef[cells.size()];
     int i = 0;
     for (Cell cell : cells) {
-      terms[i++] = new BytesRef(cell.getTokenString());
+      terms[i++] = new BytesRef(cell.getTokenString());//TODO use cell.getTokenBytes()
     }
     return new TermsFilter(getFieldName(), terms);
   }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java	(revision 4d4d7c2ca7cccc3ee7e72cadf5563bd3aed3c6bc)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java	(revision )
@@ -17,9 +17,7 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Iterator;
-
+import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.DocIdSet;
@@ -28,8 +26,10 @@
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.StringHelper;
-import com.spatial4j.core.shape.Shape;
 
+import java.io.IOException;
+import java.util.Iterator;
+
 /**
  * Traverses a {@link SpatialPrefixTree} indexed field, using the template &
  * visitor design patterns for subclasses to guide the traversal and collect
@@ -60,17 +60,14 @@
   public boolean equals(Object o) {
     if (!super.equals(o)) return false;//checks getClass == o.getClass & instanceof
 
-    AbstractVisitingPrefixTreeFilter that = (AbstractVisitingPrefixTreeFilter) o;
+    //Ignore prefixGridScanLevel as it is merely a tuning parameter.
 
-    if (prefixGridScanLevel != that.prefixGridScanLevel) return false;
-
     return true;
   }
 
   @Override
   public int hashCode() {
     int result = super.hashCode();
-    result = 31 * result + prefixGridScanLevel;
     return result;
   }
 
@@ -90,7 +87,7 @@
    * method then it's short-circuited until it finds one, at which point
    * {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)} is called. At
    * some depths, of the tree, the algorithm switches to a scanning mode that
-   * finds calls {@link #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}
+   * calls {@link #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}
    * for each leaf cell found.
    *
    * @lucene.internal
@@ -218,7 +215,7 @@
       if (hasIndexedLeaves && cell.getLevel() != 0) {
         //If the next indexed term just adds a leaf marker ('+') to cell,
         // then add all of those docs
-        assert StringHelper.startsWith(thisTerm, curVNodeTerm);
+        assert StringHelper.startsWith(thisTerm, curVNodeTerm);//TODO refactor to use method on curVNode.cell
         scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);
         if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {
           visitLeaf(scanCell);
@@ -268,15 +265,17 @@
      */
     protected void scan(int scanDetailLevel) throws IOException {
       for (;
-           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);
+           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);//TODO refactor to use method on curVNode.cell
            thisTerm = termsEnum.next()) {
         scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);
 
         int termLevel = scanCell.getLevel();
-        if (termLevel > scanDetailLevel)
-          continue;
-        if (termLevel == scanDetailLevel || scanCell.isLeaf()) {
+        if (termLevel < scanDetailLevel) {
+          if (scanCell.isLeaf())
+            visitScanned(scanCell);
+        } else if (termLevel == scanDetailLevel) {
+          if (!scanCell.isLeaf())//LUCENE-5529
-          visitScanned(scanCell);
+            visitScanned(scanCell);
         }
       }//term loop
     }
