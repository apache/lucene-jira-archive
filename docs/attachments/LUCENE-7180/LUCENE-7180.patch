diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java b/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
index 5ce819c..73b26ee 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
@@ -16,244 +16,29 @@
  */
 package org.apache.lucene.document;
 
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.lucene.geo.GeoTestUtil;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.SerialMergeScheduler;
-import org.apache.lucene.search.FieldDoc;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.SloppyMath;
-import org.apache.lucene.util.TestUtil;
+import org.apache.lucene.spatial.util.BaseGeoDistanceSortTestCase;
 
 /** Simple tests for {@link LatLonPoint#newDistanceSort} */
-public class TestLatLonPointDistanceSort extends LuceneTestCase {
-
-  /** Add three points and sort by distance */
-  public void testDistanceSort() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
-    
-    // add some docs
-    Document doc = new Document();
-    doc.add(new LatLonPoint("location", 40.759011, -73.9844722));
-    iw.addDocument(doc);
-    
-    doc = new Document();
-    doc.add(new LatLonPoint("location", 40.718266, -74.007819));
-    iw.addDocument(doc);
-    
-    doc = new Document();
-    doc.add(new LatLonPoint("location", 40.7051157, -74.0088305));
-    iw.addDocument(doc);
-    
-    IndexReader reader = iw.getReader();
-    IndexSearcher searcher = newSearcher(reader);
-    iw.close();
+public class TestLatLonPointDistanceSort extends BaseGeoDistanceSortTestCase {
 
-    Sort sort = new Sort(LatLonPoint.newDistanceSort("location", 40.7143528, -74.0059731));
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 3, sort);
-    
-    FieldDoc d = (FieldDoc) td.scoreDocs[0];
-    assertEquals(462.1028401330432, (Double)d.fields[0], 0.0D);
-    
-    d = (FieldDoc) td.scoreDocs[1];
-    assertEquals(1054.9842850974826, (Double)d.fields[0], 0.0D);
-    
-    d = (FieldDoc) td.scoreDocs[2];
-    assertEquals(5285.881528419706, (Double)d.fields[0], 0.0D);
-    
-    reader.close();
-    dir.close();
+  @Override
+  protected void addPointToDoc(String field, Document doc, double lat, double lon) {
+    doc.add(new LatLonPoint(field, lat, lon));
   }
-  
-  /** Add two points (one doc missing) and sort by distance */
-  public void testMissingLast() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
-    
-    // missing
-    Document doc = new Document();
-    iw.addDocument(doc);
-    
-    doc = new Document();
-    doc.add(new LatLonPoint("location", 40.718266, -74.007819));
-    iw.addDocument(doc);
-    
-    doc = new Document();
-    doc.add(new LatLonPoint("location", 40.7051157, -74.0088305));
-    iw.addDocument(doc);
-    
-    IndexReader reader = iw.getReader();
-    IndexSearcher searcher = newSearcher(reader);
-    iw.close();
 
-    Sort sort = new Sort(LatLonPoint.newDistanceSort("location", 40.7143528, -74.0059731));
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 3, sort);
-    
-    FieldDoc d = (FieldDoc) td.scoreDocs[0];
-    assertEquals(462.1028401330432D, (Double)d.fields[0], 0.0D);
-    
-    d = (FieldDoc) td.scoreDocs[1];
-    assertEquals(1054.9842850974826, (Double)d.fields[0], 0.0D);
-    
-    d = (FieldDoc) td.scoreDocs[2];
-    assertEquals(Double.POSITIVE_INFINITY, (Double)d.fields[0], 0.0D);
-    
-    reader.close();
-    dir.close();
-  }
-  
-  /** Run a few iterations with just 10 docs, hopefully easy to debug */
-  public void testRandom() throws Exception {
-    for (int iters = 0; iters < 100; iters++) {
-      doRandomTest(10, 100);
-    }
+  @Override
+  protected SortField newDistanceSort(String field, double centerLat, double centerLon) {
+    return LatLonPoint.newDistanceSort(field, centerLat, centerLon);
   }
-  
-  /** Runs with thousands of docs */
-  @Nightly
-  public void testRandomHuge() throws Exception {
-    for (int iters = 0; iters < 10; iters++) {
-      doRandomTest(2000, 100);
-    }
-  }
-  
-  // result class used for testing. holds an id+distance.
-  // we sort these with Arrays.sort and compare with lucene's results
-  static class Result implements Comparable<Result> {
-    int id;
-    double distance;
-    
-    Result(int id, double distance) {
-      this.id = id;
-      this.distance = distance;
-    }
-
-    @Override
-    public int compareTo(Result o) {
-      int cmp = Double.compare(distance, o.distance);
-      if (cmp == 0) {
-        return Integer.compare(id, o.id);
-      }
-      return cmp;
-    }
-
-    @Override
-    public int hashCode() {
-      final int prime = 31;
-      int result = 1;
-      long temp;
-      temp = Double.doubleToLongBits(distance);
-      result = prime * result + (int) (temp ^ (temp >>> 32));
-      result = prime * result + id;
-      return result;
-    }
 
-    @Override
-    public boolean equals(Object obj) {
-      if (this == obj) return true;
-      if (obj == null) return false;
-      if (getClass() != obj.getClass()) return false;
-      Result other = (Result) obj;
-      if (Double.doubleToLongBits(distance) != Double.doubleToLongBits(other.distance)) return false;
-      if (id != other.id) return false;
-      return true;
-    }
-
-    @Override
-    public String toString() {
-      return "Result [id=" + id + ", distance=" + distance + "]";
-    }
+  @Override
+  protected double quantizeLat(double latRaw) {
+    return LatLonPoint.decodeLatitude(LatLonPoint.encodeLatitude(latRaw));
   }
-  
-  private void doRandomTest(int numDocs, int numQueries) throws IOException {
-    Directory dir = newDirectory();    
-    IndexWriterConfig iwc = newIndexWriterConfig();
-    // else seeds may not to reproduce:
-    iwc.setMergeScheduler(new SerialMergeScheduler());
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);
-
-    for (int i = 0; i < numDocs; i++) {
-      Document doc = new Document();
-      doc.add(new StoredField("id", i));
-      doc.add(new NumericDocValuesField("id", i));
-      if (random().nextInt(10) > 7) {
-        double latRaw = GeoTestUtil.nextLatitude();
-        double lonRaw = GeoTestUtil.nextLongitude();
-        // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons
-        double lat = LatLonPoint.decodeLatitude(LatLonPoint.encodeLatitude(latRaw));
-        double lon = LatLonPoint.decodeLongitude(LatLonPoint.encodeLongitude(lonRaw));
-
-        doc.add(new LatLonPoint("field", lat, lon));
-        doc.add(new StoredField("lat", lat));
-        doc.add(new StoredField("lon", lon));
-      } // otherwise "missing"
-      writer.addDocument(doc);
-    }
-    IndexReader reader = writer.getReader();
-    IndexSearcher searcher = newSearcher(reader);
-
-    for (int i = 0; i < numQueries; i++) {
-      double lat = GeoTestUtil.nextLatitude();
-      double lon = GeoTestUtil.nextLongitude();
-      double missingValue = Double.POSITIVE_INFINITY;
-
-      Result expected[] = new Result[reader.maxDoc()];
-      
-      for (int doc = 0; doc < reader.maxDoc(); doc++) {
-        Document targetDoc = reader.document(doc);
-        final double distance;
-        if (targetDoc.getField("lat") == null) {
-          distance = missingValue; // missing
-        } else {
-          double docLatitude = targetDoc.getField("lat").numericValue().doubleValue();
-          double docLongitude = targetDoc.getField("lon").numericValue().doubleValue();
-          distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);
-        }
-        int id = targetDoc.getField("id").numericValue().intValue();
-        expected[doc] = new Result(id, distance);
-      }
-      
-      Arrays.sort(expected);
-      
-      // randomize the topN a bit
-      int topN = TestUtil.nextInt(random(), 1, reader.maxDoc());
-      // sort by distance, then ID
-      SortField distanceSort = LatLonPoint.newDistanceSort("field", lat, lon);
-      distanceSort.setMissingValue(missingValue);
-      Sort sort = new Sort(distanceSort, 
-                           new SortField("id", SortField.Type.INT));
-
-      TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), topN, sort);
-      for (int resultNumber = 0; resultNumber < topN; resultNumber++) {
-        FieldDoc fieldDoc = (FieldDoc) topDocs.scoreDocs[resultNumber];
-        Result actual = new Result((Integer) fieldDoc.fields[1], (Double) fieldDoc.fields[0]);
-        assertEquals(expected[resultNumber], actual);
-      }
 
-      // get page2 with searchAfter()
-      if (topN < reader.maxDoc()) {
-        int page2 = TestUtil.nextInt(random(), 1, reader.maxDoc() - topN);
-        TopDocs topDocs2 = searcher.searchAfter(topDocs.scoreDocs[topN - 1], new MatchAllDocsQuery(), page2, sort);
-        for (int resultNumber = 0; resultNumber < page2; resultNumber++) {
-          FieldDoc fieldDoc = (FieldDoc) topDocs2.scoreDocs[resultNumber];
-          Result actual = new Result((Integer) fieldDoc.fields[1], (Double) fieldDoc.fields[0]);
-          assertEquals(expected[topN + resultNumber], actual);
-        }
-      }
-    }
-    reader.close();
-    writer.close();
-    dir.close();
+  @Override
+  protected double quantizeLon(double lonRaw) {
+    return LatLonPoint.decodeLongitude(LatLonPoint.encodeLongitude(lonRaw));
   }
 }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java
index 8b1483a..c8a03df 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java
@@ -22,6 +22,8 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.index.DocValuesType;
 import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.search.FieldDoc;
+import org.apache.lucene.search.SortField;
 import org.apache.lucene.spatial.util.GeoEncodingUtils;
 import org.apache.lucene.geo.GeoUtils;
 
@@ -251,4 +253,25 @@ public final class GeoPointField extends Field {
     sb.append(GeoEncodingUtils.mortonUnhashLon((long) fieldsData));
     return sb.toString();
   }
+
+  /**
+   * Creates a SortField for sorting by distance from a location.
+   * <p>
+   * This sort orders documents by ascending distance from the location. The value returned in {@link FieldDoc} for
+   * the hits contains a Double instance with the distance in meters.
+   * <p>
+   * If a document is missing the field, then by default it is treated as having {@link Double#POSITIVE_INFINITY} distance
+   * (missing values sort last).
+   * <p>
+   * If a document contains multiple values for the field, the <i>closest</i> distance to the location is used.
+   *
+   * @param field field name. must not be null.
+   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.
+   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.
+   * @return SortField ordering documents by distance
+   * @throws IllegalArgumentException if {@code field} is null or location has invalid coordinates.
+   */
+  public static SortField newDistanceSort(String field, double latitude, double longitude) {
+    return new GeoPointSortField(field, latitude, longitude);
+  }
 }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointSortField.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointSortField.java
new file mode 100644
index 0000000..42969f8
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointSortField.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.document;
+
+import java.io.IOException;
+
+import org.apache.lucene.geo.GeoUtils;
+import org.apache.lucene.search.FieldComparator;
+import org.apache.lucene.search.SortField;
+import org.apache.lucene.spatial.geopoint.search.GeoPointDistanceComparator;
+
+/**
+ * Sorts {@link GeoPointField} by distance from an origin location.
+ */
+public class GeoPointSortField extends SortField {
+  final double lat;
+  final double lon;
+
+  GeoPointSortField(String field, double lat, double lon) {
+    super(field, Type.CUSTOM);
+    if (field == null) {
+      throw new IllegalArgumentException("field must not be null");
+    }
+    GeoUtils.checkLatitude(lat);
+    GeoUtils.checkLongitude(lon);
+    this.lat = lat;
+    this.lon = lon;
+    setMissingValue(Double.POSITIVE_INFINITY);
+  }
+
+  @Override
+  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {
+    return new GeoPointDistanceComparator(getField(), lat, lon, numHits);
+  }
+
+  @Override
+  public Double getMissingValue() {
+    return (Double) super.getMissingValue();
+  }
+
+  @Override
+  public void setMissingValue(Object missingValue) {
+    if (Double.valueOf(Double.POSITIVE_INFINITY).equals(missingValue) == false) {
+      throw new IllegalArgumentException("Missing value can only be Double.POSITIVE_INFINITY (missing values last), but got " + missingValue);
+    }
+    this.missingValue = missingValue;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    if (!super.equals(o)) return false;
+
+    GeoPointSortField that = (GeoPointSortField) o;
+
+    if (Double.compare(that.lat, lat) != 0) return false;
+    return Double.compare(that.lon, lon) == 0;
+
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    long temp;
+    temp = Double.doubleToLongBits(lat);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(lon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder builder = new StringBuilder();
+    builder.append("<distance:");
+    builder.append('"');
+    builder.append(getField());
+    builder.append('"');
+    builder.append(" latitude=");
+    builder.append(lat);
+    builder.append(" longitude=");
+    builder.append(lon);
+    if (Double.POSITIVE_INFINITY != getMissingValue()) {
+      builder.append(" missingValue=" + getMissingValue());
+    }
+    builder.append('>');
+    return builder.toString();
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceComparator.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceComparator.java
new file mode 100644
index 0000000..981744f
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceComparator.java
@@ -0,0 +1,197 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import java.io.IOException;
+
+import org.apache.lucene.geo.Rectangle;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.SortedNumericDocValues;
+import org.apache.lucene.search.FieldComparator;
+import org.apache.lucene.search.LeafFieldComparator;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
+import org.apache.lucene.util.BitUtil;
+import org.apache.lucene.util.SloppyMath;
+
+/**
+ * Compares documents by distance from an origin point
+ * <p>
+ * When the least competitive item on the priority queue changes (setBottom), we recompute
+ * a bounding box representing competitive distance to the top-N. Then in compareBottom, we can
+ * quickly reject hits based on bounding box alone without computing distance for every element.
+ */
+public class GeoPointDistanceComparator extends FieldComparator<Double> implements LeafFieldComparator {
+  final String field;
+  final double latitude;
+  final double longitude;
+
+  final double[] values;
+  double bottom;
+  double topValue;
+  SortedNumericDocValues currentDocs;
+
+  // current bounding box(es) for the bottom distance on the PQ.
+  // these are pre-encoded with LatLonPoint's encoding and
+  // used to exclude uncompetitive hits faster.
+  int minLon = 0;
+  int maxLon = Integer.MAX_VALUE + 1;
+  int minLat = 0;
+  int maxLat = Integer.MAX_VALUE + 1;
+
+  // second set of longitude ranges to check (for cross-dateline case)
+  int minLon2 = Integer.MAX_VALUE + 1;
+
+  // the number of times setBottom has been called (adversary protection)
+  int setBottomCounter = 0;
+
+  public GeoPointDistanceComparator(String field, double latitude, double longitude, int numHits) {
+    this.field = field;
+    this.latitude = latitude;
+    this.longitude = longitude;
+    this.values = new double[numHits];
+  }
+
+  @Override
+  public void setScorer(Scorer scorer) {}
+
+  @Override
+  public int compare(int slot1, int slot2) {
+    return Double.compare(values[slot1], values[slot2]);
+  }
+
+  @Override
+  public void setBottom(int slot) {
+    bottom = values[slot];
+    // make bounding box(es) to exclude non-competitive hits, but start
+    // sampling if we get called way too much: don't make gobs of bounding
+    // boxes if comparator hits a worst case order (e.g. backwards distance order)
+    if (setBottomCounter < 1024 || (setBottomCounter & 0x3F) == 0x3F) {
+      Rectangle box = Rectangle.fromPointDistance(latitude, longitude, haversin2(bottom));
+      // pre-encode our box to our integer encoding, so we don't have to decode
+      // to double values for uncompetitive hits. This has some cost!
+      final long minHash = GeoEncodingUtils.mortonHash(box.minLat, box.minLon);
+      final long maxHash = GeoEncodingUtils.mortonHash(box.maxLat, box.maxLon);
+      minLat = (int)BitUtil.deinterleave(minHash>>>1);
+      maxLat = (int)BitUtil.deinterleave(maxHash>>>1);
+      if (box.crossesDateline()) {
+        // box1
+        minLon = 0;
+        maxLon = (int)BitUtil.deinterleave(maxHash);
+        // box2
+        minLon2 = (int)BitUtil.deinterleave(minHash);
+      } else {
+        minLon = (int)BitUtil.deinterleave(minHash);
+        maxLon = (int)BitUtil.deinterleave(maxHash);
+        // disable box2
+        minLon2 = Integer.MAX_VALUE + 1;
+      }
+    }
+    setBottomCounter++;
+  }
+
+  @Override
+  public void setTopValue(Double value) {
+    topValue = value.doubleValue();
+  }
+
+  @Override
+  public int compareBottom(int doc) throws IOException {
+    currentDocs.setDocument(doc);
+
+    int numValues = currentDocs.count();
+    if (numValues == 0) {
+      return Double.compare(bottom, Double.POSITIVE_INFINITY);
+    }
+
+    int cmp = -1;
+    for (int i = 0; i < numValues; i++) {
+      long encoded = currentDocs.valueAt(i);
+
+      // test bounding box
+      int latitudeBits = (int)(BitUtil.deinterleave(encoded>>>1));
+      if (Integer.compareUnsigned(latitudeBits, minLat) < 0 || Integer.compareUnsigned(latitudeBits, maxLat) > 0) {
+        continue;
+      }
+      int longitudeBits = (int)BitUtil.deinterleave(encoded);
+      if ((Integer.compareUnsigned(longitudeBits, minLon) < 0 || Integer.compareUnsigned(longitudeBits, maxLon) > 0)
+          && Integer.compareUnsigned(longitudeBits, minLon2) < 0) {
+        continue;
+      }
+
+      // only compute actual distance if its inside "competitive bounding box"
+      double docLat = GeoEncodingUtils.mortonUnhashLat(encoded);
+      double docLon = GeoEncodingUtils.mortonUnhashLon(encoded);
+      cmp = Math.max(cmp, Double.compare(bottom, SloppyMath.haversinSortKey(latitude, longitude, docLat, docLon)));
+      // once we compete in the PQ, no need to continue.
+      if (cmp > 0) {
+        return cmp;
+      }
+    }
+    return cmp;
+  }
+
+  @Override
+  public void copy(int slot, int doc) throws IOException {
+    values[slot] = sortKey(doc);
+  }
+
+  @Override
+  public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {
+    LeafReader reader = context.reader();
+    // TODO add checkCompatible like LatLonPoint
+    currentDocs = DocValues.getSortedNumeric(reader, field);
+    return this;
+  }
+
+  @Override
+  public Double value(int slot) {
+    return Double.valueOf(haversin2(values[slot]));
+  }
+
+  @Override
+  public int compareTop(int doc) throws IOException {
+    return Double.compare(topValue, haversin2(sortKey(doc)));
+  }
+
+  // TODO: optimize for single-valued case?
+  // TODO: do all kinds of other optimizations!
+  double sortKey(int doc) {
+    currentDocs.setDocument(doc);
+
+    double minValue = Double.POSITIVE_INFINITY;
+    int numValues = currentDocs.count();
+    for (int i = 0; i < numValues; i++) {
+      long encoded = currentDocs.valueAt(i);
+      double docLatitude = GeoEncodingUtils.mortonUnhashLat(encoded);
+      double docLongitude = GeoEncodingUtils.mortonUnhashLon(encoded);
+      minValue = Math.min(minValue, SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude));
+    }
+    return minValue;
+  }
+
+  // second half of the haversin calculation, used to convert results from haversin1 (used internally
+  // for sorting) for display purposes.
+  static double haversin2(double partial) {
+    if (Double.isInfinite(partial)) {
+      return partial;
+    }
+    return SloppyMath.haversinMeters(partial);
+  }
+}
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointDistanceSort.java b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointDistanceSort.java
new file mode 100644
index 0000000..019b905
--- /dev/null
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointDistanceSort.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.search.SortField;
+import org.apache.lucene.spatial.geopoint.document.GeoPointField;
+import org.apache.lucene.spatial.util.BaseGeoDistanceSortTestCase;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
+
+/** Simple tests for {@link GeoPointField#newDistanceSort} */
+public class TestGeoPointDistanceSort extends BaseGeoDistanceSortTestCase {
+
+  @Override
+  protected void addPointToDoc(String field, Document doc, double lat, double lon) {
+    doc.add(new GeoPointField(field, lat, lon, GeoPointField.PREFIX_TYPE_NOT_STORED));
+  }
+
+  @Override
+  protected SortField newDistanceSort(String field, double centerLat, double centerLon) {
+    return GeoPointField.newDistanceSort(field, centerLat, centerLon);
+  }
+
+  @Override
+  protected double quantizeLat(double lat) {
+    return GeoEncodingUtils.mortonUnhashLat(GeoEncodingUtils.mortonHash(lat, 0));
+  }
+
+  @Override
+  protected double quantizeLon(double lon) {
+    return GeoEncodingUtils.mortonUnhashLon(GeoEncodingUtils.mortonHash(0, lon));
+  }
+}
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoDistanceSortTestCase.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoDistanceSortTestCase.java
new file mode 100644
index 0000000..da8f5c1
--- /dev/null
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoDistanceSortTestCase.java
@@ -0,0 +1,297 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.util;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.StoredField;
+import org.apache.lucene.geo.GeoTestUtil;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.SerialMergeScheduler;
+import org.apache.lucene.search.FieldDoc;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Sort;
+import org.apache.lucene.search.SortField;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.SloppyMath;
+import org.apache.lucene.util.TestUtil;
+
+/**
+ * Abstract class for testing distance sort
+ *
+ * TODO: some of these methods are duplicated from {@link BaseGeoPointTestCase}
+ * they should instead be reused
+ */
+abstract public class BaseGeoDistanceSortTestCase extends LuceneTestCase {
+
+  protected abstract void addPointToDoc(String field, Document doc, double lat, double lon);
+
+  protected abstract SortField newDistanceSort(String field, double centerLat, double centerLon);
+
+  protected abstract double quantizeLat(final double lat);
+
+  protected abstract double quantizeLon(final double lon);
+
+  /** Add three points and sort by distance */
+  public void testDistanceSort() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+
+    // add some docs
+
+    Document doc = new Document();
+    double lat1 = 40.759011;
+    double lon1 = -73.9844722;
+    double encLat1 = quantizeLat(lat1);
+    double encLon1 = quantizeLon(lon1);
+    addPointToDoc("location", doc, lat1, lon1);
+    iw.addDocument(doc);
+
+    doc = new Document();
+    double lat2 = 40.718266;
+    double lon2 = -74.007819;
+    double encLat2 = quantizeLat(lat2);
+    double encLon2 = quantizeLon(lon2);
+    addPointToDoc("location", doc, lat2, lon2);
+    iw.addDocument(doc);
+
+    doc = new Document();
+    double lat3 = 40.7051157;
+    double lon3 = -74.0088305;
+    double encLat3 = quantizeLat(lat3);
+    double encLon3 = quantizeLon(lon3);
+    addPointToDoc("location", doc, lat3, lon3);
+    iw.addDocument(doc);
+
+    IndexReader reader = iw.getReader();
+    IndexSearcher searcher = newSearcher(reader);
+    iw.close();
+
+    double locLat = 40.7143528;
+    double locLon = -74.0059731;
+    Sort sort = new Sort(newDistanceSort("location", locLat, locLon));
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 3, sort);
+
+    FieldDoc d = (FieldDoc) td.scoreDocs[0];
+    assertEquals(SloppyMath.haversinMeters(encLat2, encLon2, locLat, locLon), (Double)d.fields[0], 0.0D);
+
+    d = (FieldDoc) td.scoreDocs[1];
+    assertEquals(SloppyMath.haversinMeters(encLat3, encLon3, locLat, locLon), (Double)d.fields[0], 0.0D);
+
+    d = (FieldDoc) td.scoreDocs[2];
+    assertEquals(SloppyMath.haversinMeters(encLat1, encLon1, locLat, locLon), (Double)d.fields[0], 0.0D);
+
+    reader.close();
+    dir.close();
+  }
+
+  /** Add two points (one doc missing) and sort by distance */
+  public void testMissingLast() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+
+    // missing
+    Document doc = new Document();
+    iw.addDocument(doc);
+
+    doc = new Document();
+    double lat1 = 40.718266;
+    double lon1 = -74.007819;
+    double encLat1 = quantizeLat(lat1);
+    double encLon1 = quantizeLon(lon1);
+    addPointToDoc("location", doc, lat1, lon1);
+    iw.addDocument(doc);
+
+    doc = new Document();
+    double lat2 = 40.7051157;
+    double lon2 = -74.0088305;
+    double encLat2 = quantizeLat(lat2);
+    double encLon2 = quantizeLon(lon2);
+    addPointToDoc("location", doc, lat2, lon2);
+    iw.addDocument(doc);
+
+    IndexReader reader = iw.getReader();
+    IndexSearcher searcher = newSearcher(reader);
+    iw.close();
+
+    double locLat = 40.7143528;
+    double locLon = -74.0059731;
+    Sort sort = new Sort(newDistanceSort("location", locLat, locLon));
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 3, sort);
+
+    FieldDoc d = (FieldDoc) td.scoreDocs[0];
+    assertEquals(SloppyMath.haversinMeters(locLat, locLon, encLat1, encLon1), (Double)d.fields[0], 0.0D);
+
+    d = (FieldDoc) td.scoreDocs[1];
+    assertEquals(SloppyMath.haversinMeters(locLat, locLon, encLat2, encLon2), (Double)d.fields[0], 0.0D);
+
+    d = (FieldDoc) td.scoreDocs[2];
+    assertEquals(Double.POSITIVE_INFINITY, (Double)d.fields[0], 0.0D);
+
+    reader.close();
+    dir.close();
+  }
+
+  /** Run a few iterations with just 10 docs, hopefully easy to debug */
+  public void testRandom() throws Exception {
+    for (int iters = 0; iters < 100; iters++) {
+      doRandomTest(10, 100);
+    }
+  }
+
+  /** Runs with thousands of docs */
+  @Nightly
+  public void testRandomHuge() throws Exception {
+    for (int iters = 0; iters < 10; iters++) {
+      doRandomTest(2000, 100);
+    }
+  }
+
+  // result class used for testing. holds an id+distance.
+  // we sort these with Arrays.sort and compare with lucene's results
+  static class Result implements Comparable<Result> {
+    int id;
+    double distance;
+
+    Result(int id, double distance) {
+      this.id = id;
+      this.distance = distance;
+    }
+
+    @Override
+    public int compareTo(Result o) {
+      int cmp = Double.compare(distance, o.distance);
+      if (cmp == 0) {
+        return Integer.compare(id, o.id);
+      }
+      return cmp;
+    }
+
+    @Override
+    public int hashCode() {
+      final int prime = 31;
+      int result = 1;
+      long temp;
+      temp = Double.doubleToLongBits(distance);
+      result = prime * result + (int) (temp ^ (temp >>> 32));
+      result = prime * result + id;
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj) return true;
+      if (obj == null) return false;
+      if (getClass() != obj.getClass()) return false;
+      Result other = (Result) obj;
+      if (Double.doubleToLongBits(distance) != Double.doubleToLongBits(other.distance)) return false;
+      if (id != other.id) return false;
+      return true;
+    }
+
+    @Override
+    public String toString() {
+      return "Result [id=" + id + ", distance=" + distance + "]";
+    }
+  }
+
+  private void doRandomTest(int numDocs, int numQueries) throws IOException {
+    Directory dir = newDirectory();
+    IndexWriterConfig iwc = newIndexWriterConfig();
+    // else seeds may not to reproduce:
+    iwc.setMergeScheduler(new SerialMergeScheduler());
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);
+
+    for (int i = 0; i < numDocs; i++) {
+      Document doc = new Document();
+      doc.add(new StoredField("id", i));
+      doc.add(new NumericDocValuesField("id", i));
+      if (random().nextInt(10) > 7) {
+        double latRaw = GeoTestUtil.nextLatitude();
+        double lonRaw = GeoTestUtil.nextLongitude();
+        addPointToDoc("field", doc, latRaw, lonRaw);
+        doc.add(new StoredField("lat", quantizeLat(latRaw)));
+        doc.add(new StoredField("lon", quantizeLon(lonRaw)));
+      } // otherwise "missing"
+      writer.addDocument(doc);
+    }
+    IndexReader reader = writer.getReader();
+    IndexSearcher searcher = newSearcher(reader);
+
+    for (int i = 0; i < numQueries; i++) {
+      double lat = GeoTestUtil.nextLatitude();
+      double lon = GeoTestUtil.nextLongitude();
+      double missingValue = Double.POSITIVE_INFINITY;
+
+      Result expected[] = new Result[reader.maxDoc()];
+
+      for (int doc = 0; doc < reader.maxDoc(); doc++) {
+        Document targetDoc = reader.document(doc);
+        final double distance;
+        if (targetDoc.getField("lat") == null) {
+          distance = missingValue; // missing
+        } else {
+          double docLatitude = targetDoc.getField("lat").numericValue().doubleValue();
+          double docLongitude = targetDoc.getField("lon").numericValue().doubleValue();
+          distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);
+        }
+        int id = targetDoc.getField("id").numericValue().intValue();
+        expected[doc] = new Result(id, distance);
+      }
+
+      Arrays.sort(expected);
+
+      // randomize the topN a bit
+      int topN = TestUtil.nextInt(random(), 1, reader.maxDoc());
+      // sort by distance, then ID
+      SortField distanceSort = newDistanceSort("field", lat, lon);
+      distanceSort.setMissingValue(missingValue);
+      Sort sort = new Sort(distanceSort,
+          new SortField("id", SortField.Type.INT));
+
+      TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), topN, sort);
+      for (int resultNumber = 0; resultNumber < topN; resultNumber++) {
+        FieldDoc fieldDoc = (FieldDoc) topDocs.scoreDocs[resultNumber];
+        Result actual = new Result((Integer) fieldDoc.fields[1], (Double) fieldDoc.fields[0]);
+        assertEquals(expected[resultNumber], actual);
+      }
+
+      // get page2 with searchAfter()
+      if (topN < reader.maxDoc()) {
+        int page2 = TestUtil.nextInt(random(), 1, reader.maxDoc() - topN);
+        TopDocs topDocs2 = searcher.searchAfter(topDocs.scoreDocs[topN - 1], new MatchAllDocsQuery(), page2, sort);
+        for (int resultNumber = 0; resultNumber < page2; resultNumber++) {
+          FieldDoc fieldDoc = (FieldDoc) topDocs2.scoreDocs[resultNumber];
+          Result actual = new Result((Integer) fieldDoc.fields[1], (Double) fieldDoc.fields[0]);
+          assertEquals(expected[topN + resultNumber], actual);
+        }
+      }
+    }
+    reader.close();
+    writer.close();
+    dir.close();
+  }
+
+}
