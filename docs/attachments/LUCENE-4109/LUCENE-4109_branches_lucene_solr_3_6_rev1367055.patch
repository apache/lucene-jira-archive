Index: lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
===================================================================
--- lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(revision 1367055)
+++ lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(working copy)
@@ -234,6 +234,15 @@
     }
   }
 
+  public void assertQueryNotEquals(String query, Analyzer a, String result)
+      throws Exception {
+    Query q = getQuery(query, a);
+    String s = q.toString("field");
+    if (s.equals(result)) {
+        fail("Query /" + query + "/ yielded /" + s + "/, expecting was something else");
+    }
+  }
+
   public void assertQueryEqualsAllowLeadingWildcard(String query, Analyzer a, String result)
       throws Exception {
     Query q = getQueryAllowLeadingWildcard(query, a);
@@ -484,8 +493,8 @@
     String query = "(field:[1 TO *] AND field:[* TO 2]) AND field2:(z)";
     BooleanQuery q = new BooleanQuery();
     BooleanQuery bq = new BooleanQuery();
-    bq.add(new TermRangeQuery("field", "1", "*", true, true), BooleanClause.Occur.MUST);
-    bq.add(new TermRangeQuery("field", "*", "2", true, true), BooleanClause.Occur.MUST);
+    bq.add(new TermRangeQuery("field", "1", null, true, true), BooleanClause.Occur.MUST);
+    bq.add(new TermRangeQuery("field", null, "2", true, true), BooleanClause.Occur.MUST);
     q.add(bq, BooleanClause.Occur.MUST);
     q.add(new TermQuery(new Term("field2", "z")), BooleanClause.Occur.MUST);
     assertEquals(q, qp.parse(query, "foo"));
@@ -655,8 +664,24 @@
     assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
     assertQueryEquals("gack ( bar blar { a TO z}) ", null,
         "gack (bar blar {a TO z})");
+    
+    assertQueryEquals("[* TO Z]",null,"[* TO z]");
+    assertQueryEquals("[A TO *]",null,"[a TO *]");
+    assertQueryEquals("[* TO *]",null,"[* TO *]");
+    
+    assertQueryEquals("[* TO \\z]",null,"[* TO z]");
+    assertQueryNotEquals("[* TO z]",null,"[\\* TO z]");
+    assertQueryEquals("[\\a TO *]",null,"[a TO *]");
+    assertQueryNotEquals("[a TO *]",null,"[a TO \\*]");
   }
 
+  public void testRangeWithPhrase() throws Exception {
+    // StandardSyntaxParser does not differentiate between a term and a
+    // one-term-phrase in a range query.
+//  assertQueryEquals("[\\* TO \"*\"]",null,"[\\* TO \\*]"); 
+    assertQueryEquals("[\\* TO \"*\"]", null, "[\\* TO *]");
+  }
+
   public void testFarsiRangeCollating() throws Exception {
     Directory ramDir = newDirectory();
     IndexWriter iw = new IndexWriter(ramDir, newIndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)));
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/BooleanModifierNode.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/BooleanModifierNode.java	(revision 1367055)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/BooleanModifierNode.java	(working copy)
@@ -19,12 +19,14 @@
 
 import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.standard.processors.BooleanQuery2ModifierNodeProcessor;
 import org.apache.lucene.queryParser.standard.processors.GroupQueryNodeProcessor;
 
 /**
  * A {@link BooleanModifierNode} has the same behaviour as
  * {@link ModifierQueryNode}, it only indicates that this modifier was added by
- * {@link GroupQueryNodeProcessor} and not by the user. <br/>
+ * {@link GroupQueryNodeProcessor} or {@link BooleanQuery2ModifierNodeProcessor}
+ * and not by the user. <br/>
  * 
  * @see ModifierQueryNode
  */
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java	(revision 1367055)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java	(working copy)
@@ -35,6 +35,7 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
 import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
 
@@ -60,6 +61,7 @@
  * @see ParametricRangeQueryNode
  */
 public class ParametricRangeQueryNodeProcessor extends QueryNodeProcessorImpl {
+  final public static String OPEN_RANGE_TOKEN = "*";
   
   public ParametricRangeQueryNodeProcessor() {
   // empty constructor
@@ -103,6 +105,8 @@
         inclusive = true;
       }
 
+      boolean dateRangeQuery = false;
+      
       String part1 = lower.getTextAsString();
       String part2 = upper.getTextAsString();
 
@@ -130,17 +134,36 @@
           // pre-1.9 Lucene versions.
           part1 = DateField.dateToString(d1);
           part2 = DateField.dateToString(d2);
-
+	  dateRangeQuery = true;
         } else {
           part1 = DateTools.dateToString(d1, dateRes);
           part2 = DateTools.dateToString(d2, dateRes);
+	  dateRangeQuery = true;
         }
       } catch (Exception e) {
         // do nothing
       }
+      if(dateRangeQuery){ 
+        lower.setText(part1);
+        upper.setText(part2);
+      } else {  //LUCENE-3338: in Version 4.X there is a Class OpenRangeQueryNodeProcessor for this purpose
+        CharSequence lowerText = lower.getText();
+        CharSequence upperText = upper.getText();
+        if (OPEN_RANGE_TOKEN.equals(upper.getTextAsString())
+            && (!(upperText instanceof UnescapedCharSequence) || !((UnescapedCharSequence) upperText)
+                .wasEscaped(0))) {
+          upperText = null;
+        }
+        
+        if (OPEN_RANGE_TOKEN.equals(lower.getTextAsString())
+            && (!(lowerText instanceof UnescapedCharSequence) || !((UnescapedCharSequence) lowerText)
+                .wasEscaped(0))) {
+          lowerText = null;
+        }
+        lower.setText(lowerText);
+        upper.setText(upperText);
+      }
 
-      lower.setText(part1);
-      upper.setText(part2);
 
       return new RangeQueryNode(lower, upper, collator);
 
