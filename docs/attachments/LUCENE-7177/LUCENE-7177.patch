diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java
index a360fdb..ecca80d 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java
@@ -17,8 +17,11 @@
 package org.apache.lucene.spatial.geopoint.search;
 
 import org.apache.lucene.geo.Rectangle;
+import org.apache.lucene.index.PointValues.Relation;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
+import org.apache.lucene.util.BitUtil;
 import org.apache.lucene.util.SloppyMath;
 
 /** Package private implementation for the public facing GeoPointDistanceQuery delegate class.
@@ -68,40 +71,44 @@ final class GeoPointDistanceQueryImpl extends GeoPointInBBoxQueryImpl {
     }
 
     @Override
-    protected boolean cellCrosses(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      // bounding box check
-      if (maxLat < GeoPointDistanceQueryImpl.this.minLat ||
-          maxLon < GeoPointDistanceQueryImpl.this.minLon ||
-          minLat > GeoPointDistanceQueryImpl.this.maxLat ||
-          minLon > GeoPointDistanceQueryImpl.this.maxLon) {
-        return false;
-      } else if ((centerLon < minLon || centerLon > maxLon) && (axisLat+ Rectangle.AXISLAT_ERROR < minLat || axisLat- Rectangle.AXISLAT_ERROR > maxLat)) {
-        if (SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, minLat, minLon) > distanceQuery.radiusMeters &&
-            SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, minLat, maxLon) > distanceQuery.radiusMeters &&
-            SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, maxLat, minLon) > distanceQuery.radiusMeters &&
-            SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, maxLat, maxLon) > distanceQuery.radiusMeters) {
-          return false;
-        }
+    protected Relation compare(long minHash, long maxHash) {
+      long minLonBits = BitUtil.deinterleave(minHash);
+      long maxLonBits = BitUtil.deinterleave(maxHash);
+      // outside of bounding box
+      if (maxLonBits < geoPointQuery.minLonMBR || minLonBits > geoPointQuery.maxLonMBR) {
+        return Relation.CELL_OUTSIDE_QUERY;
       }
-      return true;
-    }
 
-    @Override
-    protected boolean cellWithin(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      long minLatBits = BitUtil.deinterleave(minHash >>> 1);
+      long maxLatBits = BitUtil.deinterleave(maxHash >>> 1);
+      // outside of bounding box
+      if (maxLatBits < geoPointQuery.minLatMBR || minLatBits > geoPointQuery.maxLatMBR) {
+        return Relation.CELL_OUTSIDE_QUERY;
+      }
+      
+      // decode and detect INSIDE or OUTSIDE
+      double minLon = GeoEncodingUtils.unscaleLon(minLonBits);
+      double minLat = GeoEncodingUtils.unscaleLat(minLatBits);
+      double maxLon = GeoEncodingUtils.unscaleLon(maxLonBits);
+      double maxLat = GeoEncodingUtils.unscaleLat(maxLatBits);
+      
       if (maxLon - centerLon < 90 && centerLon - minLon < 90 &&
           SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, minLat, minLon) <= distanceQuery.radiusMeters &&
           SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, minLat, maxLon) <= distanceQuery.radiusMeters &&
           SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, maxLat, minLon) <= distanceQuery.radiusMeters &&
           SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, maxLat, maxLon) <= distanceQuery.radiusMeters) {
         // we are fully enclosed, collect everything within this subtree
-        return true;
+        return Relation.CELL_INSIDE_QUERY;
+      } else if ((centerLon < minLon || centerLon > maxLon) && (axisLat+ Rectangle.AXISLAT_ERROR < minLat || axisLat- Rectangle.AXISLAT_ERROR > maxLat)) {
+        if (SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, minLat, minLon) > distanceQuery.radiusMeters &&
+            SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, minLat, maxLon) > distanceQuery.radiusMeters &&
+            SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, maxLat, minLon) > distanceQuery.radiusMeters &&
+            SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, maxLat, maxLon) > distanceQuery.radiusMeters) {
+          return Relation.CELL_OUTSIDE_QUERY;
+        }
       }
-      return false;
-    }
-
-    @Override
-    protected boolean cellIntersectsShape(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      return cellCrosses(minLat, maxLat, minLon, maxLon);
+      
+      return Relation.CELL_CROSSES_QUERY;
     }
 
     /**
@@ -111,11 +118,15 @@ final class GeoPointDistanceQueryImpl extends GeoPointInBBoxQueryImpl {
      * {@link org.apache.lucene.util.SloppyMath#haversinMeters(double, double, double, double)} method.
      */
     @Override
-    protected boolean postFilter(final double lat, final double lon) {
-      // check bbox
-      if (lat < minLat || lat > maxLat || lon < minLon || lon > maxLon) {
+    protected boolean postFilter(long value) {
+      long lonBits = BitUtil.deinterleave(value);
+      long latBits = BitUtil.deinterleave(value >>> 1);
+      if (lonBits < minLonMBR || lonBits > maxLonMBR || latBits < minLatMBR || latBits > maxLatMBR) {
         return false;
       }
+      
+      double lat = GeoEncodingUtils.unscaleLat(latBits);
+      double lon = GeoEncodingUtils.unscaleLon(lonBits);
 
       // first check the partial distance, if its more than that, it can't be <= radiusMeters
       double h1 = SloppyMath.haversinSortKey(distanceQuery.centerLat, centerLon, lat, lon);
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointGrid.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointGrid.java
new file mode 100644
index 0000000..3a86a60
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointGrid.java
@@ -0,0 +1,250 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import org.apache.lucene.geo.Polygon;
+import org.apache.lucene.index.PointValues.Relation;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
+import org.apache.lucene.util.BitUtil;
+import org.apache.lucene.util.FixedBitSet;
+
+/**
+ * This is a temporary hack, until some polygon methods have better performance!
+ * <p>
+ * When this file is removed then we have made good progress! Today point-in-polygon method 
+ * is very slow (general to all polygons, linear with the number of vertices).
+ * At the same time polygon-rectangle relation operations are also slow in the same way.
+ * <p>
+ * See the "grid" algorithm description here: http://erich.realtimerendering.com/ptinpoly/
+ * A few differences:
+ * <ul>
+ *   <li> We work in an integer encoding, so edge cases are simpler.
+ *   <li> We classify each grid cell as "contained", "not contained", or "don't know".
+ *   <li> We form a grid over a potentially complex multipolygon with holes.
+ *   <li> Construction is less efficient because we do not do anything "smart" such
+ *        as following polygon edges. 
+ *   <li> Instead we construct a baby tree to reduce the number of relation operations,
+ *        which are currently expensive.
+ * </ul>
+ * <p>
+ * We also accelerate relational operations. For some rectangles, we may know the 
+ * correct answer from the grid. This is currently limited due to the grid's size
+ * (impacts the percentage of cells it knows the answer for) and the way in which
+ * this is encoded.
+ */
+// TODO: can we improve the relations tree to better work with z-encoding directly?
+//       or should we just cutover to a 2D kd tree for relations?
+final class GeoPointGrid {
+  // must be a power of two!
+  private static final int GRID_SIZE = 1<<5;
+  // bounding box of polygons
+  private final long minLat;
+  private final long maxLat;
+  private final long minLon;
+  private final long maxLon;
+  // TODO: something more efficient than parallel bitsets? maybe one bitset?
+  private final FixedBitSet haveAnswer = new FixedBitSet(GRID_SIZE * GRID_SIZE);
+  private final FixedBitSet answer = new FixedBitSet(GRID_SIZE * GRID_SIZE);
+  
+  private final long latPerCell; // latitude range per grid cell
+  private final long lonPerCell; // longitude range per grid cell
+  
+  private final Polygon[] polygons;
+  
+  // 1D "tree" for relations: these are indexed in morton space.
+  private final FixedBitSet crosses = new FixedBitSet(GRID_SIZE * GRID_SIZE);
+  private final FixedBitSet outside = new FixedBitSet(GRID_SIZE * GRID_SIZE);
+  private final FixedBitSet inside =  new FixedBitSet(GRID_SIZE * GRID_SIZE);
+  
+  GeoPointGrid(long minLat, long maxLat, long minLon, long maxLon, Polygon... polygons) {
+    this.minLat = minLat;
+    this.maxLat = maxLat;
+    this.minLon = minLon;
+    this.maxLon = maxLon;
+    this.polygons = polygons;
+    if (minLon > maxLon) {
+      // maybe make 2 grids if you want this? 
+      throw new IllegalArgumentException("Grid cannot cross the dateline");
+    }
+    if (minLat > maxLat) {
+      throw new IllegalArgumentException("bogus bounding box");
+    }
+    long latitudeRange = maxLat - minLat;
+    long longitudeRange = maxLon - minLon;
+    // we spill over the edge of the bounding box in each direction a bit,
+    // but it prevents edge case bugs.
+    latPerCell = latitudeRange / (GRID_SIZE - 1);
+    lonPerCell = longitudeRange / (GRID_SIZE - 1);
+    fill(0, GRID_SIZE, 0, GRID_SIZE);
+  }
+  
+  /** fills a 2D range of grid cells [minLatIndex .. maxLatIndex) X [minLonIndex .. maxLonIndex) */
+  private void fill(int minLatIndex, int maxLatIndex, int minLonIndex, int maxLonIndex) {
+    // Math.min because grid cells at the edge of the bounding box are smaller than normal due to spilling.
+    long cellMinLat = minLat + (minLatIndex * latPerCell);
+    long cellMaxLat = Math.min(maxLat, minLat + (maxLatIndex * latPerCell) - 1);
+    long cellMinLon = minLon + (minLonIndex * lonPerCell);
+    long cellMaxLon = Math.min(maxLon, minLon + (maxLonIndex * lonPerCell) - 1);
+
+    assert cellMinLat <= maxLat;
+    assert cellMinLon <= maxLon;
+    assert cellMaxLat >= cellMinLat;
+    assert cellMaxLon >= cellMinLon;
+
+    Relation relation = Polygon.relate(polygons, GeoEncodingUtils.unscaleLat(cellMinLat), 
+                                                 GeoEncodingUtils.unscaleLat(cellMaxLat), 
+                                                 GeoEncodingUtils.unscaleLon(cellMinLon), 
+                                                 GeoEncodingUtils.unscaleLon(cellMaxLon));
+    if (relation != Relation.CELL_CROSSES_QUERY) {
+      // we know the answer for this region, fill the cell range
+      for (int i = minLatIndex; i < maxLatIndex; i++) {
+        for (int j = minLonIndex; j < maxLonIndex; j++) {
+          int index = i * GRID_SIZE + j;
+          int zIndex = (int) BitUtil.interleave(j, i);
+          assert haveAnswer.get(index) == false;
+          assert inside.get(zIndex) == false;
+          assert outside.get(zIndex) == false;
+          assert crosses.get(zIndex) == false;
+          haveAnswer.set(index);
+          if (relation == Relation.CELL_INSIDE_QUERY) {
+            answer.set(index);
+            inside.set(zIndex);
+          } else {
+            outside.set(zIndex);
+          }
+        }
+      }
+    } else if (minLatIndex == maxLatIndex - 1) {
+      assert minLonIndex == maxLonIndex - 1;
+      int zIndex = (int) BitUtil.interleave(minLonIndex, minLatIndex);
+      assert crosses.get(zIndex) == false;
+      crosses.set(zIndex);
+      // nothing more to do: this is a single grid cell (leaf node) and
+      // is an edge case for the polygon.
+    } else {
+      // grid range crosses our polygon, keep recursing.
+      int midLatIndex = (minLatIndex + maxLatIndex) >>> 1;
+      int midLonIndex = (minLonIndex + maxLonIndex) >>> 1;
+      fill(minLatIndex, midLatIndex, minLonIndex, midLonIndex);
+      fill(minLatIndex, midLatIndex, midLonIndex, maxLonIndex);
+      fill(midLatIndex, maxLatIndex, minLonIndex, midLonIndex);
+      fill(midLatIndex, maxLatIndex, midLonIndex, maxLonIndex);
+    }
+  }
+  
+  /** Returns true if inside one of our polygons, false otherwise */
+  boolean contains(long latitude, long longitude) {
+    // first see if the grid knows the answer
+    int index = index(latitude, longitude);
+    if (index == -1) {
+      return false; // outside of bounding box range
+    } else if (haveAnswer.get(index)) {
+      return answer.get(index);
+    }
+
+    // the grid is unsure (boundary): do a real test.
+    double docLatitude = GeoEncodingUtils.unscaleLat(latitude);
+    double docLongitude = GeoEncodingUtils.unscaleLon(longitude);
+    return Polygon.contains(polygons, docLatitude, docLongitude);
+  }
+  
+  /** Returns grid index of lat/lon, or -1 if the value is outside of the bounding box. */
+  private int index(long latitude, long longitude) {
+    if (latitude < minLat || latitude > maxLat || longitude < minLon || longitude > maxLon) {
+      return -1; // outside of bounding box range
+    }
+    
+    long latRel = latitude - minLat;
+    long lonRel = longitude - minLon;
+    
+    int latIndex = (int) (latRel / latPerCell);
+    int lonIndex = (int) (lonRel / lonPerCell);
+    return latIndex * GRID_SIZE + lonIndex;
+  }
+  
+  /** Returns z-index of lat/lon. do not call for ranges outside of the bounding box. */
+  private int zIndex(long latitude, long longitude) {
+    assert latitude >= minLat && latitude <= maxLat && longitude >= minLon && longitude <= maxLon;
+    
+    long latRel = latitude - minLat;
+    long lonRel = longitude - minLon;
+    
+    int latIndex = (int) (latRel / latPerCell);
+    int lonIndex = (int) (lonRel / lonPerCell);
+    return (int) BitUtil.interleave(lonIndex, latIndex);
+  }
+  
+  /** scans bits from [minIndex .. maxIndex] and returns true if one is found */
+  private boolean scan(FixedBitSet bitset, int minIndex, int maxIndex) {
+    int index = bitset.nextSetBit(minIndex);
+    return index >= 0 && index <= maxIndex;
+  }
+
+  /** Returns relation of bounding box to these polygons */
+  Relation relate(long minLat, long maxLat, long minLon, long maxLon) {
+    // if the bounding boxes are disjoint then the shape does not cross
+    if (maxLon < this.minLon || minLon > this.maxLon || maxLat < this.minLat || minLat > this.maxLat) {
+      return Relation.CELL_OUTSIDE_QUERY;
+    }
+    // if the rectangle fully encloses us, we cross.
+    if (minLat <= this.minLat && maxLat >= this.maxLat && minLon <= this.minLon && maxLon >= this.maxLon) {
+      return Relation.CELL_CROSSES_QUERY;
+    }
+    
+    // otherwise, scan for the first set bit in crosses, inside, outside to do relations when we can.
+    // this is very coarse due to z-order space and only used to accelerate INSIDE and OUTSIDE responses.
+    // basically: we can only reason about the lack of set bits.
+    if (minLat >= this.minLat && maxLat <= this.maxLat && minLon >= this.minLon && maxLon <= this.maxLon) {
+      // its fully within our box. it stands a chance of being INSIDE
+      int lower = zIndex(minLat, minLon);
+      int upper = zIndex(maxLat, maxLon);
+      assert upper >= lower;
+      
+      // if crosses is empty then we know everything
+      if (scan(crosses, lower, upper) == false) {
+        // fully inside query
+        if (scan(outside, lower, upper) == false) {
+          return Relation.CELL_INSIDE_QUERY;
+        }
+        // fully outside query
+        if (scan(inside, lower, upper) == false) {
+          return Relation.CELL_OUTSIDE_QUERY;
+        }
+      }
+    } else {
+      // no chance of being INSIDE, at least part of rectangle is outside.
+      // just try to determine if the overlapping portion is disjoint
+      int lower = zIndex(Math.max(minLat, this.minLat), Math.max(minLon, this.minLon));
+      int upper = zIndex(Math.min(maxLat, this.maxLat), Math.min(maxLon, this.maxLon));
+      assert upper >= lower;
+      
+      // if crosses is empty then we know everything
+      if (scan(crosses, lower, upper) == false) {
+        // fully outside query
+        if (scan(inside, lower, upper) == false) {
+          return Relation.CELL_OUTSIDE_QUERY;
+        }
+      }
+    }
+    
+    // otherwise fall back to a real computation
+    return Polygon.relate(polygons, GeoEncodingUtils.unscaleLat(minLat), 
+                                    GeoEncodingUtils.unscaleLat(maxLat), 
+                                    GeoEncodingUtils.unscaleLon(minLon), 
+                                    GeoEncodingUtils.unscaleLon(maxLon));
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java
index c19e6d2..68661da 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java
@@ -16,10 +16,13 @@
  */
 package org.apache.lucene.spatial.geopoint.search;
 
+import org.apache.lucene.index.PointValues.Relation;
 import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.util.BitUtil;
 import org.apache.lucene.util.SloppyMath;
 import org.apache.lucene.spatial.geopoint.document.GeoPointField;
 import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
 import org.apache.lucene.spatial.util.GeoRelationUtils;
 
 /** Package private implementation for the public facing GeoPointInBBoxQuery delegate class.
@@ -72,32 +75,40 @@ class GeoPointInBBoxQueryImpl extends GeoPointMultiTermQuery {
       super(query);
     }
 
-    /**
-     * Determine whether the quad-cell crosses the shape
-     */
     @Override
-    protected boolean cellCrosses(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      return GeoRelationUtils.rectCrosses(minLat, maxLat, minLon, maxLon, GeoPointInBBoxQueryImpl.this.minLat,
-                                          GeoPointInBBoxQueryImpl.this.maxLat, GeoPointInBBoxQueryImpl.this.minLon, GeoPointInBBoxQueryImpl.this.maxLon);
+    protected Relation compare(long minHash, long maxHash) {
+      double minLon = GeoEncodingUtils.mortonUnhashLon(minHash);
+      double minLat = GeoEncodingUtils.mortonUnhashLat(minHash);
+      double maxLon = GeoEncodingUtils.mortonUnhashLon(maxHash);
+      double maxLat = GeoEncodingUtils.mortonUnhashLat(maxHash);
+      if (GeoRelationUtils.rectWithin(minLat, maxLat, minLon, maxLon, 
+                                      GeoPointInBBoxQueryImpl.this.minLat,
+                                      GeoPointInBBoxQueryImpl.this.maxLat,
+                                      GeoPointInBBoxQueryImpl.this.minLon, 
+                                      GeoPointInBBoxQueryImpl.this.maxLon)) {
+        return Relation.CELL_INSIDE_QUERY;
+      } else if (GeoRelationUtils.rectCrosses(minLat, maxLat, minLon, maxLon, 
+                                              GeoPointInBBoxQueryImpl.this.minLat,
+                                              GeoPointInBBoxQueryImpl.this.maxLat, 
+                                              GeoPointInBBoxQueryImpl.this.minLon, 
+                                              GeoPointInBBoxQueryImpl.this.maxLon)) {
+        return Relation.CELL_CROSSES_QUERY;
+      } else {
+        return Relation.CELL_OUTSIDE_QUERY;
+      }
     }
 
-    /**
-     * Determine whether quad-cell is within the shape
-     */
     @Override
-    protected boolean cellWithin(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      return GeoRelationUtils.rectWithin(minLat, maxLat, minLon, maxLon, GeoPointInBBoxQueryImpl.this.minLat,
-                                         GeoPointInBBoxQueryImpl.this.maxLat,
-                                         GeoPointInBBoxQueryImpl.this.minLon, GeoPointInBBoxQueryImpl.this.maxLon);
-    }
-
-    @Override
-    protected boolean cellIntersectsShape(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      return cellIntersectsMBR(minLat, maxLat, minLon, maxLon);
-    }
-
-    @Override
-    protected boolean postFilter(final double lat, final double lon) {
+    protected boolean postFilter(long value) {
+      // TODO: if we fix rounding in the encoding, we can remove post-filtering completely for box query
+      long lonBits = BitUtil.deinterleave(value);
+      long latBits = BitUtil.deinterleave(value >>> 1);
+      if (lonBits < minLonMBR || lonBits > maxLonMBR || latBits < minLatMBR || latBits > maxLatMBR) {
+        return false;
+      }
+      
+      double lat = GeoEncodingUtils.unscaleLat(latBits);
+      double lon = GeoEncodingUtils.unscaleLon(lonBits);
       return GeoRelationUtils.pointInRectPrecise(lat, lon, minLat, maxLat, minLon, maxLon);
     }
   }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java
index 14b7cc7..afef661 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java
@@ -20,6 +20,7 @@ import java.util.Objects;
 
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
+import org.apache.lucene.util.BitUtil;
 import org.apache.lucene.geo.Polygon;
 import org.apache.lucene.index.PointValues.Relation;
 
@@ -30,12 +31,14 @@ import org.apache.lucene.index.PointValues.Relation;
 final class GeoPointInPolygonQueryImpl extends GeoPointInBBoxQueryImpl {
   private final GeoPointInPolygonQuery polygonQuery;
   private final Polygon[] polygons;
+  private final GeoPointGrid grid;
 
   GeoPointInPolygonQueryImpl(final String field, final TermEncoding termEncoding, final GeoPointInPolygonQuery q,
                              final double minLat, final double maxLat, final double minLon, final double maxLon) {
     super(field, termEncoding, minLat, maxLat, minLon, maxLon);
     this.polygonQuery = Objects.requireNonNull(q);
     this.polygons = Objects.requireNonNull(q.polygons);
+    this.grid = new GeoPointGrid(minLatMBR, maxLatMBR, minLonMBR, maxLonMBR, polygons);
   }
 
   @Override
@@ -56,32 +59,21 @@ final class GeoPointInPolygonQueryImpl extends GeoPointInBBoxQueryImpl {
     GeoPolygonCellComparator(GeoPointMultiTermQuery query) {
       super(query);
     }
-
-    @Override
-    protected boolean cellCrosses(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      return Polygon.relate(polygons, minLat, maxLat, minLon, maxLon) == Relation.CELL_CROSSES_QUERY;
-    }
-
-    @Override
-    protected boolean cellWithin(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      return Polygon.relate(polygons, minLat, maxLat, minLon, maxLon) == Relation.CELL_INSIDE_QUERY;
-    }
-
+   
     @Override
-    protected boolean cellIntersectsShape(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      return Polygon.relate(polygons, minLat, maxLat, minLon, maxLon) != Relation.CELL_OUTSIDE_QUERY;
+    protected Relation compare(long minHash, long maxHash) {
+      // grid already does bbox check (grid cannot avoid this)
+      long minLon = BitUtil.deinterleave(minHash);
+      long minLat = BitUtil.deinterleave(minHash >>> 1);
+      long maxLon = BitUtil.deinterleave(maxHash);
+      long maxLat = BitUtil.deinterleave(maxHash >>> 1);
+      return grid.relate(minLat, maxLat, minLon, maxLon);
     }
 
-    /**
-     * The two-phase query approach. The parent
-     * {@link org.apache.lucene.spatial.geopoint.search.GeoPointTermsEnum#accept} method is called to match
-     * encoded terms that fall within the bounding box of the polygon. Those documents that pass the initial
-     * bounding box filter are then compared to the provided polygon using the
-     * {@link Polygon#contains(Polygon[], double, double)} method.
-     */
     @Override
-    protected boolean postFilter(final double lat, final double lon) {
-      return Polygon.contains(polygons, lat, lon);
+    protected boolean postFilter(long value) {
+      // grid already does bbox check (grid cannot avoid this)
+      return grid.contains(BitUtil.deinterleave(value >>> 1), BitUtil.deinterleave(value));
     }
   }
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java
index 20026a1..c7cdefc 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java
@@ -20,13 +20,16 @@ package org.apache.lucene.spatial.geopoint.search;
 import java.io.IOException;
 
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.PointValues.Relation;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BitUtil;
 import org.apache.lucene.spatial.geopoint.document.GeoPointField;
 import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
 import org.apache.lucene.spatial.util.GeoRelationUtils;
 import org.apache.lucene.geo.GeoUtils;
 import org.apache.lucene.util.SloppyMath;
@@ -38,7 +41,11 @@ import org.apache.lucene.util.SloppyMath;
  * @lucene.experimental
  */
 abstract class GeoPointMultiTermQuery extends MultiTermQuery {
-  // simple bounding box optimization - no objects used to avoid dependencies
+  // exposed for subclasses - no objects used to avoid dependencies
+  // these are not quantized and are the original user-provided values
+  // TODO: these really belong in the bbox impl only (for two-phase checks).
+  // but everything currently subclasses that? If we fix rounding, they can get removed
+  // that way too (bbox won't ever need two-phases).
   protected final double minLon;
   protected final double minLat;
   protected final double maxLon;
@@ -47,12 +54,22 @@ abstract class GeoPointMultiTermQuery extends MultiTermQuery {
   protected final short maxShift;
   protected final TermEncoding termEncoding;
   protected final CellComparator cellComparator;
+  
+  // these are used for low level MBR intersection tests
+  // they are currently "expanded" 1 geopoint "ulp" in each direction to compensate for rounding/overflow issues.
+  final long minLatMBR;
+  final long maxLatMBR;
+  final long minLonMBR;
+  final long maxLonMBR;
+  
+  // TODO: maybe some two-phase checks could benefit from minHashMBR/maxHashMBR? if documents have multiple values
+  // especially this can avoid deinterleave cost.
 
   /**
    * Constructs a query matching terms that cannot be represented with a single
    * Term.
    */
-  public GeoPointMultiTermQuery(String field, final TermEncoding termEncoding, final double minLat, final double maxLat, final double minLon, final double maxLon) {
+  GeoPointMultiTermQuery(String field, final TermEncoding termEncoding, final double minLat, final double maxLat, final double minLon, final double maxLon) {
     super(field);
 
     GeoUtils.checkLatitude(minLat);
@@ -64,6 +81,21 @@ abstract class GeoPointMultiTermQuery extends MultiTermQuery {
     this.maxLat = maxLat;
     this.minLon = minLon;
     this.maxLon = maxLon;
+    
+    // TODO: add scaleLatFloor/scaleLatCeil instead of increasing one ulp ?
+    // TODO: if we improve the encoding, factor this out
+    long minLatBits = GeoEncodingUtils.scaleLat(minLat);
+    long maxLatBits = GeoEncodingUtils.scaleLat(maxLat);
+    long minLonBits = GeoEncodingUtils.scaleLon(minLon);
+    long maxLonBits = GeoEncodingUtils.scaleLon(maxLon);
+    assert minLatBits >= 0 && minLatBits <= 1L + Integer.MAX_VALUE;
+    assert maxLatBits >= 0 && maxLatBits <= 1L + Integer.MAX_VALUE;
+    assert minLonBits >= 0 && minLonBits <= 1L + Integer.MAX_VALUE;
+    assert maxLonBits >= 0 && maxLonBits <= 1L + Integer.MAX_VALUE;
+    minLatMBR = Math.max(0, minLatBits-1);
+    maxLatMBR = Math.min(1L + Integer.MAX_VALUE, maxLatBits+1);
+    minLonMBR = Math.max(0, minLonBits-1);
+    maxLonMBR = Math.min(1L + Integer.MAX_VALUE, maxLonBits+1);
 
     this.maxShift = computeMaxShift();
     this.termEncoding = termEncoding;
@@ -72,7 +104,7 @@ abstract class GeoPointMultiTermQuery extends MultiTermQuery {
     this.rewriteMethod = GEO_CONSTANT_SCORE_REWRITE;
   }
 
-  public static final RewriteMethod GEO_CONSTANT_SCORE_REWRITE = new RewriteMethod() {
+  static final RewriteMethod GEO_CONSTANT_SCORE_REWRITE = new RewriteMethod() {
     @Override
     public Query rewrite(IndexReader reader, MultiTermQuery query) {
       return new GeoPointTermQueryConstantScoreWrapper<>((GeoPointMultiTermQuery)query);
@@ -120,37 +152,32 @@ abstract class GeoPointMultiTermQuery extends MultiTermQuery {
       this.geoPointQuery = query;
     }
 
-    /**
-     * Primary driver for cells intersecting shape boundaries
-     */
-    protected boolean cellIntersectsMBR(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      return GeoRelationUtils.rectIntersects(minLat, maxLat, minLon, maxLon, geoPointQuery.minLat, geoPointQuery.maxLat,
-                                             geoPointQuery.minLon, geoPointQuery.maxLon);
-    }
-
-    /**
-     * Return whether quad-cell contains the bounding box of this shape
-     */
-    protected boolean cellContains(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-      return GeoRelationUtils.rectWithin(geoPointQuery.minLat, geoPointQuery.maxLat, geoPointQuery.minLon,
-                                         geoPointQuery.maxLon, minLat, maxLat, minLon, maxLon);
+    final boolean cellIntersectsMBR(long minHash, long maxHash) {
+      long minLon = BitUtil.deinterleave(minHash);
+      long maxLon = BitUtil.deinterleave(maxHash);
+      // outside of bounding box
+      if (maxLon < geoPointQuery.minLonMBR || minLon > geoPointQuery.maxLonMBR) {
+        return false;
+      }
+
+      long minLat = BitUtil.deinterleave(minHash >>> 1);
+      long maxLat = BitUtil.deinterleave(maxHash >>> 1);
+      // outside of bounding box
+      if (maxLat < geoPointQuery.minLatMBR || minLat > geoPointQuery.maxLatMBR) {
+        return false;
+      }
+      return true;
     }
-
-    /**
-     * Determine whether the quad-cell crosses the shape
-     */
-    abstract protected boolean cellCrosses(final double minLat, final double maxLat, final double minLon, final double maxLon);
-
-    /**
-     * Determine whether quad-cell is within the shape
+    
+    /** 
+     * Called for non-leaf cells to test how the cell relates to the query, to
+     * determine how to further recurse down the tree. 
      */
-    abstract protected boolean cellWithin(final double minLat, final double maxLat, final double minLon, final double maxLon);
+    protected abstract Relation compare(long minHash, long maxHash);
 
     /**
-     * Default shape is a rectangle, so this returns the same as {@code cellIntersectsMBR}
+     * Called for leaf cells to test if the point is in the query
      */
-    abstract protected boolean cellIntersectsShape(final double minLat, final double maxLat, final double minLon, final double maxLon);
-
-    abstract protected boolean postFilter(final double lat, final double lon);
+    protected abstract boolean postFilter(long value);
   }
 }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java
index 071ab1e..d53cc82 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java
@@ -21,6 +21,7 @@ import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 
+import org.apache.lucene.index.PointValues.Relation;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.spatial.geopoint.document.GeoPointField;
 import org.apache.lucene.spatial.util.GeoEncodingUtils;
@@ -55,7 +56,7 @@ final class GeoPointNumericTermsEnum extends GeoPointTermsEnum {
   /**
    * entry point for recursively computing ranges
    */
-  private final void computeRange(long term, final short shift) {
+  private void computeRange(long term, final short shift) {
     final long split = term | (0x1L<<shift);
     assert shift < 64;
     final long upperMax;
@@ -79,42 +80,42 @@ final class GeoPointNumericTermsEnum extends GeoPointTermsEnum {
    * @param res spatial res represented as a bit shift (MSB is lower res)
    */
   private void relateAndRecurse(final long start, final long end, final short res) {
-    final double minLon = GeoEncodingUtils.mortonUnhashLon(start);
-    final double minLat = GeoEncodingUtils.mortonUnhashLat(start);
-    final double maxLon = GeoEncodingUtils.mortonUnhashLon(end);
-    final double maxLat = GeoEncodingUtils.mortonUnhashLat(end);
-
     final short level = (short)((GeoEncodingUtils.BITS<<1)-res>>>1);
 
     // if cell is within and a factor of the precision step, or it crosses the edge of the shape add the range
-    final boolean within = res % GeoPointField.PRECISION_STEP == 0 && relationImpl.cellWithin(minLat, maxLat, minLon, maxLon);
-    if (within || (level == DETAIL_LEVEL && relationImpl.cellIntersectsShape(minLat, maxLat, minLon, maxLon))) {
+    // otherwise, we only need the MBR check
+    Relation relation = Relation.CELL_OUTSIDE_QUERY;
+    if (res % GeoPointField.PRECISION_STEP == 0 || level == DETAIL_LEVEL) {
+      relation = relationImpl.compare(start, end);
+    }
+    if (relation != Relation.CELL_OUTSIDE_QUERY) {
       final short nextRes = (short)(res-1);
+      final boolean boundary = relation == Relation.CELL_CROSSES_QUERY;
       if (nextRes % GeoPointField.PRECISION_STEP == 0) {
-        rangeBounds.add(new Range(start, nextRes, !within));
-        rangeBounds.add(new Range(start|(1L<<nextRes), nextRes, !within));
+        rangeBounds.add(new Range(start, nextRes, boundary));
+        rangeBounds.add(new Range(start|(1L<<nextRes), nextRes, boundary));
       } else {
-        rangeBounds.add(new Range(start, res, !within));
+        rangeBounds.add(new Range(start, res, boundary));
       }
-    } else if (level < DETAIL_LEVEL && relationImpl.cellIntersectsMBR(minLat, maxLat, minLon, maxLon)) {
+    } else if (level < DETAIL_LEVEL && relationImpl.cellIntersectsMBR(start, end)) {
       computeRange(start, (short) (res - 1));
     }
   }
 
   @Override
-  protected final BytesRef peek() {
+  BytesRef peek() {
     rangeBounds.get(0).fillBytesRef(this.nextSubRangeBRB);
     return nextSubRangeBRB.get();
   }
 
   @Override
-  protected void nextRange() {
+  void nextRange() {
     currentRange = rangeBounds.remove(0);
     super.nextRange();
   }
 
   @Override
-  protected final BytesRef nextSeekTerm(BytesRef term) {
+  protected BytesRef nextSeekTerm(BytesRef term) {
     while (hasNext()) {
       if (currentRange == null) {
         nextRange();
@@ -136,14 +137,14 @@ final class GeoPointNumericTermsEnum extends GeoPointTermsEnum {
   }
 
   @Override
-  protected final boolean hasNext() {
+  boolean hasNext() {
     return rangeBounds.isEmpty() == false;
   }
 
   /**
    * Internal class to represent a range along the space filling curve
    */
-  protected final class Range extends BaseRange {
+  static final class Range extends BaseRange {
     Range(final long lower, final short shift, boolean boundary) {
       super(lower, shift, boundary);
     }
@@ -153,7 +154,7 @@ final class GeoPointNumericTermsEnum extends GeoPointTermsEnum {
      * quite expensive), only when we need it.
      */
     @Override
-    protected void fillBytesRef(BytesRefBuilder result) {
+    void fillBytesRef(BytesRefBuilder result) {
       assert result != null;
       LegacyNumericUtils.longToPrefixCoded(start, shift, result);
     }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
index f511392..efb1718 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
@@ -1,5 +1,7 @@
 package org.apache.lucene.spatial.geopoint.search;
 
+import org.apache.lucene.index.PointValues.Relation;
+
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -24,8 +26,6 @@ import org.apache.lucene.spatial.geopoint.document.GeoPointField;
 import org.apache.lucene.spatial.util.GeoEncodingUtils;
 
 import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonHash;
-import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonUnhashLat;
-import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonUnhashLon;
 import static org.apache.lucene.spatial.util.GeoEncodingUtils.geoCodedToPrefixCoded;
 import static org.apache.lucene.spatial.util.GeoEncodingUtils.prefixCodedToGeoCoded;
 import static org.apache.lucene.spatial.util.GeoEncodingUtils.getPrefixCodedShift;
@@ -56,7 +56,7 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
   private boolean withinOnly = false;
   private long lastWithin;
 
-  public GeoPointPrefixTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQuery query) {
+  GeoPointPrefixTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQuery query) {
     super(tenum, query);
     this.start = mortonHash(query.minLat, query.minLon);
     this.currentRange = new Range(0, shift, true);
@@ -67,14 +67,6 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
     this.currEnd = currStart | mask;
   }
 
-  private boolean within(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-    return relationImpl.cellWithin(minLat, maxLat, minLon, maxLon);
-  }
-
-  private boolean boundary(final double minLat, final double maxLat, final double minLon, final double maxLon) {
-    return shift == maxShift && relationImpl.cellIntersectsShape(minLat, maxLat, minLon, maxLon);
-  }
-
   private boolean nextWithin() {
     if (withinOnly == false) {
       return false;
@@ -90,19 +82,16 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
   }
 
   private void nextRelation() {
-    double minLon = mortonUnhashLon(currStart);
-    double minLat = mortonUnhashLat(currStart);
-    double maxLon;
-    double maxLat;
     boolean isWithin;
     do {
-      maxLon = mortonUnhashLon(currEnd);
-      maxLat = mortonUnhashLat(currEnd);
-
       isWithin = false;
+      Relation relation = Relation.CELL_OUTSIDE_QUERY;
+      if (shift == maxShift) {
+        relation = relationImpl.compare(currStart, currEnd);
+      }
       // within or a boundary
-      if (boundary(minLat, maxLat, minLon, maxLon) == true) {
-        isWithin = within(minLat, maxLat, minLon, maxLon);
+      if (relation != Relation.CELL_OUTSIDE_QUERY) {
+        isWithin = relation == Relation.CELL_INSIDE_QUERY;
         final int m;
         if (isWithin == false || (m = shift % GeoPointField.PRECISION_STEP) == 0) {
           setNextRange(isWithin == false);
@@ -118,13 +107,11 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
       }
 
       // within cell but not at a depth factor of PRECISION_STEP
-      if (isWithin == true || (relationImpl.cellIntersectsMBR(minLat, maxLat, minLon, maxLon) == true && shift != maxShift)) {
+      if (isWithin == true || (shift != maxShift && relationImpl.cellIntersectsMBR(currStart, currEnd))) {
         // descend: currStart need not change since shift handles end of range
         currEnd = currStart | (1L<<--shift) - 1;
       } else {
         advanceVariables();
-        minLon = mortonUnhashLon(currStart);
-        minLat = mortonUnhashLat(currStart);
       }
     } while(shift < 63);
   }
@@ -148,12 +135,12 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
   }
 
   @Override
-  protected final BytesRef peek() {
+  final BytesRef peek() {
     nextRange.fillBytesRef(nextSubRangeBRB);
     return super.peek();
   }
 
-  protected void seek(long term, short res) {
+  void seek(long term, short res) {
     if (term < currStart && res < maxShift) {
       throw new IllegalArgumentException("trying to seek backwards");
     } else if (term == currStart) {
@@ -166,13 +153,13 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
   }
 
   @Override
-  protected void nextRange() {
+  void nextRange() {
     hasNext = false;
     super.nextRange();
   }
 
   @Override
-  protected final boolean hasNext() {
+  boolean hasNext() {
     if (hasNext == true || nextWithin()) {
       return true;
     }
@@ -185,7 +172,7 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
   }
 
   @Override
-  protected final BytesRef nextSeekTerm(BytesRef term) {
+  protected BytesRef nextSeekTerm(BytesRef term) {
     while (hasNext()) {
       nextRange();
       if (term == null) {
@@ -225,8 +212,8 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
     return AcceptStatus.YES;
   }
 
-  protected final class Range extends BaseRange {
-    public Range(final long start, final short res, final boolean boundary) {
+  static final class Range extends BaseRange {
+    Range(final long start, final short res, final boolean boundary) {
       super(start, res, boundary);
     }
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java
index 7e97f16..ca56596 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java
@@ -32,15 +32,12 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.TwoPhaseIterator;
 import org.apache.lucene.search.Weight;
+import org.apache.lucene.spatial.geopoint.search.GeoPointMultiTermQuery.CellComparator;
 import org.apache.lucene.util.BitSet;
 import org.apache.lucene.util.DocIdSetBuilder;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.SparseFixedBitSet;
 
-import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonUnhashLat;
-import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonUnhashLon;
-
-
 /**
  * Custom ConstantScoreWrapper for {@code GeoPointMultiTermQuery} that cuts over to DocValues
  * for post filtering boundary ranges. Multi-valued GeoPoint documents are supported.
@@ -93,6 +90,7 @@ final class GeoPointTermQueryConstantScoreWrapper <Q extends GeoPointMultiTermQu
 
         final GeoPointTermsEnum termsEnum = (GeoPointTermsEnum)(query.getTermsEnum(terms, null));
         assert termsEnum != null;
+        final CellComparator comparator = termsEnum.relationImpl;
 
         LeafReader reader = context.reader();
         // approximation (postfiltering has not yet been applied)
@@ -140,7 +138,7 @@ final class GeoPointTermQueryConstantScoreWrapper <Q extends GeoPointMultiTermQu
               int count = sdv.count();
               for (int i = 0; i < count; i++) {
                 long hash = sdv.valueAt(i);
-                if (termsEnum.postFilter(mortonUnhashLat(hash), mortonUnhashLon(hash))) {
+                if (comparator.postFilter(hash)) {
                   return true;
                 }
               }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java
index d82b340..4aebf59 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java
@@ -30,14 +30,14 @@ import org.apache.lucene.spatial.geopoint.search.GeoPointMultiTermQuery.CellComp
  *  @lucene.experimental
  */
 abstract class GeoPointTermsEnum extends FilteredTermsEnum {
-  protected final short maxShift;
+  final short maxShift;
 
-  protected BaseRange currentRange;
-  protected BytesRef currentCell;
-  protected final BytesRefBuilder currentCellBRB = new BytesRefBuilder();
-  protected final BytesRefBuilder nextSubRangeBRB = new BytesRefBuilder();
+  BaseRange currentRange;
+  BytesRef currentCell;
+  final BytesRefBuilder currentCellBRB = new BytesRefBuilder();
+  final BytesRefBuilder nextSubRangeBRB = new BytesRefBuilder();
 
-  protected final CellComparator relationImpl;
+  final CellComparator relationImpl;
 
   GeoPointTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQuery query) {
     super(tenum);
@@ -54,20 +54,20 @@ abstract class GeoPointTermsEnum extends FilteredTermsEnum {
     throw new IllegalArgumentException("Invalid GeoPoint TermEncoding " + query.termEncoding);
   }
 
-  public boolean boundaryTerm() {
+  boolean boundaryTerm() {
     if (currentCell == null) {
       throw new IllegalStateException("GeoPointTermsEnum empty or not initialized");
     }
     return currentRange.boundary;
   }
 
-  protected BytesRef peek() {
+  BytesRef peek() {
     return nextSubRangeBRB.get();
   }
 
-  abstract protected boolean hasNext();
+  abstract boolean hasNext();
 
-  protected void nextRange() {
+  void nextRange() {
     currentRange.fillBytesRef(currentCellBRB);
     currentCell = currentCellBRB.get();
   }
@@ -98,17 +98,13 @@ abstract class GeoPointTermsEnum extends FilteredTermsEnum {
     return AcceptStatus.YES;
   }
 
-  protected boolean postFilter(final double lat, final double lon) {
-    return relationImpl.postFilter(lat, lon);
-  }
-
   /**
    * Internal class to represent a range along the space filling curve
    */
-  abstract class BaseRange implements Comparable<BaseRange> {
-    protected short shift;
-    protected long start;
-    protected boolean boundary;
+  abstract static class BaseRange implements Comparable<BaseRange> {
+    short shift;
+    long start;
+    boolean boundary;
 
     BaseRange(final long lower, final short shift, boolean boundary) {
       this.boundary = boundary;
@@ -120,7 +116,7 @@ abstract class GeoPointTermsEnum extends FilteredTermsEnum {
      * Encode as a BytesRef using a reusable object. This allows us to lazily create the BytesRef (which is
      * quite expensive), only when we need it.
      */
-    abstract protected void fillBytesRef(BytesRefBuilder result);
+    abstract void fillBytesRef(BytesRefBuilder result);
 
     @Override
     public int compareTo(BaseRange other) {
@@ -131,7 +127,7 @@ abstract class GeoPointTermsEnum extends FilteredTermsEnum {
       return result;
     }
 
-    protected void set(BaseRange other) {
+    void set(BaseRange other) {
       this.start = other.start;
       this.shift = other.shift;
       this.boundary = other.boundary;
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
index d2141d9..eeaaeef 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
@@ -54,7 +54,7 @@ public final class GeoEncodingUtils {
    * encode latitude, longitude geopoint values using morton encoding method
    * https://en.wikipedia.org/wiki/Z-order_curve
    */
-  public static final Long mortonHash(final double lat, final double lon) {
+  public static final long mortonHash(final double lat, final double lon) {
     return BitUtil.interleave(scaleLon(lon), scaleLat(lat));
   }
 
@@ -68,19 +68,23 @@ public final class GeoEncodingUtils {
     return unscaleLat(BitUtil.deinterleave(hash >>> 1));
   }
 
-  private static final long scaleLon(final double val) {
+  /** encode longitude value to quantized internal representation */
+  public static final long scaleLon(final double val) {
     return (long) ((val-MIN_LON_INCL) * LON_SCALE);
   }
 
-  private static final long scaleLat(final double val) {
+  /** encode latitude value to quantized internal representation */
+  public static final long scaleLat(final double val) {
     return (long) ((val-MIN_LAT_INCL) * LAT_SCALE);
   }
 
-  private static final double unscaleLon(final long val) {
+  /** decode longitude value from quantized internal representation */
+  public static final double unscaleLon(final long val) {
     return (val / LON_SCALE) + MIN_LON_INCL;
   }
 
-  private static final double unscaleLat(final long val) {
+  /** decode latitude value from quantized internal representation */
+  public static final double unscaleLat(final long val) {
     return (val / LAT_SCALE) + MIN_LAT_INCL;
   }
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java
index a54a304..a988cbb 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java
@@ -64,12 +64,4 @@ public class GeoRelationUtils {
     return !(rectDisjoint(aMinLat, aMaxLat, aMinLon, aMaxLon, bMinLat, bMaxLat, bMinLon, bMaxLon) ||
              rectWithin(aMinLat, aMaxLat, aMinLon, aMaxLon, bMinLat, bMaxLat, bMinLon, bMaxLon));
   }
-
-  /**
-   * Computes whether a rectangle intersects another rectangle (crosses, within, touching, etc)
-   */
-  public static boolean rectIntersects(final double aMinLat, final double aMaxLat, final double aMinLon, final double aMaxLon,
-                                       final double bMinLat, final double bMaxLat, final double bMinLon, final double bMaxLon) {
-    return !((aMaxLon < bMinLon || aMinLon > bMaxLon || aMaxLat < bMinLat || aMinLat > bMaxLat));
-  }
 }
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointGrid.java b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointGrid.java
new file mode 100644
index 0000000..673a048
--- /dev/null
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointGrid.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import org.apache.lucene.geo.GeoTestUtil;
+import org.apache.lucene.geo.Polygon;
+import org.apache.lucene.geo.Rectangle;
+import org.apache.lucene.index.PointValues.Relation;
+import org.apache.lucene.spatial.geopoint.search.GeoPointGrid;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+
+/** tests against GeoPointGrid (avoiding indexing/queries) */
+public class TestGeoPointGrid extends LuceneTestCase {
+
+  /** contains() should always be consistent with underlying polygon */
+  public void testContainsRandom() throws Exception {
+    for (int i = 0; i < 100; i++) {
+      Polygon polygon = GeoTestUtil.nextPolygon();
+      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });
+      long minLat = GeoEncodingUtils.scaleLat(box.minLat);
+      long maxLat = GeoEncodingUtils.scaleLat(box.maxLat);
+      long minLon = GeoEncodingUtils.scaleLon(box.minLon);
+      long maxLon = GeoEncodingUtils.scaleLon(box.maxLon);
+      GeoPointGrid grid = new GeoPointGrid(minLat, maxLat, minLon, maxLon, polygon);
+      // we are in integer space... but exhaustive testing is slow!
+      // these checks are all inside the bounding box of the polygon!
+      for (int j = 0; j < 5000; j++) {
+        long lat = TestUtil.nextLong(random(), minLat, maxLat);
+        long lon = TestUtil.nextLong(random(), minLon, maxLon);
+
+        boolean expected = polygon.contains(GeoEncodingUtils.unscaleLat(lat), 
+                                            GeoEncodingUtils.unscaleLon(lon));
+        boolean actual = grid.contains(lat, lon);
+        assertEquals(expected, actual);
+      }
+      // check some truly random points too
+      for (int j = 0; j < 5000; j++) {
+        long lat = TestUtil.nextLong(random(), 0, Integer.MAX_VALUE);
+        long lon = TestUtil.nextLong(random(), 0, Integer.MAX_VALUE);
+
+        boolean expected = polygon.contains(GeoEncodingUtils.unscaleLat(lat), 
+                                            GeoEncodingUtils.unscaleLon(lon));
+        boolean actual = grid.contains(lat, lon);
+        assertEquals(expected, actual);
+      }
+    }
+  }
+  
+  /** relate() should always be consistent with underlying polygon */
+  public void testRelateRandom() throws Exception {
+    for (int i = 0; i < 100; i++) {
+      Polygon polygon = GeoTestUtil.nextPolygon();
+      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });
+      long minLat = GeoEncodingUtils.scaleLat(box.minLat);
+      long maxLat = GeoEncodingUtils.scaleLat(box.maxLat);
+      long minLon = GeoEncodingUtils.scaleLon(box.minLon);
+      long maxLon = GeoEncodingUtils.scaleLon(box.maxLon);
+      GeoPointGrid grid = new GeoPointGrid(minLat, maxLat, minLon, maxLon, polygon);
+      // we are in integer space... but exhaustive testing is slow!
+      // these checks are all inside the bounding box of the polygon!
+      for (int j = 0; j < 5000; j++) {
+        long lat1 = TestUtil.nextLong(random(), minLat, maxLat);
+        long lat2 = TestUtil.nextLong(random(), minLat, maxLat);
+        long lon1 = TestUtil.nextLong(random(), minLon, maxLon);
+        long lon2 = TestUtil.nextLong(random(), minLon, maxLon);
+        
+        long cellMinLat = Math.min(lat1, lat2);
+        long cellMaxLat = Math.max(lat1, lat2);
+        long cellMinLon = Math.min(lon1, lon2);
+        long cellMaxLon = Math.max(lon1, lon2);
+
+        Relation expected = Polygon.relate(new Polygon[] { polygon }, GeoEncodingUtils.unscaleLat(cellMinLat), 
+                                                                      GeoEncodingUtils.unscaleLat(cellMaxLat), 
+                                                                      GeoEncodingUtils.unscaleLon(cellMinLon), 
+                                                                      GeoEncodingUtils.unscaleLon(cellMaxLon));
+        Relation actual = grid.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);
+        if (actual != Relation.CELL_CROSSES_QUERY) {
+          assertEquals(expected, actual);
+        }
+      }
+      // check some truly random points too
+      for (int j = 0; j < 5000; j++) {
+        long lat1 = TestUtil.nextLong(random(), 0, Integer.MAX_VALUE);
+        long lat2 = TestUtil.nextLong(random(), 0, Integer.MAX_VALUE);
+        long lon1 = TestUtil.nextLong(random(), 0, Integer.MAX_VALUE);
+        long lon2 = TestUtil.nextLong(random(), 0, Integer.MAX_VALUE);
+        
+        long cellMinLat = Math.min(lat1, lat2);
+        long cellMaxLat = Math.max(lat1, lat2);
+        long cellMinLon = Math.min(lon1, lon2);
+        long cellMaxLon = Math.max(lon1, lon2);
+
+        Relation expected = Polygon.relate(new Polygon[] { polygon }, GeoEncodingUtils.unscaleLat(cellMinLat), 
+                                                                      GeoEncodingUtils.unscaleLat(cellMaxLat), 
+                                                                      GeoEncodingUtils.unscaleLon(cellMinLon), 
+                                                                      GeoEncodingUtils.unscaleLon(cellMaxLon));
+        Relation actual = grid.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);
+        if (actual != Relation.CELL_CROSSES_QUERY) {
+          assertEquals(expected, actual);
+        }
+      }
+    }
+  }
+}
