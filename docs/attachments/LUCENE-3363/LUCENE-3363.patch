Index: lucene/src/test/org/apache/lucene/search/TestAutomatonQuery.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestAutomatonQuery.java	(revision 1154943)
+++ lucene/src/test/org/apache/lucene/search/TestAutomatonQuery.java	(working copy)
@@ -154,9 +154,7 @@
     assertEquals(a1, a2);
     
     assertEquals(a1, a3);
-    
-    assertEquals(a1.toString(), a3.toString());
-    
+  
     // different class
     AutomatonQuery w1 = new WildcardQuery(newTerm("foobar"));
     // different class
Index: lucene/src/test/org/apache/lucene/index/TestTermsEnum2.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestTermsEnum2.java	(revision 1154943)
+++ lucene/src/test/org/apache/lucene/index/TestTermsEnum2.java	(working copy)
@@ -49,8 +49,6 @@
 import org.apache.lucene.util.automaton.RegExp;
 import org.apache.lucene.util.automaton.SpecialOperations;
 
-import org.junit.Ignore;
-
 public class TestTermsEnum2 extends LuceneTestCase {
   private Directory dir;
   private IndexReader reader;
@@ -97,8 +95,6 @@
   }
   
   /** tests a pre-intersected automaton against the original */
-  // nocommit -- OOME w/ ant test-core -Dtestcase=TestTermsEnum2 -Dtestmethod=testFiniteVersusInfinite -Dtests.seed=-2577608857970454726:-2463580050179334504
-  @Ignore
   public void testFiniteVersusInfinite() throws Exception {
     for (int i = 0; i < numIterations; i++) {
       String reg = AutomatonTestUtil.randomRegexp(random);
@@ -111,7 +107,7 @@
       }
 
       Automaton alternate = DaciukMihovAutomatonBuilder.build(matchedTerms);
-      //System.out.println("match " + matchedTerms.size() + " " + alternate.getNumberOfStates() + " states");
+      //System.out.println("match " + matchedTerms.size() + " " + alternate.getNumberOfStates() + " states, sigma=" + alternate.getStartPoints().length);
       //AutomatonTestUtil.minimizeSimple(alternate);
       //System.out.println("minmize done");
       AutomatonQuery a1 = new AutomatonQuery(new Term("field", ""), automaton);
Index: lucene/src/java/org/apache/lucene/search/WildcardQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/WildcardQuery.java	(revision 1154943)
+++ lucene/src/java/org/apache/lucene/search/WildcardQuery.java	(working copy)
@@ -23,9 +23,6 @@
 import org.apache.lucene.util.automaton.BasicAutomata;
 import org.apache.lucene.util.automaton.BasicOperations;
 
-import java.util.ArrayList;
-import java.util.List;
-
 /** Implements the wildcard search query. Supported wildcards are <code>*</code>, which
  * matches any character sequence (including the empty one), and <code>?</code>,
  * which matches any single character. Note this query can be slow, as it
@@ -61,35 +58,37 @@
    */
   @SuppressWarnings("fallthrough")
   public static Automaton toAutomaton(Term wildcardquery) {
-    List<Automaton> automata = new ArrayList<Automaton>();
+    Automaton automaton = null;
     
     String wildcardText = wildcardquery.text();
     
     for (int i = 0; i < wildcardText.length();) {
+      Automaton a;
       final int c = wildcardText.codePointAt(i);
       int length = Character.charCount(c);
       switch(c) {
         case WILDCARD_STRING: 
-          automata.add(BasicAutomata.makeAnyString());
+          a = BasicAutomata.makeAnyString();
           break;
         case WILDCARD_CHAR:
-          automata.add(BasicAutomata.makeAnyChar());
+          a = BasicAutomata.makeAnyChar();
           break;
         case WILDCARD_ESCAPE:
           // add the next codepoint instead, if it exists
           if (i + length < wildcardText.length()) {
             final int nextChar = wildcardText.codePointAt(i + length);
             length += Character.charCount(nextChar);
-            automata.add(BasicAutomata.makeChar(nextChar));
+            a = BasicAutomata.makeChar(nextChar);
             break;
           } // else fallthru, lenient parsing with a trailing \
         default:
-          automata.add(BasicAutomata.makeChar(c));
+          a = BasicAutomata.makeChar(c);
       }
       i += length;
+      automaton = (automaton == null) ? a : BasicOperations.concatenate(automaton, a);
     }
     
-    return BasicOperations.concatenate(automata);
+    return automaton == null ? BasicAutomata.makeEmpty() : automaton;
   }
   
   /**
Index: lucene/src/java/org/apache/lucene/search/AutomatonQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/AutomatonQuery.java	(revision 1154943)
+++ lucene/src/java/org/apache/lucene/search/AutomatonQuery.java	(working copy)
@@ -28,7 +28,6 @@
 import org.apache.lucene.util.automaton.BasicAutomata;
 import org.apache.lucene.util.automaton.BasicOperations;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
-import org.apache.lucene.util.automaton.MinimizationOperations;
 import org.apache.lucene.util.automaton.SpecialOperations;
 
 /**
@@ -41,7 +40,7 @@
  * the standard Lucene wildcard syntax with {@link WildcardQuery}.
  * </p>
  * <p>
- * When the query is executed, it will create an equivalent minimal DFA of the
+ * When the query is executed, it will create an equivalent DFA of the
  * finite-state machine, and will enumerate the term dictionary in an
  * intelligent way to reduce the number of comparisons. For example: the regular
  * expression of <code>[dl]og?</code> will make approximately four comparisons:
@@ -78,7 +77,9 @@
     super(term.field());
     this.term = term;
     this.automaton = automaton;
-    MinimizationOperations.minimize(automaton);
+    automaton.determinize();
+    automaton.removeDeadTransitions();
+    automaton.reduce(); // this is not necessary, but might improve intersection speed
     
     if (BasicOperations.isEmpty(automaton)) {
       // matches nothing
