Index: lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java	(revision 1661819)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java	(working copy)
@@ -566,6 +566,14 @@
   private static boolean segmentWasUpgraded(Directory directory, SegmentInfo si) {
     // Check marker file:
     String markerFileName = IndexFileNames.segmentFileName(si.name, "upgraded", Lucene3xSegmentInfoFormat.UPGRADED_SI_EXTENSION);
+
+    // LUCENE-6279: don't rely solely on existence of the marker file; also require that we see the marker
+    // file in our si.files(), which means we did previously at least attempt to write it:
+    if (si.files().contains(markerFileName) == false) {
+      return false;
+    }
+
+    // Also verify the marker file exists and has the proper header:
     IndexInput in = null;
     try {
       in = directory.openInput(markerFileName, IOContext.READONCE);
@@ -580,6 +588,7 @@
         IOUtils.closeWhileHandlingException(in);
       }
     }
+
     return false;
   }
 
Index: lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility3x.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility3x.java	(revision 1661819)
+++ lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility3x.java	(working copy)
@@ -29,6 +29,7 @@
 import java.util.Random;
 
 import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.DoubleDocValuesField;
@@ -53,6 +54,9 @@
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.BaseDirectoryWrapper;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.store.MockDirectoryWrapper;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
@@ -1015,4 +1019,25 @@
       dir.close();
     }
   }
+
+  // LUCENE-6279
+  public void testLeftoverUpgradedFile() throws Exception {
+    Directory dir = newDirectory(random(), oldIndexDirs.get("362.cfs"));
+    if (dir instanceof MockDirectoryWrapper) {
+      // We intentionally double-write the upgrade marker file:
+      ((MockDirectoryWrapper) dir).setPreventDoubleWrite(false);
+    }
+    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));
+
+    // Create errant leftover file, after opening IW but before closing IW:
+    IndexOutput out = dir.createOutput("_0_upgraded.si", IOContext.DEFAULT);
+    CodecUtil.writeHeader(out, "SegmentInfo3xUpgrade", 0);
+    out.close();
+
+    writer.addDocument(new Document());
+    writer.close();
+
+    // Causes FNFE on _0.si during check index before the fix:
+    dir.close();
+  }
 }
