diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/SinkTokenStream.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/SinkTokenStream.java
new file mode 100644
index 0000000..bf53950
--- /dev/null
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/SinkTokenStream.java
@@ -0,0 +1,74 @@
+package org.apache.lucene.analysis.sinks;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Objects;
+
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.util.AttributeSource;
+
+/**
+ * A {@link TokenStream} that is prefilled by adding token attribute states.
+ * This can a.o. be used to split an input token stream into multiple {@link SinkTokenStream}s.
+ * To cache a complete input token stream,
+ * a {@link org.apache.lucene.analysis.CachingTokenFilter} can be used.
+ */
+public class SinkTokenStream extends TokenStream {
+
+  private final TokenStates cachedStates;
+  private Iterator<AttributeSource.State> it = null;
+
+  /** A SinkTokenStream.
+   * @param source See {@link TokenStream#TokenStream(AttributeSource)}.
+   * @param cachedStates The token states to be provided.
+   */
+  public SinkTokenStream(AttributeSource source, TokenStates cachedStates) {
+    super(source);
+    this.cachedStates = Objects.requireNonNull(cachedStates);
+  }
+
+  /** Prepare the token stream to provide the given token states. */
+  @Override
+  public final void reset() throws IOException {
+    super.reset();
+    it = cachedStates.getStates();
+  }
+
+  /** Restore the next token state.
+   * @return true iff such a token state was available.
+   */
+  @Override
+  public final boolean incrementToken() {
+    if (!it.hasNext()) {
+      return false;
+    }
+
+    AttributeSource.State state = it.next();
+    restoreState(state);
+    return true;
+  }
+
+  /** Restore the final token state if available. */
+  @Override
+  public final void end() {
+    restoreState(cachedStates.getFinalState());
+  }
+}
+
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TeeSinkTokenFilter.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TeeSinkTokenFilter.java
index 5c30c59..8b19436 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TeeSinkTokenFilter.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TeeSinkTokenFilter.java
@@ -62,7 +62,7 @@ import org.apache.lucene.util.AttributeSource;
  */
 public final class TeeSinkTokenFilter extends TokenFilter {
 
-  private final States cachedStates = new States();
+  private TokenStates cachedStates = new TokenStates();
 
   public TeeSinkTokenFilter(TokenStream input) {
     super(input);
@@ -70,18 +70,26 @@ public final class TeeSinkTokenFilter extends TokenFilter {
 
   /** Returns a new {@link SinkTokenStream} that receives all tokens consumed by this stream. */
   public TokenStream newSinkTokenStream() {
-    return new SinkTokenStream(this.cloneAttributes(), cachedStates);
+    return new SinkTokenStream(this.cloneAttributes(), cachedStates); // share cachedStates
   }
 
   /**
-   * <code>TeeSinkTokenFilter</code> passes all tokens to the added sinks when itself is consumed. To be sure that all
-   * tokens from the input stream are passed to the sinks, you can call this methods. This instance is exhausted after
-   * this method returns, but all sinks are instant available.
+   * Consume all tokens, and thereby pass all normal tokens to the added sinks.
+   * This instance is exhausted after this method returns,
+   * but all sinks are instantly available except possibly for the final state,
+   * see {@link #end()}.
    */
   public void consumeAllTokens() throws IOException {
     while (incrementToken()) {}
   }
 
+  /**
+   * {@inheritDoc}
+   * <p>
+   * <b>NOTE:</b>
+   * This also sets aside the attribute state of the input stream when available.
+   * Therefore be sure call <code>super.incrementToken()</code> when overriding this method.
+   */
   @Override
   public boolean incrementToken() throws IOException {
     if (input.incrementToken()) {
@@ -92,81 +100,26 @@ public final class TeeSinkTokenFilter extends TokenFilter {
     return false;
   }
 
+  /**
+   * {@inheritDoc}
+   * <p>
+   * <b>NOTE:</b>
+   * This also sets aside the final token state.
+   * Therefore be sure to call <code>super.end()</code> when overriding this method.
+   */
   @Override
-  public final void end() throws IOException {
+  public void end() throws IOException {
     super.end();
     cachedStates.setFinalState(captureState());
   }
 
+  /** Release the token states that were set aside.
+   *  Do not call {@link #newSinkTokenStream} afterwards.
+   *  This also calls {@link TokenFilter#close()}.
+   */
   @Override
-  public void reset() throws IOException {
-    cachedStates.reset();
-    super.reset();
-  }
-
-  /** TokenStream output from a tee. */
-  public static final class SinkTokenStream extends TokenStream {
-    private final States cachedStates;
-    private Iterator<AttributeSource.State> it = null;
-
-    private SinkTokenStream(AttributeSource source, States cachedStates) {
-      super(source);
-      this.cachedStates = cachedStates;
-    }
-
-    @Override
-    public final boolean incrementToken() {
-      if (!it.hasNext()) {
-        return false;
-      }
-
-      AttributeSource.State state = it.next();
-      restoreState(state);
-      return true;
-    }
-
-    @Override
-    public void end() throws IOException {
-      State finalState = cachedStates.getFinalState();
-      if (finalState != null) {
-        restoreState(finalState);
-      }
-    }
-
-    @Override
-    public final void reset() {
-      it = cachedStates.getStates();
-    }
-  }
-
-  /** A convenience wrapper for storing the cached states as well the final state of the stream. */
-  private static final class States {
-
-    private final List<State> states = new ArrayList<>();
-    private State finalState;
-
-    public States() {}
-
-    void setFinalState(State finalState) {
-      this.finalState = finalState;
+  public final void close() throws IOException {
+    super.close();
+    cachedStates = null;
   }
-
-    State getFinalState() {
-      return finalState;
-    }
-
-    void add(State state) {
-      states.add(state);
-    }
-
-    Iterator<State> getStates() {
-      return states.iterator();
-    }
-
-    void reset() {
-      finalState = null;
-      states.clear();
-    }
-  }
-
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TokenStates.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TokenStates.java
new file mode 100644
index 0000000..0151908
--- /dev/null
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TokenStates.java
@@ -0,0 +1,57 @@
+package org.apache.lucene.analysis.sinks;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.util.AttributeSource.State;
+
+/** A convenience wrapper for setting aside the normal and final attribute states of a TokenStream.
+ *  Use {@link SinkTokenStream} to provide a new token stream from these states.
+ */
+public class TokenStates {
+
+  private final List<State> states = new ArrayList<>();
+  private State finalState;
+
+  public TokenStates() {}
+
+  public void add(State state) {
+    states.add(state);
+  }
+
+  public void setFinalState(State finalState) {
+    this.finalState = finalState;
+  }
+
+  public Iterator<State> getStates() {
+    return states.iterator();
+  }
+
+  public State getFinalState() {
+    return finalState;
+  }
+
+}
+
+
