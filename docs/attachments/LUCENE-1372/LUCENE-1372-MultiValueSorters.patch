Index: src/java/org/apache/lucene/search/ExtendedFieldCacheImpl.java
===================================================================
--- src/java/org/apache/lucene/search/ExtendedFieldCacheImpl.java	(revision 749477)
+++ src/java/org/apache/lucene/search/ExtendedFieldCacheImpl.java	(working copy)
@@ -30,13 +30,13 @@
  *
  **/
 class ExtendedFieldCacheImpl extends FieldCacheImpl implements ExtendedFieldCache {
-  private static final LongParser LONG_PARSER = new LongParser() {
+  static final LongParser LONG_PARSER = new LongParser() {
       public long parseLong(String value) {
         return Long.parseLong(value);
       }
   };
 
-  private static final DoubleParser DOUBLE_PARSER = new DoubleParser() {
+  static final DoubleParser DOUBLE_PARSER = new DoubleParser() {
       public double parseDouble(String value) {
         return Double.parseDouble(value);
       }
Index: src/java/org/apache/lucene/search/FieldCacheImpl.java
===================================================================
--- src/java/org/apache/lucene/search/FieldCacheImpl.java	(revision 749477)
+++ src/java/org/apache/lucene/search/FieldCacheImpl.java	(working copy)
@@ -138,26 +138,26 @@
     }
   }
 
-  private static final ByteParser BYTE_PARSER = new ByteParser() {
+  static final ByteParser BYTE_PARSER = new ByteParser() {
     public byte parseByte(String value) {
       return Byte.parseByte(value);
     }
   };
 
-  private static final ShortParser SHORT_PARSER = new ShortParser() {
+  static final ShortParser SHORT_PARSER = new ShortParser() {
     public short parseShort(String value) {
       return Short.parseShort(value);
     }
   };
 
-  private static final IntParser INT_PARSER = new IntParser() {
+  static final IntParser INT_PARSER = new IntParser() {
       public int parseInt(String value) {
         return Integer.parseInt(value);
       }
   };
 
 
-  private static final FloatParser FLOAT_PARSER = new FloatParser() {
+  static final FloatParser FLOAT_PARSER = new FloatParser() {
       public float parseFloat(String value) {
         return Float.parseFloat(value);
       }
@@ -390,8 +390,8 @@
 
           termDocs.seek (termEnum);
           while (termDocs.next()) {
-            retArray[termDocs.doc()] = t;
-          }
+              retArray[termDocs.doc()] = t;
+            }
 
           t++;
         } while (termEnum.next());
Index: src/java/org/apache/lucene/search/MultiValueSorters.java
===================================================================
--- src/java/org/apache/lucene/search/MultiValueSorters.java	(revision 0)
+++ src/java/org/apache/lucene/search/MultiValueSorters.java	(revision 0)
@@ -0,0 +1,299 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.text.Collator;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Locale;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermDocs;
+import org.apache.lucene.index.TermEnum;
+import org.apache.lucene.search.FieldCache.FloatParser;
+import org.apache.lucene.search.FieldCache.IntParser;
+import org.apache.lucene.search.FieldCache.Parser;
+import org.apache.lucene.search.FieldCacheImpl.Cache;
+import org.apache.lucene.search.FieldCacheImpl.Entry;
+
+public class MultiValueSorters {
+  public static final SortComparatorSource forFieldType(int type) {
+    return buildComparatorSource(type, null, getDefaultParser(type));
+  }
+
+  public static final SortComparatorSource forFieldType(int type, Parser parser) {
+    return buildComparatorSource(type, null, parser);
+  }
+
+  public static final SortComparatorSource forStringField(Locale locale) {
+    return buildComparatorSource(SortField.STRING, locale, null);
+  }
+
+  private static final SortComparatorSource buildComparatorSource(int type,
+      Locale locale, Parser parser) {
+    
+    if (locale != null) {
+      // Locale-specific String comparison only
+	final Collator collator = Collator.getInstance(locale);
+	return new MultiValueComparatorSource(type, multiStringsCache, parser, locale) {
+	  public int compareValues(Object o1, Object o2) {
+	    return collator.compare(o1, o2);
+	  }
+	};
+    }
+    
+    Cache cache;
+    
+    switch (type) {
+    case SortField.FLOAT:
+      cache = multiFloatsCache;
+      break;
+
+    case SortField.INT:
+      cache = multiIntsCache;
+      break;
+
+    case SortField.LONG:
+      cache = multiLongsCache;
+      break;
+
+    case SortField.DOUBLE:
+      cache = multiDoublesCache;
+      break;
+
+    case SortField.SHORT:
+      cache = multiShortsCache;
+      break;
+
+    case SortField.BYTE:
+      cache = multiBytesCache;
+      break;
+
+    case SortField.STRING:
+      cache = multiStringsCache;
+      break;
+
+    default:
+      throw new IllegalArgumentException(
+	  "cannot use multi-value comparator for type " + type);
+    }
+    
+    return new MultiValueComparatorSource(type, cache, parser, locale);
+  }
+
+  private static Parser getDefaultParser(int type) {
+    switch (type) {
+    case SortField.FLOAT:
+      return FieldCacheImpl.FLOAT_PARSER;
+    case SortField.INT:
+      return FieldCacheImpl.INT_PARSER;
+    case SortField.LONG:
+      return ExtendedFieldCacheImpl.LONG_PARSER;
+    case SortField.DOUBLE:
+      return ExtendedFieldCacheImpl.DOUBLE_PARSER;
+    case SortField.SHORT:
+      return ExtendedFieldCacheImpl.SHORT_PARSER;
+    case SortField.BYTE:
+      return ExtendedFieldCacheImpl.BYTE_PARSER;
+    case SortField.STRING:
+      // Strings don't need a parser
+      return null;
+    default:
+      throw new IllegalArgumentException(
+	  "cannot use determine default parser for type " + type);
+    }
+  }
+
+  private static final Cache multiFloatsCache = new MultiValueCache() {
+    protected Object parseValue(Parser parser, String text) {
+      return Float.valueOf(((FloatParser) parser).parseFloat(text));
+    }
+  };
+
+  private static final Cache multiIntsCache = new MultiValueCache() {
+    protected Object parseValue(Parser parser, String text) {
+      return Integer.valueOf(((IntParser) parser).parseInt(text));
+    }
+  };
+
+  private static final Cache multiLongsCache = new MultiValueCache() {
+    protected Object parseValue(Parser parser, String text) {
+      return Long.valueOf(((ExtendedFieldCacheImpl.LongParser) parser)
+	  .parseLong(text));
+    }
+  };
+
+  private static final Cache multiDoublesCache = new MultiValueCache() {
+    protected Object parseValue(Parser parser, String text) {
+      return Double.valueOf(((ExtendedFieldCacheImpl.DoubleParser) parser)
+	  .parseDouble(text));
+    }
+  };
+
+  private static final Cache multiShortsCache = new MultiValueCache() {
+    protected Object parseValue(Parser parser, String text) {
+      return Short.valueOf(((ExtendedFieldCacheImpl.ShortParser) parser)
+	  .parseShort(text));
+    }
+  };
+
+  private static final Cache multiBytesCache = new MultiValueCache() {
+    protected Object parseValue(Parser parser, String text) {
+      return Byte.valueOf(((ExtendedFieldCacheImpl.ByteParser) parser)
+	  .parseByte(text));
+    }
+  };
+
+  private static final Cache multiStringsCache = new MultiValueCache() {
+    protected Object parseValue(Parser parser, String text) {
+      // Parser ignored for Strings
+      return text;
+    }
+  };
+
+  private static class MultiValueComparatorSource implements SortComparatorSource {
+    private final int sortType;
+    private final Cache cache;
+    private final Parser parser;
+    private final Locale locale;
+
+    protected MultiValueComparatorSource(int sortType, Cache cache, Parser parser,
+	Locale locale) {
+      this.sortType = sortType;
+      this.cache = cache;
+      this.parser = parser;
+      this.locale = locale;
+    }
+
+    public ScoreDocComparator newComparator(IndexReader reader, String fieldName)
+	throws IOException {
+      final List[] values = getValuesForField(reader, fieldName.intern());
+      final Comparator compare = getComparator();
+      for (int i = 0; i < values.length; i++) {
+	if (values[i] == null) {
+	  values[i] = Collections.EMPTY_LIST;
+	} else {
+	  Collections.sort(values[i], compare);
+	}
+      }
+      return new ScoreDocComparator() {
+	public final int compare(final ScoreDoc i, final ScoreDoc j) {
+	  final List fi = values[i.doc];
+	  final List fj = values[j.doc];
+	  if (fi.isEmpty()) {
+	    return fj.isEmpty() ? 0 : -1;
+	  }
+	  if (fj.isEmpty()) {
+	    return 1;
+	  }
+	  int index = 0;
+	  while (index < fi.size() && index < fj.size()) {
+	    int result = compare.compare(fi.get(index), fj.get(index));
+	    if (result != 0) {
+	      return result;
+	    }
+	    index++;
+	  }
+	  if (fi.size() == fj.size()) {
+	    return 0;
+	  }
+	  return fi.size() < fj.size() ? -1 : 1;
+	}
+
+	public int sortType() {
+	  return sortType;
+	}
+
+	public Comparable sortValue(ScoreDoc i) {
+	  // TODO Auto-generated method stub
+	  return null;
+	}
+      };
+    }
+
+    public List[] getValuesForField(IndexReader reader, String fieldName)
+	throws IOException {
+      return (List[]) cache.get(reader, new Entry(fieldName, parser));
+    }
+
+    private Comparator getComparator() {
+      return new Comparator() {
+
+	public int compare(Object o1, Object o2) {
+	  return compareValues(o1, o2);
+	}
+      };
+    }
+
+
+    public boolean equals(Object obj) {
+      // For equality and hashCode purposes (and hence valid caching in the
+      // FieldSortedHitQueue) any parsers provided must implement hashCode and
+      // equals correctly (or be unique so that identity equality is acceptable)
+      if (!(obj instanceof MultiValueComparatorSource)) {
+	return false;
+      }
+      MultiValueComparatorSource other = (MultiValueComparatorSource) obj;
+      return (this.sortType == other.sortType) &&
+	  (this.parser == null ? other.parser == null : this.parser
+	      .equals(other.parser)) &&
+	  (this.locale == null ? other.locale == null : this.locale
+	      .equals(other.locale));
+    }
+
+    public int hashCode() {
+      int prime = 137;
+      return (((parser == null) ? 0 : parser.hashCode()) * prime + sortType) *
+	  prime + (locale == null ? 0 : locale.hashCode());
+    }
+
+    public int compareValues(Object o1, Object o2) {
+      // Must be overridden if objects returned by cache do not implement
+      // Comparable or comparison must be done in a different way.
+      return ((Comparable) o1).compareTo(o2);
+    }
+  }
+
+  /**
+   * Very similar to the caches in FieldCacheImpl, but returns a List[] of
+   * size maxDoc, where each array slot holds either null (no terms for that
+   * doc) or a List of an appropriate object type. Returned list will be
+   * ordered purely lexicographically (term storage order)
+   */
+  private abstract static class MultiValueCache extends Cache {
+    protected Object createValue(IndexReader reader, Object entryKey)
+	throws IOException {
+      Entry entry = (Entry) entryKey;
+      String field = entry.field;
+      Parser parser = (Parser) entry.custom;
+      final List[] retArray = new List[reader.maxDoc()];
+      TermDocs termDocs = reader.termDocs();
+      TermEnum termEnum = reader.terms(new Term(field));
+      try {
+	do {
+	  Term term = termEnum.term();
+	  if (term == null || term.field() != field)
+	    break;
+	  Object termVal = parseValue(parser, term.text());
+	  termDocs.seek(termEnum);
+	  while (termDocs.next()) {
+	    List current = retArray[termDocs.doc()];
+	    if (current == null) {
+	      current = new ArrayList();
+	      retArray[termDocs.doc()] = current;
+	    }
+	    retArray[termDocs.doc()].add(termVal);
+	  }
+	} while (termEnum.next());
+      } finally {
+	termDocs.close();
+	termEnum.close();
+      }
+      return retArray;
+    }
+
+    protected abstract Object parseValue(Parser parser, String text);
+  }
+}
\ No newline at end of file

Property changes on: src/java/org/apache/lucene/search/MultiValueSorters.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: src/test/org/apache/lucene/search/MultiValueSortersTest.java
===================================================================
--- src/test/org/apache/lucene/search/MultiValueSortersTest.java	(revision 0)
+++ src/test/org/apache/lucene/search/MultiValueSortersTest.java	(revision 0)
@@ -0,0 +1,141 @@
+package org.apache.lucene.search;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Locale;
+
+import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class MultiValueSortersTest extends LuceneTestCase {
+  protected IndexReader reader;
+  private static final String MULTI_VALUE_FIELD = "multi";
+  private static final String[][] FLOAT_VALUES = new String[][] {
+      new String[] { "0.1", "0.2" }, new String[] { "0.1" },
+      new String[] { ".15" }, new String[] { "0.9", "0.12" }, new String[] {} };
+
+  private static final String[][] INT_VALUES = new String[][] {
+      new String[] { "1", "2" }, new String[] { "1" }, new String[] { "015" },
+      new String[] { "9", "4" }, new String[] {} };
+
+  private static final String[][] STRING_VALUES = new String[][] {
+      new String[] { "péché", "poisson" }, new String[] { "péché" },
+      new String[] { "toujours" }, new String[] { "zèbre", "pêche" },
+      new String[] {} };
+
+  public MultiValueSortersTest(String s) {
+    super(s);
+  }
+
+  private void index(String[][] values) throws IOException {
+    RAMDirectory directory = new RAMDirectory();
+    IndexWriter writer = new IndexWriter(directory, new WhitespaceAnalyzer(),
+	true, IndexWriter.MaxFieldLength.LIMITED);
+    for (int i = 0; i < values.length; i++) {
+      Document doc = new Document();
+      for (int j = 0; j < values[i].length; j++) {
+	doc.add(new Field(MULTI_VALUE_FIELD, values[i][j], Field.Store.YES,
+	    Field.Index.TOKENIZED));
+      }
+      writer.addDocument(doc);
+    }
+    writer.close();
+    reader = IndexReader.open(directory);
+  }
+
+  public void testGetStringIndexesMultiValuesFloat() throws IOException {
+    runTest(FLOAT_VALUES, MultiValueSorters.forFieldType(SortField.FLOAT),
+	"41032");
+  }
+
+  public void testGetStringIndexesMultiValuesInt() throws IOException {
+    runTest(INT_VALUES, MultiValueSorters.forFieldType(SortField.INT), "41032");
+  }
+
+  public void testGetStringIndexesMultiValuesLong() throws IOException {
+    runTest(INT_VALUES, MultiValueSorters.forFieldType(SortField.LONG), "41032");
+  }
+
+  public void testGetStringIndexesMultiValuesDouble() throws IOException {
+    runTest(FLOAT_VALUES, MultiValueSorters.forFieldType(SortField.DOUBLE),
+	"41032");
+  }
+
+  public void testGetStringIndexesMultiValuesByte() throws IOException {
+    runTest(INT_VALUES, MultiValueSorters.forFieldType(SortField.BYTE), "41032");
+  }
+
+  public void testGetStringIndexesMultiValuesShort() throws IOException {
+    runTest(INT_VALUES, MultiValueSorters.forFieldType(SortField.SHORT),
+	"41032");
+  }
+
+  public void testGetStringIndexesMultiValuesString() throws IOException {
+    SortComparatorSource source = MultiValueSorters.forStringField(null);
+    runTest(INT_VALUES, source, "42103");
+    runTest(FLOAT_VALUES, source, "42103");
+    // Binary sort of Strings puts 'poisson' before 'péché'
+    runTest(STRING_VALUES, source, "40132");
+  }
+
+  public void testGetStringIndexesMultiValuesStringLocale() throws IOException {
+    SortComparatorSource sourceEnglish = MultiValueSorters
+	.forStringField(Locale.US);
+    runTest(INT_VALUES, sourceEnglish, "42103");
+    runTest(FLOAT_VALUES, sourceEnglish, "42103");
+    // English sorts 'péché' before 'pêche'
+    runTest(STRING_VALUES, sourceEnglish, "41032");
+
+    SortComparatorSource sourceFrench = MultiValueSorters
+	.forStringField(Locale.FRANCE);
+    runTest(INT_VALUES, sourceFrench, "42103");
+    runTest(FLOAT_VALUES, sourceFrench, "42103");
+    // French sorts 'pêche' before 'péché'
+    runTest(STRING_VALUES, sourceFrench, "43102");
+  }
+
+  private void runTest(String[][] values, SortComparatorSource source,
+      String expectedOrder) throws IOException {
+    index(values);
+    IndexSearcher searcher = new IndexSearcher(reader);
+    Hits search = searcher.search(new MatchAllDocsQuery(), new Sort(
+	new SortField(MULTI_VALUE_FIELD, source)));
+    String results = "";
+    String detail = "";
+    for (int i = 0; i < search.length(); i++) {
+      Document hit = search.doc(i);
+      results += search.id(i);
+      detail += "[";
+      Field[] fields = hit.getFields(MULTI_VALUE_FIELD);
+      for (int j = 0; j < fields.length; j++) {
+	if (j > 0) {
+	  detail += ",";
+	}
+	detail += fields[j].stringValue();
+      }
+      detail += "]";
+    }
+    assertEquals("Order " + detail + " did not match expected", expectedOrder,
+	results);
+  }
+}
\ No newline at end of file

Property changes on: src/test/org/apache/lucene/search/MultiValueSortersTest.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

