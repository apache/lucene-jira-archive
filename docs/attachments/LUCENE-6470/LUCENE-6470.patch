Index: lucene/core/src/java/org/apache/lucene/index/PrefixCodedTerms.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/PrefixCodedTerms.java	(revision 1678166)
+++ lucene/core/src/java/org/apache/lucene/index/PrefixCodedTerms.java	(working copy)
@@ -62,22 +62,27 @@
 
     /** add a term */
     public void add(Term term) {
-      assert lastTerm.equals(new Term("")) || term.compareTo(lastTerm) > 0;
+      add(term.field(), term.bytes());
+    }
 
+    /** add a term */
+    public void add(String field, BytesRef bytes) {
+      assert lastTerm.equals(new Term("")) || new Term(field, bytes).compareTo(lastTerm) > 0;
+
       try {
-        int prefix = sharedPrefix(lastTerm.bytes, term.bytes);
-        int suffix = term.bytes.length - prefix;
-        if (term.field.equals(lastTerm.field)) {
+        int prefix = sharedPrefix(lastTerm.bytes, bytes);
+        int suffix = bytes.length - prefix;
+        if (field.equals(lastTerm.field)) {
           output.writeVInt(prefix << 1);
         } else {
           output.writeVInt(prefix << 1 | 1);
-          output.writeString(term.field);
+          output.writeString(field);
         }
         output.writeVInt(suffix);
-        output.writeBytes(term.bytes.bytes, term.bytes.offset + prefix, suffix);
-        lastTermBytes.copyBytes(term.bytes);
+        output.writeBytes(bytes.bytes, bytes.offset + prefix, suffix);
+        lastTermBytes.copyBytes(bytes);
         lastTerm.bytes = lastTermBytes.get();
-        lastTerm.field = term.field;
+        lastTerm.field = field;
       } catch (IOException e) {
         throw new RuntimeException(e);
       }
Index: lucene/queries/src/java/org/apache/lucene/queries/TermsQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/TermsQuery.java	(revision 1678166)
+++ lucene/queries/src/java/org/apache/lucene/queries/TermsQuery.java	(working copy)
@@ -21,8 +21,8 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.List;
 import java.util.Set;
+import java.util.SortedSet;
 
 import org.apache.lucene.index.Fields;
 import org.apache.lucene.index.LeafReader;
@@ -46,6 +46,7 @@
 import org.apache.lucene.util.BitDocIdSet;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.ToStringUtils;
 
@@ -76,22 +77,17 @@
   private final PrefixCodedTerms termData;
   private final int termDataHashCode; // cached hashcode of termData
 
-  private static Term[] toTermArray(String field, List<BytesRef> termBytes) {
-    Term[] array = new Term[termBytes.size()];
-    int i = 0;
-    for (BytesRef t : termBytes) {
-      array[i++] = new Term(field, t);
-    }
-    return array;
-  }
-
   /**
-   * Creates a new {@link TermsQuery} from the given list. The list
+   * Creates a new {@link TermsQuery} from the given collection. It
    * can contain duplicate terms and multiple fields.
    */
-  public TermsQuery(final List<Term> terms) {
+  public TermsQuery(Collection<Term> terms) {
     Term[] sortedTerms = terms.toArray(new Term[terms.size()]);
-    ArrayUtil.timSort(sortedTerms);
+    // already sorted if we are a SortedSet with natural order
+    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;
+    if (!sorted) {
+      ArrayUtil.timSort(sortedTerms);
+    }
     PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();
     Term previous = null;
     for (Term term : sortedTerms) {
@@ -103,13 +99,27 @@
     termData = builder.finish();
     termDataHashCode = termData.hashCode();
   }
-
+  
   /**
-   * Creates a new {@link TermsQuery} from the given {@link BytesRef} list for
-   * a single field.
+   * Creates a new {@link TermsQuery} from the given collection for
+   * a single field. It can contain duplicate terms.
    */
-  public TermsQuery(final String field, final List<BytesRef> terms) {
-    this(toTermArray(field, terms));
+  public TermsQuery(String field, Collection<BytesRef> terms) {
+    BytesRef[] sortedTerms = terms.toArray(new BytesRef[terms.size()]);
+    ArrayUtil.timSort(sortedTerms);
+    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();
+    BytesRefBuilder previous = null;
+    for (BytesRef term : sortedTerms) {
+      if (previous == null) {
+        previous = new BytesRefBuilder();
+      } else if (previous.get().equals(term)) {
+        continue; // deduplicate
+      }
+      builder.add(field, term);
+      previous.copyBytes(term);
+    }
+    termData = builder.finish();
+    termDataHashCode = termData.hashCode();
   }
 
   /**
@@ -116,8 +126,7 @@
    * Creates a new {@link TermsQuery} from the given {@link BytesRef} array for
    * a single field.
    */
-  public TermsQuery(final String field, final BytesRef...terms) {
-    // this ctor prevents unnecessary Term creations
+  public TermsQuery(String field, BytesRef...terms) {
    this(field, Arrays.asList(terms));
   }
 
