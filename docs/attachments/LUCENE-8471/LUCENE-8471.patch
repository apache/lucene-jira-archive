diff --git a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java
index cbbf22ea7a..136bd81bd3 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java
@@ -762,4 +762,11 @@ final class DocumentsWriter implements Closeable, Accountable {
   public long ramBytesUsed() {
     return flushControl.ramBytesUsed();
   }
+
+  /**
+   * Returns the number of bytes currently being flushed
+   */
+  public long getFlushingBytes() {
+    return flushControl.getFlushingBytes();
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java
index ad5b7e461f..5b6f8afe9c 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java
@@ -47,7 +47,7 @@ final class DocumentsWriterFlushControl implements Accountable {
 
   private final long hardMaxBytesPerDWPT;
   private long activeBytes = 0;
-  private long flushBytes = 0;
+  private volatile long flushBytes = 0;
   private volatile int numPending = 0;
   private int numDocsSinceStalled = 0; // only with assert
   final AtomicBoolean flushDeletes = new AtomicBoolean(false);
@@ -86,7 +86,7 @@ final class DocumentsWriterFlushControl implements Accountable {
     return activeBytes;
   }
 
-  public synchronized long flushBytes() {
+  public long getFlushingBytes() {
     return flushBytes;
   }
 
@@ -257,11 +257,11 @@ final class DocumentsWriterFlushControl implements Accountable {
       if (stall != stallControl.anyStalledThreads()) {
         if (stall) {
           infoStream.message("DW", String.format(Locale.ROOT, "now stalling flushes: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b",
-                                                 netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));
+                                                 netBytes()/1024./1024., getFlushingBytes()/1024./1024., fullFlush));
           stallStartNS = System.nanoTime();
         } else {
           infoStream.message("DW", String.format(Locale.ROOT, "done stalling flushes for %.1f msec: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b",
-                                                 (System.nanoTime()-stallStartNS)/1000000., netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));
+                                                 (System.nanoTime()-stallStartNS)/1000000., netBytes()/1024./1024., getFlushingBytes()/1024./1024., fullFlush));
         }
       }
     }
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index dc16885a14..5affd85485 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -570,6 +570,14 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable,
     return docWriter.ramBytesUsed();
   }
 
+  /**
+   * Returns the number of bytes currently being flushed
+   */
+  public final long getFlushingBytes() {
+    ensureOpen();
+    return docWriter.getFlushingBytes();
+  }
+
   final long getReaderPoolRamBytesUsed() {
     return readerPool.ramBytesUsed();
   }
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestFlushByRamOrCountsPolicy.java b/lucene/core/src/test/org/apache/lucene/index/TestFlushByRamOrCountsPolicy.java
index ca5aba8d94..fa6cfa947a 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestFlushByRamOrCountsPolicy.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestFlushByRamOrCountsPolicy.java
@@ -81,7 +81,7 @@ public class TestFlushByRamOrCountsPolicy extends LuceneTestCase {
     DocumentsWriter docsWriter = writer.getDocsWriter();
     assertNotNull(docsWriter);
     DocumentsWriterFlushControl flushControl = docsWriter.flushControl;
-    assertEquals(" bytes must be 0 after init", 0, flushControl.flushBytes());
+    assertEquals(" bytes must be 0 after init", 0, writer.getFlushingBytes());
 
     IndexThread[] threads = new IndexThread[numThreads];
     for (int x = 0; x < threads.length; x++) {
@@ -95,7 +95,7 @@ public class TestFlushByRamOrCountsPolicy extends LuceneTestCase {
     }
     final long maxRAMBytes = (long) (iwc.getRAMBufferSizeMB() * 1024. * 1024.);
     assertEquals(" all flushes must be due numThreads=" + numThreads, 0,
-        flushControl.flushBytes());
+        writer.getFlushingBytes());
     assertEquals(numDocumentsToIndex, writer.numDocs());
     assertEquals(numDocumentsToIndex, writer.maxDoc());
     assertTrue("peak bytes without flush exceeded watermark",
@@ -136,7 +136,7 @@ public class TestFlushByRamOrCountsPolicy extends LuceneTestCase {
       DocumentsWriter docsWriter = writer.getDocsWriter();
       assertNotNull(docsWriter);
       DocumentsWriterFlushControl flushControl = docsWriter.flushControl;
-      assertEquals(" bytes must be 0 after init", 0, flushControl.flushBytes());
+      assertEquals(" bytes must be 0 after init", 0, writer.getFlushingBytes());
 
       IndexThread[] threads = new IndexThread[numThreads[i]];
       for (int x = 0; x < threads.length; x++) {
@@ -150,7 +150,7 @@ public class TestFlushByRamOrCountsPolicy extends LuceneTestCase {
       }
 
       assertEquals(" all flushes must be due numThreads=" + numThreads[i], 0,
-          flushControl.flushBytes());
+          writer.getFlushingBytes());
       assertEquals(numDocumentsToIndex, writer.numDocs());
       assertEquals(numDocumentsToIndex, writer.maxDoc());
       assertTrue("peak bytes without flush exceeded watermark",
@@ -182,7 +182,7 @@ public class TestFlushByRamOrCountsPolicy extends LuceneTestCase {
     assertNotNull(docsWriter);
     DocumentsWriterFlushControl flushControl = docsWriter.flushControl;
 
-    assertEquals(" bytes must be 0 after init", 0, flushControl.flushBytes());
+    assertEquals(" bytes must be 0 after init", 0, writer.getFlushingBytes());
 
     IndexThread[] threads = new IndexThread[numThreads];
     for (int x = 0; x < threads.length; x++) {
@@ -194,7 +194,7 @@ public class TestFlushByRamOrCountsPolicy extends LuceneTestCase {
     for (int x = 0; x < threads.length; x++) {
       threads[x].join();
     }
-    assertEquals(" all flushes must be due", 0, flushControl.flushBytes());
+    assertEquals(" all flushes must be due", 0, writer.getFlushingBytes());
     assertEquals(numDocumentsToIndex, writer.numDocs());
     assertEquals(numDocumentsToIndex, writer.maxDoc());
     if (flushPolicy.flushOnRAM() && !flushPolicy.flushOnDocCount()) {
@@ -255,7 +255,7 @@ public class TestFlushByRamOrCountsPolicy extends LuceneTestCase {
       DocumentsWriter docsWriter = writer.getDocsWriter();
       assertNotNull(docsWriter);
       DocumentsWriterFlushControl flushControl = docsWriter.flushControl;
-      assertEquals(" all flushes must be due", 0, flushControl.flushBytes());
+      assertEquals(" all flushes must be due", 0, writer.getFlushingBytes());
       assertEquals(numDocumentsToIndex, writer.numDocs());
       assertEquals(numDocumentsToIndex, writer.maxDoc());
       if (numThreads[i] == 1) {
