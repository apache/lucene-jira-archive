Index: src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java
===================================================================
--- src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java	(révision 1149488)
+++ src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java	(copie de travail)
@@ -29,6 +29,7 @@
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.DisjunctionMaxQuery;
 import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.vectorhighlight.FieldTermStack.TermInfo;
@@ -95,11 +96,64 @@
         if( pq.getTerms().length > 1 )
           flatQueries.add( pq );
         else if( pq.getTerms().length == 1 ){
-          flatQueries.add( new TermQuery( pq.getTerms()[0] ) );
+          flatten( new TermQuery( pq.getTerms()[0] ), flatQueries );
         }
       }
     }
-    // else discard queries
+    else if( sourceQuery instanceof MultiPhraseQuery ){
+      if( !flatQueries.contains( sourceQuery ) ){
+        MultiPhraseQuery mpq = (MultiPhraseQuery)sourceQuery;
+        Query rewritten = mpq.rewrite(null);
+        if (rewritten != mpq) {
+          flatten( rewritten, flatQueries );
+        } else {
+          // Create term combinations to rewrite into multiple PhraseQuery
+          // so that expand() can work properly
+          List<Term[]> termArrays = mpq.getTermArrays();
+          int size = termArrays.size();
+          int[] positions = mpq.getPositions();
+          int[] counts = new int[termArrays.size()];
+          int[] counter = new int[termArrays.size()];
+          int i = 0;
+          for (Term[] termArray : termArrays)
+            counts[i++] = termArray.length;
+          // Counting loop (each digit has a different maximum value)
+          boolean continuing = true;
+          while (continuing) {
+            // Handle current combination (does not skip 0-0-0-...-0)
+            PhraseQuery pq = new PhraseQuery();
+            pq.setSlop(mpq.getSlop());
+            for (i = 0 ; i < size ; ++i)
+              pq.add(termArrays.get(i)[counter[i]], positions[i]);
+            flatten( pq, flatQueries );
+            // Increment counter
+            for (i = size-1 ; i >= 0 ; i--) {
+              if (++counter[i] >= counts[i])
+                if (i > 0)
+                  counter[i] = 0;
+                else {
+                  continuing = false;
+                  break;
+                }
+              else
+                break;
+            }
+          }
+        }
+      }
+    }
+    else {
+      // Fallback to using extracted terms
+      Set<Term> terms = new HashSet<Term>();
+      try {
+          sourceQuery.extractTerms(terms);
+      } catch (UnsupportedOperationException ignore) {
+          return; // ignore error and discard query
+      }
+      for (Term term : terms) {
+        flatten( new TermQuery(term), flatQueries );
+      }
+    }
   }
   
   /*
Index: ../CHANGES.txt
===================================================================
--- ../CHANGES.txt	(révision 1149488)
+++ ../CHANGES.txt	(copie de travail)
@@ -55,6 +55,10 @@
    
 Bug Fixes
 
+ * LUCENE-3332: Expansion of MultiPhraseQuerys into PhraseQuerys (generates combination, costly).
+   Default handling of highlighting for FastVectorHighlither
+   using extracted terms. (Olivier Favre)
+ 
  * LUCENE-3045: fixed QueryNodeImpl.containsTag(String key) that was
    not lowercasing the key before checking for the tag (Adriano Crestani)
 
