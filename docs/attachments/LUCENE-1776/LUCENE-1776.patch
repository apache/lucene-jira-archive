Index: CHANGES.txt
===================================================================
--- CHANGES.txt	(revision 800193)
+++ CHANGES.txt	(working copy)
@@ -647,6 +647,12 @@
     3.0 and will then replace the current core QueryParser, which
     has been deprecated with this patch.
     (Luis Alves and Adriano Campos via Michael Busch)
+    
+36. LUCENE-1776: Add an option to not collect payloads for an ordered
+    SpanNearQuery. Payloads were not lazily loaded in this case as
+    the javadocs implied. If you have payloads and want to use an ordered
+    SpanNearQuery that does not need to use the payloads, you can
+    disable loading them with a new contructor switch.  (Mark Miller)
    
 Optimizations
 
Index: src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
===================================================================
--- src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(revision 800193)
+++ src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(working copy)
@@ -72,8 +72,13 @@
   };
   
   private SpanNearQuery query;
+  private boolean collectPayloads;
+  
+  public NearSpansOrdered(SpanNearQuery spanNearQuery, IndexReader reader) throws IOException {
+    this(spanNearQuery, reader, true);
+  }
 
-  public NearSpansOrdered(SpanNearQuery spanNearQuery, IndexReader reader)
+  public NearSpansOrdered(SpanNearQuery spanNearQuery, IndexReader reader, boolean collectPayloads)
   throws IOException {
     if (spanNearQuery.getClauses().length < 2) {
       throw new IllegalArgumentException("Less than 2 clauses: "
@@ -101,6 +106,7 @@
   public int end() { return matchEnd; }
 
   // TODO: Remove warning after API has been finalized
+  // TODO: Would be nice to be able to lazy load payloads
   public Collection/*<byte[]>*/ getPayload() throws IOException {
     return matchPayload;
   }
@@ -122,7 +128,9 @@
       }
       more = true;
     }
-    matchPayload.clear();
+    if(collectPayloads) {
+      matchPayload.clear();
+    }
     return advanceAfterOrdered();
   }
 
@@ -145,7 +153,9 @@
         return false;
       }
     }
-    matchPayload.clear();
+    if(collectPayloads) {
+      matchPayload.clear();
+    }
     return advanceAfterOrdered();
   }
   
@@ -250,7 +260,7 @@
     int lastEnd = matchEnd;
     for (int i = subSpans.length - 2; i >= 0; i--) {
       PayloadSpans prevSpans = subSpans[i];
-      if (prevSpans.isPayloadAvailable()) {
+      if (collectPayloads && prevSpans.isPayloadAvailable()) {
         Collection payload = prevSpans.getPayload();
         possiblePayload = new ArrayList(payload.size());
         possiblePayload.addAll(payload);
@@ -274,7 +284,7 @@
           } else { // prevSpans still before (lastStart, lastEnd)
             prevStart = ppStart;
             prevEnd = ppEnd;
-            if (prevSpans.isPayloadAvailable()) {
+            if (collectPayloads && prevSpans.isPayloadAvailable()) {
               Collection payload = prevSpans.getPayload();
               possiblePayload = new ArrayList(payload.size());
               possiblePayload.addAll(payload);
@@ -283,7 +293,7 @@
         }
       }
 
-      if (possiblePayload != null) {
+      if (collectPayloads && possiblePayload != null) {
         possibleMatchPayloads.addAll(possiblePayload);
       }
       
@@ -302,7 +312,7 @@
     
     boolean match = matchSlop <= allowedSlop;
     
-    if(match && possibleMatchPayloads.size() > 0) {
+    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {
       matchPayload.addAll(possibleMatchPayloads);
     }
 
Index: src/java/org/apache/lucene/search/spans/PayloadSpans.java
===================================================================
--- src/java/org/apache/lucene/search/spans/PayloadSpans.java	(revision 800193)
+++ src/java/org/apache/lucene/search/spans/PayloadSpans.java	(working copy)
@@ -33,9 +33,11 @@
    * This is invalid until {@link #next()} is called for
    * the first time.
    * This method must not be called more than once after each call
-   * of {@link #next()}. However, payloads are loaded lazily,
+   * of {@link #next()}. However, most SpanQuerys load payloads lazily,
    * so if the payload data for the current position is not needed,
-   * this method may not be called at all for performance reasons.<br>
+   * this method may not be called at all for performance reasons.
+   * The ordered case of SpanNearQuery does not load lazily and has
+   * an option to turn off payload loading.<br>
    * <br>
     * Note that the return type is a collection, thus the ordering should not be relied upon.
     * <br/>
Index: src/java/org/apache/lucene/search/spans/SpanNearQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(revision 800193)
+++ src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(working copy)
@@ -39,12 +39,17 @@
   private boolean inOrder;
 
   private String field;
+  private boolean collectPayloads;
 
   /** Construct a SpanNearQuery.  Matches spans matching a span from each
    * clause, with up to <code>slop</code> total unmatched positions between
    * them.  * When <code>inOrder</code> is true, the spans from each clause
    * must be * ordered as in <code>clauses</code>. */
   public SpanNearQuery(SpanQuery[] clauses, int slop, boolean inOrder) {
+    this(clauses, slop, inOrder, true);     
+  }
+  
+  public SpanNearQuery(SpanQuery[] clauses, int slop, boolean inOrder, boolean collectPayloads) {
 
     // copy clauses array into an ArrayList
     this.clauses = new ArrayList(clauses.length);
@@ -57,7 +62,7 @@
       }
       this.clauses.add(clause);
     }
-
+    this.collectPayloads = collectPayloads;
     this.slop = slop;
     this.inOrder = inOrder;
   }
@@ -126,7 +131,7 @@
       return ((SpanQuery)clauses.get(0)).getPayloadSpans(reader);
 
     return inOrder
-            ? (PayloadSpans) new NearSpansOrdered(this, reader)
+            ? (PayloadSpans) new NearSpansOrdered(this, reader, collectPayloads)
             : (PayloadSpans) new NearSpansUnordered(this, reader);
   }
 

