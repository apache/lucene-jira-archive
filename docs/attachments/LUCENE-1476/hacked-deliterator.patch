Index: src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentReader.java	(revision 739232)
+++ src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -405,12 +405,28 @@
       }
     }
   }
+
+  protected int[] deletedDocIDs;
   
   private void loadDeletedDocs() throws IOException {
     // NOTE: the bitvector is stored using the regular directory, not cfs
     if (hasDeletions(si)) {
       deletedDocs = new BitVector(directory(), si.getDelFileName());
-     
+
+      if (deletedDocs.count() > 0) {
+        deletedDocIDs = new int[1+deletedDocs.count()];
+        // nocommit -- hideously inefficient:
+        int upto = 0;
+        for(int i=0;i<maxDoc();i++) {
+          if (deletedDocs.get(i)) {
+            deletedDocIDs[upto++] = i;
+          }
+        }
+        deletedDocIDs[upto++] = Integer.MAX_VALUE;
+      } else {
+        deletedDocIDs = new int[] {Integer.MAX_VALUE};
+      }
+
       assert si.getDelCount() == deletedDocs.count() : 
         "delete count mismatch: info=" + si.getDelCount() + " vs BitVector=" + deletedDocs.count();
 
@@ -419,8 +435,10 @@
       assert si.getDelCount() <= maxDoc() : 
         "delete count mismatch: " + deletedDocs.count() + ") exceeds max doc (" + maxDoc() + ") for segment " + si.name;
 
-    } else
+    } else {
       assert si.getDelCount() == 0;
+      deletedDocIDs = new int[] {Integer.MAX_VALUE};
+    }
   }
   
   protected synchronized DirectoryIndexReader doReopen(SegmentInfos infos) throws CorruptIndexException, IOException {
Index: src/java/org/apache/lucene/index/SegmentTermDocs.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentTermDocs.java	(revision 739232)
+++ src/java/org/apache/lucene/index/SegmentTermDocs.java	(working copy)
@@ -42,12 +42,14 @@
   
   protected boolean currentFieldStoresPayloads;
   protected boolean currentFieldOmitTf;
-  
+  private final int[] deletedDocIDs;
+
   protected SegmentTermDocs(SegmentReader parent) {
     this.parent = parent;
     this.freqStream = (IndexInput) parent.freqStream.clone();
     synchronized (parent) {
       this.deletedDocs = parent.deletedDocs;
+      deletedDocIDs = parent.deletedDocIDs;
     }
     this.skipInterval = parent.tis.getSkipInterval();
     this.maxSkipLevels = parent.tis.getMaxSkipLevels();
@@ -75,6 +77,10 @@
     seek(ti, term);
   }
 
+  int delUpto;
+
+  private int nextDelDoc;
+  
   void seek(TermInfo ti, Term term) throws IOException {
     count = 0;
     FieldInfo fi = parent.fieldInfos.fieldInfo(term.field);
@@ -90,6 +96,8 @@
       skipPointer = freqBasePointer + ti.skipOffset;
       freqStream.seek(freqBasePointer);
       haveSkipped = false;
+      nextDelDoc = deletedDocIDs[0];
+      delUpto = 0;
     }
   }
 
@@ -124,8 +132,18 @@
       
       count++;
 
-      if (deletedDocs == null || !deletedDocs.get(doc))
+      if (doc > nextDelDoc) {
+        nextDelDoc(doc);
+      }
+
+      if (doc < nextDelDoc) {
         break;
+      } else {
+        nextDelDoc();
+        //System.out.println("  nd2 " + nextDelDoc);
+      }
+        //if (deletedDocs == null || !deletedDocs.get(doc))
+        //break;
       skippingDoc();
     }
     return true;
@@ -149,16 +167,45 @@
           freq = freqStream.readVInt();     // else read freq
         count++;
 
+        /*
         if (deletedDocs == null || !deletedDocs.get(doc)) {
           docs[i] = doc;
           freqs[i] = freq;
           ++i;
         }
+        */
+
+        if (doc > nextDelDoc) {
+          nextDelDoc(doc);
+        }
+
+        if (doc < nextDelDoc) {
+          docs[i] = doc;
+          freqs[i] = freq;
+          ++i;
+        } else {
+          nextDelDoc();
+          //System.out.println("  nd2 " + nextDelDoc);
+        }
       }
       return i;
     }
   }
 
+  // nocommit -- make better binary search like skipper
+  private final void nextDelDoc(int skipTo) {
+    //System.out.println("skip cur=" + nextDelDoc + " skipTo=" + skipTo);
+    do {
+      nextDelDoc = deletedDocIDs[++delUpto];
+      //System.out.println("  incr to " + nextDelDoc);
+    } while(nextDelDoc < skipTo);
+  }
+
+  private final void nextDelDoc() {
+    //System.out.println("next cur=" + nextDelDoc);
+    nextDelDoc = deletedDocIDs[++delUpto];
+  }
+
   private final int readNoTf(final int[] docs, final int[] freqs, final int length) throws IOException {
     int i = 0;
     while (i < length && count < df) {
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java	(revision 739232)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java	(working copy)
@@ -62,6 +62,9 @@
     super(runData);
   }
 
+  // nocommit
+  static boolean first = true;
+
   public int doLogic() throws Exception {
     int res = 0;
     boolean closeReader = false;
@@ -102,6 +105,12 @@
         }
         //System.out.println("q=" + q + ":" + hits.totalHits + " total hits"); 
 
+        // nocommit
+        if (first) {
+          System.out.println("NUMHITS=" + hits.totalHits);
+          first = false;
+        }
+
         if (withTraverse()) {
           final ScoreDoc[] scoreDocs = hits.scoreDocs;
           int traversalSize = Math.min(scoreDocs.length, traversalSize());
