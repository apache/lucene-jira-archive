diff --git a/lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java b/lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java
index c9d7fa0..b3a43cb 100644
--- a/lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java
+++ b/lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java
@@ -275,68 +275,68 @@ public class SearchGroup<GROUP_VALUE_TYPE> {
 
     public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {
 
       final int maxQueueSize = offset + topN;
 
       //System.out.println("merge");
       // Init queue:
       for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {
         final Collection<SearchGroup<T>> shard = shards.get(shardIDX);
         if (!shard.isEmpty()) {
           //System.out.println("  insert shard=" + shardIDX);
           updateNextGroup(maxQueueSize, new ShardIter<>(shard, shardIDX));
         }
       }
 
       // Pull merged topN groups:
-      final List<SearchGroup<T>> newTopGroups = new ArrayList<>();
+      final List<SearchGroup<T>> newTopGroups = new ArrayList<>(topN);
 
       int count = 0;
 
-      while(queue.size() != 0) {
+      while(!queue.isEmpty()) {
         final MergedGroup<T> group = queue.pollFirst();
         group.processed = true;
         //System.out.println("  pop: shards=" + group.shards + " group=" + (group.groupValue == null ? "null" : (((BytesRef) group.groupValue).utf8ToString())) + " sortValues=" + Arrays.toString(group.topValues));
         if (count++ >= offset) {
           final SearchGroup<T> newGroup = new SearchGroup<>();
           newGroup.groupValue = group.groupValue;
           newGroup.sortValues = group.topValues;
           newTopGroups.add(newGroup);
           if (newTopGroups.size() == topN) {
             break;
           }
         //} else {
         // System.out.println("    skip < offset");
         }
 
         // Advance all iters in this group:
         for(ShardIter<T> shardIter : group.shards) {
           updateNextGroup(maxQueueSize, shardIter);
         }
       }
 
-      if (newTopGroups.size() == 0) {
+      if (newTopGroups.isEmpty()) {
         return null;
       } else {
         return newTopGroups;
       }
     }
   }
 
   /** Merges multiple collections of top groups, for example
    *  obtained from separate index shards.  The provided
    *  groupSort must match how the groups were sorted, and
    *  the provided SearchGroups must have been computed
    *  with fillFields=true passed to {@link
    *  AbstractFirstPassGroupingCollector#getTopGroups}.
    *
    * <p>NOTE: this returns null if the topGroups is empty.
    */
   public static <T> Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> topGroups, int offset, int topN, Sort groupSort)
     throws IOException {
-    if (topGroups.size() == 0) {
+    if (topGroups.isEmpty()) {
       return null;
     } else {
       return new GroupMerger<T>(groupSort).merge(topGroups, offset, topN);
     }
   }
 }
