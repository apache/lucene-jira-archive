Index: lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape.java	(revision 6342ec699e4b5e4d1636fdf20e9b69d0a5099eab)
+++ lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape.java	(date 1546661267000)
@@ -55,7 +55,7 @@
  * @lucene.experimental
  */
 public class LatLonShape {
-  public static final int BYTES = LatLonPoint.BYTES;
+  static final int BYTES = Integer.BYTES;
 
   protected static final FieldType TYPE = new FieldType();
   static {
Index: lucene/sandbox/src/java/org/apache/lucene/geo/Rectangle2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/geo/Rectangle2D.java	(revision 6342ec699e4b5e4d1636fdf20e9b69d0a5099eab)
+++ lucene/sandbox/src/java/org/apache/lucene/geo/Rectangle2D.java	(date 1546660708000)
@@ -19,12 +19,11 @@
 
 import java.util.Arrays;
 
-import org.apache.lucene.document.LatLonShape;
 import org.apache.lucene.index.PointValues;
 import org.apache.lucene.util.FutureArrays;
 import org.apache.lucene.util.NumericUtils;
 
-import static org.apache.lucene.document.LatLonShape.BYTES;
+import static java.lang.Integer.BYTES;
 import static org.apache.lucene.geo.GeoEncodingUtils.MAX_LON_ENCODED;
 import static org.apache.lucene.geo.GeoEncodingUtils.MIN_LON_ENCODED;
 import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;
@@ -184,7 +183,7 @@
    */
   private static void encode(final int minX, final int maxX, final int minY, final int maxY, byte[] b) {
     if (b == null) {
-      b = new byte[4 * LatLonShape.BYTES];
+      b = new byte[4 * BYTES];
     }
     NumericUtils.intToSortableBytes(minY, b, 0);
     NumericUtils.intToSortableBytes(minX, b, BYTES);
Index: lucene/sandbox/src/test/org/apache/lucene/geo/TestRectangle2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/geo/TestRectangle2D.java	(revision 6342ec699e4b5e4d1636fdf20e9b69d0a5099eab)
+++ lucene/sandbox/src/test/org/apache/lucene/geo/TestRectangle2D.java	(date 1546661101000)
@@ -17,12 +17,11 @@
 
 package org.apache.lucene.geo;
 
-import org.apache.lucene.document.LatLonShape;
 import org.apache.lucene.index.PointValues;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.NumericUtils;
 
-import static org.apache.lucene.document.LatLonShape.BYTES;
+import static java.lang.Integer.BYTES;
 
 public class TestRectangle2D extends LuceneTestCase {
 
@@ -82,13 +81,13 @@
       int tMinY = StrictMath.min(StrictMath.min(ay, by), cy);
       int tMaxY = StrictMath.max(StrictMath.max(ay, by), cy);
 
-      byte[] triangle = new byte[4 * LatLonShape.BYTES];
+      byte[] triangle = new byte[4 * BYTES];
       NumericUtils.intToSortableBytes(tMinY, triangle, 0);
       NumericUtils.intToSortableBytes(tMinX, triangle, BYTES);
       NumericUtils.intToSortableBytes(tMaxY, triangle, 2 * BYTES);
       NumericUtils.intToSortableBytes(tMaxX, triangle, 3 * BYTES);
 
-      PointValues.Relation r = rectangle2D.relateRangeBBox(LatLonShape.BYTES, 0, triangle, 3 * LatLonShape.BYTES, 2 * LatLonShape.BYTES, triangle);
+      PointValues.Relation r = rectangle2D.relateRangeBBox(BYTES, 0, triangle, 3 * BYTES, 2 * BYTES, triangle);
       if (r == PointValues.Relation.CELL_OUTSIDE_QUERY) {
         assertFalse(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
         assertFalse(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
