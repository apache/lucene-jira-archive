diff --git a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
index 25205adb76..fc3a5e45e7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
@@ -21,10 +21,12 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import org.apache.lucene.index.Impact;
 import org.apache.lucene.index.Impacts;
@@ -52,32 +54,73 @@ import org.apache.lucene.util.PriorityQueue;
  * term frequencies for the document.
  */
 public final class SynonymQuery extends Query {
-  private final Term terms[];
-  
+  private final TermAndBoost terms[];
+
   /**
-   * Creates a new SynonymQuery, matching any of the supplied terms.
-   * <p>
-   * The terms must all have the same field.
+   * A builder for {@link SynonymQuery}.
    */
-  public SynonymQuery(Term... terms) {
-    this.terms = Objects.requireNonNull(terms).clone();
-    // check that all terms are the same field
-    String field = null;
-    for (Term term : terms) {
-      if (field == null) {
-        field = term.field();
-      } else if (!term.field().equals(field)) {
+  public static class Builder {
+    private final String field;
+    private final List<TermAndBoost> terms = new ArrayList<>();
+
+    /**
+     * Sole constructor
+     *
+     * @param field The target field name
+     */
+    public Builder(String field) {
+      this.field = field;
+    }
+
+    /**
+     * Adds the provided {@code term} as a synonym.
+     */
+    public Builder addTerm(Term term) {
+      return addTerm(term, 1f);
+    }
+
+    /**
+     * Adds the provided {@code term} as a synonym, document frequencies of this term
+     * will be boosted by {@code boost}.
+     */
+    public Builder addTerm(Term term, float boost) {
+      if (field.equals(term.field()) == false) {
         throw new IllegalArgumentException("Synonyms must be across the same field");
       }
+      if (Float.isNaN(boost) || Float.compare(boost, 0f) <= 0 || Float.compare(boost, 1f) > 0) {
+        throw new IllegalArgumentException("boost must be a positive float between 0 (exclusive) and 1 (inclusive)");
+      }
+      terms.add(new TermAndBoost(term, boost));
+      if (terms.size() > BooleanQuery.getMaxClauseCount()) {
+        throw new BooleanQuery.TooManyClauses();
+      }
+      return this;
     }
-    if (terms.length > BooleanQuery.getMaxClauseCount()) {
-      throw new BooleanQuery.TooManyClauses();
+
+    /**
+     * Builds the {@link SynonymQuery}.
+     */
+    public SynonymQuery build() {
+      Collections.sort(terms, Comparator.comparing(a -> a.term));
+      return new SynonymQuery(terms.toArray(new TermAndBoost[0]));
     }
-    Arrays.sort(this.terms);
+  }
+  
+  /**
+   * Creates a new SynonymQuery, matching any of the supplied terms.
+   * <p>
+   * The terms must all have the same field.
+   */
+  private SynonymQuery(TermAndBoost[] terms) {
+    this.terms = Objects.requireNonNull(terms);
   }
 
   public List<Term> getTerms() {
-    return Collections.unmodifiableList(Arrays.asList(terms));
+    return Collections.unmodifiableList(
+        Arrays.stream(terms)
+            .map(TermAndBoost::getTerm)
+            .collect(Collectors.toList())
+    );
   }
   
   @Override
@@ -87,8 +130,12 @@ public final class SynonymQuery extends Query {
       if (i != 0) {
         builder.append(" ");
       }
-      Query termQuery = new TermQuery(terms[i]);
+      Query termQuery = new TermQuery(terms[i].term);
       builder.append(termQuery.toString(field));
+      if (terms[i].boost != 1f) {
+        builder.append("^");
+        builder.append(terms[i].boost);
+      }
     }
     builder.append(")");
     return builder.toString();
@@ -101,8 +148,8 @@ public final class SynonymQuery extends Query {
 
   @Override
   public boolean equals(Object other) {
-    return sameClassAs(other) &&
-           Arrays.equals(terms, ((SynonymQuery) other).terms);
+    return sameClassAs(other)
+        && Arrays.equals(terms, ((SynonymQuery) other).terms);
   }
 
   @Override
@@ -112,7 +159,7 @@ public final class SynonymQuery extends Query {
       return new BooleanQuery.Builder().build();
     }
     if (terms.length == 1) {
-      return new TermQuery(terms[0]);
+      return terms[0].boost == 1f ? new TermQuery(terms[0].term) : new BoostQuery(new TermQuery(terms[0].term), terms[0].boost);
     }
     return this;
   }
@@ -124,8 +171,8 @@ public final class SynonymQuery extends Query {
     } else {
       // if scores are not needed, let BooleanWeight deal with optimizing that case.
       BooleanQuery.Builder bq = new BooleanQuery.Builder();
-      for (Term term : terms) {
-        bq.add(new TermQuery(term), BooleanClause.Occur.SHOULD);
+      for (TermAndBoost term : terms) {
+        bq.add(new TermQuery(term.term), BooleanClause.Occur.SHOULD);
       }
       return searcher.rewrite(bq.build()).createWeight(searcher, ScoreMode.COMPLETE_NO_SCORES, boost);
     }
@@ -141,13 +188,13 @@ public final class SynonymQuery extends Query {
       super(query);
       assert scoreMode.needsScores();
       this.scoreMode = scoreMode;
-      CollectionStatistics collectionStats = searcher.collectionStatistics(terms[0].field());
+      CollectionStatistics collectionStats = searcher.collectionStatistics(terms[0].term.field());
       long docFreq = 0;
       long totalTermFreq = 0;
       termStates = new TermStates[terms.length];
       for (int i = 0; i < termStates.length; i++) {
-        termStates[i] = TermStates.build(searcher.getTopReaderContext(), terms[i], true);
-        TermStatistics termStats = searcher.termStatistics(terms[i], termStates[i]);
+        termStates[i] = TermStates.build(searcher.getTopReaderContext(), terms[i].term, true);
+        TermStatistics termStats = searcher.termStatistics(terms[i].term, termStates[i]);
         if (termStats != null) {
           docFreq = Math.max(termStats.docFreq(), docFreq);
           totalTermFreq += termStats.totalTermFreq();
@@ -164,19 +211,22 @@ public final class SynonymQuery extends Query {
 
     @Override
     public void extractTerms(Set<Term> terms) {
-      for (Term term : SynonymQuery.this.terms) {
-        terms.add(term);
+      for (TermAndBoost term : SynonymQuery.this.terms) {
+        terms.add(term.term);
       }
     }
 
     @Override
     public Matches matches(LeafReaderContext context, int doc) throws IOException {
-      String field = terms[0].field();
-      Terms terms = context.reader().terms(field);
-      if (terms == null || terms.hasPositions() == false) {
+      String field = terms[0].term.field();
+      Terms indexTerms = context.reader().terms(field);
+      if (indexTerms == null || indexTerms.hasPositions() == false) {
         return super.matches(context, doc);
       }
-      return MatchesUtils.forField(field, () -> DisjunctionMatchesIterator.fromTerms(context, doc, getQuery(), field, Arrays.asList(SynonymQuery.this.terms)));
+      List<Term> termList = Arrays.stream(terms)
+          .map(TermAndBoost::getTerm)
+          .collect(Collectors.toList());
+      return MatchesUtils.forField(field, () -> DisjunctionMatchesIterator.fromTerms(context, doc, getQuery(), field, termList));
     }
 
     @Override
@@ -188,11 +238,13 @@ public final class SynonymQuery extends Query {
           final float freq;
           if (scorer instanceof SynonymScorer) {
             freq = ((SynonymScorer) scorer).freq();
+          } else if (scorer instanceof FreqBoostTermScorer) {
+            freq = ((FreqBoostTermScorer) scorer).freq();
           } else {
             assert scorer instanceof TermScorer;
-            freq = ((TermScorer)scorer).freq();
+            freq = ((TermScorer) scorer).freq();
           }
-          LeafSimScorer docScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].field(), true);
+          LeafSimScorer docScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].term.field(), true);
           Explanation freqExplanation = Explanation.match(freq, "termFreq=" + freq);
           Explanation scoreExplanation = docScorer.explain(doc, freqExplanation);
           return Explanation.match(
@@ -209,11 +261,12 @@ public final class SynonymQuery extends Query {
     public Scorer scorer(LeafReaderContext context) throws IOException {
       List<PostingsEnum> iterators = new ArrayList<>();
       List<ImpactsEnum> impacts = new ArrayList<>();
+      List<Float> termBoosts = new ArrayList<> ();
       for (int i = 0; i < terms.length; i++) {
         TermState state = termStates[i].get(context);
         if (state != null) {
-          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();
-          termsEnum.seekExact(terms[i].bytes(), state);
+          TermsEnum termsEnum = context.reader().terms(terms[i].term.field()).iterator();
+          termsEnum.seekExact(terms[i].term.bytes(), state);
           if (scoreMode == ScoreMode.TOP_SCORES) {
             ImpactsEnum impactsEnum = termsEnum.impacts(PostingsEnum.FREQS);
             iterators.add(impactsEnum);
@@ -223,6 +276,7 @@ public final class SynonymQuery extends Query {
             iterators.add(postingsEnum);
             impacts.add(new SlowImpactsEnum(postingsEnum));
           }
+          termBoosts.add(terms[i].boost);
         }
       }
 
@@ -230,27 +284,38 @@ public final class SynonymQuery extends Query {
         return null;
       }
 
-      LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].field(), true);
+      LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].term.field(), true);
 
       // we must optimize this case (term not in segment), disjunctions require >= 2 subs
       if (iterators.size() == 1) {
+        final TermScorer scorer;
         if (scoreMode == ScoreMode.TOP_SCORES) {
-          return new TermScorer(this, impacts.get(0), simScorer);
+          scorer = new TermScorer(this, impacts.get(0), simScorer);
         } else {
-          return new TermScorer(this, iterators.get(0), simScorer);
+          scorer = new TermScorer(this, iterators.get(0), simScorer);
         }
+        float boost = termBoosts.get(0);
+        return scoreMode == ScoreMode.COMPLETE_NO_SCORES || boost == 1f ? scorer : new FreqBoostTermScorer(boost, scorer, simScorer);
       }
 
       // we use termscorers + disjunction as an impl detail
       DisiPriorityQueue queue = new DisiPriorityQueue(iterators.size());
-      for (PostingsEnum postings : iterators) {
-        queue.add(new DisiWrapper(new TermScorer(this, postings, simScorer)));
+      for (int i = 0; i < iterators.size(); i++) {
+        PostingsEnum postings = iterators.get(i);
+        final TermScorer termScorer = new TermScorer(this, postings, simScorer);
+        float boost = termBoosts.get(i);
+        final DisiWrapperFreq wrapper = new DisiWrapperFreq(termScorer, boost);
+        queue.add(wrapper);
       }
       // Even though it is called approximation, it is accurate since none of
       // the sub iterators are two-phase iterators.
       DocIdSetIterator iterator = new DisjunctionDISIApproximation(queue);
 
-      ImpactsSource impactsSource = mergeImpacts(impacts.toArray(new ImpactsEnum[0]));
+      float[] boosts = new float[impacts.size()];
+      for (int i = 0; i < boosts.length; i++) {
+        boosts[i] = termBoosts.get(i);
+      }
+      ImpactsSource impactsSource = mergeImpacts(impacts.toArray(new ImpactsEnum[0]), boosts);
       ImpactsDISI impactsDisi = new ImpactsDISI(iterator, impactsSource, simScorer.getSimScorer());
 
       if (scoreMode == ScoreMode.TOP_SCORES) {
@@ -269,7 +334,8 @@ public final class SynonymQuery extends Query {
   /**
    * Merge impacts for multiple synonyms.
    */
-  static ImpactsSource mergeImpacts(ImpactsEnum[] impactsEnums) {
+  static ImpactsSource mergeImpacts(ImpactsEnum[] impactsEnums, float[] boosts) {
+    assert impactsEnums.length == boosts.length;
     return new ImpactsSource() {
 
       class SubIterator {
@@ -347,7 +413,17 @@ public final class SynonymQuery extends Query {
                   // Return impacts that trigger the maximum score
                   return Collections.singletonList(new Impact(Integer.MAX_VALUE, 1L));
                 }
-                toMerge.add(impacts[i].getImpacts(impactsLevel));
+                final List<Impact> impactList;
+                if (boosts[i] != 1f) {
+                  float boost = boosts[i];
+                  impactList = impacts[i].getImpacts(impactsLevel)
+                      .stream()
+                      .map(impact -> new Impact((int) Math.ceil(impact.freq * boost), impact.norm))
+                      .collect(Collectors.toList());
+                } else {
+                  impactList = impacts[i].getImpacts(impactsLevel);
+                }
+                toMerge.add(impactList);
               }
             }
             assert toMerge.size() > 0; // otherwise it would mean the docID is > docIdUpTo, which is wrong
@@ -443,14 +519,11 @@ public final class SynonymQuery extends Query {
       return iterator.docID();
     }
 
-    int freq() throws IOException {
-      DisiWrapper w = queue.topList();
-      int freq = ((PostingsEnum) w.iterator).freq();
-      for (w = w.next; w != null; w = w.next) {
-        freq += ((PostingsEnum) w.iterator).freq();
-        if (freq < 0) { // overflow
-          return Integer.MAX_VALUE;
-        }
+    float freq() throws IOException {
+      DisiWrapperFreq w = (DisiWrapperFreq) queue.topList();
+      float freq = w.freq();
+      for (w = (DisiWrapperFreq) w.next; w != null; w = (DisiWrapperFreq) w.next) {
+        freq += w.freq();
       }
       return freq;
     }
@@ -480,4 +553,88 @@ public final class SynonymQuery extends Query {
       impactsDisi.setMinCompetitiveScore(minScore);
     }
   }
+
+  private static class DisiWrapperFreq extends DisiWrapper {
+    final PostingsEnum pe;
+    final float boost;
+
+    DisiWrapperFreq(Scorer scorer, float boost) {
+      super(scorer);
+      this.pe = (PostingsEnum) scorer.iterator();
+      this.boost = boost;
+    }
+
+    float freq() throws IOException {
+      return boost * pe.freq();
+    }
+  }
+
+  private static class FreqBoostTermScorer extends FilterScorer {
+    final float boost;
+    final TermScorer in;
+    final LeafSimScorer docScorer;
+
+    public FreqBoostTermScorer(float boost, TermScorer in, LeafSimScorer docScorer) {
+      super(in);
+      if (Float.isNaN(boost) || Float.compare(boost, 0f) < 0 || Float.compare(boost, 1f) > 0) {
+        throw new IllegalArgumentException("boost must be a positive float between 0 (exclusive) and 1 (inclusive)");
+      }
+      this.boost = boost;
+      this.in = in;
+      this.docScorer = docScorer;
+    }
+
+    float freq() throws IOException {
+      return boost * in.freq();
+    }
+
+    @Override
+    public float score() throws IOException {
+      assert docID() != DocIdSetIterator.NO_MORE_DOCS;
+      return docScorer.score(in.docID(), freq());
+    }
+
+    @Override
+    public float getMaxScore(int upTo) throws IOException {
+      return in.getMaxScore(upTo);
+    }
+
+    @Override
+    public int advanceShallow(int target) throws IOException {
+      return in.advanceShallow(target);
+    }
+
+    @Override
+    public void setMinCompetitiveScore(float minScore) throws IOException {
+      in.setMinCompetitiveScore(minScore);
+    }
+  }
+
+  private static class TermAndBoost {
+    final Term term;
+    final float boost;
+
+    TermAndBoost(Term term, float boost) {
+      this.term = term;
+      this.boost = boost;
+    }
+
+    Term getTerm() {
+      return term;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+      TermAndBoost that = (TermAndBoost) o;
+      return Float.compare(that.boost, boost) == 0 &&
+          Objects.equals(term, that.term);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(term, boost);
+    }
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
index 1b1c41449c..66837b799a 100644
--- a/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
@@ -416,7 +416,7 @@ public class QueryBuilder {
     
     TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);
     PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);
-    
+
     stream.reset();
     while (stream.incrementToken()) {
       if (posIncrAtt.getPositionIncrement() != 0) {
@@ -650,7 +650,11 @@ public class QueryBuilder {
    * @return new Query instance
    */
   protected Query newSynonymQuery(Term terms[]) {
-    return new SynonymQuery(terms);
+    SynonymQuery.Builder builder = new SynonymQuery.Builder(terms[0].field());
+    for (Term term : terms) {
+      builder.addTerm(term);
+    }
+    return builder.build();
   }
 
   /**
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMatchesIterator.java b/lucene/core/src/test/org/apache/lucene/search/TestMatchesIterator.java
index e77fca6d1d..0bc243d02b 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMatchesIterator.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMatchesIterator.java
@@ -494,7 +494,9 @@ public class TestMatchesIterator extends LuceneTestCase {
   }
 
   public void testSynonymQuery() throws IOException {
-    Query q = new SynonymQuery(new Term(FIELD_WITH_OFFSETS, "w1"), new Term(FIELD_WITH_OFFSETS, "w2"));
+    Query q = new SynonymQuery.Builder(FIELD_WITH_OFFSETS)
+        .addTerm(new Term(FIELD_WITH_OFFSETS, "w1")).addTerm(new Term(FIELD_WITH_OFFSETS, "w2"))
+        .build();
     checkMatches(q, FIELD_WITH_OFFSETS, new int[][]{
         { 0, 0, 0, 0, 2, 1, 1, 3, 5 },
         { 1, 0, 0, 0, 2, 2, 2, 6, 8 },
@@ -507,7 +509,7 @@ public class TestMatchesIterator extends LuceneTestCase {
 
   public void testSynonymQueryNoPositions() throws IOException {
     for (String field : new String[]{ FIELD_FREQS, FIELD_DOCS_ONLY }) {
-      Query q = new SynonymQuery(new Term(field, "w1"), new Term(field, "w2"));
+      Query q = new SynonymQuery.Builder(field).addTerm(new Term(field, "w1")).addTerm(new Term(field, "w2")).build();
       checkNoPositionsMatches(q, field, new boolean[]{ true, true, true, true, false });
     }
   }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java b/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java
index 0847480935..fc519b280d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java
@@ -698,7 +698,10 @@ public class TestSimpleExplanations extends BaseExplanationTestCase {
   }
   
   public void testSynonymQuery() throws Exception {
-    SynonymQuery query = new SynonymQuery(new Term(FIELD, "w1"), new Term(FIELD, "w2"));
+    SynonymQuery query = new SynonymQuery.Builder(FIELD)
+        .addTerm(new Term(FIELD, "w1")
+        ).addTerm(new Term(FIELD, "w2"))
+        .build();
     qtest(query, new int[] { 0,1,2,3 });
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSimpleSearchEquivalence.java b/lucene/core/src/test/org/apache/lucene/search/TestSimpleSearchEquivalence.java
index 6386c79967..bd254afe58 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSimpleSearchEquivalence.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSimpleSearchEquivalence.java
@@ -239,7 +239,7 @@ public class TestSimpleSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     assertEquals(t1.field(), t2.field());
-    SynonymQuery q1 = new SynonymQuery(t1, t2);
+    SynonymQuery q1 = new SynonymQuery.Builder(t1.field()).addTerm(t1).addTerm(t2).build();
     BooleanQuery.Builder q2 = new BooleanQuery.Builder();
     q2.add(new TermQuery(t1), Occur.SHOULD);
     q2.add(new TermQuery(t2), Occur.SHOULD);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java
index 1768254f68..85592288c5 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java
@@ -22,7 +22,9 @@ import java.util.Arrays;
 import java.util.List;
 
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.DirectoryReader;
@@ -43,26 +45,67 @@ import org.apache.lucene.util.TestUtil;
 public class TestSynonymQuery extends LuceneTestCase {
 
   public void testEquals() {
-    QueryUtils.checkEqual(new SynonymQuery(), new SynonymQuery());
-    QueryUtils.checkEqual(new SynonymQuery(new Term("foo", "bar")),
-                          new SynonymQuery(new Term("foo", "bar")));
+    QueryUtils.checkEqual(new SynonymQuery.Builder("foo").build(), new SynonymQuery.Builder("foo").build());
+    QueryUtils.checkEqual(new SynonymQuery.Builder("foo").addTerm(new Term("foo", "bar")).build(),
+                          new SynonymQuery.Builder("foo").addTerm(new Term("foo", "bar")).build());
+
+    QueryUtils.checkEqual(new SynonymQuery.Builder("a").addTerm(new Term("a", "a")).addTerm(new Term("a", "b")).build(),
+                          new SynonymQuery.Builder("a").addTerm(new Term("a", "b")).addTerm(new Term("a", "a")).build());
+
+    QueryUtils.checkEqual(
+        new SynonymQuery.Builder("field")
+            .addTerm(new Term("field", "b"), 0.4f)
+            .addTerm(new Term("field", "c"), 0.2f)
+            .addTerm(new Term("field", "d")).build(),
+        new SynonymQuery.Builder("field")
+            .addTerm(new Term("field", "b"), 0.4f)
+            .addTerm(new Term("field", "c"), 0.2f)
+            .addTerm(new Term("field", "d")).build());
 
-    QueryUtils.checkEqual(new SynonymQuery(new Term("a", "a"), new Term("a", "b")),
-                          new SynonymQuery(new Term("a", "b"), new Term("a", "a")));
   }
 
   public void testBogusParams() {
     expectThrows(IllegalArgumentException.class, () -> {
-      new SynonymQuery(new Term("field1", "a"), new Term("field2", "b"));
+      new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a")).addTerm(new Term("field2", "b"));
+    });
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), 1.3f);
+    });
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), Float.NaN);
+    });
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), Float.POSITIVE_INFINITY);
+    });
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), Float.NEGATIVE_INFINITY);
+    });
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), -0.3f);
+    });
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), 0f);
+    });
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), -0f);
     });
   }
 
   public void testToString() {
-    assertEquals("Synonym()", new SynonymQuery().toString());
+    assertEquals("Synonym()", new SynonymQuery.Builder("foo").build().toString());
     Term t1 = new Term("foo", "bar");
-    assertEquals("Synonym(foo:bar)", new SynonymQuery(t1).toString());
+    assertEquals("Synonym(foo:bar)", new SynonymQuery.Builder("foo")
+        .addTerm(t1).build().toString());
     Term t2 = new Term("foo", "baz");
-    assertEquals("Synonym(foo:bar foo:baz)", new SynonymQuery(t1, t2).toString());
+    assertEquals("Synonym(foo:bar foo:baz)", new SynonymQuery.Builder("foo")
+        .addTerm(t1).addTerm(t2).build().toString());
   }
 
   public void testScores() throws IOException {
@@ -83,10 +126,13 @@ public class TestSynonymQuery extends LuceneTestCase {
     for (int i = 0; i < 10; ++i) {
       w.addDocument(doc);
     }
-
+    float boost = random().nextBoolean() ? random().nextFloat() : 1f;
     IndexReader reader = w.getReader();
     IndexSearcher searcher = newSearcher(reader);
-    SynonymQuery query = new SynonymQuery(new Term("f", "a"), new Term("f", "b"));
+    SynonymQuery query = new SynonymQuery.Builder("f")
+        .addTerm(new Term("f", "a"), boost == 0 ? 1f : boost)
+        .addTerm(new Term("f", "b"), boost == 0 ? 1f : boost)
+        .build();
 
     TopScoreDocCollector collector = TopScoreDocCollector.create(Math.min(reader.numDocs(), totalHitsThreshold), null, totalHitsThreshold);
     searcher.search(query, collector);
@@ -107,6 +153,64 @@ public class TestSynonymQuery extends LuceneTestCase {
     dir.close();
   }
 
+  public void testBoosts() throws IOException {
+    doTestBoosts(2);
+    doTestBoosts(Integer.MAX_VALUE);
+  }
+
+  public void doTestBoosts(int totalHitsThreshold) throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+
+    Document doc = new Document();
+    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);
+    ft.setOmitNorms(true);
+    doc.add(new Field("f", "c", ft));
+    w.addDocument(doc);
+    for (int i = 0; i < 10; ++i) {
+      doc.clear();
+      doc.add(new TextField("f", "a a a a", Store.NO));
+      w.addDocument(doc);
+      if (i % 2 == 0) {
+        doc.clear();
+        doc.add(new TextField("f", "b b", Store.NO));
+        w.addDocument(doc);
+      } else {
+        doc.clear();
+        doc.add(new TextField("f", "a a b", Store.NO));
+        w.addDocument(doc);
+      }
+    }
+    doc.clear();
+    doc.add(new TextField("f", "c", Store.NO));
+    w.addDocument(doc);
+    IndexReader reader = w.getReader();
+    IndexSearcher searcher = newSearcher(reader);
+    SynonymQuery query = new SynonymQuery.Builder("f")
+        .addTerm(new Term("f", "a"), 0.25f)
+        .addTerm(new Term("f", "b"), 0.5f)
+        .addTerm(new Term("f", "c"))
+        .build();
+
+    TopScoreDocCollector collector = TopScoreDocCollector.create(Math.min(reader.numDocs(), totalHitsThreshold), null, totalHitsThreshold);
+    searcher.search(query, collector);
+    TopDocs topDocs = collector.topDocs();
+    if (topDocs.totalHits.value < totalHitsThreshold) {
+      assertEquals(TotalHits.Relation.EQUAL_TO, topDocs.totalHits.relation);
+      assertEquals(22, topDocs.totalHits.value);
+    } else {
+      assertEquals(TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO, topDocs.totalHits.relation);
+    }
+    // All docs must have the same score
+    for (int i = 0; i < topDocs.scoreDocs.length; ++i) {
+      assertEquals(topDocs.scoreDocs[0].score, topDocs.scoreDocs[i].score, 0.0f);
+    }
+
+    reader.close();
+    w.close();
+    dir.close();
+  }
+
   public void testMergeImpacts() throws IOException {
     DummyImpactsEnum impacts1 = new DummyImpactsEnum();
     impacts1.reset(42,
@@ -129,7 +233,7 @@ public class TestSynonymQuery extends LuceneTestCase {
             1000
         });
 
-    ImpactsSource mergedImpacts = SynonymQuery.mergeImpacts(new ImpactsEnum[] { impacts1, impacts2 });
+    ImpactsSource mergedImpacts = SynonymQuery.mergeImpacts(new ImpactsEnum[] { impacts1, impacts2 }, new float[] { 1f, 1f });
     assertEquals(
         new Impact[][] {
           new Impact[] { new Impact(5, 10), new Impact(7, 12), new Impact(14, 13) },
@@ -141,6 +245,18 @@ public class TestSynonymQuery extends LuceneTestCase {
         },
         mergedImpacts.getImpacts());
 
+    ImpactsSource mergedBoostedImpacts = SynonymQuery.mergeImpacts(new ImpactsEnum[] { impacts1, impacts2 }, new float[] { 0.3f, 0.9f });
+    assertEquals(
+        new Impact[][] {
+            new Impact[] { new Impact(3, 10), new Impact(4, 12), new Impact(9, 13) },
+            new Impact[] { new Impact(Integer.MAX_VALUE, 1) }
+        },
+        new int[] {
+            90,
+            1000
+        },
+        mergedBoostedImpacts.getImpacts());
+
     // docID is > the first doIdUpTo of impacts1
     impacts2.reset(112,
         new Impact[][] {
@@ -161,6 +277,17 @@ public class TestSynonymQuery extends LuceneTestCase {
             945
         },
         mergedImpacts.getImpacts());
+
+    assertEquals(
+        new Impact[][] {
+            new Impact[] { new Impact(1, 10), new Impact(2, 12), new Impact(3, 13) }, // same as impacts1*boost
+            new Impact[] { new Impact(3, 9), new Impact(7, 11), new Impact(10, 13), new Impact(11, 14) }
+        },
+        new int[] {
+            110,
+            945
+        },
+        mergedBoostedImpacts.getImpacts());
   }
 
   private static void assertEquals(Impact[][] impacts, int[] docIdUpTo, Impacts actual) {
@@ -282,10 +409,12 @@ public class TestSynonymQuery extends LuceneTestCase {
       do {
         term2 = random().nextInt(15);
       } while (term1 == term2);
-      Query query = new SynonymQuery(
-          new Term[] {
-              new Term("foo", Integer.toString(term1)),
-              new Term("foo", Integer.toString(term2))});
+      float boost1 = random().nextBoolean() ? Math.max(random().nextFloat(), Float.MIN_NORMAL) : 1f;
+      float boost2 = random().nextBoolean() ? Math.max(random().nextFloat(), Float.MIN_NORMAL) : 1f;
+      Query query = new SynonymQuery.Builder("foo")
+          .addTerm(new Term("foo", Integer.toString(term1)), boost1)
+          .addTerm(new Term("foo", Integer.toString(term2)), boost2)
+          .build();
 
       TopScoreDocCollector collector1 = TopScoreDocCollector.create(10, null, Integer.MAX_VALUE); // COMPLETE
       TopScoreDocCollector collector2 = TopScoreDocCollector.create(10, null, 1); // TOP_SCORES
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
index afc1238a80..dc5468321f 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
@@ -138,7 +138,10 @@ public class TestQueryBuilder extends LuceneTestCase {
   
   /** simple synonyms test */
   public void testSynonyms() throws Exception {
-    SynonymQuery expected = new SynonymQuery(new Term("field", "dogs"), new Term("field", "dog"));
+    SynonymQuery expected = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "dogs"))
+        .addTerm(new Term("field", "dog"))
+        .build();
     QueryBuilder builder = new QueryBuilder(new MockSynonymAnalyzer());
     assertEquals(expected, builder.createBooleanQuery("field", "dogs"));
     assertEquals(expected, builder.createPhraseQuery("field", "dogs"));
@@ -366,7 +369,10 @@ public class TestQueryBuilder extends LuceneTestCase {
   
   /** simple CJK synonym test */
   public void testCJKSynonym() throws Exception {
-    SynonymQuery expected = new SynonymQuery(new Term("field", "国"), new Term("field", "國"));
+    SynonymQuery expected = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "国"))
+        .addTerm(new Term("field", "國"))
+        .build();
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
     assertEquals(expected, builder.createBooleanQuery("field", "国"));
     assertEquals(expected, builder.createPhraseQuery("field", "国"));
@@ -377,7 +383,10 @@ public class TestQueryBuilder extends LuceneTestCase {
   public void testCJKSynonymsOR() throws Exception {
     BooleanQuery.Builder expected = new BooleanQuery.Builder();
     expected.add(new TermQuery(new Term("field", "中")), BooleanClause.Occur.SHOULD);
-    SynonymQuery inner = new SynonymQuery(new Term("field", "国"), new Term("field", "國"));
+    SynonymQuery inner = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "国"))
+        .addTerm(new Term("field", "國"))
+        .build();
     expected.add(inner, BooleanClause.Occur.SHOULD);
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
     assertEquals(expected.build(), builder.createBooleanQuery("field", "中国"));
@@ -387,9 +396,15 @@ public class TestQueryBuilder extends LuceneTestCase {
   public void testCJKSynonymsOR2() throws Exception {
     BooleanQuery.Builder expected = new BooleanQuery.Builder();
     expected.add(new TermQuery(new Term("field", "中")), BooleanClause.Occur.SHOULD);
-    SynonymQuery inner = new SynonymQuery(new Term("field", "国"), new Term("field", "國"));
+    SynonymQuery inner = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "国"))
+        .addTerm(new Term("field", "國"))
+        .build();
     expected.add(inner, BooleanClause.Occur.SHOULD);
-    SynonymQuery inner2 = new SynonymQuery(new Term("field", "国"), new Term("field", "國"));
+    SynonymQuery inner2 = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "国"))
+        .addTerm(new Term("field", "國"))
+        .build();
     expected.add(inner2, BooleanClause.Occur.SHOULD);
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
     assertEquals(expected.build(), builder.createBooleanQuery("field", "中国国"));
@@ -399,7 +414,10 @@ public class TestQueryBuilder extends LuceneTestCase {
   public void testCJKSynonymsAND() throws Exception {
     BooleanQuery.Builder expected = new BooleanQuery.Builder();
     expected.add(new TermQuery(new Term("field", "中")), BooleanClause.Occur.MUST);
-    SynonymQuery inner = new SynonymQuery(new Term("field", "国"), new Term("field", "國"));
+    SynonymQuery inner = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "国"))
+        .addTerm(new Term("field", "國"))
+        .build();
     expected.add(inner, BooleanClause.Occur.MUST);
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
     assertEquals(expected.build(), builder.createBooleanQuery("field", "中国", BooleanClause.Occur.MUST));
@@ -409,9 +427,15 @@ public class TestQueryBuilder extends LuceneTestCase {
   public void testCJKSynonymsAND2() throws Exception {
     BooleanQuery.Builder expected = new BooleanQuery.Builder();
     expected.add(new TermQuery(new Term("field", "中")), BooleanClause.Occur.MUST);
-    SynonymQuery inner = new SynonymQuery(new Term("field", "国"), new Term("field", "國"));
+    SynonymQuery inner = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "国"))
+        .addTerm(new Term("field", "國"))
+        .build();
     expected.add(inner, BooleanClause.Occur.MUST);
-    SynonymQuery inner2 = new SynonymQuery(new Term("field", "国"), new Term("field", "國"));
+    SynonymQuery inner2 = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "国"))
+        .addTerm(new Term("field", "國"))
+        .build();
     expected.add(inner2, BooleanClause.Occur.MUST);
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
     assertEquals(expected.build(), builder.createBooleanQuery("field", "中国国", BooleanClause.Occur.MUST));
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
index 898846fa43..314cc160ba 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
@@ -224,7 +224,10 @@ public class HighlighterTest extends BaseTokenStreamTestCase implements Formatte
 
   public void testHighlightingSynonymQuery() throws Exception {
     searcher = newSearcher(reader);
-    Query query = new SynonymQuery(new Term(FIELD_NAME, "jfk"), new Term(FIELD_NAME, "kennedy"));
+    Query query = new SynonymQuery.Builder(FIELD_NAME)
+        .addTerm(new Term(FIELD_NAME, "jfk"))
+        .addTerm(new Term(FIELD_NAME, "kennedy"))
+        .build();
     QueryScorer scorer = new QueryScorer(query, FIELD_NAME);
     Highlighter highlighter = new Highlighter(scorer);
     TokenStream stream = getAnyTokenStream(FIELD_NAME, 2);
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest.java b/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest.java
index 1dce6d2804..069717a05d 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest.java
@@ -544,7 +544,10 @@ public class FastVectorHighlighterTest extends LuceneTestCase {
     int docId = 0;
 
     // query1: simple synonym query
-    SynonymQuery synQuery = new SynonymQuery(new Term("field", "quick"), new Term("field", "fast"));
+    SynonymQuery synQuery = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "quick"))
+        .addTerm(new Term("field", "fast"))
+        .build();
     FieldQuery fieldQuery  = highlighter.getFieldQuery(synQuery, reader);
     String[] bestFragments = highlighter.getBestFragments(fieldQuery, reader, docId, "field", 54, 1);
     assertEquals("the <b>quick</b> brown fox", bestFragments[0]);
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
index b759e370b2..b53c78eec9 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
@@ -309,7 +309,10 @@ public class TestQueryParser extends QueryParserTestBase {
     /** ordinary behavior, synonyms form uncoordinated boolean query */
     QueryParser dumb = new QueryParser(FIELD,
         new Analyzer1());
-    Query expanded = new SynonymQuery(new Term(FIELD, "dogs"), new Term(FIELD, "dog"));
+    Query expanded = new SynonymQuery.Builder(FIELD)
+        .addTerm(new Term(FIELD, "dogs"))
+        .addTerm(new Term(FIELD, "dog"))
+        .build();
     assertEquals(expanded, dumb.parse("\"dogs\""));
     /** even with the phrase operator the behavior is the same */
     assertEquals(expanded, dumb.parse("dogs"));
@@ -326,7 +329,10 @@ public class TestQueryParser extends QueryParserTestBase {
 
   /** simple synonyms test */
   public void testSynonyms() throws Exception {
-    Query expected = new SynonymQuery(new Term(FIELD, "dogs"), new Term(FIELD, "dog"));
+    Query expected = new SynonymQuery.Builder("dogs")
+        .addTerm(new Term(FIELD, "dogs"))
+        .addTerm(new Term(FIELD, "dog"))
+        .build();
     QueryParser qp = new QueryParser(FIELD, new MockSynonymAnalyzer());
     assertEquals(expected, qp.parse("dogs"));
     assertEquals(expected, qp.parse("\"dogs\""));
@@ -395,7 +401,10 @@ public class TestQueryParser extends QueryParserTestBase {
   
   /** simple CJK synonym test */
   public void testCJKSynonym() throws Exception {
-    Query expected = new SynonymQuery(new Term(FIELD, "国"), new Term(FIELD, "國"));
+    Query expected = new SynonymQuery.Builder(FIELD)
+        .addTerm(new Term(FIELD, "国"))
+        .addTerm(new Term(FIELD, "國"))
+        .build();
     QueryParser qp = new QueryParser(FIELD, new MockCJKSynonymAnalyzer());
     assertEquals(expected, qp.parse("国"));
     qp.setDefaultOperator(Operator.AND);
@@ -408,7 +417,10 @@ public class TestQueryParser extends QueryParserTestBase {
   public void testCJKSynonymsOR() throws Exception {
     BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
     expectedB.add(new TermQuery(new Term(FIELD, "中")), BooleanClause.Occur.SHOULD);
-    Query inner = new SynonymQuery(new Term(FIELD, "国"), new Term(FIELD, "國"));
+    Query inner = new SynonymQuery.Builder(FIELD)
+        .addTerm(new Term(FIELD, "国"))
+        .addTerm(new Term(FIELD, "國"))
+        .build();
     expectedB.add(inner, BooleanClause.Occur.SHOULD);
     Query expected = expectedB.build();
     QueryParser qp = new QueryParser(FIELD, new MockCJKSynonymAnalyzer());
@@ -421,9 +433,15 @@ public class TestQueryParser extends QueryParserTestBase {
   public void testCJKSynonymsOR2() throws Exception {
     BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
     expectedB.add(new TermQuery(new Term(FIELD, "中")), BooleanClause.Occur.SHOULD);
-    SynonymQuery inner = new SynonymQuery(new Term(FIELD, "国"), new Term(FIELD, "國"));
+    SynonymQuery inner = new SynonymQuery.Builder(FIELD)
+      .addTerm(new Term(FIELD, "国"))
+      .addTerm(new Term(FIELD, "國"))
+        .build();
     expectedB.add(inner, BooleanClause.Occur.SHOULD);
-    SynonymQuery inner2 = new SynonymQuery(new Term(FIELD, "国"), new Term(FIELD, "國"));
+    SynonymQuery inner2 = new SynonymQuery.Builder(FIELD)
+        .addTerm(new Term(FIELD, "国"))
+        .addTerm(new Term(FIELD, "國"))
+        .build();
     expectedB.add(inner2, BooleanClause.Occur.SHOULD);
     Query expected = expectedB.build();
     QueryParser qp = new QueryParser(FIELD, new MockCJKSynonymAnalyzer());
@@ -436,7 +454,10 @@ public class TestQueryParser extends QueryParserTestBase {
   public void testCJKSynonymsAND() throws Exception {
     BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
     expectedB.add(new TermQuery(new Term(FIELD, "中")), BooleanClause.Occur.MUST);
-    Query inner = new SynonymQuery(new Term(FIELD, "国"), new Term(FIELD, "國"));
+    Query inner = new SynonymQuery.Builder(FIELD)
+        .addTerm(new Term(FIELD, "国"))
+        .addTerm(new Term(FIELD, "國"))
+        .build();
     expectedB.add(inner, BooleanClause.Occur.MUST);
     Query expected = expectedB.build();
     QueryParser qp = new QueryParser(FIELD, new MockCJKSynonymAnalyzer());
@@ -450,9 +471,15 @@ public class TestQueryParser extends QueryParserTestBase {
   public void testCJKSynonymsAND2() throws Exception {
     BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
     expectedB.add(new TermQuery(new Term(FIELD, "中")), BooleanClause.Occur.MUST);
-    Query inner = new SynonymQuery(new Term(FIELD, "国"), new Term(FIELD, "國"));
+    Query inner = new SynonymQuery.Builder(FIELD)
+        .addTerm(new Term(FIELD, "国"))
+        .addTerm(new Term(FIELD, "國"))
+        .build();
     expectedB.add(inner, BooleanClause.Occur.MUST);
-    Query inner2 = new SynonymQuery(new Term(FIELD, "国"), new Term(FIELD, "國"));
+    Query inner2 = new SynonymQuery.Builder(FIELD)
+        .addTerm(new Term(FIELD, "国"))
+        .addTerm(new Term(FIELD, "國"))
+        .build();
     expectedB.add(inner2, BooleanClause.Occur.MUST);
     Query expected = expectedB.build();
     QueryParser qp = new QueryParser(FIELD, new MockCJKSynonymAnalyzer());
@@ -576,12 +603,13 @@ public class TestQueryParser extends QueryParserTestBase {
     dumb.setSplitOnWhitespace(false);
     dumb.setEnableGraphQueries(false);
     
-    TermQuery guinea = new TermQuery(new Term("field", "guinea"));
     TermQuery pig = new TermQuery(new Term("field", "pig"));
-    TermQuery cavy = new TermQuery(new Term("field", "cavy"));
 
     // A multi-word synonym source will just form a boolean query when graph queries are disabled:
-    Query inner = new SynonymQuery(new Term[] {new Term("field", "cavy"), new Term("field", "guinea")});
+    Query inner = new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "cavy"))
+        .addTerm(new Term("field", "guinea"))
+        .build();
     BooleanQuery.Builder b = new BooleanQuery.Builder();
     b.add(inner, BooleanClause.Occur.SHOULD);
     b.add(pig, BooleanClause.Occur.SHOULD);
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/BM25FQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/BM25FQuery.java
index b02989df46..82038347c5 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/BM25FQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/BM25FQuery.java
@@ -214,7 +214,7 @@ public final class BM25FQuery extends Query {
     }
     // single field and multiple terms
     if (fieldAndWeights.size() == 1) {
-      return new SynonymQuery(fieldTerms);
+      return new SynonymQuery.Builder(fieldTerms[0].field()).addTerm(fieldTerms[0]).build();
     }
     return this;
   }
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestBM25FQuery.java b/lucene/sandbox/src/test/org/apache/lucene/search/TestBM25FQuery.java
index 1dce7da363..7491093e55 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestBM25FQuery.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/search/TestBM25FQuery.java
@@ -54,8 +54,10 @@ public class TestBM25FQuery extends LuceneTestCase {
     assertEquals(actual, new TermQuery(new Term("field", "foo")));
     builder.addTerm(new BytesRef("bar"));
     actual = searcher.rewrite(builder.build());
-    assertEquals(actual, new SynonymQuery(new Term("field", "foo"),
-        new Term("field", "bar")));
+    assertEquals(actual, new SynonymQuery.Builder("field")
+        .addTerm(new Term("field", "foo"))
+        .addTerm(new Term("field", "bar"))
+        .build());
     builder.addField("another_field", 1f);
     Query query = builder.build();
     actual = searcher.rewrite(query);
