Index: CHANGES.txt
===================================================================
--- CHANGES.txt	(revision 912370)
+++ CHANGES.txt	(working copy)
@@ -59,10 +59,16 @@
  * LUCENE-1972: Restore SortField.getComparatorSource (it was
    accidentally removed in 3.0.0)  (John Wang via Uwe Schindler)
 
- * LUCENE-2190: Added setNextReader method to CustomScoreQuery, which
-   is necessary with per-segment searching to notify the subclass
-   which reader the int doc, passed to customScore, refers to.  (Paul
-   chez Jamespot via Mike McCandless)
+ * LUCENE-2190: Added a new class CustomScoreProvider to function package
+   that can be subclassed to provide custom scoring to CustomScoreQuery.
+   The methods in CustomScoreQuery that did this before were deprecated
+   and replaced by a method getCustomScoreProvider(IndexReader) that
+   returns a custom score implementation using the above class. The change
+   is necessary with per-segment searching, as CustomScoreQuery is
+   a stateless class (like all other Queries) and does not know about
+   the currently searched segment. This API works similar to Filter's
+   getDocIdSet(IndexReader).  (Paul chez Jamespot via Mike McCandless,
+   Uwe Schindler)
 
  * LUCENE-2080: Deprecate Version.LUCENE_CURRENT, as using this constant
    will cause backwards compatibility problems when upgrading Lucene. See
Index: common-build.xml
===================================================================
--- common-build.xml	(revision 912370)
+++ common-build.xml	(working copy)
@@ -606,6 +606,10 @@
           bottom="Copyright &amp;copy; ${year} Apache Software Foundation.  All Rights Reserved.">
         <tag name="todo" description="To Do:"/>
         <tag name="uml.property" description="UML Property:"/>
+        <tag name="lucene.experimental" 
+      	description="WARNING: This API is experimental and might change in incompatible ways in the next release."/>
+        <tag name="lucene.internal"
+        description="NOTE: This API is for Lucene internal purposes only and might change in incompatible ways in the next release."/>
       	<link offline="true" packagelistLoc="${javadoc.dir}"/>
       	
       	<sources />
Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(revision 912370)
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(working copy)
@@ -27,6 +27,7 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
@@ -36,6 +37,7 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.function.CustomScoreQuery;
+import org.apache.lucene.search.function.CustomScoreProvider;
 import org.apache.lucene.search.function.FieldScoreQuery;
 import org.apache.lucene.search.function.FieldScoreQuery.Type;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
@@ -188,20 +190,26 @@
     CustomScoreQuery customScore = new CustomScoreQuery(dq.getQuery(tq),fsQuery){
 
       @Override
-      public float customScore(int doc, float subQueryScore, float valSrcScore){
-        System.out.println(doc);
-        if (dq.distanceFilter.getDistance(doc) == null)
-          return 0;
+      protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+        return new CustomScoreProvider(reader) {
+          @Override // TODO: broken, as reader is not used!
+          public float customScore(int doc, float subQueryScore, float valSrcScore){
+            System.out.println(doc);
+            if (dq.distanceFilter.getDistance(doc) == null)
+              return 0;
 
-        double distance = dq.distanceFilter.getDistance(doc);
-        // boost score shouldn't exceed 1
-        if (distance < 1.0d)
-          distance = 1.0d;
-        //boost by distance is invertly proportional to
-        // to distance from center point to location
-        float score = (float) ((miles - distance) / miles );
-        return score * subQueryScore;
+            double distance = dq.distanceFilter.getDistance(doc);
+            // boost score shouldn't exceed 1
+            if (distance < 1.0d)
+              distance = 1.0d;
+            //boost by distance is invertly proportional to
+            // to distance from center point to location
+            float score = (float) ((miles - distance) / miles );
+            return score * subQueryScore;
+          }
+        };
       }
+      
     };
     // Create a distance sort
     // As the radius filter has performed the distance calculations
@@ -275,20 +283,26 @@
     CustomScoreQuery customScore = new CustomScoreQuery(dq.getQuery(tq),fsQuery){
 
       @Override
-      public float customScore(int doc, float subQueryScore, float valSrcScore){
-        System.out.println(doc);
-        if (dq.distanceFilter.getDistance(doc) == null)
-          return 0;
+      protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+        return new CustomScoreProvider(reader) {
+          @Override // TODO: broken, as reader is not used!
+          public float customScore(int doc, float subQueryScore, float valSrcScore){
+            System.out.println(doc);
+            if (dq.distanceFilter.getDistance(doc) == null)
+              return 0;
 
-        double distance = dq.distanceFilter.getDistance(doc);
-        // boost score shouldn't exceed 1
-        if (distance < 1.0d)
-          distance = 1.0d;
-        //boost by distance is invertly proportional to
-        // to distance from center point to location
-        float score = (float) ((miles - distance) / miles );
-        return score * subQueryScore;
+            double distance = dq.distanceFilter.getDistance(doc);
+            // boost score shouldn't exceed 1
+            if (distance < 1.0d)
+              distance = 1.0d;
+            //boost by distance is invertly proportional to
+            // to distance from center point to location
+            float score = (float) ((miles - distance) / miles );
+            return score * subQueryScore;
+          }
+        };
       }
+      
     };
     // Create a distance sort
     // As the radius filter has performed the distance calculations
@@ -362,23 +376,27 @@
       FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
     
       CustomScoreQuery customScore = new CustomScoreQuery(dq.getQuery(tq),fsQuery){
-      
-          @Override
+        @Override
+        protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+          return new CustomScoreProvider(reader) {
+            @Override // TODO: broken, as reader is not used!
             public float customScore(int doc, float subQueryScore, float valSrcScore){
-            //System.out.println(doc);
-            if (dq.distanceFilter.getDistance(doc) == null)
-              return 0;
-        
-            double distance = dq.distanceFilter.getDistance(doc);
-            // boost score shouldn't exceed 1
-            if (distance < 1.0d)
-              distance = 1.0d;
-            //boost by distance is invertly proportional to
-            // to distance from center point to location
-            float score = (float) ( (miles - distance) / miles );
-            return score * subQueryScore;
-          }
-        };
+              //System.out.println(doc);
+              if (dq.distanceFilter.getDistance(doc) == null)
+                return 0;
+          
+              double distance = dq.distanceFilter.getDistance(doc);
+              // boost score shouldn't exceed 1
+              if (distance < 1.0d)
+                distance = 1.0d;
+              //boost by distance is invertly proportional to
+              // to distance from center point to location
+              float score = (float) ( (miles - distance) / miles );
+              return score * subQueryScore;
+            }
+          };
+        }
+      };
       // Create a distance sort
       // As the radius filter has performed the distance calculations
       // already, pass in the filter to reuse the results.
@@ -451,23 +469,27 @@
 	    
       FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
       CustomScoreQuery customScore = new CustomScoreQuery(tq,fsQuery){
-	      
-          @Override
-            public float customScore(int doc, float subQueryScore, float valSrcScore){
-            //System.out.println(doc);
-            if (dq.distanceFilter.getDistance(doc) == null)
-              return 0;
-	        
-            double distance = dq.distanceFilter.getDistance(doc);
-            // boost score shouldn't exceed 1
-            if (distance < 1.0d)
-              distance = 1.0d;
-            //boost by distance is invertly proportional to
-            // to distance from center point to location
-            float score = (float) ( (miles - distance) / miles );
-            return score * subQueryScore;
-          }
-        };
+        @Override
+        protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+          return new CustomScoreProvider(reader) {
+              @Override // TODO: broken, as reader is not used!
+              public float customScore(int doc, float subQueryScore, float valSrcScore){
+              //System.out.println(doc);
+              if (dq.distanceFilter.getDistance(doc) == null)
+                return 0;
+            
+              double distance = dq.distanceFilter.getDistance(doc);
+              // boost score shouldn't exceed 1
+              if (distance < 1.0d)
+                distance = 1.0d;
+              //boost by distance is invertly proportional to
+              // to distance from center point to location
+              float score = (float) ( (miles - distance) / miles );
+              return score * subQueryScore;
+            }
+          };
+        }
+      };
       // Create a distance sort
       // As the radius filter has performed the distance calculations
       // already, pass in the filter to reuse the results.
Index: src/java/org/apache/lucene/search/function/CustomScoreProvider.java
===================================================================
--- src/java/org/apache/lucene/search/function/CustomScoreProvider.java	(revision 0)
+++ src/java/org/apache/lucene/search/function/CustomScoreProvider.java	(revision 0)
@@ -0,0 +1,164 @@
+package org.apache.lucene.search.function;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.ComplexExplanation;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.FieldCache; // for javadocs
+
+/**
+ * An instance of this subclass should be returned by
+ * {@link CustomScoreQuery#getCustomScoreProvider}, if you want
+ * to modify the custom score calculation of a {@link CustomScoreQuery}.
+ * <p>Since Lucene 2.9, queries operate on each segment of an Index separately,
+ * so overriding the similar (now deprecated) methods in {@link CustomScoreQuery}
+ * is no longer suitable, as the supplied <code>doc</code> ID is per-segment
+ * and without knowledge of the IndexReader you cannot access the
+ * document or {@link FieldCache}.
+ * 
+ * @lucene.experimental
+ * @since 2.9.2
+ */
+public class CustomScoreProvider {
+
+  protected final IndexReader reader;
+
+  /**
+   * Creates a new instance of the provider class for the given {@link IndexReader}.
+   */
+  public CustomScoreProvider(IndexReader reader) {
+    this.reader = reader;
+  }
+
+  /**
+   * Compute a custom score by the subQuery score and a number of 
+   * {@link ValueSourceQuery} scores.
+   * <p> 
+   * Subclasses can override this method to modify the custom score.  
+   * <p>
+   * If your custom scoring is different than the default herein you 
+   * should override at least one of the two customScore() methods.
+   * If the number of ValueSourceQueries is always &lt; 2 it is 
+   * sufficient to override the other 
+   * {@link #customScore(int, float, float) customScore()} 
+   * method, which is simpler. 
+   * <p>
+   * The default computation herein is a multiplication of given scores:
+   * <pre>
+   *     ModifiedScore = valSrcScore * valSrcScores[0] * valSrcScores[1] * ...
+   * </pre>
+   * 
+   * @param doc id of scored doc. 
+   * @param subQueryScore score of that doc by the subQuery.
+   * @param valSrcScores scores of that doc by the ValueSourceQuery.
+   * @return custom score.
+   */
+  public float customScore(int doc, float subQueryScore, float valSrcScores[]) throws IOException {
+    if (valSrcScores.length == 1) {
+      return customScore(doc, subQueryScore, valSrcScores[0]);
+    }
+    if (valSrcScores.length == 0) {
+      return customScore(doc, subQueryScore, 1);
+    }
+    float score = subQueryScore;
+    for(int i = 0; i < valSrcScores.length; i++) {
+      score *= valSrcScores[i];
+    }
+    return score;
+  }
+
+  /**
+   * Compute a custom score by the subQuery score and the ValueSourceQuery score.
+   * <p> 
+   * Subclasses can override this method to modify the custom score.
+   * <p>
+   * If your custom scoring is different than the default herein you 
+   * should override at least one of the two customScore() methods.
+   * If the number of ValueSourceQueries is always &lt; 2 it is 
+   * sufficient to override this customScore() method, which is simpler. 
+   * <p>
+   * The default computation herein is a multiplication of the two scores:
+   * <pre>
+   *     ModifiedScore = subQueryScore * valSrcScore
+   * </pre>
+   *
+   * @param doc id of scored doc. 
+   * @param subQueryScore score of that doc by the subQuery.
+   * @param valSrcScore score of that doc by the ValueSourceQuery.
+   * @return custom score.
+   */
+  public float customScore(int doc, float subQueryScore, float valSrcScore) throws IOException {
+    return subQueryScore * valSrcScore;
+  }
+
+  /**
+   * Explain the custom score.
+   * Whenever overriding {@link #customScore(int, float, float[])}, 
+   * this method should also be overridden to provide the correct explanation
+   * for the part of the custom scoring.
+   *  
+   * @param doc doc being explained.
+   * @param subQueryExpl explanation for the sub-query part.
+   * @param valSrcExpls explanation for the value source part.
+   * @return an explanation for the custom score
+   */
+  public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) throws IOException {
+    if (valSrcExpls.length == 1) {
+      return customExplain(doc, subQueryExpl, valSrcExpls[0]);
+    }
+    if (valSrcExpls.length == 0) {
+      return subQueryExpl;
+    }
+    float valSrcScore = 1;
+    for (int i = 0; i < valSrcExpls.length; i++) {
+      valSrcScore *= valSrcExpls[i].getValue();
+    }
+    Explanation exp = new Explanation( valSrcScore * subQueryExpl.getValue(), "custom score: product of:");
+    exp.addDetail(subQueryExpl);
+    for (int i = 0; i < valSrcExpls.length; i++) {
+      exp.addDetail(valSrcExpls[i]);
+    }
+    return exp;
+  }
+  
+  /**
+   * Explain the custom score.
+   * Whenever overriding {@link #customScore(int, float, float)}, 
+   * this method should also be overridden to provide the correct explanation
+   * for the part of the custom scoring.
+   *  
+   * @param doc doc being explained.
+   * @param subQueryExpl explanation for the sub-query part.
+   * @param valSrcExpl explanation for the value source part.
+   * @return an explanation for the custom score
+   */
+  public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) throws IOException {
+    float valSrcScore = 1;
+    if (valSrcExpl != null) {
+      valSrcScore *= valSrcExpl.getValue();
+    }
+    Explanation exp = new Explanation( valSrcScore * subQueryExpl.getValue(), "custom score: product of:");
+    exp.addDetail(subQueryExpl);
+    exp.addDetail(valSrcExpl);
+    return exp;
+  }
+
+}

Property changes on: src\java\org\apache\lucene\search\function\CustomScoreProvider.java
___________________________________________________________________
Added: svn:keywords
   + Date Author Id Revision HeadURL
Added: svn:eol-style
   + native

Index: src/java/org/apache/lucene/search/function/CustomScoreQuery.java
===================================================================
--- src/java/org/apache/lucene/search/function/CustomScoreQuery.java	(revision 912370)
+++ src/java/org/apache/lucene/search/function/CustomScoreQuery.java	(working copy)
@@ -40,7 +40,7 @@
  *        For most simple/convenient use cases this query is likely to be a 
  *        {@link org.apache.lucene.search.function.FieldScoreQuery FieldScoreQuery}</li>
  * </ol>
- * Subclasses can modify the computation by overriding {@link #customScore(int, float, float)}.
+ * Subclasses can modify the computation by overriding {@link #getCustomScoreProvider}.
  * 
  * <p><font color="#FF0000">
  * WARNING: The status of the <b>search.function</b> package is experimental. 
@@ -83,7 +83,6 @@
    * This parameter is optional - it can be null or even an empty array.
    */
   public CustomScoreQuery(Query subQuery, ValueSourceQuery... valSrcQueries) {
-    super();
     this.subQuery = subQuery;
     this.valSrcQueries = valSrcQueries!=null?
         valSrcQueries : new ValueSourceQuery[0];
@@ -93,11 +92,23 @@
   /*(non-Javadoc) @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) */
   @Override
   public Query rewrite(IndexReader reader) throws IOException {
-    subQuery = subQuery.rewrite(reader);
+    CustomScoreQuery clone = null;
+    
+    final Query sq = subQuery.rewrite(reader);
+    if (sq != subQuery) {
+      clone = (CustomScoreQuery) clone();
+      clone.subQuery = sq;
+    }
+
     for(int i = 0; i < valSrcQueries.length; i++) {
-      valSrcQueries[i] = (ValueSourceQuery) valSrcQueries[i].rewrite(reader);
+      final ValueSourceQuery v = (ValueSourceQuery) valSrcQueries[i].rewrite(reader);
+      if (v != valSrcQueries[i]) {
+        if (clone == null) clone = (CustomScoreQuery) clone();
+        clone.valSrcQueries[i] = v;
+      }
     }
-    return this;
+    
+    return (clone == null) ? this : clone;
   }
 
   /*(non-Javadoc) @see org.apache.lucene.search.Query#extractTerms(java.util.Set) */
@@ -142,7 +153,8 @@
     }
     CustomScoreQuery other = (CustomScoreQuery)o;
     if (this.getBoost() != other.getBoost() ||
-        !this.subQuery.equals(other.subQuery)||
+        !this.subQuery.equals(other.subQuery) ||
+        this.strict != other.strict ||
         this.valSrcQueries.length != other.valSrcQueries.length) {
       return false;
     }
@@ -153,32 +165,52 @@
   @Override
   public int hashCode() {
     return (getClass().hashCode() + subQuery.hashCode() + Arrays.hashCode(valSrcQueries))
-      ^ Float.floatToIntBits(getBoost());
-  }  
+      ^ Float.floatToIntBits(getBoost()) ^ (strict ? 1234 : 4321);
+  }
   
   /**
+   * Returns a {@link CustomScoreProvider} that calculates the custom scores
+   * for the given {@link IndexReader}. The default implementation returns a default
+   * implementation as specified in the docs of {@link CustomScoreProvider}.
+   * @since 2.9.2
+   */
+  protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) throws IOException {
+    // when deprecated methods are removed, do not extend class here, just return new default CustomScoreProvider
+    return new CustomScoreProvider(reader) {
+      
+      @Override
+      public float customScore(int doc, float subQueryScore, float valSrcScores[]) throws IOException {
+        return CustomScoreQuery.this.customScore(doc, subQueryScore, valSrcScores);
+      }
+      
+      @Override
+      public float customScore(int doc, float subQueryScore, float valSrcScore) throws IOException {
+        return CustomScoreQuery.this.customScore(doc, subQueryScore, valSrcScore);
+      }
+      
+      @Override
+      public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) throws IOException {
+        return CustomScoreQuery.this.customExplain(doc, subQueryExpl, valSrcExpls);
+      }
+      
+      @Override
+      public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) throws IOException {
+        return CustomScoreQuery.this.customExplain(doc, subQueryExpl, valSrcExpl);
+      }
+      
+    };
+  }
+
+  /**
    * Compute a custom score by the subQuery score and a number of 
    * ValueSourceQuery scores.
-   * <p> 
-   * Subclasses can override this method to modify the custom score.  
-   * <p>
-   * If your custom scoring is different than the default herein you 
-   * should override at least one of the two customScore() methods.
-   * If the number of ValueSourceQueries is always &lt; 2 it is 
-   * sufficient to override the other 
-   * {@link #customScore(int, float, float) customScore()} 
-   * method, which is simpler. 
-   * <p>
-   * The default computation herein is a multiplication of given scores:
-   * <pre>
-   *     ModifiedScore = valSrcScore * valSrcScores[0] * valSrcScores[1] * ...
-   * </pre>
-   * 
-   * @param doc id of scored doc. 
-   * @param subQueryScore score of that doc by the subQuery.
-   * @param valSrcScores scores of that doc by the ValueSourceQuery.
-   * @return custom score.
+   * @deprecated The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customScore(int,float,float[])
    */
+  @Deprecated
   public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
     if (valSrcScores.length == 1) {
       return customScore(doc, subQueryScore, valSrcScores[0]);
@@ -195,51 +227,26 @@
 
   /**
    * Compute a custom score by the subQuery score and the ValueSourceQuery score.
-   * <p> 
-   * Subclasses can override this method to modify the custom score.
-   * <p>
-   * If your custom scoring is different than the default herein you 
-   * should override at least one of the two customScore() methods.
-   * If the number of ValueSourceQueries is always &lt; 2 it is 
-   * sufficient to override this customScore() method, which is simpler. 
-   * <p>
-   * The default computation herein is a multiplication of the two scores:
-   * <pre>
-   *     ModifiedScore = subQueryScore * valSrcScore
-   * </pre>
-   *
-   * <p><b>NOTE</b>: The doc is relative to the current
-   * reader, last passed to {@link #setNextReader}.
-   * 
-   * @param doc id of scored doc. 
-   * @param subQueryScore score of that doc by the subQuery.
-   * @param valSrcScore score of that doc by the ValueSourceQuery.
-   * @return custom score.
+   * @deprecated The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customScore(int,float,float)
    */
+  @Deprecated
   public float customScore(int doc, float subQueryScore, float valSrcScore) {
     return subQueryScore * valSrcScore;
   }
 
   /**
-   * Called when the scoring switches to another reader.
-   * 
-   * @param reader
-   *          next IndexReader
-   */
-  public void setNextReader(IndexReader reader) throws IOException {
-  }
-
-  /**
    * Explain the custom score.
-   * Whenever overriding {@link #customScore(int, float, float[])}, 
-   * this method should also be overridden to provide the correct explanation
-   * for the part of the custom scoring.
-   *  
-   * @param doc doc being explained.
-   * @param subQueryExpl explanation for the sub-query part.
-   * @param valSrcExpls explanation for the value source part.
-   * @return an explanation for the custom score
+   * @deprecated The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customExplain(int,Explanation,Explanation[])
    */
+  @Deprecated
   public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
     if (valSrcExpls.length == 1) {
       return customExplain(doc, subQueryExpl, valSrcExpls[0]);
@@ -261,15 +268,13 @@
 
   /**
    * Explain the custom score.
-   * Whenever overriding {@link #customScore(int, float, float)}, 
-   * this method should also be overridden to provide the correct explanation
-   * for the part of the custom scoring.
-   *  
-   * @param doc doc being explained.
-   * @param subQueryExpl explanation for the sub-query part.
-   * @param valSrcExpl explanation for the value source part.
-   * @return an explanation for the custom score
+   * @deprecated The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customExplain(int,Explanation,Explanation[])
    */
+  @Deprecated
   public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
     float valSrcScore = 1;
     if (valSrcExpl != null) {
@@ -374,7 +379,7 @@
       for(int i = 0; i < valSrcWeights.length; i++) {
         valSrcExpls[i] = valSrcWeights[i].explain(reader, doc);
       }
-      Explanation customExp = customExplain(doc,subQueryExpl,valSrcExpls);
+      Explanation customExp = CustomScoreQuery.this.getCustomScoreProvider(reader).customExplain(doc,subQueryExpl,valSrcExpls);
       float sc = getValue() * customExp.getValue();
       Explanation res = new ComplexExplanation(
         true, sc, CustomScoreQuery.this.toString() + ", product of:");
@@ -401,6 +406,7 @@
     private Scorer subQueryScorer;
     private Scorer[] valSrcScorers;
     private IndexReader reader;
+    private final CustomScoreProvider provider;
     private float vScores[]; // reused in score() to avoid allocating this array for each doc 
 
     // constructor
@@ -412,7 +418,7 @@
       this.valSrcScorers = valSrcScorers;
       this.reader = reader;
       this.vScores = new float[valSrcScorers.length];
-      setNextReader(reader);
+      this.provider = CustomScoreQuery.this.getCustomScoreProvider(reader);
     }
 
     @Override
@@ -437,7 +443,7 @@
       for (int i = 0; i < valSrcScorers.length; i++) {
         vScores[i] = valSrcScorers[i].score();
       }
-      return qWeight * customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);
+      return qWeight * provider.customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);
     }
 
     @Override
Index: src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(revision 912370)
+++ src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(working copy)
@@ -75,32 +75,38 @@
   // must have static class otherwise serialization tests fail
   private static class CustomAddQuery extends CustomScoreQuery {
     // constructor
-    CustomAddQuery (Query q, ValueSourceQuery qValSrc) {
-      super(q,qValSrc);
+    CustomAddQuery(Query q, ValueSourceQuery qValSrc) {
+      super(q, qValSrc);
     }
+
     /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#name() */
     @Override
     public String name() {
       return "customAdd";
     }
-    /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#customScore(int, float, float) */
+    
     @Override
-    public float customScore(int doc, float subQueryScore, float valSrcScore) {
-      return subQueryScore + valSrcScore;
+    protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+      return new CustomScoreProvider(reader) {
+        @Override
+        public float customScore(int doc, float subQueryScore, float valSrcScore) {
+          return subQueryScore + valSrcScore;
+        }
+
+        @Override
+        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
+          float valSrcScore = valSrcExpl == null ? 0 : valSrcExpl.getValue();
+          Explanation exp = new Explanation(valSrcScore + subQueryExpl.getValue(), "custom score: sum of:");
+          exp.addDetail(subQueryExpl);
+          if (valSrcExpl != null) {
+            exp.addDetail(valSrcExpl);
+          }
+          return exp;
+        }
+      };
     }
-    /* (non-Javadoc)@see org.apache.lucene.search.function.CustomScoreQuery#customExplain(int, org.apache.lucene.search.Explanation, org.apache.lucene.search.Explanation)*/
-    @Override
-    public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
-      float valSrcScore = valSrcExpl==null ? 0 : valSrcExpl.getValue();
-      Explanation exp = new Explanation( valSrcScore + subQueryExpl.getValue(), "custom score: sum of:");
-      exp.addDetail(subQueryExpl);
-      if (valSrcExpl != null) {
-        exp.addDetail(valSrcExpl);
-      }
-      return exp;      
-    } 
   }
-  
+
   // must have static class otherwise serialization tests fail
   private static class CustomMulAddQuery extends CustomScoreQuery {
     // constructor
@@ -114,51 +120,56 @@
     }
     /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#customScore(int, float, float) */
     @Override
-    public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
-      if (valSrcScores.length == 0) {
-        return subQueryScore;
-      }
-      if (valSrcScores.length == 1) {
-        return subQueryScore + valSrcScores[0];
-        // confirm that skipping beyond the last doc, on the
-        // previous reader, hits NO_MORE_DOCS
-      }
-      return (subQueryScore + valSrcScores[0]) * valSrcScores[1]; // we know there are two
-    } 
-    /* (non-Javadoc)@see org.apache.lucene.search.function.CustomScoreQuery#customExplain(int, org.apache.lucene.search.Explanation, org.apache.lucene.search.Explanation)*/
-    @Override
-    public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
-      if (valSrcExpls.length == 0) {
-        return subQueryExpl;
-      }
-      Explanation exp = new Explanation(valSrcExpls[0].getValue() + subQueryExpl.getValue(), "sum of:");
-      exp.addDetail(subQueryExpl);
-      exp.addDetail(valSrcExpls[0]);
-      if (valSrcExpls.length == 1) {
-        exp.setDescription("CustomMulAdd, sum of:");
-        return exp;
-      }
-      Explanation exp2 = new Explanation(valSrcExpls[1].getValue() * exp.getValue(), "custom score: product of:");
-      exp2.addDetail(valSrcExpls[1]);
-      exp2.addDetail(exp);
-      return exp2;      
-    } 
+    protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+      return new CustomScoreProvider(reader) {
+        @Override
+        public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
+          if (valSrcScores.length == 0) {
+            return subQueryScore;
+          }
+          if (valSrcScores.length == 1) {
+            return subQueryScore + valSrcScores[0];
+            // confirm that skipping beyond the last doc, on the
+            // previous reader, hits NO_MORE_DOCS
+          }
+          return (subQueryScore + valSrcScores[0]) * valSrcScores[1]; // we know there are two
+        }
+
+        @Override
+        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
+          if (valSrcExpls.length == 0) {
+            return subQueryExpl;
+          }
+          Explanation exp = new Explanation(valSrcExpls[0].getValue() + subQueryExpl.getValue(), "sum of:");
+          exp.addDetail(subQueryExpl);
+          exp.addDetail(valSrcExpls[0]);
+          if (valSrcExpls.length == 1) {
+            exp.setDescription("CustomMulAdd, sum of:");
+            return exp;
+          }
+          Explanation exp2 = new Explanation(valSrcExpls[1].getValue() * exp.getValue(), "custom score: product of:");
+          exp2.addDetail(valSrcExpls[1]);
+          exp2.addDetail(exp);
+          return exp2;
+        }
+      };
+    }
   }
 
   private final class CustomExternalQuery extends CustomScoreQuery {
-    private IndexReader reader;
-    private int[] values;
 
-    public float customScore(int doc, float subScore, float valSrcScore) {
-      assertTrue(doc <= reader.maxDoc());
-      return (float) values[doc];
+    @Override
+    protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) throws IOException {
+      final int[] values = FieldCache.DEFAULT.getInts(reader, INT_FIELD);
+      return new CustomScoreProvider(reader) {
+        @Override
+        public float customScore(int doc, float subScore, float valSrcScore) throws IOException {
+          assertTrue(doc <= reader.maxDoc());
+          return (float) values[doc];
+        }
+      };
     }
 
-    public void setNextReader(IndexReader r) throws IOException {
-      reader = r;
-      values = FieldCache.DEFAULT.getInts(r, INT_FIELD);
-    }
-
     public CustomExternalQuery(Query q) {
       super(q);
     }
